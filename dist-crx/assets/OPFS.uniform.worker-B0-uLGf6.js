var e=(e=>(e.GET="get",e.SET="set",e.CALL="call",e.APPLY="apply",e.CONSTRUCT="construct",e.DELETE="delete",e.DELETE_PROPERTY="deleteProperty",e.HAS="has",e.OWN_KEYS="ownKeys",e.GET_OWN_PROPERTY_DESCRIPTOR="getOwnPropertyDescriptor",e.GET_PROPERTY_DESCRIPTOR="getPropertyDescriptor",e.GET_PROTOTYPE_OF="getPrototypeOf",e.SET_PROTOTYPE_OF="setPrototypeOf",e.IS_EXTENSIBLE="isExtensible",e.PREVENT_EXTENSIONS="preventExtensions",e.TRANSFER="transfer",e.IMPORT="import",e.DISPOSE="dispose",e))(e||{});"undefined"!=typeof Promise&&"function"!=typeof Promise.try&&(Promise.try=function(e,...t){try{return"function"==typeof e?Promise.resolve(e(...t)):Promise.resolve(e)}catch(n){return Promise.reject(n)}}),WeakMap.prototype.getOrInsert??=function(e,t){return this.has(e)||this.set(e,t),this.get(e)},WeakMap.prototype.getOrInsertComputed??=function(e,t){return this.has(e)||this.set(e,t(e)),this.get(e)},Map.prototype.getOrInsert??=function(e,t){return this.has(e)||this.set(e,t),this.get(e)},Map.prototype.getOrInsertComputed??=function(e,t){return this.has(e)||this.set(e,t(e)),this.get(e)};const t=Symbol.for("@fix"),n=e=>"string"==typeof e||"number"==typeof e||"boolean"==typeof e||"bigint"==typeof e||void 0===e||null==e,s=(e,n)=>e?.[t]??n??e,r=()=>crypto?.randomUUID?crypto?.randomUUID?.():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,e=>{return(+e^(t=new Uint8Array(1),crypto?.getRandomValues?crypto?.getRandomValues?.(t):(()=>{const e=new Uint8Array(t.length);for(let n=0;n<t.length;n++)e[n]=Math.floor(256*Math.random());return e})())?.[0]&15>>+e/4).toString(16);var t}),o=e=>Array.isArray(e)?e?.flatMap?.(e=>Array.isArray(e)?o(e):e):e,a=e=>o(e)?.every?.(i),i=e=>n(e)||"function"==typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer||c(e)||Array.isArray(e)&&a(e),c=e=>ArrayBuffer.isView(e)&&!(e instanceof DataView),l=e=>n(e)||"function"==typeof ArrayBuffer&&e instanceof ArrayBuffer||"function"==typeof MessagePort&&e instanceof MessagePort||"function"==typeof ReadableStream&&e instanceof ReadableStream||"function"==typeof WritableStream&&e instanceof WritableStream||"function"==typeof TransformStream&&e instanceof TransformStream||"function"==typeof ImageBitmap&&e instanceof ImageBitmap||"function"==typeof VideoFrame&&e instanceof VideoFrame||"function"==typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"function"==typeof RTCDataChannel&&e instanceof RTCDataChannel||"function"==typeof AudioData&&e instanceof AudioData||"function"==typeof WebTransportReceiveStream&&e instanceof WebTransportReceiveStream||"function"==typeof WebTransportSendStream&&e instanceof WebTransportSendStream||"function"==typeof WebTransportReceiveStream&&e instanceof WebTransportReceiveStream,h=(e,t,n)=>{if(Array.isArray(e))return e.every(i)?e.map(t):e.map((n,s)=>h(n,t,[e,s]));if(e instanceof Map){const n=Array.from(e.entries());return n.map(([e,t])=>t).every(i)?new Map(n.map(([n,s])=>[n,t(s,n,e)])):new Map(n.map(([n,s])=>[n,h(s,t,[e,n])]))}if(e instanceof Set){const n=Array.from(e.entries()),s=n.map(([e,t])=>t);return n.every(i)?new Set(s.map(t)):new Set(s.map(n=>h(n,t,[e,n])))}if("object"==typeof e&&e?.constructor==Object&&"[object Object]"==Object.prototype.toString.call(e)){const n=Array.from(Object.entries(e));return n.map(([e,t])=>t).every(i)?Object.fromEntries(n.map(([n,s])=>[n,t(s,n,e)])):Object.fromEntries(n.map(([n,s])=>[n,h(s,t,[e,n])]))}return t(e,n?.[1]??"",n?.[0]??null)},u=new WeakMap,d=new WeakMap,p=(e,t)=>e instanceof Promise||"function"==typeof e?.then?u?.has?.(e)?t(u?.get?.(e)):Promise.try?.(async()=>{const t=await e;return u?.set?.(e,t),t})?.then?.(t):t(e);class f{#e;#t;constructor(e,t){this.#e=e,this.#t=t}defineProperty(e,t,n){return s(e)instanceof Promise?Reflect.defineProperty(e,t,n):p(s(e),e=>Reflect.defineProperty(e,t,n))}deleteProperty(e,t){return s(e)instanceof Promise?Reflect.deleteProperty(e,t):p(s(e),e=>Reflect.deleteProperty(e,t))}getPrototypeOf(e){return s(e)instanceof Promise?Reflect.getPrototypeOf(e):p(s(e),e=>Reflect.getPrototypeOf(e))}setPrototypeOf(e,t){return s(e)instanceof Promise?Reflect.setPrototypeOf(e,t):p(s(e),e=>Reflect.setPrototypeOf(e,t))}isExtensible(e){return s(e)instanceof Promise?Reflect.isExtensible(e):p(s(e),e=>Reflect.isExtensible(e))}preventExtensions(e){return s(e)instanceof Promise?Reflect.ownKeys(e):p(s(e),e=>Reflect.preventExtensions(e))}ownKeys(e){const t=s(e);if(t instanceof Promise)return Object.keys(t);return p(t,e=>"object"!=typeof e&&"function"!=typeof e||null==e?[]:Object.keys(e))??[]}getOwnPropertyDescriptor(e,t){return s(e)instanceof Promise?Reflect.getOwnPropertyDescriptor(e,t):p(s(e),e=>Reflect.getOwnPropertyDescriptor(e,t))}construct(e,t,n){return p(s(e),e=>Reflect.construct(e,t,n))}has(e,t){return s(e)instanceof Promise?Reflect.has(e,t):p(s(e),e=>Reflect.has(e,t))}get(e,t,r){if(e=s(e),"promise"==t)return e;if("resolve"==t&&this.#e)return(...e)=>{const t=this.#e?.(...e);return this.#e=null,t};if("reject"==t&&this.#t)return(...e)=>{const t=this.#t?.(...e);return this.#t=null,t};if("then"==t||"catch"==t||"finally"==t){if(e instanceof Promise)return e?.[t]?.bind?.(e);{const n=Promise.try(()=>e);return n?.[t]?.bind?.(n)}}const o=m(p(e,async o=>{if(s(o)instanceof Promise)return Reflect.get(o,t,r);if(n(o))return t==Symbol.toPrimitive||t==Symbol.toStringTag?o:void 0;let a;try{a=Reflect.get(o,t,r)}catch(i){a=e?.[t]}return"function"==typeof a?a?.bind?.(o):a}));return t==Symbol.toStringTag?n(o)?String(o??"")||"":o?.[Symbol.toStringTag]?.()||String(o??"")||"":t==Symbol.toPrimitive?e=>n(o)?((e,t)=>n(e)?"number"==t?Number(e)||0:"string"==t?String(e)||"":"boolean"==t?!!e:e:null)(o,e):null:o}set(e,t,n){return p(s(e),e=>Reflect.set(e,t,n))}apply(e,t,n){if(this.#e){const e=this.#e?.(...n);return this.#e=null,e}return p(s(e,this.#e),e=>{if("function"==typeof e)return s(e),Reflect.apply(e,t,n)})}}function m(e,n,s){return e instanceof Promise||"function"==typeof e?.then?u?.has?.(e)?u?.get?.(e):(d?.has?.(e)||e?.then?.(t=>u?.set?.(e,t)),d?.getOrInsertComputed?.(e,()=>new Proxy((e=>{if("function"==typeof e||null==e)return e;const n=function(){};return n[t]=e,n})(e),new f(n,s)))):e}class _{constructor(e){this._unsubscribe=e}_closed=!1;get closed(){return this._closed}unsubscribe(){this._closed||(this._closed=!0,this._unsubscribe())}}class g{constructor(e){this._producer=e}subscribe(e,t){const n="function"==typeof e?{next:e}:e??{},s=new AbortController;t?.signal?.addEventListener("abort",()=>s.abort());let r,o=!0;const a=()=>{o=!1,s.abort(),r?.()},i={next:e=>o&&n.next?.(e),error:e=>{o&&(n.error?.(e),a())},complete:()=>{o&&(n.complete?.(),a())},signal:s.signal,get active(){return o&&!s.signal.aborted}};try{r=this._producer(i)}catch(c){i.error(c)}return new _(a)}pipe(...e){return e.reduce((e,t)=>t(e),this)}}class y{_subs=new Set;_buffer=[];_maxBuffer;_replay;constructor(e={}){this._maxBuffer=e.bufferSize??0,this._replay=e.replayOnSubscribe??!1}next(e){this._maxBuffer>0&&(this._buffer.push(e),this._buffer.length>this._maxBuffer&&this._buffer.shift());for(const n of this._subs)try{n.next?.(e)}catch(t){n.error?.(t)}}error(e){for(const t of this._subs)t.error?.(e)}complete(){for(const e of this._subs)e.complete?.();this._subs.clear()}subscribe(e){const t="function"==typeof e?{next:e}:e;if(this._subs.add(t),this._replay)for(const s of this._buffer)try{t.next?.(s)}catch(n){t.error?.(n)}return new _(()=>{this._subs.delete(t)})}getValue(){return this._buffer.at(-1)}getBuffer(){return[...this._buffer]}get subscriberCount(){return this._subs.size}}function b(){if(void 0!==globalThis.Deno)return"deno";if(void 0!==globalThis.process&&globalThis.process?.versions?.node)return"node";if("undefined"!=typeof ServiceWorkerGlobalScope&&self instanceof ServiceWorkerGlobalScope)return"service-worker";if("undefined"!=typeof SharedWorkerGlobalScope&&self instanceof SharedWorkerGlobalScope)return"shared-worker";if("undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope)return"worker";if("undefined"!=typeof chrome&&chrome.runtime?.id){if("function"==typeof chrome.runtime.getBackgroundPage||chrome.runtime.getManifest?.()?.background?.service_worker)return"chrome-background";if(void 0!==chrome.devtools)return"chrome-devtools";if("undefined"!=typeof document&&"chrome-extension:"===globalThis?.location?.protocol){if((chrome.extension?.getViews?.({type:"popup"})??[]).includes(globalThis))return"chrome-popup"}if("undefined"!=typeof document&&"chrome-extension:"!==globalThis?.location?.protocol)return"chrome-content"}return"undefined"!=typeof globalThis&&"undefined"!=typeof document?"window":"unknown"}function w(e){return e?"undefined"!=typeof Worker&&e instanceof Worker?"worker":"undefined"!=typeof SharedWorker&&e instanceof SharedWorker?"shared-worker":"undefined"!=typeof MessagePort&&e instanceof MessagePort?"message-port":"undefined"!=typeof BroadcastChannel&&e instanceof BroadcastChannel?"broadcast":"undefined"!=typeof WebSocket&&e instanceof WebSocket?"websocket":"undefined"!=typeof RTCDataChannel&&e instanceof RTCDataChannel?"rtc-data":"chrome-runtime"===e||"chrome-tabs"===e||"chrome-port"===e||"chrome-external"===e?e:"undefined"!=typeof chrome&&e&&"object"==typeof e&&"function"==typeof e.postMessage&&e.onMessage?.addListener?"chrome-port":e===self||e===globalThis||"self"===e?"self":"internal":"internal"}function C(e){if(!e)return"unknown";if(e.contextType)return e.contextType;const t=e.sender??"";return t.includes("worker")?"worker":t.includes("sw")||t.includes("service")?"service-worker":t.includes("chrome")||t.includes("crx")?"chrome-content":t.includes("background")?"chrome-background":"unknown"}const v={get:(e,t)=>Reflect.get(e,t),set:(e,t,n)=>Reflect.set(e,t,n),has:(e,t)=>Reflect.has(e,t),apply:(e,t,n)=>Reflect.apply(e,t,n),construct:(e,t)=>Reflect.construct(e,t),deleteProperty:(e,t)=>Reflect.deleteProperty(e,t),ownKeys:e=>Reflect.ownKeys(e),getOwnPropertyDescriptor:(e,t)=>Reflect.getOwnPropertyDescriptor(e,t),getPrototypeOf:e=>Reflect.getPrototypeOf(e),setPrototypeOf:(e,t)=>Reflect.setPrototypeOf(e,t),isExtensible:e=>Reflect.isExtensible(e),preventExtensions:e=>Reflect.preventExtensions(e)},k=Symbol.for("uniform.proxy"),x=Symbol.for("uniform.proxy.internals");class P{constructor(e,t){this._invoker=e,this._config={channel:t.channel,basePath:t.basePath??[],invoker:e,cache:t.cache??!0,timeout:t.timeout??3e4}}_config;_childCache=new Map;get(e,t,n){const s=String(t);if(t===k)return!0;if(t===x)return this._config;if(t===$)return!0;if(t===z)return this._getDescriptor();if("then"===t||"catch"===t||"finally"===t)return;if("symbol"==typeof t)return;if("$path"===t)return this._config.basePath;if("$channel"===t)return this._config.channel;if("$descriptor"===t)return this._getDescriptor();if("$invoke"===t)return this._invoker;const r=[...this._config.basePath,s];if(this._config.cache&&this._childCache.has(s))return this._childCache.get(s);const o=S(this._invoker,{...this._config,basePath:r});return this._config.cache&&this._childCache.set(s,o),o}set(t,n,s,r){return"symbol"==typeof n||this._invoker(e.SET,[...this._config.basePath,String(n)],[s]),!0}apply(t,n,s){return this._invoker(e.APPLY,this._config.basePath,[s])}construct(t,n,s){return this._invoker(e.CONSTRUCT,this._config.basePath,[n])}has(t,n){return"symbol"!=typeof n&&this._invoker(e.HAS,this._config.basePath,[n])}deleteProperty(t,n){return"symbol"==typeof n||this._invoker(e.DELETE_PROPERTY,[...this._config.basePath,String(n)],[])}ownKeys(e){return[]}getOwnPropertyDescriptor(e,t){return{configurable:!0,enumerable:!0,writable:!0}}getPrototypeOf(e){return Function.prototype}setPrototypeOf(t,n){return this._invoker(e.SET_PROTOTYPE_OF,this._config.basePath,[n])}isExtensible(e){return!0}preventExtensions(t){return this._invoker(e.PREVENT_EXTENSIONS,this._config.basePath,[])}_getDescriptor(){return{path:this._config.basePath,channel:this._config.channel,primitive:!1}}}function S(e,t){const n=new P(e,t);return new Proxy(function(){},n)}function T(e,t,n){if(!e||"object"!=typeof e)return e;if(e.primitive)return e;const s=F.get(e);if(s)return s;const r=S(t,{channel:n??e.channel??"unknown",basePath:e.path??[]});return F.set(e,r),B.set(r,e),r}const E=T;class R{constructor(e,t){this._createId=e,this._emitEvent=t}_connections=new Map;register(e){const t=function(e){return[e.localChannel,e.remoteChannel,e.sender,e.transportType,e.direction].join("::")}(e),n=Date.now(),s=this._connections.get(t);if(s)return s.updatedAt=n,s.status="active",s.metadata={...s.metadata,...e.metadata},s;const r={id:this._createId(),localChannel:e.localChannel,remoteChannel:e.remoteChannel,sender:e.sender,transportType:e.transportType,direction:e.direction,status:"active",createdAt:n,updatedAt:n,metadata:e.metadata};return this._connections.set(t,r),this._emitEvent?.({type:"connected",connection:r,timestamp:n}),r}markNotified(e,t){const n=Date.now();e.lastNotifyAt=n,e.updatedAt=n,this._emitEvent?.({type:"notified",connection:e,timestamp:n,payload:t})}closeByChannel(e){const t=Date.now();for(const n of this._connections.values())n.localChannel!==e&&n.remoteChannel!==e||"closed"!==n.status&&(n.status="closed",n.updatedAt=t,this._emitEvent?.({type:"disconnected",connection:n,timestamp:t}))}closeAll(){const e=Date.now();for(const t of this._connections.values())"closed"!==t.status&&(t.status="closed",t.updatedAt=e,this._emitEvent?.({type:"disconnected",connection:t,timestamp:e}))}query(e={}){return function(e,t={}){const n=t.includeClosed??!1,s=t.status??(n?void 0:"active");return[...e].filter(e=>!(s&&e.status!==s||t.channel&&e.localChannel!==t.channel&&e.remoteChannel!==t.channel||t.localChannel&&e.localChannel!==t.localChannel||t.remoteChannel&&e.remoteChannel!==t.remoteChannel||t.sender&&e.sender!==t.sender||t.transportType&&e.transportType!==t.transportType||t.direction&&e.direction!==t.direction)).sort((e,t)=>t.updatedAt-e.updatedAt)}(this._connections.values(),e)}values(){return[...this._connections.values()]}clear(){this._connections.clear()}}class O{_name;_contextType;_config;_transports=new Map;_defaultTransport=null;_connectionEvents=new y({bufferSize:200});_connectionRegistry=new R(()=>r(),e=>this._connectionEvents.next(e));_pending=new Map;_subscriptions=[];_inbound=new y({bufferSize:100});_outbound=new y({bufferSize:100});_invocations=new y({bufferSize:100});_responses=new y({bufferSize:100});_exposed=new Map;_proxyCache=new WeakMap;__getPrivate(e){return this[e]}__setPrivate(e,t){this[e]=t}constructor(e){const t="string"==typeof e?{name:e}:e;this._name=t.name,this._contextType=!1!==t.autoDetect?b():"unknown",this._config={name:t.name,autoDetect:t.autoDetect??!0,timeout:t.timeout??3e4,reflect:t.reflect??v,bufferSize:t.bufferSize??100,autoListen:t.autoListen??!0},this._config.autoListen&&this._isWorkerContext()&&this.listen(self)}connect(e,t={}){const n=w(e),s=t.targetChannel??this._inferTargetChannel(e,n),r=this._createTransportBinding(e,n,s,t);this._transports.set(s,r),this._defaultTransport||(this._defaultTransport=r);const o=this._registerConnection({localChannel:this._name,remoteChannel:s,sender:this._name,transportType:n,direction:"outgoing",metadata:{phase:"connect"}});return this._emitConnectionSignal(r,"connect",{connectionId:o.id,from:this._name,to:s}),this}listen(e,t={}){const n=w(e),s=t.targetChannel??this._inferTargetChannel(e,n),r=e=>this._handleIncoming(e),o=this._registerConnection({localChannel:this._name,remoteChannel:s,sender:s,transportType:n,direction:"incoming",metadata:{phase:"listen"}});switch(n){case"worker":case"message-port":case"broadcast":!1!==t.autoStart&&e.start&&e.start(),e.addEventListener?.("message",e=>r(e.data));break;case"websocket":e.addEventListener?.("message",e=>{try{r(JSON.parse(e.data))}catch{}});break;case"chrome-runtime":chrome.runtime.onMessage?.addListener?.((e,t,n)=>(r(e),!0));break;case"chrome-tabs":chrome.runtime.onMessage?.addListener?.((e,n)=>(null==t.tabId||n?.tab?.id===t.tabId)&&(r(e),!0));break;case"chrome-port":e?.onMessage?.addListener?.(e=>{r(e)});break;case"chrome-external":chrome.runtime.onMessageExternal?.addListener?.(e=>(r(e),!0));break;case"self":addEventListener?.("message",e=>r(e.data));break;default:t.onMessage&&t.onMessage(r)}return this._sendSignalToTarget(e,n,{connectionId:o.id,from:this._name,to:s,tabId:t.tabId,externalId:t.externalId},"notify"),this}attach(e,t={}){return this.connect(e,t)}expose(e,t){const n=[e];return X(n,t),this._exposed.set(e,{name:e,obj:t,path:n}),this}exposeAll(e){for(const[t,n]of Object.entries(e))this.expose(t,n);return this}async import(t,n){return this.invoke(n??this._getDefaultTarget(),e.IMPORT,[],[t])}invoke(e,t,n,s=[]){const o=r(),a=Promise.withResolvers();this._pending.set(o,a);const i=setTimeout(()=>{this._pending.has(o)&&(this._pending.delete(o),a.reject(new Error(`Request timeout: ${t} on ${n.join(".")}`)))},this._config.timeout),c={id:o,channel:e,sender:this._name,type:"request",payload:{channel:e,sender:this._name,action:t,path:n,args:s},timestamp:Date.now()};return this._send(e,c),this._outbound.next(c),a.promise.finally(()=>clearTimeout(i))}get(t,n,s){return this.invoke(t,e.GET,n,[s])}set(t,n,s,r){return this.invoke(t,e.SET,n,[s,r])}call(t,n,s=[]){return this.invoke(t,e.APPLY,n,[s])}construct(t,n,s=[]){return this.invoke(t,e.CONSTRUCT,n,[s])}proxy(e,t=[]){const n=e??this._getDefaultTarget();return this._createProxy(n,t)}remote(e,t){return this.proxy(t,[e])}wrapDescriptor(e,t){return T(e,(n,s,r)=>{const o=t??e?.channel??this._getDefaultTarget();return this.invoke(o,n,s,r)},t??e?.channel??this._getDefaultTarget())}subscribe(e){return this._inbound.subscribe(e)}next(e){this._send(e.channel,e),this._outbound.next(e)}emit(e,t,n){const s={id:r(),channel:e,sender:this._name,type:"event",payload:{type:t,data:n},timestamp:Date.now()};this.next(s)}notify(e,t={},n="notify"){const s=this._transports.get(e);return!!s&&(this._emitConnectionSignal(s,n,{from:this._name,to:e,...t}),!0)}get onMessage(){return this._inbound}get onOutbound(){return this._outbound}get onInvocation(){return this._invocations}get onResponse(){return this._responses}get onConnection(){return this._connectionEvents}subscribeConnections(e){return this._connectionEvents.subscribe(e)}queryConnections(e={}){return this._connectionRegistry.query(e)}notifyConnections(e={},t={}){let n=0;const s=this.queryConnections({...t,status:"active",includeClosed:!1});for(const r of s){const t=this._transports.get(r.remoteChannel);t&&(this._emitConnectionSignal(t,"notify",{connectionId:r.id,from:this._name,to:r.remoteChannel,...e}),n++)}return n}get name(){return this._name}get contextType(){return this._contextType}get config(){return this._config}get connectedChannels(){return[...this._transports.keys()]}get exposedModules(){return[...this._exposed.keys()]}close(){this._subscriptions.forEach(e=>e.unsubscribe()),this._subscriptions=[],this._pending.clear(),this._markAllConnectionsClosed();for(const e of this._transports.values()){try{e.cleanup?.()}catch{}if("message-port"===e.transportType||"broadcast"===e.transportType)try{e.target?.close?.()}catch{}}this._transports.clear(),this._defaultTransport=null,this._connectionRegistry.clear(),this._inbound.complete(),this._outbound.complete(),this._invocations.complete(),this._responses.complete(),this._connectionEvents.complete()}_handleIncoming(e){if(e&&"object"==typeof e)switch(this._inbound.next(e),e.type){case"request":e.channel===this._name&&this._handleRequest(e);break;case"response":this._handleResponse(e);break;case"event":break;case"signal":this._handleSignal(e)}}_handleResponse(e){const t=e.reqId??e.id,n=this._pending.get(t);if(n){if(this._pending.delete(t),e.payload?.error)n.reject(new Error(e.payload.error));else{const t=e.payload?.result,s=e.payload?.descriptor;null!=t?n.resolve(t):s?n.resolve(this.wrapDescriptor(s,e.sender)):n.resolve(void 0)}this._responses.next({id:t,channel:e.channel,sender:e.sender,result:e.payload?.result,descriptor:e.payload?.descriptor,timestamp:Date.now()})}}async _handleRequest(e){const t=e.payload;if(!t)return;const{action:n,path:s,args:r,sender:o}=t,a=e.reqId??e.id;this._invocations.next({id:a,channel:this._name,sender:o,action:n,path:s,args:r??[],timestamp:Date.now(),contextType:C(e)});const{result:i,toTransfer:c,newPath:l}=await this._executeAction(n,s,r??[],o);await this._sendResponse(a,n,o,l,i,c)}async _executeAction(e,t,n,s){const{result:r,toTransfer:o,path:a}=ne(e,t,n,{channel:this._name,sender:s,reflect:this._config.reflect});return{result:await r,toTransfer:o,newPath:a}}async _sendResponse(e,t,n,s,r,o){const{response:a,transfer:i}=await se(e,t,this._name,n,s,r,o),c={id:e,...a,timestamp:Date.now(),transferable:i};this._send(n,c,i)}_handleSignal(e){const t=e?.payload??{},n=t.from??e.sender??"unknown",s=e.transportType??this._transports.get(e.channel)?.transportType??"internal",r=this._registerConnection({localChannel:this._name,remoteChannel:n,sender:e.sender??n,transportType:s,direction:"incoming"});this._markConnectionNotified(r,t)}_registerConnection(e){return this._connectionRegistry.register(e)}_markConnectionNotified(e,t){this._connectionRegistry.markNotified(e,t)}_emitConnectionSignal(e,t,n={}){const s={id:r(),type:"signal",channel:e.targetChannel,sender:this._name,transportType:e.transportType,payload:{type:t,from:this._name,to:e.targetChannel,...n},timestamp:Date.now()};(e?.sender??e?.postMessage)?.call(e,s);const o=this._registerConnection({localChannel:this._name,remoteChannel:e.targetChannel,sender:this._name,transportType:e.transportType,direction:"outgoing"});this._markConnectionNotified(o,s.payload)}_sendSignalToTarget(e,t,n,s){const o={id:r(),type:"signal",channel:n.to??this._name,sender:this._name,transportType:t,payload:{type:s,...n},timestamp:Date.now()};try{if("websocket"===t)return void e?.send?.(JSON.stringify(o));if("chrome-runtime"===t)return void chrome.runtime?.sendMessage?.(o);if("chrome-tabs"===t){const e=n.tabId;return void(null!=e&&chrome.tabs?.sendMessage?.(e,o))}if("chrome-port"===t)return void e?.postMessage?.(o);if("chrome-external"===t)return void(n.externalId&&chrome.runtime?.sendMessage?.(n.externalId,o));e?.postMessage?.(o,{transfer:[]})}catch{}}_markAllConnectionsClosed(){this._connectionRegistry.closeAll()}_createTransportBinding(e,t,n,s){let r,o;switch(t){case"worker":case"message-port":case"broadcast":!1!==s.autoStart&&e.start&&e.start(),r=(t,n)=>e.postMessage(t,{transfer:n});{const t=e=>this._handleIncoming(e.data);e.addEventListener?.("message",t),o=()=>e.removeEventListener?.("message",t)}break;case"websocket":r=t=>e.send(JSON.stringify(t));{const t=e=>{try{this._handleIncoming(JSON.parse(e.data))}catch{}};e.addEventListener?.("message",t),o=()=>e.removeEventListener?.("message",t)}break;case"chrome-runtime":r=e=>chrome.runtime.sendMessage(e);{const e=e=>this._handleIncoming(e);chrome.runtime.onMessage?.addListener?.(e),o=()=>chrome.runtime.onMessage?.removeListener?.(e)}break;case"chrome-tabs":r=e=>{null!=s.tabId&&chrome.tabs?.sendMessage?.(s.tabId,e)};{const e=(e,t)=>(null==s.tabId||t?.tab?.id===s.tabId)&&(this._handleIncoming(e),!0);chrome.runtime.onMessage?.addListener?.(e),o=()=>chrome.runtime.onMessage?.removeListener?.(e)}break;case"chrome-port":if(e?.postMessage&&e?.onMessage?.addListener){r=t=>e.postMessage(t);const t=e=>this._handleIncoming(e);e.onMessage.addListener(t),o=()=>{try{e.onMessage.removeListener(t)}catch{}try{e.disconnect?.()}catch{}}}else{const e=s.portName??n,t=null!=s.tabId&&chrome.tabs?.connect?chrome.tabs.connect(s.tabId,{name:e}):chrome.runtime.connect({name:e});r=e=>t.postMessage(e);const a=e=>this._handleIncoming(e);t.onMessage.addListener(a),o=()=>{try{t.onMessage.removeListener(a)}catch{}try{t.disconnect()}catch{}}}break;case"chrome-external":r=e=>{s.externalId&&chrome.runtime.sendMessage(s.externalId,e)};{const e=e=>(this._handleIncoming(e),!0);chrome.runtime.onMessageExternal?.addListener?.(e),o=()=>chrome.runtime.onMessageExternal?.removeListener?.(e)}break;case"self":r=(e,t)=>postMessage(e,{transfer:t??[]});{const e=e=>this._handleIncoming(e.data);addEventListener?.("message",e),o=()=>removeEventListener?.("message",e)}break;default:s.onMessage&&(o=s.onMessage(e=>this._handleIncoming(e))),r=t=>e?.postMessage?.(t)}return{target:e,targetChannel:n,transportType:t,sender:r,cleanup:o,postMessage:(e,t)=>r?.(e,t),start:()=>e?.start?.(),close:()=>e?.close?.()}}_send(e,t,n){const s=this._transports.get(e)??this._defaultTransport;(s?.sender??s?.postMessage)?.call(s,t,n)}_getDefaultTarget(){return this._defaultTransport?this._defaultTransport.targetChannel:"worker"}_inferTargetChannel(e,t){return"worker"===t?"worker":"broadcast"===t&&e.name?e.name:"self"===t?"self":`${t}-${r().slice(0,8)}`}_createProxy(e,t){return S((t,n,s)=>this.invoke(e,t,n,s),{channel:e,basePath:t,cache:!0,timeout:this._config.timeout})}_isWorkerContext(){return["worker","shared-worker","service-worker"].includes(this._contextType)}}function M(e){return new O(e)}let D=null;const I="undefined";[typeof ArrayBuffer!=I?ArrayBuffer:null,typeof MessagePort!=I?MessagePort:null,typeof ReadableStream!=I?ReadableStream:null,typeof WritableStream!=I?WritableStream:null,typeof TransformStream!=I?TransformStream:null,typeof WebTransportReceiveStream!=I?WebTransportReceiveStream:null,typeof WebTransportSendStream!=I?WebTransportSendStream:null,typeof AudioData!=I?AudioData:null,typeof ImageBitmap!=I?ImageBitmap:null,typeof VideoFrame!=I?VideoFrame:null,typeof OffscreenCanvas!=I?OffscreenCanvas:null,typeof RTCDataChannel!=I?RTCDataChannel:null].filter(e=>null!=e);const A={name:"unknown",instance:null},j=new Map,N=t=>[...Object.values(e)].includes(t);let L=class{constructor(e,t={}){this.channelName=e,this.options=t,this._channel=function(){if(!D){const e=b();D=["worker","shared-worker","service-worker"].includes(e)?M({name:"worker",autoListen:!0}):M({name:"host",autoListen:!1})}return D}()}_channel;request(e,t,n,s={}){return"string"==typeof e&&(e=[e]),Array.isArray(t)&&N(e)&&(n=t,t=e,e=[]),this._channel.invoke(this.channelName,t,e,n)}doImportModule(e,t){return this._channel.import(e,this.channelName)}},W=class{constructor(e,t={}){this.channel=e,this.options=t,this._unified=M({name:e,autoListen:!1}),A.name=e,A.instance=this}_unified;broadcasts={};createRemoteChannel(e,t={},n){return n&&(this._unified.attach(n,{targetChannel:e}),this.broadcasts[e]=n),Promise.resolve(new L(e,t))}getChannel(){return this.channel}request(e,t,n,s={},r="worker"){return"string"==typeof e&&(e=[e]),Array.isArray(t)&&N(e)&&(r=s,s=n,n=t,t=e,e=[]),this._unified.invoke(r,t,e,n)}resolveResponse(e,t){return Promise.resolve(t)}async handleAndResponse(e,t,n){const s=await async function(e,t,n,s){const{channel:r,sender:o,path:a,action:i,args:c}=e;if(r!==n)return null;const{result:l,toTransfer:h,path:u}=ne(i,a,c,{channel:r,sender:o,...s});return se(t,i,n,o,u,l,h)}(e,t,this.channel);s&&n?.(s.response,s.transfer)}close(){this._unified.close()}};const q=new WeakMap,B=new WeakMap,F=new WeakMap,U=(e,t=A?.name,s)=>"object"==typeof e&&null!=e||"function"==typeof e&&null!=e?B.has(e)?B.get(e):q.has(e)?q.get(e):a(e)||s?.includes?.(e)||t==A?.name?e:{$isDescriptor:!0,path:Y.get(e)??(()=>{const t=[r()];return X(t,e),t})(),owner:A?.name,channel:t,primitive:n(e),writable:!0,enumerable:!0,configurable:!0,argumentCount:e instanceof Function?e.length:-1}:i(e)?e:null,$=Symbol.for("@requestHandler"),z=Symbol.for("@descriptor"),G=e=>i(e)||e?.[z]?e:e?.$isDescriptor?E(e,{}):a(e)?e:null,H=new Map,Y=new WeakMap,K=(e,t)=>{if(null==t||Array.isArray(t)||(t=[t]),null==t||t?.length<1)return e;const s=e?.[z]??(e?.$isDescriptor?e:null);if(s&&s?.owner==A?.name&&(e=V(s?.path)??e),n(e))return e;for(const n of t)if(e=e?.[n],null==e)return e;return e},V=e=>{if(null==e||Array.isArray(e)||(e=[e]),null==e||e?.length<1)return null;const t=H?.get?.(e?.[0])??null;return null!=t?K(t,e?.slice?.(1)):null},X=(e,t)=>{const n=t?.[z]??(t?.$isDescriptor?t:null);if(n&&n?.owner==A?.name&&(t=V(n?.path)??t),null==e||Array.isArray(e)||(e=[e]),null==e||e?.length<1)return null;const s=H?.get?.(e?.[0])??null;return e?.length>1?K(s,e?.slice?.(1,-1))[e?.[e?.length-1]]=t:H?.set?.(e?.[0],t),"object"!=typeof t&&"function"!=typeof t||Y?.set?.(t,e),t},J=e=>{if(null==e||Array.isArray(e)||(e=[e]),null==e||e?.length<1)return!1;return!(H?.get?.(e?.[0])??null)&&e?.length<=1&&(H?.delete?.(e?.[0]),!0)},Q=e=>{const t=e?.[z]??(e?.$isDescriptor?e:null);t&&t?.owner==A?.name&&(e=V(t?.path)??e);const n=Y?.get?.(e)??t?.path;return!(null==n||n?.length<1)&&(J(n),"object"!=typeof e&&"function"!=typeof e||Y?.delete?.(e),!0)},Z=e=>{const t=e?.[z]??(e?.$isDescriptor?e:null);return null==(Y?.get?.(e)??t?.path)},ee=e=>("object"==typeof e||"function"==typeof e)&&null!=e,te={get:(e,t)=>e?.[t],set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>t in e,apply:(e,t,n)=>e.apply(t,n),construct:(e,t)=>new e(...t),deleteProperty:(e,t)=>delete e[t],ownKeys:e=>Object.keys(e),getOwnPropertyDescriptor:(e,t)=>Object.getOwnPropertyDescriptor(e,t),getPrototypeOf:e=>Object.getPrototypeOf(e),setPrototypeOf:(e,t)=>Object.setPrototypeOf(e,t),isExtensible:e=>Object.isExtensible(e),preventExtensions:e=>Object.preventExtensions(e)};function ne(t,n,s,r={}){const{channel:o="",sender:a="",reflect:i=te}=r,c=r.target??V(n),u=[];let d=null,p=n;switch(String(t).toLowerCase()){case"import":case e.IMPORT:d=import(s?.[0]);break;case"transfer":case e.TRANSFER:l(c)&&o!==a&&u.push(c),d=c;break;case"get":case e.GET:{const e=s?.[0],t=i.get?.(c,e)??c?.[e];d="function"==typeof t&&null!=c?t.bind(c):t,p=[...n,String(e)];break}case"set":case e.SET:{const[e,t]=s,o=h(t,G);d=r.target?i.set?.(c,e,o)??(c[e]=o,!0):i.set?.(c,e,o)??X([...n,String(e)],o);break}case"apply":case"call":case e.APPLY:case e.CALL:if("function"==typeof c){const e=r.context??(r.target?void 0:V(n.slice(0,-1))),t=h(s?.[0]??s??[],G);d=i.apply?.(c,e,t)??c.apply(e,t),l(d)&&"transfer"===n?.at(-1)&&o!==a&&u.push(d)}break;case"construct":case e.CONSTRUCT:if("function"==typeof c){const e=h(s?.[0]??s??[],G);d=i.construct?.(c,e)??new c(...e)}break;case"delete":case"deleteproperty":case"dispose":case e.DELETE:case e.DELETE_PROPERTY:case e.DISPOSE:if(r.target){const e=n[n.length-1];d=i.deleteProperty?.(c,e)??delete c[e]}else d=n?.length>0?J(n):Q(c),d&&(p=Y.get(c)??[]);break;case"has":case e.HAS:d=i.has?.(c,s?.[0])??(!!ee(c)&&s?.[0]in c);break;case"ownkeys":case e.OWN_KEYS:d=i.ownKeys?.(c)??(ee(c)?Object.keys(c):[]);break;case"getownpropertydescriptor":case"getpropertydescriptor":case e.GET_OWN_PROPERTY_DESCRIPTOR:case e.GET_PROPERTY_DESCRIPTOR:d=i.getOwnPropertyDescriptor?.(c,s?.[0]??n?.at(-1)??"")??(ee(c)?Object.getOwnPropertyDescriptor(c,s?.[0]??n?.at(-1)??""):void 0);break;case"getprototypeof":case e.GET_PROTOTYPE_OF:d=i.getPrototypeOf?.(c)??(ee(c)?Object.getPrototypeOf(c):null);break;case"setprototypeof":case e.SET_PROTOTYPE_OF:d=i.setPrototypeOf?.(c,s?.[0])??(!!ee(c)&&Object.setPrototypeOf(c,s?.[0]));break;case"isextensible":case e.IS_EXTENSIBLE:d=i.isExtensible?.(c)??(!ee(c)||Object.isExtensible(c));break;case"preventextensions":case e.PREVENT_EXTENSIONS:d=i.preventExtensions?.(c)??(!!ee(c)&&Object.preventExtensions(c))}return{result:d,toTransfer:u,path:p}}async function se(t,s,o,a,c,u,d){const p=await u,f=l(p)&&d.includes(p)||i(p);let m=c;f||"get"===s||s===e.GET||"object"!=typeof p&&"function"!=typeof p||(Z(p)?(m=[r()],X(m,p)):m=Y.get(p)??[]);const _=V(m),g="get"===s||s===e.GET?m?.at(-1):void 0,y=V(c),b=h(p,e=>U(e,o,d))??p;return{response:{channel:a,sender:o,reqId:t,action:s,type:"response",payload:{result:f?b:null,type:typeof p,channel:a,sender:o,descriptor:{$isDescriptor:!0,path:m,owner:o,channel:o,primitive:n(p),writable:!0,enumerable:!0,configurable:!0,argumentCount:y instanceof Function?y.length:-1,...ee(_)&&null!=g?Object.getOwnPropertyDescriptor(_,g):{}}}},transfer:d}}class re{constructor(e,t="internal",n={}){this._name=e,this._transportType=t,this._opts={timeout:3e4,autoReconnect:!0,reconnectInterval:1e3,maxReconnectAttempts:5,bufferMessages:!0,bufferSize:1e3,metadata:{},...n},this._setupSubscriptions()}_id=r();_state="disconnected";_inbound=new y({bufferSize:1e3});_outbound=new y({bufferSize:1e3});_stateChanges=new y;_connectedPeers=new Map;_subs=[];_stats={messagesSent:0,messagesReceived:0,bytesTransferred:0,latencyMs:0,uptime:0,reconnectCount:0};_startTime=0;_pending=new Map;_buffer=[];_opts;subscribe(e,t){var n;return(t?(n=e=>e.sender===t,e=>new g(t=>{const s=e.subscribe({next:e=>n(e)&&t.next(e),error:e=>t.error(e),complete:()=>t.complete()});return()=>s.unsubscribe()}))(this._inbound):this._inbound).subscribe("function"==typeof e?{next:e}:e)}next(e){"connected"===this._state?(this._outbound.next(e),this._stats.messagesSent++):this._opts.bufferMessages&&this._buffer.length<this._opts.bufferSize&&this._buffer.push(e)}async request(e,t,n={}){const s=r(),o=Promise.withResolvers();this._pending.set(s,o);const a=setTimeout(()=>{this._pending.has(s)&&(this._pending.delete(s),o.reject(new Error("Request timeout")))},n.timeout??this._opts.timeout);return this.next({id:r(),channel:e,sender:this._name,type:"request",reqId:s,payload:{...t,action:n.action,path:n.path},timestamp:Date.now()}),o.promise.finally(()=>clearTimeout(a))}respond(e,t){this.next({id:r(),channel:e.sender,sender:this._name,type:"response",reqId:e.reqId,payload:t,timestamp:Date.now()})}emit(e,t,n){this.next({id:r(),channel:e,sender:this._name,type:"event",payload:{type:t,data:n},timestamp:Date.now()})}subscribeOutbound(e){return this._outbound.subscribe("function"==typeof e?{next:e}:e)}pushInbound(e){if(this._stats.messagesReceived++,"response"===e.type&&e.reqId){const t=this._pending.get(e.reqId);if(t)return this._pending.delete(e.reqId),void t.resolve(e.payload)}this._inbound.next(e)}async connect(){"connected"!==this._state&&(this._setState("connecting"),this._startTime=Date.now(),this._setState("connected"),this._flushBuffer())}disconnect(){"disconnected"!==this._state&&"closed"!==this._state&&(this._setState("disconnected"),this._subs.forEach(e=>e.unsubscribe()),this._subs=[])}close(){this.disconnect(),this._setState("closed"),this._inbound.complete(),this._outbound.complete(),this._stateChanges.complete()}markConnected(){this._setState("connected"),this._flushBuffer()}markDisconnected(){this._setState("disconnected")}_setState(e){this._state!==e&&(this._state=e,this._stateChanges.next(e))}_flushBuffer(){for(const e of this._buffer)this._outbound.next(e);this._buffer=[]}_setupSubscriptions(){this._subs.push(this._inbound.subscribe({next:e=>{"signal"===e.type&&"connect"===e.payload?.type&&this._connectedPeers.set(e.sender,{name:e.sender,state:"connected",isHost:!1})}}))}get id(){return this._id}get name(){return this._name}get state(){return this._state}get transportType(){return this._transportType}get stats(){return{...this._stats,uptime:this._startTime?Date.now()-this._startTime:0}}get stateChanges(){return this._stateChanges}get connectedPeers(){return[...this._connectedPeers.keys()]}get meta(){return{id:this._id,name:this._name,state:this._state,isHost:!1,connectedChannels:new Set(this._connectedPeers.keys())}}}class oe{_connections=new Map;static _instance=null;static getInstance(){return oe._instance||(oe._instance=new oe),oe._instance}getOrCreate(e,t="internal",n={}){return this._connections.has(e)||this._connections.set(e,new re(e,t,n)),this._connections.get(e)}get(e){return this._connections.get(e)}has(e){return this._connections.has(e)}delete(e){return this._connections.get(e)?.close(),this._connections.delete(e)}clear(){this._connections.forEach(e=>e.close()),this._connections.clear()}get size(){return this._connections.size}get names(){return[...this._connections.keys()]}}const ae=()=>oe.getInstance(),ie="messages",ce="mailbox",le="pending",he="exchange",ue="transactions";class de{_db=null;_isOpen=!1;_openPromise=null;_channelName;_messageUpdates=new y;_exchangeUpdates=new y;constructor(e){this._channelName=e}async open(){return this._db&&this._isOpen?this._db:(this._openPromise||(this._openPromise=new Promise((e,t)=>{const n=indexedDB.open("uniform_channels",1);n.onerror=()=>{this._openPromise=null,t(new Error("Failed to open IndexedDB"))},n.onsuccess=()=>{this._db=n.result,this._isOpen=!0,this._openPromise=null,e(this._db)},n.onupgradeneeded=e=>{const t=e.target.result;this._createStores(t)}})),this._openPromise)}close(){this._db&&(this._db.close(),this._db=null,this._isOpen=!1)}_createStores(e){if(!e.objectStoreNames.contains(ie)){const t=e.createObjectStore(ie,{keyPath:"id"});t.createIndex("channel","channel",{unique:!1}),t.createIndex("status","status",{unique:!1}),t.createIndex("recipient","recipient",{unique:!1}),t.createIndex("createdAt","createdAt",{unique:!1}),t.createIndex("channel_status",["channel","status"],{unique:!1})}if(!e.objectStoreNames.contains(ce)){const t=e.createObjectStore(ce,{keyPath:"id"});t.createIndex("channel","channel",{unique:!1}),t.createIndex("priority","priority",{unique:!1}),t.createIndex("expiresAt","expiresAt",{unique:!1})}if(!e.objectStoreNames.contains(le)){const t=e.createObjectStore(le,{keyPath:"id"});t.createIndex("channel","channel",{unique:!1}),t.createIndex("createdAt","createdAt",{unique:!1})}if(!e.objectStoreNames.contains(he)){const t=e.createObjectStore(he,{keyPath:"id"});t.createIndex("key","key",{unique:!0}),t.createIndex("owner","owner",{unique:!1})}if(!e.objectStoreNames.contains(ue)){e.createObjectStore(ue,{keyPath:"id"}).createIndex("createdAt","createdAt",{unique:!1})}}async defer(e,t={}){const n=await this.open(),s={id:r(),channel:e.channel,sender:e.sender??this._channelName,recipient:e.channel,type:e.type,payload:e.payload,status:"pending",priority:t.priority??0,createdAt:Date.now(),updatedAt:Date.now(),expiresAt:t.expiresIn?Date.now()+t.expiresIn:null,retryCount:0,maxRetries:t.maxRetries??3,metadata:t.metadata};return new Promise((e,t)=>{const r=n.transaction([ie,ce],"readwrite"),o=r.objectStore(ie),a=r.objectStore(ce);o.add(s),a.add(s),r.oncomplete=()=>{this._messageUpdates.next(s),e(s.id)},r.onerror=()=>t(new Error("Failed to defer message"))})}async getDeferredMessages(e,t={}){const n=await this.open();return new Promise((s,r)=>{const o=n.transaction(ie,"readonly").objectStore(ie),a=t.status?o.index("channel_status"):o.index("channel"),i=t.status?IDBKeyRange.only([e,t.status]):IDBKeyRange.only(e),c=a.getAll(i,t.limit);c.onsuccess=()=>{let e=c.result;t.offset&&(e=e.slice(t.offset)),s(e)},c.onerror=()=>r(new Error("Failed to get deferred messages"))})}async processNextPending(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(ie,"readwrite").objectStore(ie).index("channel_status").openCursor(IDBKeyRange.only([e,"pending"]));r.onsuccess=()=>{const e=r.result;if(e){const t=e.value;t.status="processing",t.updatedAt=Date.now(),e.update(t),this._messageUpdates.next(t),n(t)}else n(null)},r.onerror=()=>s(new Error("Failed to process pending message"))})}async markDelivered(e){await this._updateMessageStatus(e,"delivered")}async markFailed(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(ie,"readwrite").objectStore(ie),o=r.get(e);o.onsuccess=()=>{const e=o.result;e?(e.retryCount++,e.updatedAt=Date.now(),e.retryCount<e.maxRetries?e.status="pending":e.status="failed",r.put(e),this._messageUpdates.next(e),n("pending"===e.status)):n(!1)},o.onerror=()=>s(new Error("Failed to mark message as failed"))})}async _updateMessageStatus(e,t){const n=await this.open();return new Promise((s,r)=>{const o=n.transaction(ie,"readwrite").objectStore(ie),a=o.get(e);a.onsuccess=()=>{const e=a.result;e&&(e.status=t,e.updatedAt=Date.now(),o.put(e),this._messageUpdates.next(e)),s()},a.onerror=()=>r(new Error("Failed to update message status"))})}async getMailbox(e,t={}){const n=await this.open();return new Promise((s,r)=>{const o=n.transaction(ce,"readonly").objectStore(ce).index("channel").getAll(IDBKeyRange.only(e),t.limit);o.onsuccess=()=>{let e=o.result;"priority"===t.sortBy?e.sort((e,t)=>t.priority-e.priority):e.sort((e,t)=>t.createdAt-e.createdAt),s(e)},o.onerror=()=>r(new Error("Failed to get mailbox"))})}async getMailboxStats(e){const t=await this.getDeferredMessages(e),n={total:t.length,pending:0,processing:0,delivered:0,failed:0,expired:0},s=Date.now();for(const r of t)r.expiresAt&&r.expiresAt<s?n.expired++:n[r.status]++;return n}async clearMailbox(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(ce,"readwrite"),o=r.objectStore(ce).index("channel");let a=0;const i=o.openCursor(IDBKeyRange.only(e));i.onsuccess=()=>{const e=i.result;e&&(e.delete(),a++,e.continue())},r.oncomplete=()=>n(a),r.onerror=()=>s(new Error("Failed to clear mailbox"))})}async registerPending(e){const t=await this.open(),n={id:r(),channel:this._channelName,type:e.type,data:e.data,metadata:e.metadata,createdAt:Date.now(),status:"pending"};return new Promise((e,s)=>{const r=t.transaction(le,"readwrite");r.objectStore(le).add(n),r.oncomplete=()=>e(n.id),r.onerror=()=>s(new Error("Failed to register pending operation"))})}async getPendingOperations(){const e=await this.open();return new Promise((t,n)=>{const s=e.transaction(le,"readonly").objectStore(le).index("channel").getAll(IDBKeyRange.only(this._channelName));s.onsuccess=()=>t(s.result),s.onerror=()=>n(new Error("Failed to get pending operations"))})}async completePending(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(le,"readwrite");r.objectStore(le).delete(e),r.oncomplete=()=>n(),r.onerror=()=>s(new Error("Failed to complete pending operation"))})}async awaitPending(e,t={}){const n=t.timeout??3e4,s=t.pollInterval??100,r=Date.now();for(;Date.now()-r<n;){const t=await this._getPendingById(e);if(!t)return null;if("completed"===t.status)return await this.completePending(e),t.result;await new Promise(e=>setTimeout(e,s))}throw new Error(`Pending operation ${e} timed out`)}async _getPendingById(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(le,"readonly").objectStore(le).get(e);r.onsuccess=()=>n(r.result??null),r.onerror=()=>s(new Error("Failed to get pending operation"))})}async exchangePut(e,t,n={}){const s=await this.open(),o={id:r(),key:e,value:t,owner:this._channelName,sharedWith:n.sharedWith??["*"],version:1,createdAt:Date.now(),updatedAt:Date.now()};return new Promise((t,n)=>{const r=s.transaction(he,"readwrite"),a=r.objectStore(he),i=a.index("key").get(e);i.onsuccess=()=>{const e=i.result;e&&(o.id=e.id,o.version=e.version+1,o.createdAt=e.createdAt),a.put(o)},r.oncomplete=()=>{this._exchangeUpdates.next(o),t(o.id)},r.onerror=()=>n(new Error("Failed to put exchange data"))})}async exchangeGet(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(he,"readonly").objectStore(he).index("key").get(e);r.onsuccess=()=>{const e=r.result;e&&this._canAccessExchange(e)?n(e.value):n(null)},r.onerror=()=>s(new Error("Failed to get exchange data"))})}async exchangeDelete(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(he,"readwrite"),o=r.objectStore(he),a=o.index("key").get(e);a.onsuccess=()=>{const e=a.result;e&&e.owner===this._channelName?o.delete(e.id):n(!1)},r.oncomplete=()=>n(!0),r.onerror=()=>s(new Error("Failed to delete exchange data"))})}async exchangeLock(e,t={}){const n=await this.open(),s=t.timeout??3e4;return new Promise((t,r)=>{const o=n.transaction(he,"readwrite"),a=o.objectStore(he),i=a.index("key").get(e);i.onsuccess=()=>{const e=i.result;e?e.lock&&e.lock.holder!==this._channelName&&e.lock.expiresAt>Date.now()?t(!1):(e.lock={holder:this._channelName,acquiredAt:Date.now(),expiresAt:Date.now()+s},e.updatedAt=Date.now(),a.put(e)):t(!1)},o.oncomplete=()=>t(!0),o.onerror=()=>r(new Error("Failed to acquire lock"))})}async exchangeUnlock(e){const t=await this.open();return new Promise((n,s)=>{const r=t.transaction(he,"readwrite"),o=r.objectStore(he),a=o.index("key").get(e);a.onsuccess=()=>{const e=a.result;e&&e.lock?.holder===this._channelName&&(delete e.lock,e.updatedAt=Date.now(),o.put(e))},r.oncomplete=()=>n(),r.onerror=()=>s(new Error("Failed to release lock"))})}_canAccessExchange(e){return e.owner===this._channelName||(!!e.sharedWith.includes("*")||e.sharedWith.includes(this._channelName))}async beginTransaction(){return new pe(this)}async executeTransaction(e){const t=await this.open(),n=new Set(e.map(e=>e.store));return new Promise((s,r)=>{const o=t.transaction(Array.from(n),"readwrite");for(const t of e){const e=o.objectStore(t.store);switch(t.type){case"put":void 0!==t.value&&e.put(t.value);break;case"delete":void 0!==t.key&&e.delete(t.key);break;case"update":if(void 0!==t.key){const n=e.get(t.key);n.onsuccess=()=>{n.result&&t.value&&e.put({...n.result,...t.value})}}}}o.oncomplete=()=>s(),o.onerror=()=>r(new Error("Transaction failed"))})}onMessageUpdate(e){return this._messageUpdates.subscribe({next:e})}onExchangeUpdate(e){return this._exchangeUpdates.subscribe({next:e})}async cleanupExpired(){const e=await this.open(),t=Date.now();return new Promise((n,s)=>{const r=e.transaction([ie,ce],"readwrite"),o=r.objectStore(ie),a=r.objectStore(ce);let i=0;const c=o.openCursor();c.onsuccess=()=>{const e=c.result;if(e){const n=e.value;n.expiresAt&&n.expiresAt<t&&(e.delete(),i++),e.continue()}};const l=a.openCursor();l.onsuccess=()=>{const e=l.result;if(e){const n=e.value;n.expiresAt&&n.expiresAt<t&&(e.delete(),i++),e.continue()}},r.oncomplete=()=>n(i),r.onerror=()=>s(new Error("Failed to cleanup expired"))})}}class pe{constructor(e){this._storage=e}_operations=[];_isCommitted=!1;_isRolledBack=!1;put(e,t){return this._checkState(),this._operations.push({id:r(),type:"put",store:e,value:t,timestamp:Date.now()}),this}delete(e,t){return this._checkState(),this._operations.push({id:r(),type:"delete",store:e,key:t,timestamp:Date.now()}),this}update(e,t,n){return this._checkState(),this._operations.push({id:r(),type:"update",store:e,key:t,value:n,timestamp:Date.now()}),this}async commit(){this._checkState(),0!==this._operations.length?(await this._storage.executeTransaction(this._operations),this._isCommitted=!0):this._isCommitted=!0}rollback(){this._operations=[],this._isRolledBack=!0}get operationCount(){return this._operations.length}_checkState(){if(this._isCommitted)throw new Error("Transaction already committed");if(this._isRolledBack)throw new Error("Transaction already rolled back")}}const fe=new Map;const me=new URL(""+new URL("Worker-BCSbBPGz.ts",import.meta.url).href,import.meta.url);class _e{constructor(e,t,n={}){var s,r,o,a;this._channel=e,this._context=t,this._options=n,this._connection=(s=e,ae().getOrCreate(s,r,o)),this._storage=(a=e,fe.has(a)||fe.set(a,new de(a)),fe.get(a))}_connection;_storage;async request(e,t,n,s={}){let r="string"==typeof e?[e]:e,o=t,a=n;Array.isArray(t)&&be(e)&&(s=n,a=t,o=e,r=[]);const i=this._context.getHost();return i?.request(r,o,a,s,this._channel)}async doImportModule(t,n={}){return this.request([],e.IMPORT,[t],n)}async deferMessage(e,t={}){return this._storage.defer({channel:this._channel,sender:this._context.hostName,type:"request",payload:e},t)}async getPendingMessages(){return this._storage.getDeferredMessages(this._channel,{status:"pending"})}get connection(){return this._connection}get channelName(){return this._channel}get context(){return this._context}}class ge{constructor(e,t,n={}){this._channel=e,this._context=t,this._options=n,this._connection=ae().getOrCreate(e,"internal",n),this._unified=new O({name:e,autoListen:!1,timeout:n?.timeout})}_connection;_unified;get _forResolves(){return this._unified.__getPrivate("_pending")}get _subscriptions(){return this._unified.__getPrivate("_subscriptions")}get _broadcasts(){return this._unified.__getPrivate("_transports")}createRemoteChannel(e,t={},n){const s=function(e){if(!e)return null;if(we(e))return e;const t=e;return{target:t,postMessage:(e,n)=>{t.postMessage?.(e,n)},addEventListener:t.addEventListener?.bind(t),removeEventListener:t.removeEventListener?.bind(t),start:t.start?.bind(t),close:t.close?.bind(t)}}(n??this._context.$createOrUseExistingRemote(e,t,n??null)?.messageChannel?.port1),r=function(e){const t=we(e)?e.target:e;return t?"chrome-runtime"===t?"chrome-runtime":"chrome-tabs"===t?"chrome-tabs":"chrome-port"===t?"chrome-port":"chrome-external"===t?"chrome-external":"undefined"!=typeof MessagePort&&t instanceof MessagePort?"message-port":"undefined"!=typeof BroadcastChannel&&t instanceof BroadcastChannel?"broadcast":"undefined"!=typeof Worker&&t instanceof Worker?"worker":"undefined"!=typeof WebSocket&&t instanceof WebSocket?"websocket":"undefined"!=typeof chrome&&"object"==typeof t&&t&&"function"==typeof t.postMessage&&t.onMessage?.addListener?"chrome-port":"undefined"!=typeof self&&t===self?"self":"internal":"internal"}(s?.target??s);if(this._unified.listen(s?.target,{targetChannel:e}),s){this._broadcasts?.set?.(e,s);!("self"===r&&"undefined"==typeof postMessage)&&this._unified.connect(s,{targetChannel:e}),this._context.$registerConnection({localChannel:this._channel,remoteChannel:e,sender:this._channel,direction:"outgoing",transportType:r}),this.notifyChannel(e,{contextId:this._context.id,contextName:this._context.hostName},"connect")}return new _e(e,this._context,t)}getChannel(){return this._channel}get connection(){return this._connection}request(e,t,n,s={},r="worker"){let o="string"==typeof e?[e]:e,a=n;return Array.isArray(t)&&be(e)&&(r=s,s=n,a=t,t=e,o=[]),this._unified.invoke(r,t,o??[],Array.isArray(a)?a:[a])}resolveResponse(e,t){this._forResolves.get(e)?.resolve?.(t);const n=this._forResolves.get(e)?.promise;return this._forResolves.delete(e),n}async handleAndResponse(e,t,n){}notifyChannel(e,t={},n="notify"){return this._unified.notify(e,{...t,from:this._channel,to:e},n)}getConnectedChannels(){return this._unified.connectedChannels}close(){this._subscriptions.forEach(e=>e.unsubscribe()),this._forResolves.clear(),this._broadcasts?.values?.()?.forEach(e=>e.close?.()),this._broadcasts?.clear?.(),this._unified.close()}get unified(){return this._unified}}class ye{constructor(e={}){this._options=e,this._hostName=e.name??`ctx-${this._id.slice(0,8)}`,!1!==e.useGlobalSelf&&(this._globalSelf="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:null)}_id=r();_hostName;_host=null;_endpoints=new Map;_unifiedByChannel=new Map;_unifiedConnectionSubs=new Map;_remoteChannels=new Map;_deferredChannels=new Map;_connectionEvents=new y({bufferSize:200});_connectionRegistry=new R(()=>r(),e=>this._emitConnectionEvent(e));_closed=!1;_globalSelf=null;initHost(e){if(this._host&&!e)return this._host;const t=e??this._hostName;if(this._hostName=t,this._endpoints.has(t))return this._host=this._endpoints.get(t).handler,this._host;this._host=new ge(t,this,this._options.defaultOptions);const n={name:t,handler:this._host,connection:this._host.connection,subscriptions:[],ready:Promise.resolve(null),unified:this._host.unified};return this._endpoints.set(t,n),this._registerUnifiedChannel(t,this._host.unified),this._host}getHost(){return this._host??this.initHost()}get hostName(){return this._hostName}get id(){return this._id}get onConnection(){return this._connectionEvents}subscribeConnections(e){return this._connectionEvents.subscribe(e)}notifyConnections(e={},t={}){let n=0;for(const s of this._endpoints.values()){const r=s.handler.getConnectedChannels();for(const o of r){if(t.localChannel&&t.localChannel!==s.name)continue;if(t.remoteChannel&&t.remoteChannel!==o)continue;const r=this.queryConnections({localChannel:s.name,remoteChannel:o,status:"active"})[0];t.sender&&r?.sender!==t.sender||(t.transportType&&r?.transportType!==t.transportType||t.channel&&t.channel!==s.name&&t.channel!==o||s.handler.notifyChannel(o,e,"notify")&&n++)}}return n}queryConnections(e={}){return this._connectionRegistry.query(e).map(e=>({...e,contextId:this._id}))}createChannel(e,t={}){if(this._endpoints.has(e))return this._endpoints.get(e);const n=new ge(e,this,{...this._options.defaultOptions,...t}),s={name:e,handler:n,connection:n.connection,subscriptions:[],ready:Promise.resolve(null),unified:n.unified};return this._endpoints.set(e,s),this._registerUnifiedChannel(e,n.unified),s}createChannels(e,t={}){const n=new Map;for(const s of e)n.set(s,this.createChannel(s,t));return n}getChannel(e){return this._endpoints.get(e)}getOrCreateChannel(e,t={}){return this._endpoints.get(e)??this.createChannel(e,t)}hasChannel(e){return this._endpoints.has(e)}getChannelNames(){return[...this._endpoints.keys()]}get size(){return this._endpoints.size}defer(e,t){this._deferredChannels.set(e,t)}async initDeferred(e){const t=this._deferredChannels.get(e);if(!t)return null;const n=await t();return this._endpoints.set(e,n),this._deferredChannels.delete(e),n}isDeferred(e){return this._deferredChannels.has(e)}async getChannelAsync(e){return this._endpoints.has(e)?this._endpoints.get(e):this._deferredChannels.has(e)?this.initDeferred(e):null}async addWorker(e,t,n={}){const s=Ce(t);if(!s)throw new Error(`Failed to create worker for channel: ${e}`);const r=new ge(e,this,{...this._options.defaultOptions,...n}),o=r.createRemoteChannel(e,n,s),a={name:e,handler:r,connection:r.connection,subscriptions:[],transportType:"worker",ready:Promise.resolve(o),unified:r.unified};return this._endpoints.set(e,a),this._registerUnifiedChannel(e,r.unified),this._remoteChannels.set(e,{channel:e,context:this,remote:Promise.resolve(o),transport:s,transportType:"worker"}),a}async addPort(e,t,n={}){const s=new ge(e,this,{...this._options.defaultOptions,...n});t.start?.();const r=s.createRemoteChannel(e,n,t),o={name:e,handler:s,connection:s.connection,subscriptions:[],transportType:"message-port",ready:Promise.resolve(r),unified:s.unified};return this._endpoints.set(e,o),this._registerUnifiedChannel(e,s.unified),this._remoteChannels.set(e,{channel:e,context:this,remote:Promise.resolve(r),transport:t,transportType:"message-port"}),o}async addBroadcast(e,t,n={}){const s=new BroadcastChannel(t??e),r=new ge(e,this,{...this._options.defaultOptions,...n}),o=r.createRemoteChannel(e,n,s),a={name:e,handler:r,connection:r.connection,subscriptions:[],transportType:"broadcast",ready:Promise.resolve(o),unified:r.unified};return this._endpoints.set(e,a),this._registerUnifiedChannel(e,r.unified),this._remoteChannels.set(e,{channel:e,context:this,remote:Promise.resolve(o),transport:s,transportType:"broadcast"}),a}addSelfChannel(e,t={}){const n=new ge(e,this,{...this._options.defaultOptions,...t}),s=this._globalSelf??("undefined"!=typeof self?self:null),r={name:e,handler:n,connection:n.connection,subscriptions:[],transportType:"self",ready:Promise.resolve(s?n.createRemoteChannel(e,t,s):null),unified:n.unified};return this._endpoints.set(e,r),this._registerUnifiedChannel(e,n.unified),r}async addTransport(e,t){const n=t.options??{};switch(t.type){case"worker":if(!t.worker)throw new Error("Worker required for worker transport");return this.addWorker(e,t.worker,n);case"message-port":if(!t.port)throw new Error("Port required for message-port transport");return this.addPort(e,t.port,n);case"broadcast":const s="string"==typeof t.broadcast?t.broadcast:void 0;return this.addBroadcast(e,s,n);case"self":return this.addSelfChannel(e,n);default:return this.createChannel(e,n)}}createChannelPair(e,t,n={}){const s=new MessageChannel,r=new ge(e,this,{...this._options.defaultOptions,...n}),o=new ge(t,this,{...this._options.defaultOptions,...n});s.port1.start(),s.port2.start();const a=r.createRemoteChannel(t,n,s.port1),i=o.createRemoteChannel(e,n,s.port2),c={name:e,handler:r,connection:r.connection,subscriptions:[],transportType:"message-port",ready:a,unified:r.unified},l={name:t,handler:o,connection:o.connection,subscriptions:[],transportType:"message-port",ready:i,unified:o.unified};return this._endpoints.set(e,c),this._endpoints.set(t,l),this._registerUnifiedChannel(e,r.unified),this._registerUnifiedChannel(t,o.unified),{channel1:c,channel2:l,messageChannel:s}}get globalSelf(){return this._globalSelf}async connectRemote(e,t={},n){return this.initHost(),this._host.createRemoteChannel(e,t,n)}async importModuleInChannel(e,t,n={},s){const r=await this.connectRemote(e,n.channelOptions,s);return r?.doImportModule?.(t,n.importOptions)}$createOrUseExistingRemote(e,t={},n){if(null==e||n)return null;if(this._remoteChannels.has(e))return this._remoteChannels.get(e);const s=new MessageChannel,r=m(new Promise(n=>{const r=Ce(me);r?.addEventListener?.("message",e=>{"channelCreated"===e.data.type&&(s.port1?.start?.(),n(new _e(e.data.channel,this,t)))}),r?.postMessage?.({type:"createChannel",channel:e,sender:this._hostName,options:t,messagePort:s.port2},{transfer:[s.port2]})})),o={channel:e,context:this,messageChannel:s,remote:r};return this._remoteChannels.set(e,o),o}$registerConnection(e){return{...this._connectionRegistry.register(e),contextId:this._id}}$markNotified(e){const t=this._connectionRegistry.register({localChannel:e.localChannel,remoteChannel:e.remoteChannel,sender:e.sender,direction:e.direction,transportType:e.transportType});this._connectionRegistry.markNotified(t,e.payload)}$observeSignal(e){e.payload;this.$markNotified({localChannel:e.localChannel,remoteChannel:e.remoteChannel,sender:e.sender,direction:"incoming",transportType:e.transportType,payload:e.payload})}$forwardUnifiedConnectionEvent(e,t){const n=t.connection.transportType??"internal",s=this._connectionRegistry.register({localChannel:t.connection.localChannel||e,remoteChannel:t.connection.remoteChannel,sender:t.connection.sender,direction:t.connection.direction,transportType:n,metadata:t.connection.metadata});"notified"===t.type?this._connectionRegistry.markNotified(s,t.payload):"disconnected"===t.type&&this._connectionRegistry.closeByChannel(t.connection.localChannel)}closeChannel(e){const t=this._endpoints.get(e);return!!t&&(t.subscriptions.forEach(e=>e.unsubscribe()),t.handler.close(),t.transport?.detach(),this._unifiedConnectionSubs.get(e)?.unsubscribe(),this._unifiedConnectionSubs.delete(e),this._unifiedByChannel.delete(e),this._endpoints.delete(e),e===this._hostName&&(this._host=null),this._connectionRegistry.closeByChannel(e),!0)}close(){if(!this._closed){this._closed=!0;for(const[e]of this._endpoints)this.closeChannel(e);this._remoteChannels.clear(),this._host=null,this._unifiedConnectionSubs.forEach(e=>e.unsubscribe()),this._unifiedConnectionSubs.clear(),this._unifiedByChannel.clear(),this._connectionRegistry.clear(),this._connectionEvents.complete()}}get closed(){return this._closed}_registerUnifiedChannel(e,t){this._unifiedByChannel.set(e,t),this._unifiedConnectionSubs.get(e)?.unsubscribe();const n=t.subscribeConnections(t=>{this.$forwardUnifiedConnectionEvent(e,t)});this._unifiedConnectionSubs.set(e,n)}_emitConnectionEvent(e){this._connectionEvents.next({...e,connection:{...e.connection,contextId:this._id}})}}function be(t){return[...Object.values(e)].includes(t)}function we(e){return!!e&&"object"==typeof e&&"target"in e&&"function"==typeof e.postMessage}function Ce(e){if(e instanceof Worker)return e;if(e instanceof URL)return new Worker(e.href,{type:"module"});if("function"==typeof e)try{return new e({type:"module"})}catch{return e({type:"module"})}return"string"==typeof e?e.startsWith("/")?new Worker(new URL(e.replace(/^\//,"./"),import.meta.url).href,{type:"module"}):URL.canParse(e)||e.startsWith("./")?new Worker(new URL(e,import.meta.url).href,{type:"module"}):new Worker(URL.createObjectURL(new Blob([e],{type:"application/javascript"})),{type:"module"}):e instanceof Blob||e instanceof File?new Worker(URL.createObjectURL(e),{type:"module"}):e??("undefined"!=typeof self?self:null)}const ve=new Map;class ke{_context;_config;_subscriptions=[];_incomingConnections=new y({bufferSize:100});_channelCreated=new y({bufferSize:100});_channelClosed=new y;constructor(e={}){this._config={name:e.name??"worker",workerName:e.workerName??`worker-${r().slice(0,8)}`,autoAcceptChannels:e.autoAcceptChannels??!0,allowedChannels:e.allowedChannels??[],maxChannels:e.maxChannels??100,autoConnect:e.autoConnect??!0,useGlobalSelf:!0,defaultOptions:e.defaultOptions??{},isolatedStorage:e.isolatedStorage??!1,...e},this._context=function(e={}){const t=new ye(e);return e.name&&ve.set(e.name,t),t}({name:this._config.name,useGlobalSelf:!0,defaultOptions:e.defaultOptions}),this._setupMessageListener()}get onConnection(){return this._incomingConnections}get onChannelCreated(){return this._channelCreated}get onChannelClosed(){return this._channelClosed}subscribeConnections(e){return this._incomingConnections.subscribe(e)}subscribeChannelCreated(e){return this._channelCreated.subscribe(e)}acceptConnection(e){if(!this._canAcceptChannel(e.channel))return null;const t=this._context.createChannel(e.channel,e.options);return e.port&&(e.port.start?.(),t.handler.createRemoteChannel(e.sender,e.options,e.port)),this._channelCreated.next({channel:e.channel,endpoint:t,sender:e.sender,timestamp:Date.now()}),this._postChannelCreated(e.channel,e.sender,e.id),t}createChannel(e,t){return this._context.createChannel(e,t)}getChannel(e){return this._context.getChannel(e)}hasChannel(e){return this._context.hasChannel(e)}getChannelNames(){return this._context.getChannelNames()}queryConnections(e={}){return this._context.queryConnections(e)}notifyConnections(e={},t={}){return this._context.notifyConnections(e,t)}closeChannel(e){const t=this._context.closeChannel(e);return t&&this._channelClosed.next({channel:e,timestamp:Date.now()}),t}get context(){return this._context}get config(){return this._config}_setupMessageListener(){addEventListener("message",e=>{this._handleIncomingMessage(e)})}_handleIncomingMessage(e){const t=e.data;if(t&&"object"==typeof t)switch(t.type){case"createChannel":this._handleCreateChannel(t);break;case"connectChannel":this._handleConnectChannel(t);break;case"addPort":this._handleAddPort(t);break;case"listChannels":this._handleListChannels(t);break;case"closeChannel":this._handleCloseChannel(t);break;case"ping":postMessage({type:"pong",id:t.id,timestamp:Date.now()});break;default:if(t.channel&&this._context.hasChannel(t.channel)){const e=this._context.getChannel(t.channel);e?.handler?.handleAndResponse?.(t.payload,t.reqId)}}}_handleCreateChannel(e){const t={id:e.reqId??r(),channel:e.channel,sender:e.sender??"unknown",type:"channel",port:e.messagePort,timestamp:Date.now(),options:e.options};this._incomingConnections.next(t),this._config.autoAcceptChannels&&this.acceptConnection(t)}_handleConnectChannel(e){const t={id:e.reqId??r(),channel:e.channel,sender:e.sender??"unknown",type:e.portType??"channel",port:e.port,timestamp:Date.now(),options:e.options};if(this._incomingConnections.next(t),this._config.autoAcceptChannels&&this._canAcceptChannel(e.channel)){const t=this._context.getOrCreateChannel(e.channel,e.options);e.port&&(e.port.start?.(),t.handler.createRemoteChannel(e.sender,e.options,e.port)),postMessage({type:"channelConnected",channel:e.channel,reqId:e.reqId})}}_handleAddPort(e){if(!e.port||!e.channel)return;const t={id:e.reqId??r(),channel:e.channel,sender:e.sender??"unknown",type:"port",port:e.port,timestamp:Date.now(),options:e.options};this._incomingConnections.next(t),this._config.autoAcceptChannels&&this.acceptConnection(t)}_handleListChannels(e){postMessage({type:"channelList",channels:this.getChannelNames(),reqId:e.reqId})}_handleCloseChannel(e){e.channel&&(this.closeChannel(e.channel),postMessage({type:"channelClosed",channel:e.channel,reqId:e.reqId}))}_canAcceptChannel(e){return!(this._context.size>=this._config.maxChannels)&&(!(this._config.allowedChannels.length>0)||this._config.allowedChannels.includes(e))}_postChannelCreated(e,t,n){postMessage({type:"channelCreated",channel:e,sender:t,reqId:n,timestamp:Date.now()})}close(){this._subscriptions.forEach(e=>e.unsubscribe()),this._subscriptions=[],this._incomingConnections.complete(),this._channelCreated.complete(),this._channelClosed.complete(),this._context.close()}}let xe=null;var Pe;Pe={name:"worker"},xe||(xe=new ke(Pe));const Se=(e,t="worker")=>{const n=((e="$host$")=>{if(A?.instance&&"$host$"===e)return A.instance;if(j.has(e))return j.get(e)??null;const t=new W(e);return"$host$"===e&&(A.name=e,A.instance=t),j.set(e,t),t})(t??"worker");return Object.keys(e).forEach(t=>{e[t]}),n},Te=new Map,Ee=new Map,Re=async(e="")=>e&&Te.has(e)?Te.get(e):await navigator.storage.getDirectory(),Oe=e=>e?.trim?.()?.replace(/\/+/g,"/")||"/",Me=async(e,t,n)=>{const s=Oe(t).split("/").filter(e=>e);let r=e;for(const o of s)r=await r.getDirectoryHandle(o,{create:n});return r},De={mount:async({id:e,handle:t})=>(Te.set(e,t),!0),unmount:async({id:e})=>(Te.delete(e),!0),readDirectory:async({rootId:e,path:t,create:n})=>{try{const s=await Re(e),r=await Me(s,t,n),o=[];for await(const[e,t]of r.entries())o.push([e,t]);return o}catch(s){return console.warn("Worker readDirectory error:",s),[]}},readFile:async({rootId:e,path:t,type:n})=>{try{const s=await Re(e),r=Oe(t).split("/").filter(e=>e),o=r.pop(),a=r.join("/"),i=await Me(s,a,!1),c=await i.getFileHandle(o,{create:!1}),l=await c.getFile();return"text"===n?await l.text():"arrayBuffer"===n?await l.arrayBuffer():l}catch(s){return console.warn("Worker readFile error:",s),null}},writeFile:async({rootId:e,path:t,data:n})=>{try{const s=await Re(e),r=Oe(t).split("/").filter(e=>e),o=r.pop(),a=r.join("/"),i=await Me(s,a,!0),c=await i.getFileHandle(o,{create:!0}),l=await c.createWritable();return await l.write(n),await l.close(),!0}catch(s){return console.warn("Worker writeFile error:",s),!1}},remove:async({rootId:e,path:t,recursive:n})=>{try{const s=await Re(e),r=Oe(t).split("/").filter(e=>e),o=r.pop(),a=r.join("/"),i=await Me(s,a,!1);return await i.removeEntry(o,{recursive:n}),!0}catch(s){return!1}},observe:async({rootId:e,path:t,id:n})=>{try{if(Ee.has(n))return!0;const s=await Re(e),r=await Me(s,t,!1);if("undefined"!=typeof FileSystemObserver){const e=new FileSystemObserver(e=>{const t=e.map(e=>{const t=e.changedHandle?.name||e.relativePathComponents?.at(-1);return{type:e.type,name:t,kind:e.changedHandle?.kind||(t?.includes(".")?"file":"directory"),handle:e.changedHandle,path:e.relativePathComponents.join("/")}});self.postMessage({type:"observation",id:n,changes:t})});return e.observe(r),Ee.set(n,e),!0}return!1}catch(s){return!1}},unobserve:async({id:e})=>{const t=Ee.get(e);return t&&(t.disconnect(),Ee.delete(e)),!0},copy:async({from:e,to:t})=>{try{const n=async(e,t)=>{if("directory"===e.kind)for await(const[s,r]of e.entries())if("directory"===r.kind){const e=await t.getDirectoryHandle(s,{create:!0});await n(r,e)}else{const e=await r.getFile(),n=await t.getFileHandle(s,{create:!0}),o=await n.createWritable();await o.write(e),await o.close()}else{const n=await e.getFile(),s=await t.createWritable();await s.write(n),await s.close()}};return await n(e,t),!0}catch(n){return console.warn("Worker copy error:",n),!1}}};self.addEventListener("message",async e=>{if(!e.data||"object"!=typeof e.data)return;const{id:t,type:n,payload:s}=e.data;if(De[n])try{const e=await De[n](s);self.postMessage({id:t,result:e})}catch(r){self.postMessage({id:t,error:r?.message||String(r)})}else t&&self.postMessage({id:t,error:`Unknown operation type: ${n}`})}),De&&Se(De);const Ie=async e=>{const t=De[e.type];if(!t)throw new Error(`Unknown message type: ${e.type}`);return await t(e.payload)};globalThis.processMessage=async e=>{try{if("batch"===e.type){const t=[];for(const n of e.payload){const e=await Ie(n);t.push(e)}return t}return await Ie(e)}catch(t){throw console.error("[OPFS Worker] Message processing error:",t),t}};
