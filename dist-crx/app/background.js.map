{"version":3,"mappings":"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","names":["MARKDOWN_EXT_RE","r"],"ignoreList":[],"sources":["../../src/crx/service/api.ts","../../src/crx/sw.ts"],"sourcesContent":["/**\n * CRX Service API\n *\n * Handles all service-worker-side operations:\n *  - Tab capture (screenshot) with optional crop rect\n *  - AI processing pipeline (recognize, solve, code, css, custom)\n *  - Clipboard copy (COPY_HACK multi-fallback)\n *  - Markdown loading with URL normalization\n *  - Runtime channel message routing\n */\n\nimport { ableToShowImage, encodeWithJSquash, removeAnyPrefix } from \"@rs-core/workers/ImageProcess\";\nimport {\n    recognizeImageData,\n    solveAndAnswer,\n    writeCode,\n    extractCSS,\n    recognizeByInstructions,\n} from \"../../com/service/service/RecognizeData\";\nimport type { RecognizeResult } from \"../../com/service/service/RecognizeData\";\nimport { toText } from \"@rs-core/modules/Clipboard\";\nimport { getCustomInstructions } from \"@rs-com/service/misc/CustomInstructions\";\n\n// ---------------------------------------------------------------------------\n// Constants\n// ---------------------------------------------------------------------------\n\n/** Compress images larger than 2 MB */\nconst SIZE_THRESHOLD = 2 * 1024 * 1024;\n\nconst MARKDOWN_EXT_RE = /\\.(?:md|markdown|mdown|mkd|mkdn|mdtxt|mdtext)(?:$|[?#])/i;\n\n// ---------------------------------------------------------------------------\n// Types\n// ---------------------------------------------------------------------------\n\nexport type SnipMode = \"recognize\" | \"solve\" | \"code\" | \"css\" | \"custom\";\n\ninterface CaptureOptions {\n    rect?: { x: number; y: number; width: number; height: number };\n    scale?: number;\n}\n\ninterface CaptureResult {\n    ok: boolean;\n    data?: string;\n    error?: string;\n}\n\n// ---------------------------------------------------------------------------\n// Internal helpers\n// ---------------------------------------------------------------------------\n\nconst isProbablyUrl = (v: string) => { try { return Boolean(new URL(v)); } catch { return false; } };\n\nconst formatRuntimeError = (e: unknown): string => {\n    if (e instanceof Error) {\n        const firstStackLine = e.stack?.split?.(\"\\n\")?.[1]?.trim?.();\n        return firstStackLine ? `${e.name}: ${e.message} @ ${firstStackLine}` : `${e.name}: ${e.message}`;\n    }\n    return String(e);\n};\n\nconst dataUrlToFile = async (dataUrl: string, name = \"snip.png\"): Promise<File | Blob> => {\n    try {\n        const res = await fetch(dataUrl);\n        const blob = await res.blob();\n        try { return new File([blob], name, { type: blob.type || \"image/png\", lastModified: Date.now() }); }\n        catch { return blob; }\n    } catch {\n        return new Blob([dataUrl], { type: \"text/plain\" });\n    }\n};\n\nconst compressIfNeeded = async (dataUrl: string): Promise<string> => {\n    if (dataUrl.length <= SIZE_THRESHOLD) return dataUrl;\n    try {\n        // @ts-ignore — Uint8Array.fromBase64/toBase64 available in modern Chrome\n        const binary = Uint8Array.fromBase64(removeAnyPrefix(dataUrl), { alphabet: \"base64\" });\n        const blob = new Blob([binary], { type: \"image/png\" });\n        const bitmap = await createImageBitmap(blob);\n        const ab = await encodeWithJSquash(bitmap);\n        bitmap?.close?.();\n        if (ab) {\n            // @ts-ignore\n            return `data:image/jpeg;base64,${new Uint8Array(ab).toBase64({ alphabet: \"base64\" })}`;\n        }\n    } catch (e) {\n        console.warn(\"[api] compression failed:\", e);\n    }\n    return dataUrl;\n};\n\n/** Best-available timing function (RAF → setTimeout → immediate) */\nconst schedule = (() => {\n    if (typeof requestAnimationFrame !== \"undefined\") return requestAnimationFrame;\n    if (typeof setTimeout !== \"undefined\") return (cb: () => void) => setTimeout(cb, 0);\n    return (cb: () => void) => cb();\n})();\n\n/** Extract meaningful text from an AI recognition result */\nconst extractRecognizedText = (result: RecognizeResult): string => {\n    if (typeof result === \"string\") return result;\n    if (!result?.ok) return \"\";\n\n    let text = result.data;\n    if (text && typeof text !== \"string\") {\n        try { text = JSON.stringify(text); } catch { text = String(text); }\n    }\n    if (!text) return \"\";\n\n    // Try to unwrap JSON wrappers\n    if (text.trim().startsWith(\"{\") || text.trim().startsWith(\"[\")) {\n        try {\n            const p = JSON.parse(text);\n            const candidate =\n                p?.recognized_data ?? p?.data ?? p?.text;\n            if (typeof candidate === \"string\") return candidate.trim();\n            if (candidate != null) return JSON.stringify(candidate);\n        } catch { /* not JSON */ }\n    }\n    return (typeof text === \"string\" ? text : String(text)).trim();\n};\n\n// ---------------------------------------------------------------------------\n// Unified Tab Capture\n// ---------------------------------------------------------------------------\n\n/**\n * Capture the visible tab as a data-URL, optionally cropped.\n * Compresses large images and validates the result.\n */\nconst captureVisibleTab = async (options?: CaptureOptions): Promise<string> => {\n    const captureOpts: { format: \"png\" | \"jpeg\"; quality?: number; rect?: any; scale?: number } = {\n        format: \"png\",\n        scale: options?.scale ?? 1,\n    };\n    if (options?.rect && options.rect.width > 0 && options.rect.height > 0) {\n        captureOpts.rect = options.rect;\n    }\n\n    const dataUrl = await new Promise<string>((resolve, reject) => {\n        chrome.tabs.captureVisibleTab(captureOpts, (url) => {\n            if (chrome.runtime.lastError) reject(new Error(chrome.runtime.lastError.message));\n            else resolve(url);\n        });\n    });\n\n    let finalUrl = await compressIfNeeded(dataUrl);\n    if (!finalUrl || !(await ableToShowImage(finalUrl))) finalUrl = dataUrl;\n    return finalUrl;\n};\n\n// ---------------------------------------------------------------------------\n// Unified AI processing\n// ---------------------------------------------------------------------------\n\n/** Map mode → AI function */\nconst AI_DISPATCH: Record<string, (input: File | Blob) => Promise<CaptureResult>> = {\n    recognize: recognizeImageData,\n    solve: solveAndAnswer,\n    code: writeCode,\n    css: extractCSS,\n};\n\n/**\n * Capture visible tab + run AI processing + copy result to clipboard.\n * Handles all modes (recognize, solve, code, css, custom).\n */\nconst captureAndProcess = async (\n    ext: typeof chrome,\n    rect: CaptureOptions[\"rect\"],\n    mode: SnipMode = \"recognize\",\n    extra?: { instructionId?: string; sender?: chrome.runtime.MessageSender },\n): Promise<CaptureResult> => {\n    // 1. Screenshot\n    const imageUrl = await captureVisibleTab({ rect });\n\n    // 2. Convert to file\n    const file = await dataUrlToFile(imageUrl, \"snip.png\");\n\n    // 3. Process\n    let result: CaptureResult;\n\n    if (mode === \"custom\" && extra?.instructionId) {\n        const instructions = await getCustomInstructions().catch(() => []);\n        const instruction = instructions.find((i) => i.id === extra.instructionId);\n        if (!instruction) return { ok: false, error: \"Custom instruction not found\" };\n\n        const input = [{\n            type: \"message\",\n            role: \"user\",\n            content: [{ type: \"input_image\", image_url: imageUrl }],\n        }];\n        const raw = await recognizeByInstructions(input, instruction.instruction);\n        const text = extractRecognizedText(raw);\n        result = {\n            ok: raw?.ok ?? !!text,\n            data: text,\n            error: raw?.error || (!text ? `${instruction.label} failed` : undefined),\n        };\n    } else {\n        const fn = AI_DISPATCH[mode] ?? AI_DISPATCH.recognize;\n        result = await fn(file);\n    }\n\n    // 4. Copy to clipboard\n    if (result.ok && result.data) {\n        await COPY_HACK(ext, result, extra?.sender?.tab?.id).catch(console.warn);\n    }\n\n    return result;\n};\n\n// ---------------------------------------------------------------------------\n// Runtime channel handlers (for createRuntimeChannelModule calls)\n// ---------------------------------------------------------------------------\n\nconst handleCapture = (ext: typeof chrome, data: any, sender: any) =>\n    captureAndProcess(ext, data.rect, data.mode || \"recognize\", { sender });\n\nconst handleCaptureScreenshot = async (_ext: typeof chrome, data: any) => {\n    const imageUrl = await captureVisibleTab({ rect: data.rect });\n    return { ok: true, data: imageUrl, imageData: imageUrl };\n};\n\nconst handleProcessImage = async (ext: typeof chrome, data: any, sender: any) => {\n    const imageData = data.imageData;\n    const mode: SnipMode = data.mode || \"recognize\";\n    const file = typeof imageData === \"string\" ? await dataUrlToFile(imageData) : imageData;\n\n    const fn = AI_DISPATCH[mode] ?? AI_DISPATCH.recognize;\n    const result = await fn(file);\n\n    if (result.ok && result.data) {\n        await COPY_HACK(ext, result, sender?.tab?.id).catch(console.warn);\n    }\n    return result;\n};\n\nconst handleProcessText = async (_ext: typeof chrome, data: any) =>\n    recognizeImageData(new Blob([data.content], { type: \"text/plain\" }));\n\nconst handleDoCopy = async (ext: typeof chrome, data: any) => {\n    const result = await COPY_HACK(ext, data.data, data.tabId);\n    return { success: result?.ok || false };\n};\n\nconst handleCaptureWithRect = async (data: any) =>\n    ({ status: \"rect_selection_required\", mode: data.mode } as const);\n\n// ---------------------------------------------------------------------------\n// Markdown loader (service-worker-side)\n// ---------------------------------------------------------------------------\n\nconst normalizeSourceUrl = (candidate: string): string => {\n    try {\n        const u = new URL(candidate);\n\n        // GitHub blob → raw.githubusercontent.com\n        if (u.hostname === \"github.com\") {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const idx = parts.indexOf(\"blob\") === 2 ? 2 : parts.indexOf(\"raw\") === 2 ? 2 : -1;\n            if (parts.length >= 5 && idx === 2) {\n                return `https://raw.githubusercontent.com/${parts[0]}/${parts[1]}/${parts[3]}/${parts.slice(4).join(\"/\")}`;\n            }\n        }\n\n        // GitLab blob → raw\n        if (u.hostname.endsWith(\"gitlab.com\")) {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const di = parts.indexOf(\"-\");\n            if (di >= 0 && parts[di + 1] === \"blob\") {\n                return `https://${u.hostname}/${parts.slice(0, di).join(\"/\")}/-/raw/${parts[di + 2] || \"\"}/${parts.slice(di + 3).join(\"/\")}`;\n            }\n        }\n\n        // Bitbucket — ?raw=1\n        if (u.hostname === \"bitbucket.org\") {\n            if (!u.searchParams.has(\"raw\")) u.searchParams.set(\"raw\", \"1\");\n            return u.toString();\n        }\n\n        return u.toString();\n    } catch { return candidate; }\n};\n\nconst looksLikeHtmlDocument = (text: string): boolean => {\n    const t = (text || \"\").trimStart().toLowerCase();\n    return t.startsWith(\"<!doctype html\") || t.startsWith(\"<html\") || t.startsWith(\"<head\") || t.startsWith(\"<body\");\n};\n\nconst looksLikeMarkdown = (text: string): boolean => {\n    const t = (text || \"\").trim();\n    if (!t || looksLikeHtmlDocument(t)) return false;\n    let hits = 0;\n    if (/^#{1,6}\\s+.+$/m.test(t)) hits++;\n    if (/^\\s*[-*+]\\s+\\S+/m.test(t)) hits++;\n    if (/^\\s*\\d+\\.\\s+\\S+/m.test(t)) hits++;\n    if (/```[\\s\\S]*?```/.test(t)) hits++;\n    if (/\\[([^\\]]+)\\]\\(([^)]+)\\)/.test(t)) hits++;\n    return hits >= 2;\n};\n\nconst guessLanguage = (url: URL): string => {\n    const ext = ((url.pathname.split(\"/\").pop() || \"\").split(\".\").pop() || \"\").toLowerCase();\n    const map: Record<string, string> = {\n        ts: \"ts\", tsx: \"tsx\", js: \"js\", jsx: \"jsx\", json: \"json\",\n        css: \"css\", scss: \"scss\", html: \"html\", htm: \"html\", xml: \"xml\",\n        yml: \"yaml\", yaml: \"yaml\", py: \"py\", sh: \"sh\", go: \"go\", rs: \"rs\", java: \"java\",\n    };\n    return map[ext] || \"\";\n};\n\nconst handleLoadMarkdown = async (src: string) => {\n    let text = \"\";\n    let normalizedSrc: string | undefined;\n\n    try {\n        normalizedSrc = normalizeSourceUrl(src);\n        const u = new URL(normalizedSrc);\n        const res = await fetch(u.href, { credentials: \"include\", cache: \"no-store\", headers: { accept: \"text/markdown,text/plain,*/*\" } });\n        if (!res.ok) return { error: `Failed to load: ${res.status}` };\n\n        text = await res.text();\n\n        if (!looksLikeHtmlDocument(text)) {\n            const ct = (res.headers.get(\"content-type\") || \"\").toLowerCase();\n            const isMd = MARKDOWN_EXT_RE.test(u.pathname) || ct.includes(\"text/markdown\") || looksLikeMarkdown(text);\n            if (!isMd) {\n                const lang = guessLanguage(u);\n                text = `\\`\\`\\`${lang}\\n${text.replace(/\\r\\n/g, \"\\n\")}\\n\\`\\`\\`\\n`;\n            }\n        }\n    } catch {\n        text = src; // not a URL — treat as raw markdown\n    }\n\n    const key = `md_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n    await chrome.storage.session.set({ [key]: text });\n    return { key, src: isProbablyUrl(normalizedSrc || src) ? (normalizedSrc || src) : undefined };\n};\n\n// ---------------------------------------------------------------------------\n// COPY_HACK — multi-fallback clipboard write\n// ---------------------------------------------------------------------------\n\nexport const COPY_HACK = async (\n    ext: typeof chrome,\n    data: { ok?: boolean; data?: string; error?: string },\n    tabId?: number,\n): Promise<{ ok: boolean; error?: string }> => {\n    const text = toText(data?.data).trim();\n    if (!text) return { ok: false, error: \"Empty content\" };\n\n    return new Promise<{ ok: boolean; error?: string }>((resolve) => {\n        schedule(async () => {\n            // 1. Content-script on specified tab\n            if (tabId && tabId > 0) {\n                try {\n                    const tab = await ext.tabs.get(tabId).catch(() => null);\n                    if (tab) {\n                        await ext.scripting.executeScript({ target: { tabId }, files: [\"content/main.ts\"] }).catch(() => {});\n                        const r = await ext.tabs.sendMessage(tabId, { type: \"COPY_HACK\", data: text });\n                        if (r?.ok) return resolve({ ok: true });\n                    }\n                } catch { /* continue */ }\n            }\n\n            // 2. Offscreen document\n            try {\n                const offscreenUrl = \"offscreen/copy.html\";\n                const existing = await ext.runtime.getContexts?.({\n                    contextTypes: [ext.runtime.ContextType.OFFSCREEN_DOCUMENT as any],\n                    documentUrls: [ext.runtime.getURL(offscreenUrl)],\n                })?.catch?.(() => []);\n\n                if (!existing?.length) {\n                    await ext.offscreen.createDocument({\n                        url: offscreenUrl,\n                        reasons: [ext.offscreen.Reason.CLIPBOARD],\n                        justification: \"Clipboard access for copied text\",\n                    });\n                    await new Promise((r) => setTimeout(r, 500));\n                }\n                const r = await ext.runtime.sendMessage({ target: \"offscreen\", type: \"COPY_HACK\", data: text });\n                if (r?.ok) return resolve({ ok: true });\n            } catch { /* continue */ }\n\n            // 3. Any available tab\n            try {\n                const tabs = await ext.tabs.query({}).catch(() => []);\n                for (const tab of tabs || []) {\n                    if (tab?.id && tab.id !== tabId) {\n                        try {\n                            await ext.scripting.executeScript({ target: { tabId: tab.id }, files: [\"content/main.ts\"] }).catch(() => {});\n                            const r = await ext.tabs.sendMessage(tab.id, { type: \"COPY_HACK\", data: text });\n                            if (r?.ok) return resolve({ ok: true });\n                        } catch { /* next tab */ }\n                    }\n                }\n            } catch { /* continue */ }\n\n            // 4. Direct clipboard API (service worker — limited support)\n            try {\n                if (typeof navigator !== \"undefined\" && navigator.clipboard?.writeText) {\n                    await navigator.clipboard.writeText(text);\n                    return resolve({ ok: true });\n                }\n            } catch { /* continue */ }\n\n            resolve({ ok: false, error: \"All clipboard methods failed\" });\n        });\n    });\n};\n\n// ---------------------------------------------------------------------------\n// Public: enableCapture — registers message listeners on service worker\n// ---------------------------------------------------------------------------\n\n/**\n * Register all capture/processing/markdown message listeners on the service worker.\n * Called once from sw.ts at startup.\n */\nexport const enableCapture = (ext: typeof chrome) => {\n    ext.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n        // ---- Runtime channel messages (from createRuntimeChannelModule) ----\n        if (msg?.id?.startsWith(\"crx_\") && msg?.type && msg?.data) {\n            (async () => {\n                try {\n                    const route: Record<string, () => Promise<any>> = {\n                        capture: () => handleCapture(ext, msg.data, sender),\n                        captureScreenshot: () => handleCaptureScreenshot(ext, msg.data),\n                        processImage: () => handleProcessImage(ext, msg.data, sender),\n                        processText: () => handleProcessText(ext, msg.data),\n                        doCopy: () => handleDoCopy(ext, msg.data),\n                        loadMarkdown: () => handleLoadMarkdown(msg.data),\n                        captureWithRect: () => handleCaptureWithRect(msg.data),\n                    };\n                    const handler = route[msg.type];\n                    sendResponse(handler ? await handler() : { ok: false, error: `Unknown method: ${msg.type}` });\n                } catch (e) {\n                    sendResponse({ ok: false, error: formatRuntimeError(e) });\n                }\n            })();\n            return true;\n        }\n\n        // ---- Legacy direct messages (CAPTURE / CAPTURE_SOLVE / etc.) ----\n        const CAPTURE_MODES: Record<string, SnipMode> = {\n            CAPTURE: \"recognize\",\n            CAPTURE_SOLVE: \"solve\",\n            CAPTURE_ANSWER: \"solve\",\n            CAPTURE_CODE: \"code\",\n            CAPTURE_CSS: \"css\",\n            CAPTURE_CUSTOM: \"custom\",\n        };\n\n        if (msg?.type && msg.type in CAPTURE_MODES) {\n            const mode = CAPTURE_MODES[msg.type];\n            (async () => {\n                try {\n                    const result = await captureAndProcess(ext, msg.rect, mode, {\n                        instructionId: msg.instructionId,\n                        sender,\n                    });\n                    sendResponse(result);\n                } catch (e) {\n                    sendResponse({ ok: false, error: formatRuntimeError(e) });\n                }\n            })();\n            return true;\n        }\n\n        // ---- Download ----\n        if (msg?.type === \"DOWNLOAD\" && msg.dataUrl) {\n            chrome.downloads.download(\n                { url: msg.dataUrl, filename: \"snip.png\", saveAs: true },\n                (id) => {\n                    if (chrome.runtime.lastError) {\n                        sendResponse({ ok: false, error: chrome.runtime.lastError.message, dataUrl: msg.dataUrl });\n                    } else {\n                        sendResponse({ ok: true, id });\n                    }\n                },\n            );\n            return true;\n        }\n\n        return false;\n    });\n};\n","/**\n * CrossWord — Chrome Extension Service Worker\n *\n * Responsibilities:\n *  - Context menu setup (copy-as-*, snip modes, markdown viewer, custom instructions)\n *  - Keyboard command handling (Ctrl+Shift+X/Y)\n *  - AI recognition message dispatch (gpt:recognize, gpt:solve, gpt:code, gpt:css, gpt:custom, gpt:translate)\n *  - Markdown URL detection & auto-redirect to viewer\n *  - CRX result pipeline (clipboard → content-script → popup → workcenter → notification)\n *  - CRX unified messaging integration\n *\n * Heavy capture/AI/clipboard logic is in `./service/api.ts`.\n */\n\nimport { createTimelineGenerator, requestNewTimeline } from \"@rs-com/service/service/MakeTimeline\";\nimport { COPY_HACK, enableCapture } from \"./service/api\";\nimport type { GPTResponses } from \"@rs-com/service/model/GPT-Responses\";\nimport { recognizeImageData } from \"../com/service/service/RecognizeData\";\nimport { getGPTInstance, processDataWithInstruction } from \"@rs-com/service/service/RecognizeData\";\nimport { getCustomInstructions, type CustomInstruction } from \"@rs-com/service/misc/CustomInstructions\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport { executionCore } from \"@rs-com/service/misc/ExecutionCore\";\nimport type { ActionContext, ActionInput } from \"@rs-com/service/misc/ActionHistory\";\nimport { crxMessaging, registerCrxHandler, broadcastToCrxTabs } from \"../com/core/CrxMessaging\";\nimport { CRX_SOLVE_AND_ANSWER_INSTRUCTION, CRX_WRITE_CODE_INSTRUCTION, CRX_EXTRACT_CSS_INSTRUCTION } from \"@rs-com/core/BuiltInAI\";\n\n// ---------------------------------------------------------------------------\n// Environment detection\n// ---------------------------------------------------------------------------\n\nconst isInCrxEnvironment = crxMessaging.isCrxEnvironment();\n\n// ---------------------------------------------------------------------------\n// Broadcast helpers\n// ---------------------------------------------------------------------------\n\nconst TOAST_CHANNEL = \"rs-toast\";\nconst AI_RECOGNITION_CHANNEL = \"rs-ai-recognition\";\nconst POPUP_CHANNEL = \"rs-popup\";\n\nconst broadcast = (channel: string, message: unknown): void => {\n    try { const bc = new BroadcastChannel(channel); bc.postMessage(message); bc.close(); }\n    catch { /* ignore */ }\n};\n\nconst showExtensionToast = (message: string, kind: \"info\" | \"success\" | \"warning\" | \"error\" = \"info\"): void =>\n    broadcast(TOAST_CHANNEL, { type: \"show-toast\", options: { message, kind, duration: 3000 } });\n\n// ---------------------------------------------------------------------------\n// Clipboard shortcut\n// ---------------------------------------------------------------------------\n\nconst requestClipboardCopy = async (data: unknown, showFeedback = true, tabId?: number): Promise<void> => {\n    try {\n        let resolvedTabId = tabId;\n        if ((!resolvedTabId || resolvedTabId <= 0) && showFeedback) {\n            const tabs = await chrome.tabs.query({ active: true, currentWindow: true }).catch(() => []);\n            resolvedTabId = tabs?.[0]?.id;\n        }\n        await COPY_HACK(chrome, { ok: true, data: data as any }, resolvedTabId);\n    } catch (e) { console.warn(\"[SW] clipboard copy failed:\", e); }\n};\n\n// ---------------------------------------------------------------------------\n// Custom instructions helper\n// ---------------------------------------------------------------------------\n\nconst loadCustomInstructions = async (): Promise<CustomInstruction[]> => {\n    try { return await getCustomInstructions(); }\n    catch { return []; }\n};\n\n// ---------------------------------------------------------------------------\n// Execution core wrapper\n// ---------------------------------------------------------------------------\n\nconst processChromeExtensionAction = async (\n    input: ActionInput,\n    sessionId?: string,\n): Promise<{ success: boolean; result?: any; error?: string }> => {\n    try {\n        const context: ActionContext = {\n            source: \"chrome-extension\",\n            sessionId: sessionId || `crx_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,\n        };\n        const result = await executionCore.execute(input, context);\n        if (result.type === \"error\") {\n            return { success: false, error: result.content || result.error || \"Processing failed\", result };\n        }\n        return { success: true, result };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n};\n\n// ============================================================================\n// DIRECT CHROME MESSAGE HANDLING\n// ============================================================================\n\nif (isInCrxEnvironment && chrome.runtime?.onMessage) {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        if (!message?.type) return false;\n\n        // --- processCapture (direct) ---\n        if (message.type === \"processCapture\") {\n            (async () => {\n                try {\n                    const rect = message.data?.rect;\n                    const opts: chrome.tabs.CaptureVisibleTabOptions & { rect?: any; scale?: number } = { format: \"png\", scale: 1 };\n                    if (rect?.width > 0 && rect?.height > 0) opts.rect = rect;\n\n                    const dataUrl = await new Promise<string>((resolve, reject) => {\n                        chrome.tabs.captureVisibleTab(opts, (url) => {\n                            chrome.runtime.lastError ? reject(new Error(chrome.runtime.lastError.message)) : resolve(url);\n                        });\n                    });\n                    const blob = await (await fetch(dataUrl)).blob();\n                    const result = await recognizeImageData(blob);\n                    sendResponse({ success: true, result });\n                } catch (error) {\n                    sendResponse({ success: false, error: error instanceof Error ? error.message : String(error) });\n                }\n            })();\n            return true;\n        }\n\n        // --- processText (direct) ---\n        if (message.type === \"processText\") {\n            sendResponse({ success: true, result: { type: \"text\", content: message.data?.content, processed: true } });\n            return false;\n        }\n\n        return false;\n    });\n}\n\n// ============================================================================\n// CRX UNIFIED MESSAGING HANDLERS\n// ============================================================================\n\nif (isInCrxEnvironment) {\n    registerCrxHandler(\"processImage\", async (data: { imageData: string; mode: string; customInstructionId?: string }) => {\n        const result = await processChromeExtensionAction({ type: \"recognize\", data: data.imageData, mode: data.mode, customInstructionId: data.customInstructionId });\n        crxMessaging.sendRuntimeMessage({ type: \"processingComplete\", data: { result }, metadata: { progress: 100 } }).catch(() => {});\n        return result;\n    });\n\n    registerCrxHandler(\"processCapture\", async (data: any) =>\n        processChromeExtensionAction({ type: \"capture\", data, mode: data.type?.toLowerCase().replace(\"capture_\", \"\") || \"recognize\" })\n    );\n\n    registerCrxHandler(\"processText\", async (data: { content: string; contentType: string }) =>\n        processChromeExtensionAction({ type: \"process\", data: data.content, contentType: data.contentType })\n    );\n\n    registerCrxHandler(\"getProcessingStatus\", async (data: { operationId: string }) =>\n        ({ status: \"completed\", operationId: data.operationId })\n    );\n\n    registerCrxHandler(\"cancelProcessing\", async (data: { operationId: string }) =>\n        ({ cancelled: true, operationId: data.operationId })\n    );\n}\n\nregisterCrxHandler(\"getSettings\", async () => { try { return await loadSettings(); } catch (e) { throw e; } });\nregisterCrxHandler(\"updateSettings\", async (updates: any) => ({ success: true }));\nregisterCrxHandler(\"ping\", async () => ({ status: \"ok\", context: \"service-worker\", timestamp: Date.now() }));\n\nregisterCrxHandler(\"broadcastResult\", async (data: { result: any; type: string }) => {\n    await broadcastToCrxTabs({ type: \"ai-result\", data: data.result, metadata: { source: \"service-worker\" } });\n    broadcast(AI_RECOGNITION_CHANNEL, { type: data.type, result: data.result, timestamp: Date.now(), source: \"crx-service-worker\" });\n    return { broadcasted: true };\n});\n\n// ============================================================================\n// CRX RESULT PIPELINE\n// ============================================================================\n\ninterface CrxResult {\n    id: string;\n    type: \"text\" | \"image\" | \"markdown\" | \"processed\";\n    content: string | ArrayBuffer;\n    source: \"crx-snip\" | \"content-script\" | \"ai-processing\";\n    timestamp: number;\n    metadata?: Record<string, any>;\n}\n\ninterface CrxDestination {\n    type: \"clipboard\" | \"content-script\" | \"popup\" | \"workcenter\" | \"notification\";\n    tabId?: number;\n    frameId?: number;\n    options?: Record<string, any>;\n}\n\ninterface PendingResult {\n    id: string;\n    result: CrxResult;\n    destinations: CrxDestination[];\n    status: \"pending\" | \"processing\" | \"completed\" | \"failed\";\n    attempts: number;\n    createdAt: number;\n    completedAt?: number;\n    error?: string;\n}\n\nclass CrxResultPipeline {\n    resultQueue: PendingResult[] = [];\n    private maxQueueSize = 50;\n    private maxRetries = 3;\n    private interval: ReturnType<typeof setInterval> | null = null;\n\n    constructor() { this.interval = globalThis.setInterval(() => this.processQueue(), 1000); }\n\n    async enqueue(result: CrxResult, destinations: CrxDestination[]): Promise<string> {\n        const pr: PendingResult = { id: crypto.randomUUID(), result, destinations, status: \"pending\", attempts: 0, createdAt: Date.now() };\n        this.resultQueue.push(pr);\n        if (this.resultQueue.length > this.maxQueueSize) this.resultQueue.shift();\n        return pr.id;\n    }\n\n    getStatus() {\n        const c = { pending: 0, processing: 0, completed: 0, failed: 0 };\n        for (const r of this.resultQueue) c[r.status]++;\n        return { queueSize: this.resultQueue.length, ...c };\n    }\n\n    getPending(dest?: string) {\n        return this.resultQueue.filter((r) => r.status === \"pending\" && (!dest || r.destinations.some((d) => d.type === dest)));\n    }\n\n    clearCompleted() {\n        const n = this.resultQueue.filter((r) => r.status === \"completed\").length;\n        this.resultQueue = this.resultQueue.filter((r) => r.status !== \"completed\");\n        return n;\n    }\n\n    destroy() { if (this.interval) clearInterval(this.interval); this.interval = null; this.resultQueue = []; }\n\n    // --- internal ---\n\n    private async processQueue() {\n        for (const pr of this.resultQueue.filter((r) => r.status === \"pending\")) {\n            pr.status = \"processing\";\n            pr.attempts++;\n            let anyOk = false;\n            for (const dest of pr.destinations) {\n                try { await this.deliver(pr.result, dest); anyOk = true; } catch { /* continue */ }\n            }\n            if (anyOk) { pr.status = \"completed\"; pr.completedAt = Date.now(); }\n            else if (pr.attempts >= this.maxRetries) { pr.status = \"failed\"; pr.error = \"All destinations failed\"; }\n            else pr.status = \"pending\";\n        }\n    }\n\n    private async deliver(result: CrxResult, dest: CrxDestination) {\n        const textContent = typeof result.content === \"string\" ? result.content : `[Binary ${(result.content as ArrayBuffer).byteLength} bytes]`;\n\n        switch (dest.type) {\n            case \"clipboard\":\n                await requestClipboardCopy(textContent, dest.options?.showFeedback !== false, dest.tabId);\n                break;\n\n            case \"content-script\": {\n                const msg = { type: \"crx-result-delivered\", result, destination: dest.type, timestamp: Date.now() };\n                if (dest.tabId) await chrome.tabs.sendMessage(dest.tabId, msg, { frameId: dest.frameId });\n                else await broadcastToCrxTabs(msg as any);\n                break;\n            }\n            case \"popup\":\n                broadcast(POPUP_CHANNEL, { type: \"crx-result-delivered\", result, destination: dest.type, timestamp: Date.now() });\n                break;\n\n            case \"workcenter\":\n                try {\n                    const { unifiedMessaging } = await import(\"@rs-com/core/UnifiedMessaging\");\n                    await unifiedMessaging.sendMessage({\n                        id: result.id, type: \"content-share\", source: \"crx-snip\", destination: \"workcenter\",\n                        contentType: result.type, data: { text: textContent, processed: true, source: result.source, metadata: result.metadata },\n                        metadata: { title: `CRX-Snip ${result.type} Result`, timestamp: result.timestamp, source: result.source },\n                    });\n                } catch { throw new Error(\"WorkCenter delivery failed\"); }\n                break;\n\n            case \"notification\":\n                await chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: `CrossWord ${result.source}`, message: textContent.length > 100 ? textContent.slice(0, 100) + \"...\" : textContent });\n                break;\n        }\n    }\n}\n\nconst pipeline = new CrxResultPipeline();\n\n// Cleanup on termination\nself.addEventListener(\"beforeunload\", () => pipeline.destroy());\n\n// Pipeline convenience helpers\nconst enqueueText = (content: string, destinations: CrxDestination[]) =>\n    pipeline.enqueue({ id: crypto.randomUUID(), type: \"text\", content, source: \"crx-snip\", timestamp: Date.now() }, destinations);\n\nconst processCrxSnipWithPipeline = async (\n    content: string | ArrayBuffer,\n    contentType = \"text\",\n    extraDest: CrxDestination[] = [],\n): Promise<{ success: boolean; resultId?: string; error?: string }> => {\n    try {\n        let processedContent: string | ArrayBuffer = content;\n        let finalType = contentType;\n\n        if ((contentType === \"image\" || content instanceof ArrayBuffer) && content instanceof ArrayBuffer) {\n            const blob = new Blob([content], { type: \"image/png\" });\n            const rec = await recognizeImageData(blob);\n            processedContent = rec.text || \"\";\n            finalType = \"text\";\n        }\n\n        const input: ActionInput = {\n            type: \"process\", content: processedContent, contentType: finalType as any,\n            metadata: { source: \"crx-snip\", timestamp: Date.now(), background: true, originalType: contentType },\n        };\n        const result = await processChromeExtensionAction(input);\n\n        if (result.success && result.result) {\n            const crxResult: CrxResult = {\n                id: crypto.randomUUID(), type: \"processed\",\n                content: typeof result.result === \"string\" ? result.result : String(result.result),\n                source: \"crx-snip\", timestamp: Date.now(),\n            };\n            const destinations: CrxDestination[] = [\n                { type: \"clipboard\", options: { showFeedback: true } },\n                { type: \"content-script\" },\n                { type: \"workcenter\" },\n                { type: \"notification\" },\n                ...extraDest,\n            ];\n            const resultId = await pipeline.enqueue(crxResult, destinations);\n            return { success: true, resultId };\n        }\n        return { success: false, error: result.error };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n};\n\n// ============================================================================\n// MARKDOWN VIEWER SUPPORT\n// ============================================================================\n\nconst VIEWER_PAGE = \"markdown/viewer.html\";\nconst VIEWER_ORIGIN = chrome.runtime.getURL(\"\");\nconst VIEWER_URL = chrome.runtime.getURL(VIEWER_PAGE);\nconst MARKDOWN_EXT_RE = /\\.(?:md|markdown|mdown|mkd|mkdn|mdtxt|mdtext)(?:$|[?#])/i;\nconst MD_VIEW_MENU_ID = \"crossword:markdown-view\";\n\nconst isMarkdownUrl = (candidate?: string | null): candidate is string => {\n    if (!candidate || typeof candidate !== \"string\") return false;\n    try {\n        const url = new URL(candidate);\n        if (url.protocol === \"chrome-extension:\") return false;\n        if (![\"http:\", \"https:\", \"file:\", \"ftp:\"].includes(url.protocol)) return false;\n        if (MARKDOWN_EXT_RE.test(url.pathname)) return true;\n        if (url.hostname === \"raw.githubusercontent.com\" || url.hostname === \"gist.githubusercontent.com\") {\n            if (MARKDOWN_EXT_RE.test(url.pathname)) return true;\n            if (/(^|\\/)readme(\\.md)?($|[?#])/i.test(url.pathname)) return true;\n        }\n        return false;\n    } catch { return false; }\n};\n\nconst isMarkdownContent = (text: string): boolean => {\n    if (!text) return false;\n    const trimmed = text.trim();\n    if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\")) return false;\n    if (/<[a-zA-Z][^>]*>/.test(trimmed)) return false;\n\n    let score = 0, hits = 0;\n    const patterns: [RegExp, number][] = [\n        [/^---[\\s\\S]+?---/, 0.9], [/^#{1,6}\\s+.+$/m, 0.8], [/^\\s*[-*+]\\s+\\S+/m, 0.7],\n        [/^\\s*\\d+\\.\\s+\\S+/m, 0.7], [/`{1,3}[^`]*`{1,3}/, 0.6], [/\\[([^\\]]+)\\]\\(([^)]+)\\)/, 0.5],\n        [/!\\[([^\\]]+)\\]\\(([^)]+)\\)/, 0.5], [/\\*\\*[^*]+\\*\\*/, 0.4], [/\\*[^*]+\\*/, 0.3],\n    ];\n    for (const [re, s] of patterns) { if (re.test(text)) { score += s; hits++; } }\n    return hits >= 2 && score >= 0.8;\n};\n\nconst normalizeMarkdownSourceUrl = (candidate: string) => {\n    try {\n        const u = new URL(candidate);\n        if (u.hostname === \"github.com\") {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            if (parts.length >= 5 && parts[2] === \"blob\") {\n                return `https://raw.githubusercontent.com/${parts[0]}/${parts[1]}/${parts[3]}/${parts.slice(4).join(\"/\")}`;\n            }\n        }\n        if (u.hostname.endsWith(\"gitlab.com\")) {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const di = parts.indexOf(\"-\");\n            if (di >= 0 && parts[di + 1] === \"blob\") {\n                return `https://${u.hostname}/${parts.slice(0, di).join(\"/\")}/-/raw/${parts[di + 2] || \"\"}/${parts.slice(di + 3).join(\"/\")}`;\n            }\n        }\n        if (u.hostname === \"bitbucket.org\") { if (!u.searchParams.has(\"raw\")) u.searchParams.set(\"raw\", \"1\"); return u.toString(); }\n        return u.toString();\n    } catch { return candidate; }\n};\n\nconst toViewerUrl = (source?: string | null, markdownKey?: string | null) => {\n    if (!source) return VIEWER_URL;\n    const p = new URLSearchParams();\n    p.set(\"src\", source);\n    if (markdownKey) p.set(\"mdk\", markdownKey);\n    return `${VIEWER_URL}?${p}`;\n};\n\nconst openViewer = (source?: string | null, tabId?: number, markdownKey?: string | null) => {\n    const url = toViewerUrl(source ?? undefined, markdownKey);\n    if (typeof tabId === \"number\") chrome.tabs.update(tabId, { url })?.catch?.(console.warn);\n    else chrome.tabs.create({ url })?.catch?.(console.warn);\n};\n\nconst createSessionKey = () => {\n    try { return `md:${crypto.randomUUID()}`; }\n    catch { return `md:${Date.now()}:${Math.random().toString(16).slice(2)}`; }\n};\n\nconst putMarkdownToSession = async (text: string) => {\n    const key = createSessionKey();\n    try { await chrome.storage?.session?.set?.({ [key]: text }); return key; }\n    catch { return null; }\n};\n\nconst fetchMarkdownText = async (candidate: string) => {\n    const src = normalizeMarkdownSourceUrl(candidate);\n    const res = await fetch(src, { credentials: \"include\", cache: \"no-store\" });\n    const text = await res.text().catch(() => \"\");\n    return { ok: res.ok, status: res.status, src, text };\n};\n\nconst openMarkdownInViewer = async (originalUrl: string, tabId: number) => {\n    if (originalUrl.startsWith(\"file:\")) { openViewer(originalUrl, tabId, null); return; }\n    const fetched = await fetchMarkdownText(originalUrl).catch(() => null);\n    if (!fetched) { openViewer(normalizeMarkdownSourceUrl(originalUrl), tabId, null); return; }\n    const key = fetched.ok && fetched.text ? await putMarkdownToSession(fetched.text) : null;\n    openViewer(fetched.src, tabId, key);\n};\n\nconst tryReadMarkdownFromTab = async (tabId: number, url?: string) => {\n    try {\n        const results = await chrome.scripting.executeScript({\n            target: { tabId },\n            func: (pageUrl: string) => {\n                if (pageUrl.includes(\"github.com\")) {\n                    const rawBtn = document.querySelector(\"a[href*='raw']\") as HTMLAnchorElement;\n                    if (rawBtn?.href) return `__RAW_URL__${rawBtn.href}`;\n                    const md = document.querySelector(\".markdown-body\");\n                    if (md?.textContent?.trim()) return md.textContent.trim();\n                }\n                return document?.body?.innerText?.trim() || \"\";\n            },\n            args: [url || \"\"],\n        });\n        const val = results?.[0]?.result;\n        if (typeof val === \"string\" && val.startsWith(\"__RAW_URL__\")) {\n            try { const r = await fetch(val.replace(\"__RAW_URL__\", \"\")); if (r.ok) return await r.text(); } catch { /* fallback */ }\n        }\n        return typeof val === \"string\" ? val : \"\";\n    } catch { return \"\"; }\n};\n\n// ============================================================================\n// CONTEXT MENUS\n// ============================================================================\n\nconst CTX_CONTEXTS = [\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\", \"action\"] as const satisfies\n    [`${chrome.contextMenus.ContextType}`, ...`${chrome.contextMenus.ContextType}`[]];\n\nconst CTX_ITEMS = [\n    { id: \"copy-as-latex\", title: \"Copy as LaTeX\" },\n    { id: \"copy-as-mathml\", title: \"Copy as MathML\" },\n    { id: \"copy-as-markdown\", title: \"Copy as Markdown\" },\n    { id: \"copy-as-html\", title: \"Copy as HTML\" },\n    { id: \"START_SNIP\", title: \"Snip and Recognize (AI)\" },\n    { id: \"SOLVE_AND_ANSWER\", title: \"Solve / Answer (AI)\" },\n    { id: \"WRITE_CODE\", title: \"Write Code (AI)\" },\n    { id: \"EXTRACT_CSS\", title: \"Extract CSS Styles (AI)\" },\n];\n\nconst CUSTOM_PREFIX = \"CUSTOM_INSTRUCTION:\";\nlet customMenuIds: string[] = [];\n\nconst updateCustomInstructionMenus = async () => {\n    for (const id of customMenuIds) { try { await chrome.contextMenus.remove(id); } catch { /* ignore */ } }\n    customMenuIds = [];\n\n    const enabled = (await loadCustomInstructions().catch(() => [])).filter((i) => i.enabled);\n    if (!enabled.length) return;\n\n    const sepId = \"CUSTOM_SEP\";\n    try { chrome.contextMenus.create({ id: sepId, type: \"separator\", contexts: CTX_CONTEXTS }); customMenuIds.push(sepId); } catch { /* */ }\n    for (const inst of enabled) {\n        const id = `${CUSTOM_PREFIX}${inst.id}`;\n        try { chrome.contextMenus.create({ id, title: `🎯 ${inst.label}`, contexts: CTX_CONTEXTS }); customMenuIds.push(id); } catch { /* */ }\n    }\n};\n\nchrome.storage.onChanged.addListener((changes, area) => {\n    if (area === \"local\" && changes[\"rs-settings\"]) updateCustomInstructionMenus().catch(() => {});\n});\n\n// ============================================================================\n// onInstalled — create context menus\n// ============================================================================\n\nchrome.runtime.onInstalled.addListener(() => {\n    for (const item of CTX_ITEMS) {\n        try { chrome.contextMenus.create({ id: item.id, title: item.title, visible: true, contexts: CTX_CONTEXTS }); } catch { /* */ }\n    }\n    try {\n        chrome.contextMenus.create({\n            id: MD_VIEW_MENU_ID, title: \"Open in Markdown Viewer\", contexts: [\"link\", \"page\"],\n            targetUrlPatterns: [\"*://*/*.md\", \"*://*/*.markdown\", \"file://*/*.md\", \"file://*/*.markdown\"],\n        });\n    } catch { /* */ }\n\n    // CRX-Snip context menus\n    try { chrome.contextMenus.create({ id: \"crx-snip-text\", title: \"Process Text with CrossWord (CRX-Snip)\", contexts: [\"selection\"] }); } catch { /* */ }\n    try { chrome.contextMenus.create({ id: \"crx-snip-screen\", title: \"Capture & Process Screen Area (CRX-Snip)\", contexts: [\"page\", \"frame\", \"editable\"] }); } catch { /* */ }\n\n    updateCustomInstructionMenus().catch(() => {});\n});\n\n// ============================================================================\n// Context menu click routing\n// ============================================================================\n\nconst sendToTabOrActive = async (tabId: number | undefined, message: unknown) => {\n    if (tabId != null && tabId >= 0) return chrome.tabs.sendMessage(tabId, message)?.catch?.(console.warn);\n    const tabs = await chrome.tabs.query({ currentWindow: true, active: true })?.catch?.(() => []);\n    for (const tab of tabs || []) {\n        if (tab?.id != null && tab.id >= 0) return chrome.tabs.sendMessage(tab.id, message)?.catch?.(console.warn);\n    }\n};\n\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n    const tabId = tab?.id;\n    const menuId = String(info.menuItemId);\n\n    // Snip / AI modes\n    const snipMap: Record<string, string> = {\n        START_SNIP: \"START_SNIP\", SOLVE_AND_ANSWER: \"SOLVE_AND_ANSWER\",\n        WRITE_CODE: \"WRITE_CODE\", EXTRACT_CSS: \"EXTRACT_CSS\",\n    };\n    if (menuId in snipMap) { sendToTabOrActive(tabId, { type: snipMap[menuId] }); return; }\n\n    // Custom instructions\n    if (menuId.startsWith(CUSTOM_PREFIX)) {\n        sendToTabOrActive(tabId, { type: \"CUSTOM_INSTRUCTION\", instructionId: menuId.slice(CUSTOM_PREFIX.length) });\n        return;\n    }\n\n    // Markdown viewer\n    if (menuId === MD_VIEW_MENU_ID) {\n        const candidate = (info as any).linkUrl || (info as any).pageUrl;\n        if (candidate && isMarkdownUrl(candidate)) { void openMarkdownInViewer(candidate, tabId ?? 0); return; }\n        openViewer(candidate, tabId);\n        return;\n    }\n\n    // CRX-Snip text/screen via context menu\n    if (menuId === \"crx-snip-text\" && info.selectionText) {\n        processCrxSnipWithPipeline(info.selectionText, \"text\").then((r) => {\n            chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Text processed and copied!\" : `Failed: ${r.error || \"Unknown\"}` });\n        });\n        return;\n    }\n    if (menuId === \"crx-snip-screen\") {\n        (async () => {\n            try {\n                const imageData = await captureScreenArea();\n                if (!imageData) { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture cancelled\" }); return; }\n                const r = await processCrxSnipWithPipeline(imageData, \"image\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Captured and processed!\" : `Failed: ${r.error || \"Unknown\"}` });\n            } catch { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture failed\" }); }\n        })();\n        return;\n    }\n\n    // Copy-as-* and other operations → forward to content script\n    sendToTabOrActive(tabId, { type: menuId });\n});\n\n// ============================================================================\n// Keyboard commands\n// ============================================================================\n\nchrome.commands.onCommand.addListener(async (command) => {\n    if (command === \"crx-snip-text\") {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) return;\n        try {\n            const results = await chrome.scripting.executeScript({ target: { tabId: tabs[0].id }, func: () => (typeof window != \"undefined\" ? window : globalThis)?.getSelection()?.toString() || \"\" });\n            const text = results[0]?.result || \"\";\n            if (text) {\n                const r = await processCrxSnipWithPipeline(text, \"text\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Text processed!\" : `Failed: ${r.error}` });\n            } else {\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Select text first, then Ctrl+Shift+X\" });\n            }\n        } catch { /* ignore */ }\n    } else if (command === \"crx-snip-screen\") {\n        try {\n            const imageData = await captureScreenArea();\n            if (imageData) {\n                const r = await processCrxSnipWithPipeline(imageData, \"image\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Captured and processed!\" : `Failed: ${r.error}` });\n            } else {\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture cancelled\" });\n            }\n        } catch { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture failed\" }); }\n    }\n});\n\n// ============================================================================\n// Screen capture helper (tab capture + desktop capture fallback)\n// ============================================================================\n\nconst captureScreenArea = async (options?: { rect?: { x: number; y: number; width: number; height: number }; scale?: number }): Promise<ArrayBuffer | null> => {\n    try {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) throw new Error(\"No active tab\");\n\n        const opts: chrome.tabs.CaptureVisibleTabOptions & { rect?: any; scale?: number } = { format: \"png\", quality: 100, scale: options?.scale ?? 1 };\n        if (options?.rect) opts.rect = options.rect;\n\n        const screenshot = await chrome.tabs.captureVisibleTab(tabs[0].windowId, opts);\n        const b64 = screenshot.split(\",\")[1];\n        const bin = atob(b64);\n        const bytes = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);\n        return bytes.buffer;\n    } catch {\n        // Fallback: desktop capture via offscreen document\n        try {\n            const streamId = await new Promise<string>((resolve: (id: string) => void, reject: (error: Error) => void) => {\n                chrome.desktopCapture.chooseDesktopMedia([\"screen\", \"window\"], { frameRate: 1 }, (id) => id ? resolve(id) : reject(new Error(\"Cancelled\")));\n            });\n\n            const offscreenUrl = chrome.runtime.getURL(\"offscreen/capture.html\");\n            const existing = await chrome.runtime.getContexts({ contextTypes: [chrome.runtime.ContextType.OFFSCREEN_DOCUMENT] });\n            if (!existing.length) {\n                await chrome.offscreen.createDocument({ url: offscreenUrl, reasons: [chrome.offscreen.Reason.USER_MEDIA], justification: \"Screen capture\" });\n            }\n            const response = await chrome.runtime.sendMessage({ type: \"capture-desktop\", streamId });\n            return response?.success && response?.imageData ? response.imageData : null;\n        } catch { return null; }\n    }\n};\n\n// ============================================================================\n// AI MESSAGE HANDLERS (gpt:recognize, gpt:solve, gpt:code, gpt:css, gpt:custom, gpt:translate)\n// ============================================================================\n\n/** Helper: process with GPT using a built-in instruction */\nconst processWithBuiltInInstruction = async (\n    instruction: string,\n    input: any,\n    sender: chrome.runtime.MessageSender,\n    mode: string,\n    sendResponse: (r: any) => void,\n) => {\n    const requestId = `${mode}_${Date.now()}`;\n    broadcast(AI_RECOGNITION_CHANNEL, { type: mode, requestId, status: \"processing\" });\n\n    try {\n        const gpt = await getGPTInstance();\n        if (!gpt) { const err = { ok: false, error: \"AI service not available\" }; broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...err }); sendResponse(err); return; }\n\n        gpt.getPending?.()?.push?.({ type: \"message\", role: \"user\", content: [{ type: \"input_text\", text: instruction }, { type: \"input_text\", text: input || \"\" }] });\n        const rawResponse = await gpt.sendRequest(\"high\", \"medium\");\n        const response = { ok: !!rawResponse, data: rawResponse || \"\", error: rawResponse ? undefined : \"Failed\" };\n\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...response });\n        if (response.ok && response.data) await requestClipboardCopy(response.data, true, sender?.tab?.id);\n        sendResponse(response);\n    } catch (e) {\n        const err = { ok: false, error: String(e) };\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...err });\n        showExtensionToast(`${mode} failed: ${e}`, \"error\");\n        sendResponse(err);\n    }\n};\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (!message?.type) return false;\n\n    // Timeline\n    if (message.type === \"MAKE_TIMELINE\") {\n        createTimelineGenerator(message.source || null, message.speechPrompt || null).then(async (gptRes) => {\n            sendResponse(await (requestNewTimeline(gptRes as unknown as GPTResponses) as unknown as Promise<any[]> || []));\n        }).catch((e: Error) => sendResponse({ error: e.message }));\n        return true;\n    }\n\n    // gpt:recognize\n    if (message.type === \"gpt:recognize\") {\n        const requestId = message.requestId || `rec_${Date.now()}`;\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"recognize\", requestId, status: \"processing\" });\n        recognizeImageData(message.input, async (result) => {\n            const response = { ok: result?.ok, data: result?.raw, error: result?.error };\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, ...response });\n            if (result?.ok && result?.raw && message.autoCopy !== false) {\n                const text = typeof result.raw === \"string\" ? result.raw : result.raw?.latex || result.raw?.text || JSON.stringify(result.raw);\n                await requestClipboardCopy(text, true);\n            }\n            sendResponse(response);\n        })?.catch?.((e) => {\n            const err = { ok: false, error: String(e) };\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, ...err });\n            showExtensionToast(`Recognition failed: ${e}`, \"error\");\n            sendResponse(err);\n        });\n        return true;\n    }\n\n    // gpt:solve / gpt:answer / gpt:solve-answer\n    if (message.type === \"gpt:solve\" || message.type === \"gpt:answer\" || message.type === \"gpt:solve-answer\") {\n        processWithBuiltInInstruction(CRX_SOLVE_AND_ANSWER_INSTRUCTION, message.input, sender, \"solve-answer\", sendResponse);\n        return true;\n    }\n\n    // gpt:code\n    if (message.type === \"gpt:code\") {\n        processWithBuiltInInstruction(CRX_WRITE_CODE_INSTRUCTION, message.input, sender, \"code\", sendResponse);\n        return true;\n    }\n\n    // gpt:css\n    if (message.type === \"gpt:css\") {\n        processWithBuiltInInstruction(CRX_EXTRACT_CSS_INSTRUCTION, message.input, sender, \"css\", sendResponse);\n        return true;\n    }\n\n    // gpt:custom\n    if (message.type === \"gpt:custom\") {\n        (async () => {\n            let instructionText = message.instruction;\n            let instructionLabel = \"Custom\";\n            if (!instructionText && message.instructionId) {\n                const found = (await loadCustomInstructions().catch(() => [])).find((i) => i.id === message.instructionId);\n                if (found) { instructionText = found.instruction; instructionLabel = found.label; }\n            }\n            if (!instructionText) { sendResponse({ ok: false, error: \"No instruction found\" }); return; }\n\n            const requestId = message.requestId || `custom_${Date.now()}`;\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"custom\", requestId, label: instructionLabel, status: \"processing\" });\n\n            processDataWithInstruction(message.input, { instruction: instructionText, outputFormat: \"auto\", intermediateRecognition: { enabled: false } })\n                .then(async (result) => {\n                    const response = { ok: result?.ok, data: result?.data, error: result?.error };\n                    broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode: \"custom\", label: instructionLabel, ...response });\n                    if (result?.ok && result?.data && message.autoCopy !== false) await requestClipboardCopy(result.data, true, sender?.tab?.id);\n                    sendResponse(response);\n                }).catch((e: any) => {\n                    const err = { ok: false, error: String(e) };\n                    broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode: \"custom\", label: instructionLabel, ...err });\n                    showExtensionToast(`${instructionLabel} failed: ${e}`, \"error\");\n                    sendResponse(err);\n                });\n        })();\n        return true;\n    }\n\n    // gpt:translate\n    if (message.type === \"gpt:translate\") {\n        (async () => {\n            const inputText = message.input;\n            const targetLang = message.targetLanguage || \"English\";\n            if (!inputText?.trim()) { sendResponse({ ok: false, error: \"No text\" }); return; }\n\n            const instruction = `Translate the following text to ${targetLang}.\\nPreserve formatting (Markdown, KaTeX, code blocks, etc.).\\nOnly translate natural language, keep technical notation unchanged.\\nReturn ONLY the translated text.`;\n            try {\n                const settings = await loadSettings();\n                const ai = (await settings)?.ai;\n                if (!ai?.apiKey) { sendResponse({ ok: false, error: \"No API key configured\" }); return; }\n\n                const baseUrl = ai.baseUrl || \"https://api.proxyapi.ru/openai/v1\";\n                const model = ai.model || \"gpt-5.2\";\n                const res = await fetch(`${baseUrl}/responses`, {\n                    method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${ai.apiKey}` },\n                    body: JSON.stringify({ model, input: inputText, instructions: instruction, reasoning: { effort: \"low\" }, text: { verbosity: \"low\" } }),\n                });\n                if (!res.ok) throw new Error(`Translation API: ${res.status}`);\n                const data = await res.json();\n                sendResponse({ ok: true, data: data?.output?.at?.(-1)?.content?.[0]?.text || inputText });\n            } catch (e) { sendResponse({ ok: false, error: String(e), data: inputText }); }\n        })();\n        return true;\n    }\n\n    // share-target\n    if (message.type === \"share-target\") {\n        const { title, text, url, files } = message.data || {};\n        chrome.storage?.local?.set?.({ \"rs-share-target-data\": { title, text, url, files: files?.map?.((f: File) => f.name) || [], timestamp: Date.now() } }).catch(() => {});\n        broadcast(\"rs-share-target\", { type: \"share-received\", data: { title, text, url, timestamp: Date.now() } });\n        showExtensionToast(\"Content received\", \"info\");\n        sendResponse({ ok: true });\n        return true;\n    }\n\n    return false;\n});\n\n// ============================================================================\n// Markdown auto-detection (webNavigation)\n// ============================================================================\n\nchrome.webNavigation?.onCommitted?.addListener?.((details) => {\n    if (details.frameId !== 0) return;\n    const { tabId, url } = details;\n    if (!isMarkdownUrl(url) || url.startsWith(VIEWER_ORIGIN) || url.startsWith(\"file:\")) return;\n    void openMarkdownInViewer(url, tabId);\n});\n\nchrome.webNavigation?.onCompleted?.addListener?.((details) => {\n    (async () => {\n        if (details.frameId !== 0) return;\n        const { tabId, url } = details;\n        if (!isMarkdownUrl(url) || url.startsWith(VIEWER_ORIGIN) || !url.startsWith(\"file:\")) return;\n        const text = await tryReadMarkdownFromTab(tabId, url);\n        const key = text ? await putMarkdownToSession(text) : null;\n        openViewer(url, tabId, key);\n    })().catch(console.warn);\n});\n\n// ============================================================================\n// CRX-Snip and pipeline message handlers\n// ============================================================================\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n    (async () => {\n        // CRX-Snip processing\n        if (message?.type === \"crx-snip\") {\n            if (!message.content) { sendResponse({ success: false, error: \"missing content\" }); return; }\n            sendResponse(await processCrxSnipWithPipeline(message.content, message.contentType || \"text\"));\n            return;\n        }\n\n        // Screen capture trigger from popup\n        if (message?.type === \"crx-snip-screen-capture\") {\n            try {\n                const imageData = await captureScreenArea(message.rect ? { rect: message.rect, scale: message.scale || 1 } : undefined);\n                if (imageData) { sendResponse(await processCrxSnipWithPipeline(imageData, \"image\")); }\n                else sendResponse({ success: false, error: \"Capture cancelled\" });\n            } catch (e) { sendResponse({ success: false, error: e instanceof Error ? e.message : String(e) }); }\n            return;\n        }\n\n        // Pipeline management\n        if (message?.type === \"crx-pipeline-status\") { sendResponse({ success: true, status: pipeline.getStatus() }); return; }\n        if (message?.type === \"crx-pipeline-pending\") { sendResponse({ success: true, pending: pipeline.getPending(message.destinationType) }); return; }\n        if (message?.type === \"crx-pipeline-clear-completed\") { sendResponse({ success: true, clearedCount: pipeline.clearCompleted() }); return; }\n\n        if (message?.type === \"crx-result-send-to-destination\") {\n            const pr = pipeline.resultQueue.find((r) => r.id === message.resultId);\n            if (!pr || !message.destination) { sendResponse({ success: false, error: \"Not found\" }); return; }\n            pr.destinations.push(message.destination);\n            if (pr.status === \"completed\") pr.status = \"pending\";\n            sendResponse({ success: true, resultId: message.resultId });\n            return;\n        }\n\n        // Markdown loading\n        if (message?.type !== \"md:load\") return;\n        const src = typeof message.src === \"string\" ? message.src : \"\";\n        if (!src) { sendResponse({ ok: false, error: \"missing src\" }); return; }\n        const fetched = await fetchMarkdownText(src);\n        const key = fetched.ok && fetched.text ? await putMarkdownToSession(fetched.text) : null;\n        sendResponse({ ok: fetched.ok, status: fetched.status, src: fetched.src, key });\n    })().catch((e) => sendResponse({ ok: false, error: String(e) }));\n    return true;\n});\n\n// ============================================================================\n// Enable capture handlers from service/api.ts\n// ============================================================================\n\nenableCapture(chrome);\n"],"file":"background.js"}