{"version":3,"mappings":"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","names":["MARKDOWN_EXT_RE","r","options"],"ignoreList":[],"sources":["../../src/crx/service/api.ts","../../src/com/service/misc/ActionHistory.ts","../../src/com/service/misc/ExecutionCore.ts","../../src/crx/sw.ts"],"sourcesContent":["/**\n * CRX Service API\n *\n * Handles all service-worker-side operations:\n *  - Tab capture (screenshot) with optional crop rect\n *  - AI processing pipeline (recognize, solve, code, css, custom)\n *  - Clipboard copy (COPY_HACK multi-fallback)\n *  - Markdown loading with URL normalization\n *  - Runtime channel message routing\n */\n\nimport { ableToShowImage, encodeWithJSquash, removeAnyPrefix } from \"@rs-core/workers/ImageProcess\";\nimport {\n    recognizeImageData,\n    solveAndAnswer,\n    writeCode,\n    extractCSS,\n    recognizeByInstructions,\n} from \"../../com/service/service/RecognizeData\";\nimport type { RecognizeResult } from \"../../com/service/service/RecognizeData\";\nimport { toText } from \"@rs-core/modules/Clipboard\";\nimport { getCustomInstructions } from \"@rs-com/service/misc/CustomInstructions\";\n\n// ---------------------------------------------------------------------------\n// Constants\n// ---------------------------------------------------------------------------\n\n/** Compress images larger than 2 MB */\nconst SIZE_THRESHOLD = 2 * 1024 * 1024;\n\nconst MARKDOWN_EXT_RE = /\\.(?:md|markdown|mdown|mkd|mkdn|mdtxt|mdtext)(?:$|[?#])/i;\n\n// ---------------------------------------------------------------------------\n// Types\n// ---------------------------------------------------------------------------\n\nexport type SnipMode = \"recognize\" | \"solve\" | \"code\" | \"css\" | \"custom\";\n\ninterface CaptureOptions {\n    rect?: { x: number; y: number; width: number; height: number };\n    scale?: number;\n}\n\ninterface CaptureResult {\n    ok: boolean;\n    data?: string;\n    error?: string;\n}\n\n// ---------------------------------------------------------------------------\n// Internal helpers\n// ---------------------------------------------------------------------------\n\nconst isProbablyUrl = (v: string) => { try { return Boolean(new URL(v)); } catch { return false; } };\n\nconst dataUrlToFile = async (dataUrl: string, name = \"snip.png\"): Promise<File | Blob> => {\n    try {\n        const res = await fetch(dataUrl);\n        const blob = await res.blob();\n        try { return new File([blob], name, { type: blob.type || \"image/png\", lastModified: Date.now() }); }\n        catch { return blob; }\n    } catch {\n        return new Blob([dataUrl], { type: \"text/plain\" });\n    }\n};\n\nconst compressIfNeeded = async (dataUrl: string): Promise<string> => {\n    if (dataUrl.length <= SIZE_THRESHOLD) return dataUrl;\n    try {\n        // @ts-ignore  Uint8Array.fromBase64/toBase64 available in modern Chrome\n        const binary = Uint8Array.fromBase64(removeAnyPrefix(dataUrl), { alphabet: \"base64\" });\n        const blob = new Blob([binary], { type: \"image/png\" });\n        const bitmap = await createImageBitmap(blob);\n        const ab = await encodeWithJSquash(bitmap);\n        bitmap?.close?.();\n        if (ab) {\n            // @ts-ignore\n            return `data:image/jpeg;base64,${new Uint8Array(ab).toBase64({ alphabet: \"base64\" })}`;\n        }\n    } catch (e) {\n        console.warn(\"[api] compression failed:\", e);\n    }\n    return dataUrl;\n};\n\n/** Best-available timing function (RAF  setTimeout  immediate) */\nconst schedule = (() => {\n    if (typeof requestAnimationFrame !== \"undefined\") return requestAnimationFrame;\n    if (typeof setTimeout !== \"undefined\") return (cb: () => void) => setTimeout(cb, 0);\n    return (cb: () => void) => cb();\n})();\n\n/** Extract meaningful text from an AI recognition result */\nconst extractRecognizedText = (result: RecognizeResult): string => {\n    if (typeof result === \"string\") return result;\n    if (!result?.ok) return \"\";\n\n    let text = result.data;\n    if (text && typeof text !== \"string\") {\n        try { text = JSON.stringify(text); } catch { text = String(text); }\n    }\n    if (!text) return \"\";\n\n    // Try to unwrap JSON wrappers\n    if (text.trim().startsWith(\"{\") || text.trim().startsWith(\"[\")) {\n        try {\n            const p = JSON.parse(text);\n            const candidate =\n                p?.recognized_data ?? p?.data ?? p?.text;\n            if (typeof candidate === \"string\") return candidate.trim();\n            if (candidate != null) return JSON.stringify(candidate);\n        } catch { /* not JSON */ }\n    }\n    return (typeof text === \"string\" ? text : String(text)).trim();\n};\n\n// ---------------------------------------------------------------------------\n// Unified Tab Capture\n// ---------------------------------------------------------------------------\n\n/**\n * Capture the visible tab as a data-URL, optionally cropped.\n * Compresses large images and validates the result.\n */\nconst captureVisibleTab = async (options?: CaptureOptions): Promise<string> => {\n    const captureOpts: { format: \"png\" | \"jpeg\"; quality?: number; rect?: any; scale?: number } = {\n        format: \"png\",\n        scale: options?.scale ?? 1,\n    };\n    if (options?.rect && options.rect.width > 0 && options.rect.height > 0) {\n        captureOpts.rect = options.rect;\n    }\n\n    const dataUrl = await new Promise<string>((resolve, reject) => {\n        chrome.tabs.captureVisibleTab(captureOpts, (url) => {\n            if (chrome.runtime.lastError) reject(new Error(chrome.runtime.lastError.message));\n            else resolve(url);\n        });\n    });\n\n    let finalUrl = await compressIfNeeded(dataUrl);\n    if (!finalUrl || !(await ableToShowImage(finalUrl))) finalUrl = dataUrl;\n    return finalUrl;\n};\n\n// ---------------------------------------------------------------------------\n// Unified AI processing\n// ---------------------------------------------------------------------------\n\n/** Map mode  AI function */\nconst AI_DISPATCH: Record<string, (input: File | Blob) => Promise<CaptureResult>> = {\n    recognize: recognizeImageData,\n    solve: solveAndAnswer,\n    code: writeCode,\n    css: extractCSS,\n};\n\n/**\n * Capture visible tab + run AI processing + copy result to clipboard.\n * Handles all modes (recognize, solve, code, css, custom).\n */\nconst captureAndProcess = async (\n    ext: typeof chrome,\n    rect: CaptureOptions[\"rect\"],\n    mode: SnipMode = \"recognize\",\n    extra?: { instructionId?: string; sender?: chrome.runtime.MessageSender },\n): Promise<CaptureResult> => {\n    // 1. Screenshot\n    const imageUrl = await captureVisibleTab({ rect });\n\n    // 2. Convert to file\n    const file = await dataUrlToFile(imageUrl, \"snip.png\");\n\n    // 3. Process\n    let result: CaptureResult;\n\n    if (mode === \"custom\" && extra?.instructionId) {\n        const instructions = await getCustomInstructions().catch(() => []);\n        const instruction = instructions.find((i) => i.id === extra.instructionId);\n        if (!instruction) return { ok: false, error: \"Custom instruction not found\" };\n\n        const input = [{\n            type: \"message\",\n            role: \"user\",\n            content: [{ type: \"input_image\", image_url: imageUrl }],\n        }];\n        const raw = await recognizeByInstructions(input, instruction.instruction);\n        const text = extractRecognizedText(raw);\n        result = {\n            ok: raw?.ok ?? !!text,\n            data: text,\n            error: raw?.error || (!text ? `${instruction.label} failed` : undefined),\n        };\n    } else {\n        const fn = AI_DISPATCH[mode] ?? AI_DISPATCH.recognize;\n        result = await fn(file);\n    }\n\n    // 4. Copy to clipboard\n    if (result.ok && result.data) {\n        await COPY_HACK(ext, result, extra?.sender?.tab?.id).catch(console.warn);\n    }\n\n    return result;\n};\n\n// ---------------------------------------------------------------------------\n// Runtime channel handlers (for createRuntimeChannelModule calls)\n// ---------------------------------------------------------------------------\n\nconst handleCapture = (ext: typeof chrome, data: any, sender: any) =>\n    captureAndProcess(ext, data.rect, data.mode || \"recognize\", { sender });\n\nconst handleCaptureScreenshot = async (_ext: typeof chrome, data: any) => {\n    const imageUrl = await captureVisibleTab({ rect: data.rect });\n    return { ok: true, data: imageUrl, imageData: imageUrl };\n};\n\nconst handleProcessImage = async (ext: typeof chrome, data: any, sender: any) => {\n    const imageData = data.imageData;\n    const mode: SnipMode = data.mode || \"recognize\";\n    const file = typeof imageData === \"string\" ? await dataUrlToFile(imageData) : imageData;\n\n    const fn = AI_DISPATCH[mode] ?? AI_DISPATCH.recognize;\n    const result = await fn(file);\n\n    if (result.ok && result.data) {\n        await COPY_HACK(ext, result, sender?.tab?.id).catch(console.warn);\n    }\n    return result;\n};\n\nconst handleProcessText = async (_ext: typeof chrome, data: any) =>\n    recognizeImageData(new Blob([data.content], { type: \"text/plain\" }));\n\nconst handleDoCopy = async (ext: typeof chrome, data: any) => {\n    const result = await COPY_HACK(ext, data.data, data.tabId);\n    return { success: result?.ok || false };\n};\n\nconst handleCaptureWithRect = async (data: any) =>\n    ({ status: \"rect_selection_required\", mode: data.mode } as const);\n\n// ---------------------------------------------------------------------------\n// Markdown loader (service-worker-side)\n// ---------------------------------------------------------------------------\n\nconst normalizeSourceUrl = (candidate: string): string => {\n    try {\n        const u = new URL(candidate);\n\n        // GitHub blob  raw.githubusercontent.com\n        if (u.hostname === \"github.com\") {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const idx = parts.indexOf(\"blob\") === 2 ? 2 : parts.indexOf(\"raw\") === 2 ? 2 : -1;\n            if (parts.length >= 5 && idx === 2) {\n                return `https://raw.githubusercontent.com/${parts[0]}/${parts[1]}/${parts[3]}/${parts.slice(4).join(\"/\")}`;\n            }\n        }\n\n        // GitLab blob  raw\n        if (u.hostname.endsWith(\"gitlab.com\")) {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const di = parts.indexOf(\"-\");\n            if (di >= 0 && parts[di + 1] === \"blob\") {\n                return `https://${u.hostname}/${parts.slice(0, di).join(\"/\")}/-/raw/${parts[di + 2] || \"\"}/${parts.slice(di + 3).join(\"/\")}`;\n            }\n        }\n\n        // Bitbucket  ?raw=1\n        if (u.hostname === \"bitbucket.org\") {\n            if (!u.searchParams.has(\"raw\")) u.searchParams.set(\"raw\", \"1\");\n            return u.toString();\n        }\n\n        return u.toString();\n    } catch { return candidate; }\n};\n\nconst looksLikeHtmlDocument = (text: string): boolean => {\n    const t = (text || \"\").trimStart().toLowerCase();\n    return t.startsWith(\"<!doctype html\") || t.startsWith(\"<html\") || t.startsWith(\"<head\") || t.startsWith(\"<body\");\n};\n\nconst looksLikeMarkdown = (text: string): boolean => {\n    const t = (text || \"\").trim();\n    if (!t || looksLikeHtmlDocument(t)) return false;\n    let hits = 0;\n    if (/^#{1,6}\\s+.+$/m.test(t)) hits++;\n    if (/^\\s*[-*+]\\s+\\S+/m.test(t)) hits++;\n    if (/^\\s*\\d+\\.\\s+\\S+/m.test(t)) hits++;\n    if (/```[\\s\\S]*?```/.test(t)) hits++;\n    if (/\\[([^\\]]+)\\]\\(([^)]+)\\)/.test(t)) hits++;\n    return hits >= 2;\n};\n\nconst guessLanguage = (url: URL): string => {\n    const ext = ((url.pathname.split(\"/\").pop() || \"\").split(\".\").pop() || \"\").toLowerCase();\n    const map: Record<string, string> = {\n        ts: \"ts\", tsx: \"tsx\", js: \"js\", jsx: \"jsx\", json: \"json\",\n        css: \"css\", scss: \"scss\", html: \"html\", htm: \"html\", xml: \"xml\",\n        yml: \"yaml\", yaml: \"yaml\", py: \"py\", sh: \"sh\", go: \"go\", rs: \"rs\", java: \"java\",\n    };\n    return map[ext] || \"\";\n};\n\nconst handleLoadMarkdown = async (src: string) => {\n    let text = \"\";\n    let normalizedSrc: string | undefined;\n\n    try {\n        normalizedSrc = normalizeSourceUrl(src);\n        const u = new URL(normalizedSrc);\n        const res = await fetch(u.href, { credentials: \"include\", cache: \"no-store\", headers: { accept: \"text/markdown,text/plain,*/*\" } });\n        if (!res.ok) return { error: `Failed to load: ${res.status}` };\n\n        text = await res.text();\n\n        if (!looksLikeHtmlDocument(text)) {\n            const ct = (res.headers.get(\"content-type\") || \"\").toLowerCase();\n            const isMd = MARKDOWN_EXT_RE.test(u.pathname) || ct.includes(\"text/markdown\") || looksLikeMarkdown(text);\n            if (!isMd) {\n                const lang = guessLanguage(u);\n                text = `\\`\\`\\`${lang}\\n${text.replace(/\\r\\n/g, \"\\n\")}\\n\\`\\`\\`\\n`;\n            }\n        }\n    } catch {\n        text = src; // not a URL  treat as raw markdown\n    }\n\n    const key = `md_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n    await chrome.storage.session.set({ [key]: text });\n    return { key, src: isProbablyUrl(normalizedSrc || src) ? (normalizedSrc || src) : undefined };\n};\n\n// ---------------------------------------------------------------------------\n// COPY_HACK  multi-fallback clipboard write\n// ---------------------------------------------------------------------------\n\nexport const COPY_HACK = async (\n    ext: typeof chrome,\n    data: { ok?: boolean; data?: string; error?: string },\n    tabId?: number,\n): Promise<{ ok: boolean; error?: string }> => {\n    const text = toText(data?.data).trim();\n    if (!text) return { ok: false, error: \"Empty content\" };\n\n    return new Promise<{ ok: boolean; error?: string }>((resolve) => {\n        schedule(async () => {\n            // 1. Content-script on specified tab\n            if (tabId && tabId > 0) {\n                try {\n                    const tab = await ext.tabs.get(tabId).catch(() => null);\n                    if (tab) {\n                        await ext.scripting.executeScript({ target: { tabId }, files: [\"content/main.ts\"] }).catch(() => {});\n                        const r = await ext.tabs.sendMessage(tabId, { type: \"COPY_HACK\", data: text });\n                        if (r?.ok) return resolve({ ok: true });\n                    }\n                } catch { /* continue */ }\n            }\n\n            // 2. Offscreen document\n            try {\n                const offscreenUrl = \"offscreen/copy.html\";\n                const existing = await ext.runtime.getContexts?.({\n                    contextTypes: [ext.runtime.ContextType.OFFSCREEN_DOCUMENT as any],\n                    documentUrls: [ext.runtime.getURL(offscreenUrl)],\n                })?.catch?.(() => []);\n\n                if (!existing?.length) {\n                    await ext.offscreen.createDocument({\n                        url: offscreenUrl,\n                        reasons: [ext.offscreen.Reason.CLIPBOARD],\n                        justification: \"Clipboard access for copied text\",\n                    });\n                    await new Promise((r) => setTimeout(r, 500));\n                }\n                const r = await ext.runtime.sendMessage({ target: \"offscreen\", type: \"COPY_HACK\", data: text });\n                if (r?.ok) return resolve({ ok: true });\n            } catch { /* continue */ }\n\n            // 3. Any available tab\n            try {\n                const tabs = await ext.tabs.query({}).catch(() => []);\n                for (const tab of tabs || []) {\n                    if (tab?.id && tab.id !== tabId) {\n                        try {\n                            await ext.scripting.executeScript({ target: { tabId: tab.id }, files: [\"content/main.ts\"] }).catch(() => {});\n                            const r = await ext.tabs.sendMessage(tab.id, { type: \"COPY_HACK\", data: text });\n                            if (r?.ok) return resolve({ ok: true });\n                        } catch { /* next tab */ }\n                    }\n                }\n            } catch { /* continue */ }\n\n            // 4. Direct clipboard API (service worker  limited support)\n            try {\n                if (typeof navigator !== \"undefined\" && navigator.clipboard?.writeText) {\n                    await navigator.clipboard.writeText(text);\n                    return resolve({ ok: true });\n                }\n            } catch { /* continue */ }\n\n            resolve({ ok: false, error: \"All clipboard methods failed\" });\n        });\n    });\n};\n\n// ---------------------------------------------------------------------------\n// Public: enableCapture  registers message listeners on service worker\n// ---------------------------------------------------------------------------\n\n/**\n * Register all capture/processing/markdown message listeners on the service worker.\n * Called once from sw.ts at startup.\n */\nexport const enableCapture = (ext: typeof chrome) => {\n    ext.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n        // ---- Runtime channel messages (from createRuntimeChannelModule) ----\n        if (msg?.id?.startsWith(\"crx_\") && msg?.type && msg?.data) {\n            (async () => {\n                try {\n                    const route: Record<string, () => Promise<any>> = {\n                        capture: () => handleCapture(ext, msg.data, sender),\n                        captureScreenshot: () => handleCaptureScreenshot(ext, msg.data),\n                        processImage: () => handleProcessImage(ext, msg.data, sender),\n                        processText: () => handleProcessText(ext, msg.data),\n                        doCopy: () => handleDoCopy(ext, msg.data),\n                        loadMarkdown: () => handleLoadMarkdown(msg.data),\n                        captureWithRect: () => handleCaptureWithRect(msg.data),\n                    };\n                    const handler = route[msg.type];\n                    sendResponse(handler ? await handler() : { ok: false, error: `Unknown method: ${msg.type}` });\n                } catch (e) {\n                    sendResponse({ ok: false, error: String(e) });\n                }\n            })();\n            return true;\n        }\n\n        // ---- Legacy direct messages (CAPTURE / CAPTURE_SOLVE / etc.) ----\n        const CAPTURE_MODES: Record<string, SnipMode> = {\n            CAPTURE: \"recognize\",\n            CAPTURE_SOLVE: \"solve\",\n            CAPTURE_ANSWER: \"solve\",\n            CAPTURE_CODE: \"code\",\n            CAPTURE_CSS: \"css\",\n            CAPTURE_CUSTOM: \"custom\",\n        };\n\n        if (msg?.type && msg.type in CAPTURE_MODES) {\n            const mode = CAPTURE_MODES[msg.type];\n            (async () => {\n                try {\n                    const result = await captureAndProcess(ext, msg.rect, mode, {\n                        instructionId: msg.instructionId,\n                        sender,\n                    });\n                    sendResponse(result);\n                } catch (e) {\n                    sendResponse({ ok: false, error: String(e) });\n                }\n            })();\n            return true;\n        }\n\n        // ---- Download ----\n        if (msg?.type === \"DOWNLOAD\" && msg.dataUrl) {\n            chrome.downloads.download(\n                { url: msg.dataUrl, filename: \"snip.png\", saveAs: true },\n                (id) => {\n                    if (chrome.runtime.lastError) {\n                        sendResponse({ ok: false, error: chrome.runtime.lastError.message, dataUrl: msg.dataUrl });\n                    } else {\n                        sendResponse({ ok: true, id });\n                    }\n                },\n            );\n            return true;\n        }\n\n        return false;\n    });\n};\n","export interface ActionContext {\n    source: 'workcenter' | 'share-target' | 'launch-queue' | 'chrome-extension' | 'service-worker';\n    sessionId?: string;\n    userAgent?: string;\n    referrer?: string;\n}\n\nexport interface RecognizedData {\n    content: string;\n    timestamp: number;\n    source: 'files' | 'text' | 'url' | 'markdown' | 'image' | 'mixed';\n    recognizedAs: 'markdown' | 'html' | 'text' | 'json' | 'xml' | 'other'; // Format recognized as\n    metadata?: Record<string, any>;\n    responseId?: string; // GPT/AI response ID from HTTP level\n}\n\nexport interface ProcessedData {\n    content: string;\n    timestamp: number;\n    action: string; // Template/action applied\n    sourceData: RecognizedData; // Reference to recognized data that was processed\n    metadata?: Record<string, any>;\n    responseId?: string; // GPT/AI response ID from HTTP level\n}\n\nexport interface ActionInput {\n    type: 'files' | 'text' | 'url' | 'markdown' | 'image' | 'mixed';\n    files?: File[];\n    text?: string;\n    url?: string;\n    recognizedData?: RecognizedData; // New: structured recognized data\n    processedData?: ProcessedData[]; // New: chain of processed data\n    recognizedContent?: string; // Legacy: keep for backward compatibility\n    metadata?: Record<string, any>;\n}\n\nexport interface ActionResult {\n    type: 'markdown' | 'json' | 'text' | 'html' | 'error';\n    content: string;\n    rawData?: any;\n    processingTime?: number;\n    tokenUsage?: number;\n    model?: string;\n    autoCopied?: boolean;\n    responseId?: string; // GPT/AI response ID from HTTP level\n    dataCategory?: 'recognized' | 'processed'; // Whether this is raw recognition or processed result\n    processingChain?: ProcessedData[]; // Chain of processing steps if applicable\n}\n\nexport interface ActionEntry {\n    id: string;\n    timestamp: number;\n    context: ActionContext;\n    action: string; // 'recognize', 'analyze', 'solve', 'generate', etc.\n    input: ActionInput;\n    result?: ActionResult;\n    status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';\n    error?: string;\n    ruleSet?: string; // Which rule set was applied\n    executionId?: string; // Links to execution core\n    dataCategory?: 'recognized' | 'processed'; // Core-level data categorization\n    parentActionId?: string; // Links to parent recognized action for processed entries\n}\n\nexport interface ActionHistoryState {\n    entries: ActionEntry[];\n    maxEntries: number;\n    autoSave: boolean;\n    filters: {\n        source?: ActionContext['source'];\n        action?: string;\n        status?: ActionEntry['status'];\n        dateRange?: { start: number; end: number };\n    };\n}\n\nexport class ActionHistoryStore {\n    private state: ActionHistoryState;\n    private storageKey = 'rs-action-history';\n\n    constructor(maxEntries: number = 500, autoSave: boolean = true) {\n        this.state = {\n            entries: [],\n            maxEntries,\n            autoSave,\n            filters: {}\n        };\n\n        this.loadHistory();\n    }\n\n    /**\n     * Add a new action entry\n     */\n    addEntry(entry: Omit<ActionEntry, 'id' | 'timestamp'>): ActionEntry {\n        const fullEntry: ActionEntry = {\n            ...entry,\n            id: this.generateId(),\n            timestamp: Date.now()\n        };\n\n        this.state.entries.unshift(fullEntry);\n\n        // Maintain max entries limit\n        if (this.state.entries.length > this.state.maxEntries) {\n            this.state.entries = this.state.entries.slice(0, this.state.maxEntries);\n        }\n\n        return fullEntry;\n    }\n\n    /**\n     * Update an existing entry\n     */\n    updateEntry(id: string, updates: Partial<ActionEntry>): boolean {\n        const index = this.state.entries.findIndex(entry => entry.id === id);\n        if (index === -1) return false;\n\n        Object.assign(this.state.entries[index], updates);\n        return true;\n    }\n\n    /**\n     * Get entry by ID\n     */\n    getEntry(id: string): ActionEntry | undefined {\n        return this.state.entries.find(entry => entry.id === id);\n    }\n\n    /**\n     * Get filtered entries\n     */\n    getEntries(filters?: Partial<ActionHistoryState['filters']>): ActionEntry[] {\n        let entries = [...this.state.entries];\n\n        if (filters?.source) {\n            entries = entries.filter(entry => entry.context.source === filters.source);\n        }\n\n        if (filters?.action) {\n            entries = entries.filter(entry => entry.action === filters.action);\n        }\n\n        if (filters?.status) {\n            entries = entries.filter(entry => entry.status === filters.status);\n        }\n\n        if (filters?.dateRange) {\n            entries = entries.filter(entry =>\n                entry.timestamp >= filters.dateRange!.start &&\n                entry.timestamp <= filters.dateRange!.end\n            );\n        }\n\n        return entries;\n    }\n\n    /**\n     * Get recent entries\n     */\n    getRecentEntries(limit: number = 50): ActionEntry[] {\n        return this.state.entries.slice(0, limit);\n    }\n\n    /**\n     * Remove entry\n     */\n    removeEntry(id: string): boolean {\n        const index = this.state.entries.findIndex(entry => entry.id === id);\n        if (index === -1) return false;\n\n        this.state.entries.splice(index, 1);\n        return true;\n    }\n\n    /**\n     * Clear all entries\n     */\n    clearEntries(): void {\n        this.state.entries = [];\n    }\n\n    /**\n     * Set filters\n     */\n    setFilters(filters: Partial<ActionHistoryState['filters']>): void {\n        Object.assign(this.state.filters, filters);\n    }\n\n    /**\n     * Get statistics\n     */\n    getStats() {\n        const entries = this.state.entries;\n        const total = entries.length;\n        const completed = entries.filter(e => e.status === 'completed').length;\n        const failed = entries.filter(e => e.status === 'failed').length;\n        const pending = entries.filter(e => e.status === 'pending' || e.status === 'processing').length;\n\n        const bySource = entries.reduce((acc, entry) => {\n            acc[entry.context.source] = (acc[entry.context.source] || 0) + 1;\n            return acc;\n        }, {} as Record<string, number>);\n\n        const byAction = entries.reduce((acc, entry) => {\n            acc[entry.action] = (acc[entry.action] || 0) + 1;\n            return acc;\n        }, {} as Record<string, number>);\n\n        return {\n            total,\n            completed,\n            failed,\n            pending,\n            successRate: total > 0 ? (completed / total) * 100 : 0,\n            bySource,\n            byAction\n        };\n    }\n\n    /**\n     * Export entries\n     */\n    exportEntries(format: 'json' | 'csv' = 'json', filters?: Partial<ActionHistoryState['filters']>): string {\n        const entries = this.getEntries(filters);\n\n        if (format === 'csv') {\n            const headers = ['ID', 'Timestamp', 'Source', 'Action', 'Status', 'Input Type', 'Result Type', 'Processing Time'];\n            const rows = entries.map(entry => [\n                entry.id,\n                new Date(entry.timestamp).toISOString(),\n                entry.context.source,\n                entry.action,\n                entry.status,\n                entry.input.type,\n                entry.result?.type || '',\n                entry.result?.processingTime || ''\n            ]);\n\n            return [headers, ...rows].map(row => row.map(cell => `\"${cell}\"`).join(',')).join('\\n');\n        }\n\n        return JSON.stringify(entries, null, 2);\n    }\n\n    /**\n     * Import entries\n     */\n    importEntries(data: string, format: 'json' | 'csv' = 'json'): number {\n        let entries: ActionEntry[] = [];\n\n        if (format === 'json') {\n            try {\n                entries = JSON.parse(data);\n            } catch (e) {\n                throw new Error('Invalid JSON format');\n            }\n        } else {\n            // CSV parsing would be implemented here\n            throw new Error('CSV import not implemented yet');\n        }\n\n        // Validate entries\n        const validEntries = entries.filter(entry =>\n            entry.id && entry.timestamp && entry.context && entry.action\n        );\n\n        // Add valid entries\n        validEntries.forEach(entry => {\n            if (!this.getEntry(entry.id)) {\n                this.state.entries.push(entry);\n            }\n        });\n\n        // Sort by timestamp (newest first)\n        this.state.entries.sort((a, b) => b.timestamp - a.timestamp);\n\n        // Maintain max entries limit\n        if (this.state.entries.length > this.state.maxEntries) {\n            this.state.entries = this.state.entries.slice(0, this.state.maxEntries);\n        }\n\n        this.saveHistory();\n        return validEntries.length;\n    }\n\n    private generateId(): string {\n        return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private loadHistory(): void {\n        try {\n            if (typeof localStorage === \"undefined\") return;\n            const stored = localStorage.getItem(this.storageKey);\n            if (stored) {\n                const data = JSON.parse(stored);\n                if (Array.isArray(data)) {\n                    this.state.entries = data.map(entry => ({\n                        ...entry,\n                        // Ensure backward compatibility\n                        context: entry.context || { source: 'unknown' },\n                        input: entry.input || { type: 'unknown' },\n                        status: entry.status || 'completed'\n                    }));\n                }\n            }\n        } catch (e) {\n            console.warn('Failed to load action history:', e);\n            this.state.entries = [];\n        }\n    }\n\n    private saveHistory(): void {\n        if (!this.state.autoSave) return;\n\n        try {\n            if (typeof localStorage === \"undefined\") return;\n            localStorage.setItem(this.storageKey, JSON.stringify(this.state.entries));\n        } catch (e) {\n            console.warn('Failed to save action history:', e);\n        }\n    }\n}\n\n// Singleton instance\nexport const actionHistory = new ActionHistoryStore();","import { processDataWithInstruction } from '@rs-com/service/service/RecognizeData';\nimport { toBase64 } from '@rs-com/service/model/GPT-Responses';\nimport { actionHistory, type ActionEntry, type ActionContext, type ActionInput, type ActionResult } from './ActionHistory';\n\nexport interface ExecutionRule {\n    id: string;\n    name: string;\n    description: string;\n    source: ActionContext['source'];\n    inputTypes: ActionInput['type'][];\n    action: string;\n    condition: (input: ActionInput, context: ActionContext) => boolean;\n    processor: (input: ActionInput, context: ActionContext, options?: ExecutionOptions) => Promise<ActionResult>;\n    autoCopy: boolean;\n    autoSave: boolean;\n    priority: number; // Higher priority rules are checked first\n}\n\nexport interface ExecutionOptions {\n    ruleSet?: string;\n    forceAction?: string;\n    skipHistory?: boolean;\n    customInstruction?: string;\n    recognitionFormat?: \"auto\" | \"markdown\" | \"html\" | \"text\" | \"json\" | \"most-suitable\" | \"most-optimized\" | \"most-legibility\";\n    processingFormat?: \"markdown\" | \"html\" | \"json\" | \"text\" | \"typescript\" | \"javascript\" | \"python\" | \"java\" | \"cpp\" | \"csharp\" | \"php\" | \"ruby\" | \"go\" | \"rust\" | \"xml\" | \"yaml\" | \"css\" | \"scss\";\n}\n\nexport class ExecutionCore {\n    private rules: ExecutionRule[] = [];\n    private ruleSets: Map<string, ExecutionRule[]> = new Map();\n\n    constructor(rules?: ExecutionOptions) {\n        this.initializeDefaultRules(rules ?? {\n            recognitionFormat: 'markdown',\n            processingFormat: 'markdown'\n        });\n    }\n\n    /**\n     * Register a new execution rule\n     */\n    registerRule(rule: ExecutionRule): void {\n        this.rules.push(rule);\n        this.rules.sort((a, b) => b.priority - a.priority); // Higher priority first\n    }\n\n    /**\n     * Register a rule set\n     */\n    registerRuleSet(name: string, rules: ExecutionRule[]): void {\n        this.ruleSets.set(name, rules);\n    }\n\n    /**\n     * Execute an action based on input and context\n     */\n    async execute(input: ActionInput, context: ActionContext, options: ExecutionOptions = {}): Promise<ActionResult> {\n        const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n        // Create history entry\n        const entry: Omit<ActionEntry, 'id' | 'timestamp' | 'result'> = {\n            context,\n            action: options.forceAction || 'auto',\n            input,\n            status: 'processing',\n            ruleSet: options.ruleSet,\n            executionId\n        };\n\n        const historyEntry = actionHistory.addEntry(entry);\n\n        try {\n            // Find matching rule\n            const rule = this.findMatchingRule(input, context, options);\n\n            if (!rule) {\n                throw new Error('No matching execution rule found');\n            }\n\n            // Update action in history\n            actionHistory.updateEntry(historyEntry.id, { action: rule.action });\n\n            // Execute the processor\n            const startTime = Date.now();\n            const result = await rule.processor(input, context, options);\n            const processingTime = Date.now() - startTime;\n\n            // Enhance result with metadata\n            const enhancedResult: ActionResult = {\n                ...result,\n                processingTime,\n                autoCopied: rule.autoCopy\n            };\n\n            // Update history with result\n            actionHistory.updateEntry(historyEntry.id, {\n                result: enhancedResult,\n                status: 'completed',\n                dataCategory: enhancedResult.dataCategory\n            });\n\n            // Auto-copy if enabled\n            if (rule.autoCopy && enhancedResult.type !== 'error') {\n                await this.autoCopyResult(enhancedResult, context);\n            }\n\n            return enhancedResult;\n\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n\n            // Update history with error\n            actionHistory.updateEntry(historyEntry.id, {\n                status: 'failed',\n                error: errorMessage\n            });\n\n            // Return error result\n            return {\n                type: 'error',\n                content: errorMessage\n            };\n        }\n    }\n\n    /**\n     * Find the best matching rule for the given input and context\n     */\n    private findMatchingRule(input: ActionInput, context: ActionContext, options: ExecutionOptions): ExecutionRule | null {\n        // Check forced action first\n        if (options.forceAction) {\n            const forcedRule = this.rules.find(rule =>\n                rule.action === options.forceAction &&\n                rule.source === context.source &&\n                rule.inputTypes.includes(input.type)\n            );\n            if (forcedRule) return forcedRule;\n        }\n\n        // Check rule set if specified\n        if (options.ruleSet) {\n            const ruleSet = this.ruleSets.get(options.ruleSet);\n            if (ruleSet) {\n                const matchingRule = ruleSet.find(rule =>\n                    rule.source === context.source &&\n                    rule.inputTypes.includes(input.type) &&\n                    rule.condition(input, context)\n                );\n                if (matchingRule) return matchingRule;\n            }\n        }\n\n        // Find best matching rule from all rules\n        return this.rules.find(rule =>\n            rule.source === context.source &&\n            rule.inputTypes.includes(input.type) &&\n            rule.condition(input, context)\n        ) || null;\n    }\n\n    /**\n     * Auto-copy result to clipboard\n     */\n    private async autoCopyResult(result: ActionResult, context: ActionContext): Promise<void> {\n        try {\n            let textToCopy = '';\n\n            // Extract text content based on result type\n            switch (result.type) {\n                case 'markdown':\n                case 'text':\n                    textToCopy = result.content;\n                    break;\n                case 'json':\n                    // For JSON, try to extract meaningful text content\n                    try {\n                        const data = JSON.parse(result.content);\n                        if (typeof data === 'string') {\n                            textToCopy = data;\n                        } else if (data.recognized_data) {\n                            textToCopy = Array.isArray(data.recognized_data)\n                                ? data.recognized_data.join('\\n\\n')\n                                : String(data.recognized_data);\n                        } else {\n                            textToCopy = result.content; // Fallback to raw JSON\n                        }\n                    } catch {\n                        textToCopy = result.content;\n                    }\n                    break;\n                case 'html':\n                    // Strip HTML tags for clipboard\n                    textToCopy = result.content.replace(/<[^>]*>/g, '');\n                    break;\n                default:\n                    return; // Don't auto-copy errors\n            }\n\n            if (textToCopy.trim()) {\n                // Use different copy methods based on context\n                if (context.source === 'chrome-extension') {\n                    // Use Chrome extension clipboard API\n                    if (typeof chrome !== 'undefined' && chrome.runtime) {\n                        // This will be handled by the extension's background script\n                        return;\n                    }\n                } else if (typeof navigator !== 'undefined' && navigator.clipboard) {\n                    await navigator.clipboard.writeText(textToCopy.trim());\n                } else if (typeof document !== 'undefined' && document.body) {\n                    // Fallback method - only available in main thread context\n                    const textArea = document.createElement('textarea');\n                    textArea.value = textToCopy.trim();\n                    document.body.appendChild(textArea);\n                    textArea.select();\n                    document.execCommand('copy');\n                    document.body.removeChild(textArea);\n                } else {\n                    // Service worker context - cannot access DOM\n                    console.log('[ExecutionCore] Cannot auto-copy in service worker context - DOM not available');\n                    return;\n                }\n\n                // Broadcast copy notification\n                this.notifyCopySuccess(context);\n            }\n        } catch (error) {\n            console.warn('Failed to auto-copy result:', error);\n        }\n    }\n\n    /**\n     * Notify about successful copy\n     */\n    private notifyCopySuccess(context: ActionContext): void {\n        // Broadcast to different contexts based on source\n        const message = { type: 'copy-success', context };\n\n        if (context.source === 'chrome-extension') {\n            // Chrome extension notification\n            if (typeof chrome !== 'undefined' && chrome.runtime) {\n                chrome.runtime.sendMessage(message);\n            }\n        } else {\n            // Broadcast channel for web contexts\n            try {\n                const bc = new BroadcastChannel('rs-clipboard');\n                bc.postMessage(message);\n                bc.close();\n            } catch (e) {\n                console.warn('Failed to broadcast copy success:', e);\n            }\n        }\n    }\n\n    /**\n     * Initialize default execution rules\n     */\n    private initializeDefaultRules(options?: ExecutionOptions): void {\n        // Work Center Rules\n        // Text/Markdown files - treat as source data, no recognition needed\n        this.registerRule({\n            id: 'workcenter-text-files-source',\n            name: 'Work Center Text File Source',\n            description: 'Process text/markdown files as source data',\n            source: 'workcenter',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 11 // Higher than recognition, lower than analysis\n        });\n\n        this.registerRule({\n            id: 'workcenter-files-recognize',\n            name: 'Work Center File Recognition',\n            description: 'Recognize content from uploaded files',\n            source: 'workcenter',\n            inputTypes: ['files', 'image'],\n            action: 'recognize',\n            condition: (input) => Boolean((input?.files?.length ?? 0) > 0),\n            processor: async (input, context, options) => {\n                let result;\n\n                // Determine recognition format instruction\n                const formatInstruction = this.getRecognitionFormatInstruction(options?.recognitionFormat);\n\n                // Handle multiple files by creating a combined message\n                if (input.files!.length > 1) {\n                    // Create a message array with multiple file attachments\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Analyze and recognize content from the following ${input.files!.length} files. ${formatInstruction}` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    // Convert each file to the proper format\n                                    const FileCtor = (globalThis as any).File;\n                                    const isFile = FileCtor && file instanceof FileCtor;\n\n                                    const header = { type: \"input_text\", text: `\\n--- File ${index + 1}: ${file.name} ---\\n` };\n\n                                    if (isFile && file.type.startsWith('image/')) {\n                                        try {\n                                            const arrayBuffer = await file.arrayBuffer();\n                                            const bytes = new Uint8Array(arrayBuffer);\n                                            const base64 = toBase64(bytes);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_image\",\n                                                    detail: \"auto\",\n                                                    image_url: `data:${file.type};base64,${base64}`\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to process image ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to process image: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    } else {\n                                        try {\n                                            const text = await file.text();\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: text\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to read file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to read file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    }\n                                }))).flat()\n                            ].filter(item => item !== null)\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: `Analyze and recognize content from the provided files. ${formatInstruction}`,\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false } // Already processed\n                        }\n                    );\n                } else {\n                    // Single file - use the original approach\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single image file, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: `Analyze and recognize content from the provided image. ${formatInstruction}`,\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process image ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: `Analyze and recognize content from the provided file. ${formatInstruction}`,\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Analyze and recognize content from the provided file',\n                                outputFormat: options?.recognitionFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 10\n        });\n\n        this.registerRule({\n            id: 'workcenter-text-analyze',\n            name: 'Work Center Text Analysis',\n            description: 'Analyze provided text content',\n            source: 'workcenter',\n            inputTypes: ['text', 'markdown'],\n            action: 'analyze',\n            condition: (input) => Boolean(input.text || input.recognizedContent),\n            processor: async (input, context, options) => {\n                const content = input.recognizedContent || input.recognizedData?.content || input.text || '';\n\n                // Determine if we have files that need special processing\n                const hasImages = input.files?.some(f => f.type.startsWith('image/') || f.type === 'image/svg+xml') || false;\n                const hasSvgContent = typeof content === 'string' && content.includes('<svg');\n\n                // Use user-provided instruction if available, otherwise default to analysis\n                const userInstruction = input.text && input.text.trim() && input.text.trim() !== \"Analyze and process the provided content intelligently\";\n                const instructions = userInstruction\n                    ? input?.text?.trim?.()\n                    : `Analyze the provided content. ${this.getProcessingFormatInstruction(options?.processingFormat)}`;\n\n                const result = await processDataWithInstruction(\n                    hasImages || hasSvgContent ? [content, ...(input.files || [])] : content,\n                    {\n                        instruction: instructions,\n                        outputFormat: options?.processingFormat || 'auto',\n                        outputLanguage: 'auto',\n                        enableSVGImageGeneration: 'auto',\n                        intermediateRecognition: {\n                            enabled: hasImages,\n                            outputFormat: options?.recognitionFormat || 'markdown',\n                            dataPriorityInstruction: undefined,\n                            cacheResults: true\n                        },\n                        dataType: hasSvgContent ? 'svg' : (hasImages ? 'image' : 'text'),\n                        processingEffort: 'medium',\n                        processingVerbosity: 'medium'\n                    }\n                );\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'processed'\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 9\n        });\n\n        // Share Target Rules\n        // Share target text/markdown files - treat as source data\n        this.registerRule({\n            id: 'share-target-text-files-source',\n            name: 'Share Target Text File Source',\n            description: 'Process shared text/markdown files as source data',\n            source: 'share-target',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `share_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 16 // Higher priority for share target\n        });\n\n        this.registerRule({\n            id: 'share-target-images-recognize',\n            name: 'Share Target Image Recognition',\n            description: 'Recognize content from shared images',\n            source: 'share-target',\n            inputTypes: ['image', 'files'],\n            action: 'recognize',\n            condition: (input) => input.files?.some(f => f.type.startsWith('image/')) || false,\n            processor: async (input) => {\n                const imageFiles = input.files!.filter(f => f.type.startsWith('image/'));\n                let result;\n\n                if (imageFiles.length > 1) {\n                    // Handle multiple images\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Recognize and extract text/content from the following ${imageFiles.length} shared images:` },\n                                ...(await Promise.all(imageFiles.map(async (file, index) => {\n                                    try {\n                                        const arrayBuffer = await file.arrayBuffer();\n                                        const bytes = new Uint8Array(arrayBuffer);\n                                        const base64 = btoa(String.fromCharCode(...bytes));\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Image ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_image\",\n                                                detail: \"auto\",\n                                                image_url: `data:${file.type};base64,${base64}`\n                                            }\n                                        ];\n                                    } catch (error) {\n                                        console.warn(`Failed to process image ${file.name}:`, error);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Image ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_text\",\n                                                text: `[Failed to process image: ${file.name}]`\n                                            }\n                                        ];\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Recognize and extract text/content from the shared images',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single image\n                    result = await processDataWithInstruction(\n                        imageFiles[0],\n                        {\n                            instruction: 'Recognize and extract text/content from the shared image',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 15\n        });\n\n        this.registerRule({\n            id: 'share-target-markdown-view',\n            name: 'Share Target Markdown View',\n            description: 'View shared markdown content',\n            source: 'share-target',\n            inputTypes: ['text', 'markdown'],\n            action: 'view',\n            condition: (input) => this.isMarkdownContent(input.text || ''),\n            processor: async (input) => {\n                // For markdown content shared via share target, just return it as-is\n                return {\n                    type: 'markdown',\n                    content: input.text || ''\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 14\n        });\n\n        this.registerRule({\n            id: 'share-target-url-analyze',\n            name: 'Share Target URL Analysis',\n            description: 'Analyze shared URL content',\n            source: 'share-target',\n            inputTypes: ['url'],\n            action: 'analyze',\n            condition: () => true,\n            processor: async (input, context, options) => {\n                const instructions = `Analyze the content from this URL and provide insights. ${this.getProcessingFormatInstruction(options?.processingFormat)}`;\n                const result = await processDataWithInstruction(\n                    input.url!,\n                    {\n                        instruction: instructions,\n                        outputFormat: options?.processingFormat || 'auto',\n                        outputLanguage: 'auto',\n                        enableSVGImageGeneration: 'auto',\n                        intermediateRecognition: { enabled: false },\n                        dataType: 'text'\n                    }\n                );\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 13\n        });\n\n        // Chrome Extension Rules\n        // Chrome extension text/markdown files - treat as source data\n        this.registerRule({\n            id: 'chrome-extension-text-files-source',\n            name: 'Chrome Extension Text File Source',\n            description: 'Process Chrome extension text/markdown files as source data',\n            source: 'chrome-extension',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `crx_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: true, // Chrome extension often wants immediate results\n            autoSave: true,\n            priority: 26 // Higher priority for Chrome extension\n        });\n\n        this.registerRule({\n            id: 'chrome-extension-screenshot-recognize',\n            name: 'Chrome Extension Screenshot Recognition',\n            description: 'Recognize content from screenshot',\n            source: 'chrome-extension',\n            inputTypes: ['image'],\n            action: 'recognize',\n            condition: () => true,\n            processor: async (input) => {\n                let result;\n\n                if (input.files!.length > 1) {\n                    // Handle multiple screenshots\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Analyze the following ${input.files!.length} screenshots and extract any visible text or content:` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    try {\n                                        const arrayBuffer = await file.arrayBuffer();\n                                        const bytes = new Uint8Array(arrayBuffer);\n                                        const base64 = toBase64(bytes);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Screenshot ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_image\",\n                                                detail: \"auto\",\n                                                image_url: `data:${file.type};base64,${base64}`\n                                            }\n                                        ];\n                                    } catch (error) {\n                                        console.warn(`Failed to process screenshot ${file.name}:`, error);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Screenshot ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_text\",\n                                                text: `[Failed to process screenshot: ${file.name}]`\n                                            }\n                                        ];\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Analyze the screenshots and extract any visible text or content',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single screenshot\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single screenshot, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: 'Analyze the screenshot and extract any visible text or content',\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process screenshot ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: 'Analyze the screenshot and extract any visible text or content',\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Analyze the screenshot and extract any visible text or content',\n                                outputFormat: options?.recognitionFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 20\n        });\n\n        // Launch Queue Rules (similar to share target)\n        // Launch queue text/markdown files - treat as source data\n        this.registerRule({\n            id: 'launch-queue-text-files-source',\n            name: 'Launch Queue Text File Source',\n            description: 'Process launch queue text/markdown files as source data',\n            source: 'launch-queue',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `launch_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: true, // Launch queue often wants immediate results\n            autoSave: true,\n            priority: 21 // Higher priority for launch queue\n        });\n\n        this.registerRule({\n            id: 'launch-queue-files-process',\n            name: 'Launch Queue File Processing',\n            description: 'Process files from launch queue',\n            source: 'launch-queue',\n            inputTypes: ['files', 'mixed'],\n            action: 'process',\n            condition: () => true,\n            processor: async (input) => {\n                let result;\n\n                if (input.files!.length > 1) {\n                    // Handle multiple files from launch queue\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Process the following ${input.files!.length} files:` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    const FileCtor = (globalThis as any).File;\n                                    const isFile = FileCtor && file instanceof FileCtor;\n\n                                    const header = { type: \"input_text\", text: `\\n--- File ${index + 1}: ${file.name} ---\\n` };\n\n                                    if (isFile && file.type.startsWith('image/')) {\n                                        try {\n                                            const arrayBuffer = await file.arrayBuffer();\n                                            const bytes = new Uint8Array(arrayBuffer);\n                                            const base64 = toBase64(bytes);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_image\",\n                                                    detail: \"auto\",\n                                                    image_url: `data:${file.type};base64,${base64}`\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to process file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to process file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    } else {\n                                        try {\n                                            const text = await file.text();\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: text\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to read file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to read file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Process the provided content',\n                            outputFormat: options?.processingFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single file\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single image file, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: 'Process the provided image content',\n                                    outputFormat: options?.processingFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process image ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: 'Process the provided content',\n                                    outputFormat: options?.processingFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Process the provided content',\n                                outputFormat: options?.processingFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 12\n        });\n    }\n\n    /**\n     * Check if content is markdown\n     */\n    private isMarkdownContent(text: string): boolean {\n        if (!text || typeof text !== 'string') return false;\n\n        const trimmed = text.trim();\n        if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\")) return false;\n        if (/<[a-zA-Z][^>]*>/.test(trimmed)) return false;\n\n        // Check for markdown patterns\n        const patterns = [\n            /^---[\\s\\S]+?---/, // YAML frontmatter\n            /^#{1,6}\\s+.+$/m, // Headings\n            /^\\s*[-*+]\\s+\\S+/m, // Unordered lists\n            /^\\s*\\d+\\.\\s+\\S+/m, // Ordered lists\n            /`{1,3}[^`]*`{1,3}/, // Code blocks/inline code\n            /\\[([^\\]]+)\\]\\(([^)]+)\\)/, // Links\n            /!\\[([^\\]]+)\\]\\(([^)]+)\\)/, // Images\n        ];\n\n        return patterns.some(pattern => pattern.test(text));\n    }\n\n    /**\n     * Format AI result for display\n     */\n    private detectResultFormat(result: any): 'json' | 'markdown' | 'text' | 'html' {\n        if (!result) return 'text';\n\n        try {\n            // Check if result.data exists and is an object\n            const data = result.data || result;\n\n            // If it's structured recognition data (has specific fields), return JSON\n            if (data && typeof data === 'object') {\n                const hasStructuredFields = [\n                    'recognized_data',\n                    'verbose_data',\n                    'keywords_and_tags',\n                    'confidence',\n                    'suggested_type',\n                    'using_ready'\n                ].some(field => field in data);\n\n                if (hasStructuredFields) {\n                    return 'json';\n                }\n\n                // If it's any other object, check if it looks like markdown content\n                if (data.content || data.text || data.message) {\n                    return 'markdown';\n                }\n\n                // Default to JSON for objects\n                return 'json';\n            }\n\n            // If it's a string, check if it looks like markdown\n            if (typeof data === 'string') {\n                // Simple heuristic: if it contains markdown-like elements or is multi-line\n                if (data.includes('\\n') || data.includes('#') || data.includes('*') || data.includes('`')) {\n                    return 'markdown';\n                }\n                return 'text';\n            }\n\n            // Default fallback\n            return 'json';\n        } catch (error) {\n            console.warn('Failed to detect result format:', error);\n            return 'text';\n        }\n    }\n\n    private formatAIResult(result: any): string {\n        if (!result) return 'No result';\n\n        try {\n            // Extract meaningful content from AI response\n            let content = '';\n\n            if (result.data) {\n                if (typeof result.data === 'string') {\n                    content = result.data;\n                } else if (result.data.recognized_data) {\n                    const recognized = result.data.recognized_data;\n                    content = Array.isArray(recognized) ? recognized.join('\\n\\n') : String(recognized);\n                } else {\n                    content = JSON.stringify(result.data, null, 2);\n                }\n            } else if (typeof result === 'string') {\n                content = result;\n            } else {\n                content = JSON.stringify(result, null, 2);\n            }\n\n            // Unwrap unwanted code block formatting\n            content = this.unwrapUnwantedCodeBlocks(content);\n\n            return content;\n        } catch (error) {\n            console.warn('Failed to format AI result:', error);\n            return String(result);\n        }\n    }\n\n    private unwrapUnwantedCodeBlocks(content: string): string {\n        if (!content) return content;\n\n        // Remove wrapping code blocks that are not intended for code\n        // Pattern: ```language\\ncontent\\n```\n        const codeBlockRegex = /^```(?:katex|md|markdown|html|xml|json|text)?\\n([\\s\\S]*?)\\n```$/;\n\n        const match = content.trim().match(codeBlockRegex);\n        if (match) {\n            const unwrapped = match[1].trim();\n\n            // Additional check: if the unwrapped content looks like it should be wrapped\n            // (e.g., actual code, or multiple lines that are clearly formatted content),\n            // keep the original. Otherwise, unwrap it.\n            const lines = unwrapped.split('\\n');\n\n            // If it's a single line or looks like markup/math, unwrap\n            if (lines.length === 1 ||\n                unwrapped.includes('<math') ||\n                unwrapped.includes('<span class=\"katex') ||\n                unwrapped.includes('<content') ||\n                unwrapped.startsWith('<') && unwrapped.endsWith('>') ||\n                /^\\s*<[^>]+>/.test(unwrapped)) {\n                console.log('[AI Response] Unwrapped unwanted code block formatting');\n                return unwrapped;\n            }\n\n            // If it looks like actual code (multiple lines, indentation, etc.), keep wrapped\n            if (lines.length > 3 ||\n                lines.some(line => line.match(/^\\s{4,}/) || line.includes('function') || line.includes('const ') || line.includes('let '))) {\n                return content; // Keep the code block\n            }\n\n            // Default to unwrapping for single/multiple simple lines\n            console.log('[AI Response] Unwrapped unwanted code block formatting');\n            return unwrapped;\n        }\n\n        return content;\n    }\n\n    private getRecognitionFormatInstruction(format?: \"auto\" | \"markdown\" | \"html\" | \"text\" | \"json\" | \"most-suitable\" | \"most-optimized\" | \"most-legibility\"): string {\n        if (!format || format === 'auto') {\n            return 'Output the content in the most appropriate format (markdown is preferred for structured content).';\n        }\n\n        switch (format) {\n            case 'most-suitable':\n                return 'Analyze the content and output it in the most suitable format for its type and structure. Choose the format that best represents the content\\'s nature and purpose.';\n            case 'most-optimized':\n                return 'Output the content in the most optimized format for storage and transmission efficiency. Prefer compact representations while maintaining essential information.';\n            case 'most-legibility':\n                return 'Output the content in the most human-readable and legible format. Prioritize clarity, readability, and ease of understanding over compactness.';\n            case 'markdown':\n                return 'Output the recognized content in Markdown format.';\n            case 'html':\n                return 'Output the recognized content in HTML format.';\n            case 'text':\n                return 'Output the recognized content as plain text.';\n            case 'json':\n                return 'Output the recognized content as structured JSON data.';\n            default:\n                return 'Output the content in the most appropriate format (markdown is preferred for structured content).';\n        }\n    }\n\n    private getProcessingFormatInstruction(format?: \"markdown\" | \"html\" | \"json\" | \"text\" | \"typescript\" | \"javascript\" | \"python\" | \"java\" | \"cpp\" | \"csharp\" | \"php\" | \"ruby\" | \"go\" | \"rust\" | \"xml\" | \"yaml\" | \"css\" | \"scss\"): string {\n        if (!format || format === 'markdown') {\n            return 'Output the processed result in Markdown format.';\n        }\n\n        switch (format) {\n            case 'html':\n                return 'Output the processed result in HTML format.';\n            case 'json':\n                return 'Output the processed result as structured JSON data.';\n            case 'text':\n                return 'Output the processed result as plain text.';\n            case 'typescript':\n                return 'Output the processed result as TypeScript code.';\n            case 'javascript':\n                return 'Output the processed result as JavaScript code.';\n            case 'python':\n                return 'Output the processed result as Python code.';\n            case 'java':\n                return 'Output the processed result as Java code.';\n            case 'cpp':\n                return 'Output the processed result as C++ code.';\n            case 'csharp':\n                return 'Output the processed result as C# code.';\n            case 'php':\n                return 'Output the processed result as PHP code.';\n            case 'ruby':\n                return 'Output the processed result as Ruby code.';\n            case 'go':\n                return 'Output the processed result as Go code.';\n            case 'rust':\n                return 'Output the processed result as Rust code.';\n            case 'xml':\n                return 'Output the processed result in XML format.';\n            case 'yaml':\n                return 'Output the processed result in YAML format.';\n            case 'css':\n                return 'Output the processed result as CSS code.';\n            case 'scss':\n                return 'Output the processed result as SCSS code.';\n            default:\n                return 'Output the processed result in Markdown format.';\n        }\n    }\n}\n\n// Singleton instance\nexport const executionCore = new ExecutionCore();","/**\n * CrossWord  Chrome Extension Service Worker\n *\n * Responsibilities:\n *  - Context menu setup (copy-as-*, snip modes, markdown viewer, custom instructions)\n *  - Keyboard command handling (Ctrl+Shift+X/Y)\n *  - AI recognition message dispatch (gpt:recognize, gpt:solve, gpt:code, gpt:css, gpt:custom, gpt:translate)\n *  - Markdown URL detection & auto-redirect to viewer\n *  - CRX result pipeline (clipboard  content-script  popup  workcenter  notification)\n *  - CRX unified messaging integration\n *\n * Heavy capture/AI/clipboard logic is in `./service/api.ts`.\n */\n\nimport { createTimelineGenerator, requestNewTimeline } from \"@rs-com/service/service/MakeTimeline\";\nimport { COPY_HACK, enableCapture } from \"./service/api\";\nimport type { GPTResponses } from \"@rs-com/service/model/GPT-Responses\";\nimport { recognizeImageData } from \"../com/service/service/RecognizeData\";\nimport { getGPTInstance, processDataWithInstruction } from \"@rs-com/service/service/RecognizeData\";\nimport { getCustomInstructions, type CustomInstruction } from \"@rs-com/service/misc/CustomInstructions\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport { executionCore } from \"@rs-com/service/misc/ExecutionCore\";\nimport type { ActionContext, ActionInput } from \"@rs-com/service/misc/ActionHistory\";\nimport { crxMessaging, registerCrxHandler, broadcastToCrxTabs } from \"../com/core/CrxMessaging\";\nimport { CRX_SOLVE_AND_ANSWER_INSTRUCTION, CRX_WRITE_CODE_INSTRUCTION, CRX_EXTRACT_CSS_INSTRUCTION } from \"@rs-com/core/BuiltInAI\";\n\n// ---------------------------------------------------------------------------\n// Environment detection\n// ---------------------------------------------------------------------------\n\nconst isInCrxEnvironment = crxMessaging.isCrxEnvironment();\n\n// ---------------------------------------------------------------------------\n// Broadcast helpers\n// ---------------------------------------------------------------------------\n\nconst TOAST_CHANNEL = \"rs-toast\";\nconst AI_RECOGNITION_CHANNEL = \"rs-ai-recognition\";\nconst POPUP_CHANNEL = \"rs-popup\";\n\nconst broadcast = (channel: string, message: unknown): void => {\n    try { const bc = new BroadcastChannel(channel); bc.postMessage(message); bc.close(); }\n    catch { /* ignore */ }\n};\n\nconst showExtensionToast = (message: string, kind: \"info\" | \"success\" | \"warning\" | \"error\" = \"info\"): void =>\n    broadcast(TOAST_CHANNEL, { type: \"show-toast\", options: { message, kind, duration: 3000 } });\n\n// ---------------------------------------------------------------------------\n// Clipboard shortcut\n// ---------------------------------------------------------------------------\n\nconst requestClipboardCopy = async (data: unknown, showFeedback = true, tabId?: number): Promise<void> => {\n    try {\n        let resolvedTabId = tabId;\n        if ((!resolvedTabId || resolvedTabId <= 0) && showFeedback) {\n            const tabs = await chrome.tabs.query({ active: true, currentWindow: true }).catch(() => []);\n            resolvedTabId = tabs?.[0]?.id;\n        }\n        await COPY_HACK(chrome, { ok: true, data: data as any }, resolvedTabId);\n    } catch (e) { console.warn(\"[SW] clipboard copy failed:\", e); }\n};\n\n// ---------------------------------------------------------------------------\n// Custom instructions helper\n// ---------------------------------------------------------------------------\n\nconst loadCustomInstructions = async (): Promise<CustomInstruction[]> => {\n    try { return await getCustomInstructions(); }\n    catch { return []; }\n};\n\n// ---------------------------------------------------------------------------\n// Execution core wrapper\n// ---------------------------------------------------------------------------\n\nconst processChromeExtensionAction = async (\n    input: ActionInput,\n    sessionId?: string,\n): Promise<{ success: boolean; result?: any; error?: string }> => {\n    try {\n        const context: ActionContext = {\n            source: \"chrome-extension\",\n            sessionId: sessionId || `crx_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,\n        };\n        const result = await executionCore.execute(input, context);\n        if (result.type === \"error\") {\n            return { success: false, error: result.content || result.error || \"Processing failed\", result };\n        }\n        return { success: true, result };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n};\n\n// ============================================================================\n// DIRECT CHROME MESSAGE HANDLING\n// ============================================================================\n\nif (isInCrxEnvironment && chrome.runtime?.onMessage) {\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        if (!message?.type) return false;\n\n        // --- processCapture (direct) ---\n        if (message.type === \"processCapture\") {\n            (async () => {\n                try {\n                    const rect = message.data?.rect;\n                    const opts: chrome.tabs.CaptureVisibleTabOptions & { rect?: any; scale?: number } = { format: \"png\", scale: 1 };\n                    if (rect?.width > 0 && rect?.height > 0) opts.rect = rect;\n\n                    const dataUrl = await new Promise<string>((resolve, reject) => {\n                        chrome.tabs.captureVisibleTab(opts, (url) => {\n                            chrome.runtime.lastError ? reject(new Error(chrome.runtime.lastError.message)) : resolve(url);\n                        });\n                    });\n                    const blob = await (await fetch(dataUrl)).blob();\n                    const result = await recognizeImageData(blob);\n                    sendResponse({ success: true, result });\n                } catch (error) {\n                    sendResponse({ success: false, error: error instanceof Error ? error.message : String(error) });\n                }\n            })();\n            return true;\n        }\n\n        // --- processText (direct) ---\n        if (message.type === \"processText\") {\n            sendResponse({ success: true, result: { type: \"text\", content: message.data?.content, processed: true } });\n            return false;\n        }\n\n        return false;\n    });\n}\n\n// ============================================================================\n// CRX UNIFIED MESSAGING HANDLERS\n// ============================================================================\n\nif (isInCrxEnvironment) {\n    registerCrxHandler(\"processImage\", async (data: { imageData: string; mode: string; customInstructionId?: string }) => {\n        const result = await processChromeExtensionAction({ type: \"recognize\", data: data.imageData, mode: data.mode, customInstructionId: data.customInstructionId });\n        crxMessaging.sendRuntimeMessage({ type: \"processingComplete\", data: { result }, metadata: { progress: 100 } }).catch(() => {});\n        return result;\n    });\n\n    registerCrxHandler(\"processCapture\", async (data: any) =>\n        processChromeExtensionAction({ type: \"capture\", data, mode: data.type?.toLowerCase().replace(\"capture_\", \"\") || \"recognize\" })\n    );\n\n    registerCrxHandler(\"processText\", async (data: { content: string; contentType: string }) =>\n        processChromeExtensionAction({ type: \"process\", data: data.content, contentType: data.contentType })\n    );\n\n    registerCrxHandler(\"getProcessingStatus\", async (data: { operationId: string }) =>\n        ({ status: \"completed\", operationId: data.operationId })\n    );\n\n    registerCrxHandler(\"cancelProcessing\", async (data: { operationId: string }) =>\n        ({ cancelled: true, operationId: data.operationId })\n    );\n}\n\nregisterCrxHandler(\"getSettings\", async () => { try { return await loadSettings(); } catch (e) { throw e; } });\nregisterCrxHandler(\"updateSettings\", async (updates: any) => ({ success: true }));\nregisterCrxHandler(\"ping\", async () => ({ status: \"ok\", context: \"service-worker\", timestamp: Date.now() }));\n\nregisterCrxHandler(\"broadcastResult\", async (data: { result: any; type: string }) => {\n    await broadcastToCrxTabs({ type: \"ai-result\", data: data.result, metadata: { source: \"service-worker\" } });\n    broadcast(AI_RECOGNITION_CHANNEL, { type: data.type, result: data.result, timestamp: Date.now(), source: \"crx-service-worker\" });\n    return { broadcasted: true };\n});\n\n// ============================================================================\n// CRX RESULT PIPELINE\n// ============================================================================\n\ninterface CrxResult {\n    id: string;\n    type: \"text\" | \"image\" | \"markdown\" | \"processed\";\n    content: string | ArrayBuffer;\n    source: \"crx-snip\" | \"content-script\" | \"ai-processing\";\n    timestamp: number;\n    metadata?: Record<string, any>;\n}\n\ninterface CrxDestination {\n    type: \"clipboard\" | \"content-script\" | \"popup\" | \"workcenter\" | \"notification\";\n    tabId?: number;\n    frameId?: number;\n    options?: Record<string, any>;\n}\n\ninterface PendingResult {\n    id: string;\n    result: CrxResult;\n    destinations: CrxDestination[];\n    status: \"pending\" | \"processing\" | \"completed\" | \"failed\";\n    attempts: number;\n    createdAt: number;\n    completedAt?: number;\n    error?: string;\n}\n\nclass CrxResultPipeline {\n    resultQueue: PendingResult[] = [];\n    private maxQueueSize = 50;\n    private maxRetries = 3;\n    private interval: ReturnType<typeof setInterval> | null = null;\n\n    constructor() { this.interval = globalThis.setInterval(() => this.processQueue(), 1000); }\n\n    async enqueue(result: CrxResult, destinations: CrxDestination[]): Promise<string> {\n        const pr: PendingResult = { id: crypto.randomUUID(), result, destinations, status: \"pending\", attempts: 0, createdAt: Date.now() };\n        this.resultQueue.push(pr);\n        if (this.resultQueue.length > this.maxQueueSize) this.resultQueue.shift();\n        return pr.id;\n    }\n\n    getStatus() {\n        const c = { pending: 0, processing: 0, completed: 0, failed: 0 };\n        for (const r of this.resultQueue) c[r.status]++;\n        return { queueSize: this.resultQueue.length, ...c };\n    }\n\n    getPending(dest?: string) {\n        return this.resultQueue.filter((r) => r.status === \"pending\" && (!dest || r.destinations.some((d) => d.type === dest)));\n    }\n\n    clearCompleted() {\n        const n = this.resultQueue.filter((r) => r.status === \"completed\").length;\n        this.resultQueue = this.resultQueue.filter((r) => r.status !== \"completed\");\n        return n;\n    }\n\n    destroy() { if (this.interval) clearInterval(this.interval); this.interval = null; this.resultQueue = []; }\n\n    // --- internal ---\n\n    private async processQueue() {\n        for (const pr of this.resultQueue.filter((r) => r.status === \"pending\")) {\n            pr.status = \"processing\";\n            pr.attempts++;\n            let anyOk = false;\n            for (const dest of pr.destinations) {\n                try { await this.deliver(pr.result, dest); anyOk = true; } catch { /* continue */ }\n            }\n            if (anyOk) { pr.status = \"completed\"; pr.completedAt = Date.now(); }\n            else if (pr.attempts >= this.maxRetries) { pr.status = \"failed\"; pr.error = \"All destinations failed\"; }\n            else pr.status = \"pending\";\n        }\n    }\n\n    private async deliver(result: CrxResult, dest: CrxDestination) {\n        const textContent = typeof result.content === \"string\" ? result.content : `[Binary ${(result.content as ArrayBuffer).byteLength} bytes]`;\n\n        switch (dest.type) {\n            case \"clipboard\":\n                await requestClipboardCopy(textContent, dest.options?.showFeedback !== false, dest.tabId);\n                break;\n\n            case \"content-script\": {\n                const msg = { type: \"crx-result-delivered\", result, destination: dest.type, timestamp: Date.now() };\n                if (dest.tabId) await chrome.tabs.sendMessage(dest.tabId, msg, { frameId: dest.frameId });\n                else await broadcastToCrxTabs(msg as any);\n                break;\n            }\n            case \"popup\":\n                broadcast(POPUP_CHANNEL, { type: \"crx-result-delivered\", result, destination: dest.type, timestamp: Date.now() });\n                break;\n\n            case \"workcenter\":\n                try {\n                    const { unifiedMessaging } = await import(\"@rs-com/core/UnifiedMessaging\");\n                    await unifiedMessaging.sendMessage({\n                        id: result.id, type: \"content-share\", source: \"crx-snip\", destination: \"workcenter\",\n                        contentType: result.type, data: { text: textContent, processed: true, source: result.source, metadata: result.metadata },\n                        metadata: { title: `CRX-Snip ${result.type} Result`, timestamp: result.timestamp, source: result.source },\n                    });\n                } catch { throw new Error(\"WorkCenter delivery failed\"); }\n                break;\n\n            case \"notification\":\n                await chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: `CrossWord ${result.source}`, message: textContent.length > 100 ? textContent.slice(0, 100) + \"...\" : textContent });\n                break;\n        }\n    }\n}\n\nconst pipeline = new CrxResultPipeline();\n\n// Cleanup on termination\nself.addEventListener(\"beforeunload\", () => pipeline.destroy());\n\n// Pipeline convenience helpers\nconst enqueueText = (content: string, destinations: CrxDestination[]) =>\n    pipeline.enqueue({ id: crypto.randomUUID(), type: \"text\", content, source: \"crx-snip\", timestamp: Date.now() }, destinations);\n\nconst processCrxSnipWithPipeline = async (\n    content: string | ArrayBuffer,\n    contentType = \"text\",\n    extraDest: CrxDestination[] = [],\n): Promise<{ success: boolean; resultId?: string; error?: string }> => {\n    try {\n        let processedContent: string | ArrayBuffer = content;\n        let finalType = contentType;\n\n        if ((contentType === \"image\" || content instanceof ArrayBuffer) && content instanceof ArrayBuffer) {\n            const blob = new Blob([content], { type: \"image/png\" });\n            const rec = await recognizeImageData(blob);\n            processedContent = rec.text || \"\";\n            finalType = \"text\";\n        }\n\n        const input: ActionInput = {\n            type: \"process\", content: processedContent, contentType: finalType as any,\n            metadata: { source: \"crx-snip\", timestamp: Date.now(), background: true, originalType: contentType },\n        };\n        const result = await processChromeExtensionAction(input);\n\n        if (result.success && result.result) {\n            const crxResult: CrxResult = {\n                id: crypto.randomUUID(), type: \"processed\",\n                content: typeof result.result === \"string\" ? result.result : String(result.result),\n                source: \"crx-snip\", timestamp: Date.now(),\n            };\n            const destinations: CrxDestination[] = [\n                { type: \"clipboard\", options: { showFeedback: true } },\n                { type: \"content-script\" },\n                { type: \"workcenter\" },\n                { type: \"notification\" },\n                ...extraDest,\n            ];\n            const resultId = await pipeline.enqueue(crxResult, destinations);\n            return { success: true, resultId };\n        }\n        return { success: false, error: result.error };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n};\n\n// ============================================================================\n// MARKDOWN VIEWER SUPPORT\n// ============================================================================\n\nconst VIEWER_PAGE = \"markdown/viewer.html\";\nconst VIEWER_ORIGIN = chrome.runtime.getURL(\"\");\nconst VIEWER_URL = chrome.runtime.getURL(VIEWER_PAGE);\nconst MARKDOWN_EXT_RE = /\\.(?:md|markdown|mdown|mkd|mkdn|mdtxt|mdtext)(?:$|[?#])/i;\nconst MD_VIEW_MENU_ID = \"crossword:markdown-view\";\n\nconst isMarkdownUrl = (candidate?: string | null): candidate is string => {\n    if (!candidate || typeof candidate !== \"string\") return false;\n    try {\n        const url = new URL(candidate);\n        if (url.protocol === \"chrome-extension:\") return false;\n        if (![\"http:\", \"https:\", \"file:\", \"ftp:\"].includes(url.protocol)) return false;\n        if (MARKDOWN_EXT_RE.test(url.pathname)) return true;\n        if (url.hostname === \"raw.githubusercontent.com\" || url.hostname === \"gist.githubusercontent.com\") {\n            if (MARKDOWN_EXT_RE.test(url.pathname)) return true;\n            if (/(^|\\/)readme(\\.md)?($|[?#])/i.test(url.pathname)) return true;\n        }\n        return false;\n    } catch { return false; }\n};\n\nconst isMarkdownContent = (text: string): boolean => {\n    if (!text) return false;\n    const trimmed = text.trim();\n    if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\")) return false;\n    if (/<[a-zA-Z][^>]*>/.test(trimmed)) return false;\n\n    let score = 0, hits = 0;\n    const patterns: [RegExp, number][] = [\n        [/^---[\\s\\S]+?---/, 0.9], [/^#{1,6}\\s+.+$/m, 0.8], [/^\\s*[-*+]\\s+\\S+/m, 0.7],\n        [/^\\s*\\d+\\.\\s+\\S+/m, 0.7], [/`{1,3}[^`]*`{1,3}/, 0.6], [/\\[([^\\]]+)\\]\\(([^)]+)\\)/, 0.5],\n        [/!\\[([^\\]]+)\\]\\(([^)]+)\\)/, 0.5], [/\\*\\*[^*]+\\*\\*/, 0.4], [/\\*[^*]+\\*/, 0.3],\n    ];\n    for (const [re, s] of patterns) { if (re.test(text)) { score += s; hits++; } }\n    return hits >= 2 && score >= 0.8;\n};\n\nconst normalizeMarkdownSourceUrl = (candidate: string) => {\n    try {\n        const u = new URL(candidate);\n        if (u.hostname === \"github.com\") {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            if (parts.length >= 5 && parts[2] === \"blob\") {\n                return `https://raw.githubusercontent.com/${parts[0]}/${parts[1]}/${parts[3]}/${parts.slice(4).join(\"/\")}`;\n            }\n        }\n        if (u.hostname.endsWith(\"gitlab.com\")) {\n            const parts = u.pathname.split(\"/\").filter(Boolean);\n            const di = parts.indexOf(\"-\");\n            if (di >= 0 && parts[di + 1] === \"blob\") {\n                return `https://${u.hostname}/${parts.slice(0, di).join(\"/\")}/-/raw/${parts[di + 2] || \"\"}/${parts.slice(di + 3).join(\"/\")}`;\n            }\n        }\n        if (u.hostname === \"bitbucket.org\") { if (!u.searchParams.has(\"raw\")) u.searchParams.set(\"raw\", \"1\"); return u.toString(); }\n        return u.toString();\n    } catch { return candidate; }\n};\n\nconst toViewerUrl = (source?: string | null, markdownKey?: string | null) => {\n    if (!source) return VIEWER_URL;\n    const p = new URLSearchParams();\n    p.set(\"src\", source);\n    if (markdownKey) p.set(\"mdk\", markdownKey);\n    return `${VIEWER_URL}?${p}`;\n};\n\nconst openViewer = (source?: string | null, tabId?: number, markdownKey?: string | null) => {\n    const url = toViewerUrl(source ?? undefined, markdownKey);\n    if (typeof tabId === \"number\") chrome.tabs.update(tabId, { url })?.catch?.(console.warn);\n    else chrome.tabs.create({ url })?.catch?.(console.warn);\n};\n\nconst createSessionKey = () => {\n    try { return `md:${crypto.randomUUID()}`; }\n    catch { return `md:${Date.now()}:${Math.random().toString(16).slice(2)}`; }\n};\n\nconst putMarkdownToSession = async (text: string) => {\n    const key = createSessionKey();\n    try { await chrome.storage?.session?.set?.({ [key]: text }); return key; }\n    catch { return null; }\n};\n\nconst fetchMarkdownText = async (candidate: string) => {\n    const src = normalizeMarkdownSourceUrl(candidate);\n    const res = await fetch(src, { credentials: \"include\", cache: \"no-store\" });\n    const text = await res.text().catch(() => \"\");\n    return { ok: res.ok, status: res.status, src, text };\n};\n\nconst openMarkdownInViewer = async (originalUrl: string, tabId: number) => {\n    if (originalUrl.startsWith(\"file:\")) { openViewer(originalUrl, tabId, null); return; }\n    const fetched = await fetchMarkdownText(originalUrl).catch(() => null);\n    if (!fetched) { openViewer(normalizeMarkdownSourceUrl(originalUrl), tabId, null); return; }\n    const key = fetched.ok && fetched.text ? await putMarkdownToSession(fetched.text) : null;\n    openViewer(fetched.src, tabId, key);\n};\n\nconst tryReadMarkdownFromTab = async (tabId: number, url?: string) => {\n    try {\n        const results = await chrome.scripting.executeScript({\n            target: { tabId },\n            func: (pageUrl: string) => {\n                if (pageUrl.includes(\"github.com\")) {\n                    const rawBtn = document.querySelector(\"a[href*='raw']\") as HTMLAnchorElement;\n                    if (rawBtn?.href) return `__RAW_URL__${rawBtn.href}`;\n                    const md = document.querySelector(\".markdown-body\");\n                    if (md?.textContent?.trim()) return md.textContent.trim();\n                }\n                return document?.body?.innerText?.trim() || \"\";\n            },\n            args: [url || \"\"],\n        });\n        const val = results?.[0]?.result;\n        if (typeof val === \"string\" && val.startsWith(\"__RAW_URL__\")) {\n            try { const r = await fetch(val.replace(\"__RAW_URL__\", \"\")); if (r.ok) return await r.text(); } catch { /* fallback */ }\n        }\n        return typeof val === \"string\" ? val : \"\";\n    } catch { return \"\"; }\n};\n\n// ============================================================================\n// CONTEXT MENUS\n// ============================================================================\n\nconst CTX_CONTEXTS = [\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\", \"action\"] as const satisfies\n    [`${chrome.contextMenus.ContextType}`, ...`${chrome.contextMenus.ContextType}`[]];\n\nconst CTX_ITEMS = [\n    { id: \"copy-as-latex\", title: \"Copy as LaTeX\" },\n    { id: \"copy-as-mathml\", title: \"Copy as MathML\" },\n    { id: \"copy-as-markdown\", title: \"Copy as Markdown\" },\n    { id: \"copy-as-html\", title: \"Copy as HTML\" },\n    { id: \"START_SNIP\", title: \"Snip and Recognize (AI)\" },\n    { id: \"SOLVE_AND_ANSWER\", title: \"Solve / Answer (AI)\" },\n    { id: \"WRITE_CODE\", title: \"Write Code (AI)\" },\n    { id: \"EXTRACT_CSS\", title: \"Extract CSS Styles (AI)\" },\n];\n\nconst CUSTOM_PREFIX = \"CUSTOM_INSTRUCTION:\";\nlet customMenuIds: string[] = [];\n\nconst updateCustomInstructionMenus = async () => {\n    for (const id of customMenuIds) { try { await chrome.contextMenus.remove(id); } catch { /* ignore */ } }\n    customMenuIds = [];\n\n    const enabled = (await loadCustomInstructions().catch(() => [])).filter((i) => i.enabled);\n    if (!enabled.length) return;\n\n    const sepId = \"CUSTOM_SEP\";\n    try { chrome.contextMenus.create({ id: sepId, type: \"separator\", contexts: CTX_CONTEXTS }); customMenuIds.push(sepId); } catch { /* */ }\n    for (const inst of enabled) {\n        const id = `${CUSTOM_PREFIX}${inst.id}`;\n        try { chrome.contextMenus.create({ id, title: ` ${inst.label}`, contexts: CTX_CONTEXTS }); customMenuIds.push(id); } catch { /* */ }\n    }\n};\n\nchrome.storage.onChanged.addListener((changes, area) => {\n    if (area === \"local\" && changes[\"rs-settings\"]) updateCustomInstructionMenus().catch(() => {});\n});\n\n// ============================================================================\n// onInstalled  create context menus\n// ============================================================================\n\nchrome.runtime.onInstalled.addListener(() => {\n    for (const item of CTX_ITEMS) {\n        try { chrome.contextMenus.create({ id: item.id, title: item.title, visible: true, contexts: CTX_CONTEXTS }); } catch { /* */ }\n    }\n    try {\n        chrome.contextMenus.create({\n            id: MD_VIEW_MENU_ID, title: \"Open in Markdown Viewer\", contexts: [\"link\", \"page\"],\n            targetUrlPatterns: [\"*://*/*.md\", \"*://*/*.markdown\", \"file://*/*.md\", \"file://*/*.markdown\"],\n        });\n    } catch { /* */ }\n\n    // CRX-Snip context menus\n    try { chrome.contextMenus.create({ id: \"crx-snip-text\", title: \"Process Text with CrossWord (CRX-Snip)\", contexts: [\"selection\"] }); } catch { /* */ }\n    try { chrome.contextMenus.create({ id: \"crx-snip-screen\", title: \"Capture & Process Screen Area (CRX-Snip)\", contexts: [\"page\", \"frame\", \"editable\"] }); } catch { /* */ }\n\n    updateCustomInstructionMenus().catch(() => {});\n});\n\n// ============================================================================\n// Context menu click routing\n// ============================================================================\n\nconst sendToTabOrActive = async (tabId: number | undefined, message: unknown) => {\n    if (tabId != null && tabId >= 0) return chrome.tabs.sendMessage(tabId, message)?.catch?.(console.warn);\n    const tabs = await chrome.tabs.query({ currentWindow: true, active: true })?.catch?.(() => []);\n    for (const tab of tabs || []) {\n        if (tab?.id != null && tab.id >= 0) return chrome.tabs.sendMessage(tab.id, message)?.catch?.(console.warn);\n    }\n};\n\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n    const tabId = tab?.id;\n    const menuId = String(info.menuItemId);\n\n    // Snip / AI modes\n    const snipMap: Record<string, string> = {\n        START_SNIP: \"START_SNIP\", SOLVE_AND_ANSWER: \"SOLVE_AND_ANSWER\",\n        WRITE_CODE: \"WRITE_CODE\", EXTRACT_CSS: \"EXTRACT_CSS\",\n    };\n    if (menuId in snipMap) { sendToTabOrActive(tabId, { type: snipMap[menuId] }); return; }\n\n    // Custom instructions\n    if (menuId.startsWith(CUSTOM_PREFIX)) {\n        sendToTabOrActive(tabId, { type: \"CUSTOM_INSTRUCTION\", instructionId: menuId.slice(CUSTOM_PREFIX.length) });\n        return;\n    }\n\n    // Markdown viewer\n    if (menuId === MD_VIEW_MENU_ID) {\n        const candidate = (info as any).linkUrl || (info as any).pageUrl;\n        if (candidate && isMarkdownUrl(candidate)) { void openMarkdownInViewer(candidate, tabId ?? 0); return; }\n        openViewer(candidate, tabId);\n        return;\n    }\n\n    // CRX-Snip text/screen via context menu\n    if (menuId === \"crx-snip-text\" && info.selectionText) {\n        processCrxSnipWithPipeline(info.selectionText, \"text\").then((r) => {\n            chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Text processed and copied!\" : `Failed: ${r.error || \"Unknown\"}` });\n        });\n        return;\n    }\n    if (menuId === \"crx-snip-screen\") {\n        (async () => {\n            try {\n                const imageData = await captureScreenArea();\n                if (!imageData) { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture cancelled\" }); return; }\n                const r = await processCrxSnipWithPipeline(imageData, \"image\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Captured and processed!\" : `Failed: ${r.error || \"Unknown\"}` });\n            } catch { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture failed\" }); }\n        })();\n        return;\n    }\n\n    // Copy-as-* and other operations  forward to content script\n    sendToTabOrActive(tabId, { type: menuId });\n});\n\n// ============================================================================\n// Keyboard commands\n// ============================================================================\n\nchrome.commands.onCommand.addListener(async (command) => {\n    if (command === \"crx-snip-text\") {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) return;\n        try {\n            const results = await chrome.scripting.executeScript({ target: { tabId: tabs[0].id }, func: () => window.getSelection()?.toString() || \"\" });\n            const text = results[0]?.result || \"\";\n            if (text) {\n                const r = await processCrxSnipWithPipeline(text, \"text\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Text processed!\" : `Failed: ${r.error}` });\n            } else {\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Select text first, then Ctrl+Shift+X\" });\n            }\n        } catch { /* ignore */ }\n    } else if (command === \"crx-snip-screen\") {\n        try {\n            const imageData = await captureScreenArea();\n            if (imageData) {\n                const r = await processCrxSnipWithPipeline(imageData, \"image\");\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: r.success ? \"Captured and processed!\" : `Failed: ${r.error}` });\n            } else {\n                chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture cancelled\" });\n            }\n        } catch { chrome.notifications.create({ type: \"basic\", iconUrl: \"icons/icon.png\", title: \"CrossWord CRX-Snip\", message: \"Capture failed\" }); }\n    }\n});\n\n// ============================================================================\n// Screen capture helper (tab capture + desktop capture fallback)\n// ============================================================================\n\nconst captureScreenArea = async (options?: { rect?: { x: number; y: number; width: number; height: number }; scale?: number }): Promise<ArrayBuffer | null> => {\n    try {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) throw new Error(\"No active tab\");\n\n        const opts: chrome.tabs.CaptureVisibleTabOptions & { rect?: any; scale?: number } = { format: \"png\", quality: 100, scale: options?.scale ?? 1 };\n        if (options?.rect) opts.rect = options.rect;\n\n        const screenshot = await chrome.tabs.captureVisibleTab(tabs[0].windowId, opts);\n        const b64 = screenshot.split(\",\")[1];\n        const bin = atob(b64);\n        const bytes = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);\n        return bytes.buffer;\n    } catch {\n        // Fallback: desktop capture via offscreen document\n        try {\n            const streamId = await new Promise<string>((resolve, reject) => {\n                chrome.desktopCapture.chooseDesktopMedia([\"screen\", \"window\"], { frameRate: 1 }, (id) => id ? resolve(id) : reject(new Error(\"Cancelled\")));\n            });\n\n            const offscreenUrl = chrome.runtime.getURL(\"offscreen/capture.html\");\n            const existing = await chrome.runtime.getContexts({ contextTypes: [chrome.runtime.ContextType.OFFSCREEN_DOCUMENT] });\n            if (!existing.length) {\n                await chrome.offscreen.createDocument({ url: offscreenUrl, reasons: [chrome.offscreen.Reason.USER_MEDIA], justification: \"Screen capture\" });\n            }\n            const response = await chrome.runtime.sendMessage({ type: \"capture-desktop\", streamId });\n            return response?.success && response?.imageData ? response.imageData : null;\n        } catch { return null; }\n    }\n};\n\n// ============================================================================\n// AI MESSAGE HANDLERS (gpt:recognize, gpt:solve, gpt:code, gpt:css, gpt:custom, gpt:translate)\n// ============================================================================\n\n/** Helper: process with GPT using a built-in instruction */\nconst processWithBuiltInInstruction = async (\n    instruction: string,\n    input: any,\n    sender: chrome.runtime.MessageSender,\n    mode: string,\n    sendResponse: (r: any) => void,\n) => {\n    const requestId = `${mode}_${Date.now()}`;\n    broadcast(AI_RECOGNITION_CHANNEL, { type: mode, requestId, status: \"processing\" });\n\n    try {\n        const gpt = await getGPTInstance();\n        if (!gpt) { const err = { ok: false, error: \"AI service not available\" }; broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...err }); sendResponse(err); return; }\n\n        gpt.getPending?.()?.push?.({ type: \"message\", role: \"user\", content: [{ type: \"input_text\", text: instruction }, { type: \"input_text\", text: input || \"\" }] });\n        const rawResponse = await gpt.sendRequest(\"high\", \"medium\");\n        const response = { ok: !!rawResponse, data: rawResponse || \"\", error: rawResponse ? undefined : \"Failed\" };\n\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...response });\n        if (response.ok && response.data) await requestClipboardCopy(response.data, true, sender?.tab?.id);\n        sendResponse(response);\n    } catch (e) {\n        const err = { ok: false, error: String(e) };\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode, ...err });\n        showExtensionToast(`${mode} failed: ${e}`, \"error\");\n        sendResponse(err);\n    }\n};\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (!message?.type) return false;\n\n    // Timeline\n    if (message.type === \"MAKE_TIMELINE\") {\n        createTimelineGenerator(message.source || null, message.speechPrompt || null).then(async (gptRes) => {\n            sendResponse(await (requestNewTimeline(gptRes as unknown as GPTResponses) as unknown as Promise<any[]> || []));\n        }).catch((e: Error) => sendResponse({ error: e.message }));\n        return true;\n    }\n\n    // gpt:recognize\n    if (message.type === \"gpt:recognize\") {\n        const requestId = message.requestId || `rec_${Date.now()}`;\n        broadcast(AI_RECOGNITION_CHANNEL, { type: \"recognize\", requestId, status: \"processing\" });\n        recognizeImageData(message.input, async (result) => {\n            const response = { ok: result?.ok, data: result?.raw, error: result?.error };\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, ...response });\n            if (result?.ok && result?.raw && message.autoCopy !== false) {\n                const text = typeof result.raw === \"string\" ? result.raw : result.raw?.latex || result.raw?.text || JSON.stringify(result.raw);\n                await requestClipboardCopy(text, true);\n            }\n            sendResponse(response);\n        })?.catch?.((e) => {\n            const err = { ok: false, error: String(e) };\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, ...err });\n            showExtensionToast(`Recognition failed: ${e}`, \"error\");\n            sendResponse(err);\n        });\n        return true;\n    }\n\n    // gpt:solve / gpt:answer / gpt:solve-answer\n    if (message.type === \"gpt:solve\" || message.type === \"gpt:answer\" || message.type === \"gpt:solve-answer\") {\n        processWithBuiltInInstruction(CRX_SOLVE_AND_ANSWER_INSTRUCTION, message.input, sender, \"solve-answer\", sendResponse);\n        return true;\n    }\n\n    // gpt:code\n    if (message.type === \"gpt:code\") {\n        processWithBuiltInInstruction(CRX_WRITE_CODE_INSTRUCTION, message.input, sender, \"code\", sendResponse);\n        return true;\n    }\n\n    // gpt:css\n    if (message.type === \"gpt:css\") {\n        processWithBuiltInInstruction(CRX_EXTRACT_CSS_INSTRUCTION, message.input, sender, \"css\", sendResponse);\n        return true;\n    }\n\n    // gpt:custom\n    if (message.type === \"gpt:custom\") {\n        (async () => {\n            let instructionText = message.instruction;\n            let instructionLabel = \"Custom\";\n            if (!instructionText && message.instructionId) {\n                const found = (await loadCustomInstructions().catch(() => [])).find((i) => i.id === message.instructionId);\n                if (found) { instructionText = found.instruction; instructionLabel = found.label; }\n            }\n            if (!instructionText) { sendResponse({ ok: false, error: \"No instruction found\" }); return; }\n\n            const requestId = message.requestId || `custom_${Date.now()}`;\n            broadcast(AI_RECOGNITION_CHANNEL, { type: \"custom\", requestId, label: instructionLabel, status: \"processing\" });\n\n            processDataWithInstruction(message.input, { instruction: instructionText, outputFormat: \"auto\", intermediateRecognition: { enabled: false } })\n                .then(async (result) => {\n                    const response = { ok: result?.ok, data: result?.data, error: result?.error };\n                    broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode: \"custom\", label: instructionLabel, ...response });\n                    if (result?.ok && result?.data && message.autoCopy !== false) await requestClipboardCopy(result.data, true, sender?.tab?.id);\n                    sendResponse(response);\n                }).catch((e: any) => {\n                    const err = { ok: false, error: String(e) };\n                    broadcast(AI_RECOGNITION_CHANNEL, { type: \"result\", requestId, mode: \"custom\", label: instructionLabel, ...err });\n                    showExtensionToast(`${instructionLabel} failed: ${e}`, \"error\");\n                    sendResponse(err);\n                });\n        })();\n        return true;\n    }\n\n    // gpt:translate\n    if (message.type === \"gpt:translate\") {\n        (async () => {\n            const inputText = message.input;\n            const targetLang = message.targetLanguage || \"English\";\n            if (!inputText?.trim()) { sendResponse({ ok: false, error: \"No text\" }); return; }\n\n            const instruction = `Translate the following text to ${targetLang}.\\nPreserve formatting (Markdown, KaTeX, code blocks, etc.).\\nOnly translate natural language, keep technical notation unchanged.\\nReturn ONLY the translated text.`;\n            try {\n                const settings = await loadSettings();\n                const ai = (await settings)?.ai;\n                if (!ai?.apiKey) { sendResponse({ ok: false, error: \"No API key configured\" }); return; }\n\n                const baseUrl = ai.baseUrl || \"https://api.proxyapi.ru/openai/v1\";\n                const model = ai.model || \"gpt-5.2\";\n                const res = await fetch(`${baseUrl}/responses`, {\n                    method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${ai.apiKey}` },\n                    body: JSON.stringify({ model, input: inputText, instructions: instruction, reasoning: { effort: \"low\" }, text: { verbosity: \"low\" } }),\n                });\n                if (!res.ok) throw new Error(`Translation API: ${res.status}`);\n                const data = await res.json();\n                sendResponse({ ok: true, data: data?.output?.at?.(-1)?.content?.[0]?.text || inputText });\n            } catch (e) { sendResponse({ ok: false, error: String(e), data: inputText }); }\n        })();\n        return true;\n    }\n\n    // share-target\n    if (message.type === \"share-target\") {\n        const { title, text, url, files } = message.data || {};\n        chrome.storage?.local?.set?.({ \"rs-share-target-data\": { title, text, url, files: files?.map?.((f: File) => f.name) || [], timestamp: Date.now() } }).catch(() => {});\n        broadcast(\"rs-share-target\", { type: \"share-received\", data: { title, text, url, timestamp: Date.now() } });\n        showExtensionToast(\"Content received\", \"info\");\n        sendResponse({ ok: true });\n        return true;\n    }\n\n    return false;\n});\n\n// ============================================================================\n// Markdown auto-detection (webNavigation)\n// ============================================================================\n\nchrome.webNavigation?.onCommitted?.addListener?.((details) => {\n    if (details.frameId !== 0) return;\n    const { tabId, url } = details;\n    if (!isMarkdownUrl(url) || url.startsWith(VIEWER_ORIGIN) || url.startsWith(\"file:\")) return;\n    void openMarkdownInViewer(url, tabId);\n});\n\nchrome.webNavigation?.onCompleted?.addListener?.((details) => {\n    (async () => {\n        if (details.frameId !== 0) return;\n        const { tabId, url } = details;\n        if (!isMarkdownUrl(url) || url.startsWith(VIEWER_ORIGIN) || !url.startsWith(\"file:\")) return;\n        const text = await tryReadMarkdownFromTab(tabId, url);\n        const key = text ? await putMarkdownToSession(text) : null;\n        openViewer(url, tabId, key);\n    })().catch(console.warn);\n});\n\n// ============================================================================\n// CRX-Snip and pipeline message handlers\n// ============================================================================\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n    (async () => {\n        // CRX-Snip processing\n        if (message?.type === \"crx-snip\") {\n            if (!message.content) { sendResponse({ success: false, error: \"missing content\" }); return; }\n            sendResponse(await processCrxSnipWithPipeline(message.content, message.contentType || \"text\"));\n            return;\n        }\n\n        // Screen capture trigger from popup\n        if (message?.type === \"crx-snip-screen-capture\") {\n            try {\n                const imageData = await captureScreenArea(message.rect ? { rect: message.rect, scale: message.scale || 1 } : undefined);\n                if (imageData) { sendResponse(await processCrxSnipWithPipeline(imageData, \"image\")); }\n                else sendResponse({ success: false, error: \"Capture cancelled\" });\n            } catch (e) { sendResponse({ success: false, error: e instanceof Error ? e.message : String(e) }); }\n            return;\n        }\n\n        // Pipeline management\n        if (message?.type === \"crx-pipeline-status\") { sendResponse({ success: true, status: pipeline.getStatus() }); return; }\n        if (message?.type === \"crx-pipeline-pending\") { sendResponse({ success: true, pending: pipeline.getPending(message.destinationType) }); return; }\n        if (message?.type === \"crx-pipeline-clear-completed\") { sendResponse({ success: true, clearedCount: pipeline.clearCompleted() }); return; }\n\n        if (message?.type === \"crx-result-send-to-destination\") {\n            const pr = pipeline.resultQueue.find((r) => r.id === message.resultId);\n            if (!pr || !message.destination) { sendResponse({ success: false, error: \"Not found\" }); return; }\n            pr.destinations.push(message.destination);\n            if (pr.status === \"completed\") pr.status = \"pending\";\n            sendResponse({ success: true, resultId: message.resultId });\n            return;\n        }\n\n        // Markdown loading\n        if (message?.type !== \"md:load\") return;\n        const src = typeof message.src === \"string\" ? message.src : \"\";\n        if (!src) { sendResponse({ ok: false, error: \"missing src\" }); return; }\n        const fetched = await fetchMarkdownText(src);\n        const key = fetched.ok && fetched.text ? await putMarkdownToSession(fetched.text) : null;\n        sendResponse({ ok: fetched.ok, status: fetched.status, src: fetched.src, key });\n    })().catch((e) => sendResponse({ ok: false, error: String(e) }));\n    return true;\n});\n\n// ============================================================================\n// Enable capture handlers from service/api.ts\n// ============================================================================\n\nenableCapture(chrome);\n"],"file":"background.js"}