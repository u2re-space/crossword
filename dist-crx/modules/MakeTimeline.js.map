{"version":3,"file":"MakeTimeline.js","sources":["../../src/com/store/IDBQueue.ts","../../src/com/template/EntityUtils.ts","../../src/com/template/EntityId.ts","../../src/core/storage/OPFSMod.ts","../../src/core/storage/FileSystem.ts","../../src/com/service/misc/Cache.ts","../../src/com/template/Entities-v2.md?raw","../../src/core/time/index.ts","../../src/com/service/service/MakeTimeline.ts"],"sourcesContent":["import { JSOX } from \"jsox\";\n\nexport const DB_NAME = 'req-queue';\nexport const STORE = 'queue';\nexport const DB_VERSION = 3; // увеличьте, если меняете схему/индексы\n\ntype QueueRecord<T = unknown> = {\n  id?: number;\n  payload: T;\n  enqueuedAt: number;\n  locked: boolean;\n  lockedAt: number | null;\n};\n\nfunction idbOpen(): Promise<IDBDatabase> {\n  return new Promise((res, rej) => {\n    const req = indexedDB.open(DB_NAME, DB_VERSION);\n    req.onupgradeneeded = () => {\n      const db = req.result;\n\n      // Для предсказуемости пересоздадим стор (в дев-окружении можно просто дропнуть БД из DevTools)\n      if (db.objectStoreNames.contains(STORE)) db.deleteObjectStore(STORE);\n      const store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });\n\n      // Индекс для выборки \"незалоченных\" по порядку: [locked, id]\n      store.createIndex('byLockedId', ['locked', 'id'], { unique: false });\n      // Индекс по времени лока — ускоряет снятие просроченных локов\n      store.createIndex('byLockedAt', 'lockedAt', { unique: false });\n    };\n    req.onsuccess = () => res(req.result);\n    req.onerror = () => rej(req.error);\n  });\n}\n\n// Вспомогалка\nfunction withTx<T>(\n  db: IDBDatabase,\n  mode: IDBTransactionMode,\n  fn: (store: IDBObjectStore) => Promise<T> | T\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const tx = db.transaction(STORE, mode);\n    const store = tx.objectStore(STORE);\n    let done = false;\n\n    const finish = (err?: any, val?: T) => {\n      if (done) return;\n      done = true;\n      err ? reject(err) : resolve(val as T);\n    };\n\n    Promise.resolve()\n      .then(() => fn(store))\n      .then((result) => {\n        tx.oncomplete = () => finish(undefined, result);\n        tx.onerror = () => finish(tx.error || new Error('Transaction error'));\n        tx.onabort = () => finish(tx.error || new Error('Transaction aborted'));\n      })\n      .catch((e) => {\n        try {\n          tx.abort();\n        } catch { }\n        finish(e);\n      });\n  });\n}\n\n// ---------- API ----------\n\nexport async function pushOne<T = unknown>(payload: T): Promise<number> {\n  const db = await idbOpen();\n  try {\n    return await withTx<number>(db, 'readwrite', async (store) => {\n      const rec: QueueRecord<T> = {\n        payload,\n        enqueuedAt: Date.now(),\n        locked: false,\n        lockedAt: null,\n      };\n      const req = store.add(rec);\n      return await new Promise<number>((res, rej) => {\n        req.onsuccess = () => res(req.result as number);\n        req.onerror = () => rej(req.error);\n      });\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function pushMany<T = unknown>(payloads: T[]): Promise<number[]> {\n  const db = await idbOpen();\n  try {\n    return await withTx<number[]>(db, 'readwrite', async (store) => {\n      const ids: number[] = [];\n      for (const p of payloads) {\n        const rec: QueueRecord<T> = {\n          payload: p,\n          enqueuedAt: Date.now(),\n          locked: false,\n          lockedAt: null,\n        };\n        const req = store.add(rec);\n        // eslint-disable-next-line no-await-in-loop\n        const id = await new Promise<number>((res, rej) => {\n          req.onsuccess = () => res(req.result as number);\n          req.onerror = () => rej(req.error);\n        });\n        ids.push(id);\n      }\n      return ids;\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function size(): Promise<number> {\n  const db = await idbOpen();\n  try {\n    return await withTx<number>(db, 'readonly', async (store) => {\n      const req = store.count();\n      return await new Promise<number>((res, rej) => {\n        req.onsuccess = () => res(req.result);\n        req.onerror = () => rej(req.error);\n      });\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function peek<T = unknown>(limit = 50): Promise<Array<QueueRecord<T>>> {\n  const db = await idbOpen();\n  try {\n    return await withTx<Array<QueueRecord<T>>>(db, 'readonly', async (store) => {\n      const result: Array<QueueRecord<T>> = [];\n      const idx = store.index('byLockedId');\n      const range = IDBKeyRange.bound([false, -Infinity], [false, Infinity]);\n      return await new Promise<Array<QueueRecord<T>>>((res, rej) => {\n        const curReq = idx.openCursor(range, 'next');\n        curReq.onerror = () => rej(curReq.error);\n        curReq.onsuccess = () => {\n          const cursor = curReq.result;\n          if (!cursor || result.length >= limit) return res(result);\n          result.push(cursor.value as QueueRecord<T>);\n          cursor.continue();\n        };\n      });\n    });\n  } finally {\n    db.close();\n  }\n}\n\n// Снять просроченные блокировки (visibility timeout)\nasync function unlockExpired(store: IDBObjectStore, cutoff: number): Promise<void> {\n  const idx = store.index('byLockedAt');\n  // lockedAt < cutoff\n  const range = IDBKeyRange.upperBound(cutoff, true);\n  await new Promise<void>((res, rej) => {\n    const curReq = idx.openCursor(range);\n    curReq.onerror = () => rej(curReq.error);\n    curReq.onsuccess = () => {\n      const cursor = curReq.result;\n      if (!cursor) return res();\n      const rec = cursor.value as QueueRecord;\n      if (rec.locked && typeof rec.lockedAt === 'number' && rec.lockedAt < cutoff) {\n        rec.locked = false;\n        rec.lockedAt = null;\n        const putReq = cursor.update(rec);\n        putReq.onerror = () => rej(putReq.error);\n        putReq.onsuccess = () => cursor.continue();\n      } else {\n        cursor.continue();\n      }\n    };\n  });\n}\n\nexport async function claimBatch<T = unknown>(\n  limit = 50,\n  lockMs = 5 * 60_000 // 5 минут\n): Promise<Array<QueueRecord<T>>> {\n  const now = Date.now();\n  const cutoff = now - lockMs;\n  const db = await idbOpen();\n  try {\n    return await withTx<Array<QueueRecord<T>>>(db, 'readwrite', async (store) => {\n      // 1) освободим протухшие лизы\n      await unlockExpired(store, cutoff);\n\n      // 2) залочим первые N незалоченных по порядку\n      const idx = store.index('byLockedId');\n      const range = IDBKeyRange.bound([false, -Infinity], [false, Infinity]);\n      const claimed: Array<QueueRecord<T>> = [];\n\n      await new Promise<void>((res, rej) => {\n        const curReq = idx.openCursor(range, 'next');\n        curReq.onerror = () => rej(curReq.error);\n        curReq.onsuccess = () => {\n          const cursor = curReq.result;\n          if (!cursor || claimed.length >= limit) return res();\n\n          const rec = cursor.value as QueueRecord<T>;\n          rec.locked = true;\n          rec.lockedAt = now;\n          const putReq = cursor.update(rec);\n          putReq.onerror = () => rej(putReq.error);\n          putReq.onsuccess = () => {\n            claimed.push(rec);\n            cursor.continue();\n          };\n        };\n      });\n\n      return claimed;\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function ack(ids: Array<number>): Promise<void> {\n  if (!ids.length) return;\n  const db = await idbOpen();\n  try {\n    await withTx<void>(db, 'readwrite', async (store) => {\n      for (const id of ids) {\n        const req = store.delete(id);\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise<void>((res, rej) => {\n          req.onsuccess = () => res();\n          req.onerror = () => rej(req.error);\n        });\n      }\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function nack(ids: Array<number>): Promise<void> {\n  if (!ids.length) return;\n  const db = await idbOpen();\n  try {\n    await withTx<void>(db, 'readwrite', async (store) => {\n      for (const id of ids) {\n        const getReq = store.get(id);\n        // eslint-disable-next-line no-await-in-loop\n        const rec = await new Promise<QueueRecord | undefined>((res, rej) => {\n          getReq.onsuccess = () => res(getReq.result as QueueRecord | undefined);\n          getReq.onerror = () => rej(getReq.error);\n        });\n        if (!rec) continue;\n        rec.locked = false;\n        rec.lockedAt = null;\n        const putReq = store.put(rec);\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise<void>((res, rej) => {\n          putReq.onsuccess = () => res();\n          putReq.onerror = () => rej(putReq.error);\n        });\n      }\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function dumpAll<T = unknown>(full = false): Promise<Array<T | QueueRecord<T>>> {\n  const db = await idbOpen();\n  try {\n    return await withTx<Array<T | QueueRecord<T>>>(db, 'readonly', async (store) => {\n      // getAll поддерживается в современных браузерах; если нужна совместимость — замените на курсор\n      const req = store.getAll();\n      return await new Promise((res, rej) => {\n        req.onsuccess = () => {\n          const arr = req.result as Array<QueueRecord<T>>;\n          res(full ? arr : arr.map((r) => r.payload));\n        };\n        req.onerror = () => rej(req.error);\n      });\n    });\n  } finally {\n    db.close();\n  }\n}\n\nexport async function loadFromArray<T = unknown>(payloads: T[]): Promise<number[]> {\n  return pushMany(payloads);\n}\n\n// Утилита: забирает пачками, вызывает обработчик, подтверждает/возвращает\nexport async function drain<T = unknown>(\n  handler: (payloads: T[], records: Array<QueueRecord<T>>) => Promise<void> | void,\n  opts?: { batchSize?: number; lockMs?: number; stopOnEmpty?: boolean }\n): Promise<void> {\n  const batchSize = opts?.batchSize ?? 50;\n  const lockMs = opts?.lockMs ?? 5 * 60_000;\n  const stopOnEmpty = opts?.stopOnEmpty ?? true;\n\n  // Простой цикл; можно запускать периодически из SW/таймера\n  while (true) {\n    const batch = await claimBatch<T>(batchSize, lockMs);\n    if (batch.length === 0) {\n      if (stopOnEmpty) return;\n      await new Promise((r) => setTimeout(r, 1000));\n      continue;\n    }\n\n    const ids = batch.map((r) => r.id!) as number[];\n    try {\n      await handler(batch.map((r) => r.payload), batch);\n      await ack(ids);\n    } catch (e) {\n      // обработчик упал — вернём в очередь\n      await nack(ids);\n      throw e; // либо логируйте и продолжайте\n    }\n  }\n}\n\n// Вернуть все записи и полностью очистить store\nexport async function dumpAndClear<T = unknown>(full = false): Promise<Array<T | QueueRecord<T>>> {\n  const db = await idbOpen();\n  try {\n    return await withTx<Array<T | QueueRecord<T>>>(db, 'readwrite', async (store) => {\n      // читаем всё\n      const all = await new Promise<Array<QueueRecord<T>>>((res, rej) => {\n        const req = store.getAll();\n        req.onsuccess = () => res(req.result as Array<QueueRecord<T>>);\n        req.onerror = () => rej(req.error);\n      });\n\n      // очищаем стор\n      await new Promise<void>((res, rej) => {\n        const req = store.clear();\n        req.onsuccess = () => res();\n        req.onerror = () => rej(req.error);\n      });\n\n      return full ? all : all.map((r) => r.payload);\n    });\n  } finally {\n    db.close();\n  }\n}\n\n// Вернуть и удалить только незалоченные записи (сохраняя залоченные)\nexport async function popAllUnlocked<T = unknown>(full = false): Promise<Array<T | QueueRecord<T>>> {\n  const db = await idbOpen();\n  try {\n    return await withTx<Array<T | QueueRecord<T>>>(db, 'readwrite', async (store) => {\n      const out: Array<QueueRecord<T>> = [];\n      const idx = store.index('byLockedId');\n      const range = IDBKeyRange.bound([false, -Infinity], [false, Infinity]); // locked=false\n\n      await new Promise<void>((res, rej) => {\n        const curReq = idx.openCursor(range, 'next');\n        curReq.onerror = () => rej(curReq.error);\n        curReq.onsuccess = () => {\n          const cursor = curReq.result;\n          if (!cursor) return res();\n          const rec = cursor.value as QueueRecord<T>;\n          out.push(rec);\n\n          const delReq = cursor.delete(); // удаляем эту запись\n          delReq.onerror = () => rej(delReq.error);\n          delReq.onsuccess = () => cursor.continue();\n        };\n      });\n\n      return full ? out : out.map((r) => r.payload);\n    });\n  } finally {\n    db.close();\n  }\n}\n\n// Remove old items from queue\nexport async function prune(maxAgeMs = 7 * 24 * 60 * 60 * 1000): Promise<number> {\n  const now = Date.now();\n  const cutoff = now - maxAgeMs;\n  const db = await idbOpen();\n  try {\n    return await withTx<number>(db, 'readwrite', async (store) => {\n      let count = 0;\n      const req = store.openCursor();\n      await new Promise<void>((res, rej) => {\n        req.onsuccess = () => {\n          const cursor = req.result;\n          if (!cursor) return res();\n          const rec = cursor.value as QueueRecord;\n          if (rec.enqueuedAt < cutoff) {\n            cursor.delete();\n            count++;\n          }\n          cursor.continue();\n        };\n        req.onerror = () => rej(req.error);\n      });\n      return count;\n    });\n  } finally {\n    db.close();\n  }\n}\n\n// Remove duplicate payloads from queue\nexport async function deduplicate(): Promise<number> {\n    const db = await idbOpen();\n    try {\n        return await withTx<number>(db, 'readwrite', async (store) => {\n            const hashes = new Set<string>();\n            let count = 0;\n            const req = store.openCursor();\n             await new Promise<void>((res, rej) => {\n                req.onsuccess = () => {\n                   const cursor = req.result;\n                   if (!cursor) return res();\n                   const rec = cursor.value as QueueRecord;\n                   try {\n                       const hash = JSOX.stringify(rec.payload);\n                       if (hashes.has(hash)) {\n                           cursor.delete();\n                           count++;\n                       } else {\n                           hashes.add(hash);\n                       }\n                   } catch (e) {\n                       // ignore serialization errors\n                   }\n                   cursor.continue();\n                };\n                req.onerror = () => rej(req.error);\n             });\n             return count;\n        });\n    } finally {\n        db.close();\n    }\n}\n","/*\n *\n * Needs for direct uploading JSON files to IndexedDB and Cache.\n * Not always AI may be needed for sorting into database, so we need to detect type of data.\n * Detects by fields, such as 'kind', some 'properties', structure, keywords, etc.\n */\n\nimport { JSOX } from \"jsox\";\n\n//\nexport type SectionKey = \"main\" | \"schedule\" | \"properties\" | \"contacts\" | \"relations\" | \"meta\";\nexport type EntityFieldRule = {\n    name: string;\n    label: string;\n    path: string;\n    section?: SectionKey | string;\n    helper?: string;\n    placeholder?: string;\n    textarea?: boolean;\n    multi?: boolean;\n    numeric?: boolean;\n    json?: boolean;\n    type?: string;\n    options?: string[];\n    datalist?: string[];\n    required?: boolean;\n};\n\n//\nexport type EntitySchema = {\n    kind?: string[];\n    fields: EntityFieldRule[];\n};\n\n\n\nconst optionize = (values: string[] | undefined): string[] => (values ?? []).map((value) => value);\n\nconst locationField = (name: string, path: string, section: SectionKey = \"relations\", label = \"Location\", helper?: string): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    textarea: true,\n    helper: helper ?? \"String or JSON representation of the location\"\n});\n\nconst contactFields = (basePath: string): EntityFieldRule[] => [\n    {\n        name: \"contacts.email\",\n        label: \"Emails\",\n        path: `${basePath}.email`,\n        section: \"contacts\",\n        textarea: true,\n        helper: \"One email per line\",\n        multi: true\n    },\n    {\n        name: \"contacts.phone\",\n        label: \"Phones\",\n        path: `${basePath}.phone`,\n        section: \"contacts\",\n        textarea: true,\n        helper: \"One phone per line\",\n        multi: true\n    },\n    {\n        name: \"contacts.links\",\n        label: \"Links\",\n        path: `${basePath}.links`,\n        section: \"contacts\",\n        textarea: true,\n        helper: \"One link per line\",\n        multi: true\n    }\n];\n\nexport const selectField = (name: string, label: string, path: string, options: string[], section: SectionKey = \"properties\", helper?: string): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    helper,\n    options: optionize(options)\n});\n\n//\nexport const COLOR_OPTIONS = [\n    \"red\",\n    \"green\",\n    \"blue\",\n    \"yellow\",\n    \"orange\",\n    \"purple\",\n    \"brown\",\n    \"gray\",\n    \"black\",\n    \"white\"\n];\n\nexport const TASK_STATUS_OPTIONS = [\n    \"under_consideration\",\n    \"pending\",\n    \"in_progress\",\n    \"completed\",\n    \"failed\",\n    \"delayed\",\n    \"canceled\",\n    \"other\"\n];\n\n//\nexport const AFFECT_OPTIONS = [\"positive\", \"negative\", \"neutral\"];\nexport const GENDER_OPTIONS = [\"male\", \"female\", \"other\"];\n\n\nconst dateStructFields = (\n    name: string,\n    label: string,\n    basePath: string,\n    section: SectionKey = \"schedule\"\n): EntityFieldRule[] => [\n        {\n            name: `${name}.date`,\n            label: `${label} (Date)`,\n            path: `${basePath}.date`,\n            section,\n            placeholder: \"YYYY-MM-DD\"\n        },\n        {\n            name: `${name}.iso_date`,\n            label: `${label} (ISO)`,\n            path: `${basePath}.iso_date`,\n            section,\n            placeholder: \"YYYY-MM-DDTHH:MM\",\n            helper: \"ISO 8601 date-time\"\n        },\n        {\n            name: `${name}.timestamp`,\n            label: `${label} (Timestamp)`,\n            path: `${basePath}.timestamp`,\n            section,\n            numeric: true,\n            type: \"number\",\n            helper: \"Unix milliseconds\"\n        }\n    ];\n\nconst arrayField = (\n    name: string,\n    label: string,\n    path: string,\n    section: SectionKey = \"relations\",\n    helper?: string\n): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    textarea: true,\n    multi: true,\n    helper\n});\n\nconst jsonField = (\n    name: string,\n    label: string,\n    path: string,\n    section: SectionKey = \"properties\",\n    helper?: string\n): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    json: true,\n    textarea: true,\n    helper\n});\n\nconst stringField = (\n    name: string,\n    label: string,\n    path: string,\n    section: SectionKey = \"properties\",\n    placeholder?: string,\n    helper?: string\n): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    placeholder,\n    helper\n});\n\nconst numberField = (\n    name: string,\n    label: string,\n    path: string,\n    section: SectionKey = \"properties\",\n    helper?: string\n): EntityFieldRule => ({\n    name,\n    label,\n    path,\n    section,\n    numeric: true,\n    type: \"number\",\n    helper\n});\n\nconst biographyFields = (basePath: string): EntityFieldRule[] => [\n    {\n        name: \"biography.firstName\",\n        label: \"First name\",\n        path: `${basePath}.firstName`,\n        section: \"main\"\n    },\n    {\n        name: \"biography.lastName\",\n        label: \"Last name\",\n        path: `${basePath}.lastName`,\n        section: \"main\"\n    },\n    {\n        name: \"biography.middleName\",\n        label: \"Middle name\",\n        path: `${basePath}.middleName`,\n        section: \"main\"\n    },\n    {\n        name: \"biography.nickName\",\n        label: \"Nick name\",\n        path: `${basePath}.nickName`,\n        section: \"main\"\n    },\n    {\n        name: \"biography.birthdate\",\n        label: \"Birth date\",\n        path: `${basePath}.birthdate`,\n        section: \"meta\",\n        placeholder: \"YYYY-MM-DD or ISO date\"\n    },\n    selectField(\"biography.gender\", \"Gender\", `${basePath}.gender`, GENDER_OPTIONS, \"meta\")\n];\n\nexport const BASE_ENTITY_FIELD_RULES: EntityFieldRule[] = [\n    {\n        name: \"id\",\n        label: \"Identifier\",\n        path: \"id\",\n        section: \"main\",\n        placeholder: \"unique-id-or-code\",\n        helper: \"Stable unique identifier\"\n    },\n    {\n        name: \"name\",\n        label: \"Name\",\n        path: \"name\",\n        section: \"main\",\n        placeholder: \"machine-name\",\n        helper: \"Lowercase machine-readable name\"\n    },\n    {\n        name: \"title\",\n        label: \"Title\",\n        path: \"title\",\n        section: \"main\",\n        placeholder: \"Human readable name\",\n        helper: \"Shown in cards and lists\"\n    },\n    {\n        name: \"kind\",\n        label: \"Kind\",\n        path: \"kind\",\n        section: \"main\",\n        helper: \"Determines category-specific behaviour\"\n    },\n    {\n        name: \"description\",\n        label: \"Description\",\n        path: \"description\",\n        section: \"main\",\n        textarea: true,\n        helper: \"Markdown supported\"\n    },\n    selectField(\"variant\", \"Variant\", \"variant\", COLOR_OPTIONS, \"meta\", \"Visual accent colour\"),\n    {\n        name: \"icon\",\n        label: \"Icon\",\n        path: \"icon\",\n        section: \"meta\",\n        placeholder: \"phosphor/name\"\n    },\n    {\n        name: \"image\",\n        label: \"Image\",\n        path: \"image\",\n        section: \"meta\",\n        placeholder: \"https://example.com/image.jpg\"\n    },\n    {\n        name: \"tags\",\n        label: \"Tags\",\n        path: \"tags\",\n        section: \"meta\",\n        textarea: true,\n        helper: \"One tag per line\",\n        multi: true\n    }\n];\n\n//\nexport const FIELD_ALIASES: Record<string, string> = {\n    title: \"title\",\n    kind: \"kind\",\n    name: \"name\",\n    id: \"id\",\n    price: \"properties.price\",\n    quantity: \"properties.quantity\",\n    begin_time: \"properties.begin_time\",\n    end_time: \"properties.end_time\",\n    email: \"properties.contacts.email\",\n    phone: \"properties.contacts.phone\",\n    links: \"properties.contacts.links\",\n    \"contacts.email\": \"properties.contacts.email\",\n    \"contacts.phone\": \"properties.contacts.phone\",\n    \"contacts.links\": \"properties.contacts.links\"\n};\n\n//\nexport const LEGACY_PROPERTY_RULES: Record<string, EntityFieldRule> = {\n    price: numberField(\"price\", \"Price\", \"properties.price\", \"properties\", \"Price as number\"),\n    quantity: numberField(\"quantity\", \"Quantity\", \"properties.quantity\"),\n    begin_time: stringField(\"begin_time\", \"Begin\", \"properties.begin_time\", \"schedule\", \"YYYY-MM-DD or ISO string\"),\n    end_time: stringField(\"end_time\", \"End\", \"properties.end_time\", \"schedule\", \"YYYY-MM-DD or ISO string\"),\n    location: locationField(\"location\", \"properties.location\"),\n    services: arrayField(\"services\", \"Services\", \"properties.services\", \"relations\", \"Service IDs, one per line\"),\n    members: arrayField(\"members\", \"Members\", \"properties.members\", \"relations\", \"Member IDs, one per line\"),\n    actions: arrayField(\"actions\", \"Actions\", \"properties.actions\", \"relations\", \"Action IDs, one per line\"),\n    bonuses: arrayField(\"bonuses\", \"Bonuses\", \"properties.bonuses\", \"properties\", \"Bonus IDs, one per line\"),\n    rewards: arrayField(\"rewards\", \"Rewards\", \"properties.rewards\", \"properties\", \"Reward IDs, one per line\"),\n    feedbacks: arrayField(\"feedbacks\", \"Feedbacks\", \"properties.feedbacks\", \"properties\", \"Feedback IDs, one per line\"),\n    tasks: arrayField(\"tasks\", \"Tasks\", \"properties.tasks\", \"relations\", \"Task IDs, one per line\"),\n    persons: arrayField(\"persons\", \"Persons\", \"properties.persons\", \"relations\", \"Person IDs, one per line\"),\n    events: arrayField(\"events\", \"Events\", \"properties.events\", \"relations\", \"Event IDs, one per line\"),\n    image: arrayField(\"image\", \"Images\", \"properties.image\", \"properties\", \"Image URLs, one per line\"),\n    availability: stringField(\"availability\", \"Availability\", \"properties.availability\", \"properties\"),\n    availabilityTime: arrayField(\"availabilityTime\", \"Availability time\", \"properties.availabilityTime\", \"properties\", \"Time ranges, one per line\"),\n    availabilityDays: arrayField(\"availabilityDays\", \"Availability days\", \"properties.availabilityDays\", \"properties\", \"Day names, one per line\"),\n    permissions: stringField(\"permissions\", \"Permissions\", \"properties.permissions\", \"properties\"),\n    purpose: stringField(\"purpose\", \"Purpose\", \"properties.purpose\", \"properties\"),\n    home: locationField(\"home\", \"properties.home\"),\n    jobs: arrayField(\"jobs\", \"Jobs\", \"properties.jobs\", \"relations\", \"Job IDs, one per line\"),\n    coordinates: jsonField(\"coordinates\", \"Coordinates\", \"properties.coordinates\", \"properties\", \"JSON object with latitude and longitude\")\n};\n\n\n\n\nexport const ENTITY_KIND_MAP: Record<string, string[]> = {\n    task: [\"job\", \"action\", \"other\"],\n    event: [\n        \"education\",\n        \"lecture\",\n        \"conference\",\n        \"meeting\",\n        \"seminar\",\n        \"workshop\",\n        \"presentation\",\n        \"celebration\",\n        \"opening\",\n        \"other\"\n    ],\n    action: [\n        \"thinking\",\n        \"imagination\",\n        \"remembering\",\n        \"speaking\",\n        \"learning\",\n        \"listening\",\n        \"reading\",\n        \"writing\",\n        \"moving\",\n        \"traveling\",\n        \"speech\",\n        \"physically\",\n        \"crafting\",\n        \"following\",\n        \"other\"\n    ],\n    service: [\"product\", \"consultation\", \"advice\", \"medical\", \"mentoring\", \"training\", \"item\", \"thing\", \"other\"],\n    item: [\"currency\", \"book\", \"electronics\", \"furniture\", \"medicine\", \"tools\", \"software\", \"consumables\", \"other\"],\n    skill: [\"skill\", \"knowledge\", \"ability\", \"trait\", \"experience\", \"other\"],\n    vendor: [\"vendor\", \"company\", \"organization\", \"institution\", \"other\"],\n    place: [\n        \"placement\",\n        \"place\",\n        \"school\",\n        \"university\",\n        \"service\",\n        \"clinic\",\n        \"pharmacy\",\n        \"hospital\",\n        \"library\",\n        \"market\",\n        \"location\",\n        \"shop\",\n        \"restaurant\",\n        \"cafe\",\n        \"bar\",\n        \"hotel\",\n        \"other\"\n    ],\n    factor: [\"weather\", \"health\", \"family\", \"relationships\", \"job\", \"traffic\", \"business\", \"economy\", \"politics\", \"news\", \"other\"],\n    person: [\"specialist\", \"consultant\", \"coach\", \"mentor\", \"dear\", \"helper\", \"assistant\", \"friend\", \"family\", \"relative\", \"other\"],\n    bonus: []\n};\n\nexport const ENTITY_SCHEMAS: Record<string, EntitySchema> = {\n    task: {\n        kind: ENTITY_KIND_MAP.task,\n        fields: [\n            selectField(\"status\", \"Status\", \"properties.status\", TASK_STATUS_OPTIONS, \"properties\", \"Task state\"),\n            ...dateStructFields(\"begin_time\", \"Begin\", \"properties.begin_time\"),\n            ...dateStructFields(\"end_time\", \"End\", \"properties.end_time\"),\n            locationField(\"location\", \"properties.location\"),\n            ...contactFields(\"properties.contacts\"),\n            arrayField(\"members\", \"Members\", \"properties.members\", \"relations\", \"Entity IDs, one per line\"),\n            arrayField(\"events\", \"Events\", \"properties.events\", \"relations\", \"Event IDs, one per line\")\n        ]\n    },\n    event: {\n        kind: ENTITY_KIND_MAP.event,\n        fields: [\n            ...dateStructFields(\"begin_time\", \"Begin\", \"properties.begin_time\"),\n            ...dateStructFields(\"end_time\", \"End\", \"properties.end_time\"),\n            locationField(\"location\", \"properties.location\"),\n            ...contactFields(\"properties.contacts\")\n        ]\n    },\n    action: {\n        kind: ENTITY_KIND_MAP.action,\n        fields: [\n            stringField(\"affect\", \"Affect\", \"properties.affect\", \"properties\", \"Describe impact or affect\"),\n            arrayField(\"steps\", \"Steps\", \"properties.steps\", \"properties\", \"Action steps, one per line\"),\n            arrayField(\"related\", \"Related\", \"properties.related\", \"relations\", \"Related entity IDs, one per line\")\n        ]\n    },\n    service: {\n        kind: ENTITY_KIND_MAP.service,\n        fields: [\n            locationField(\"location\", \"properties.location\"),\n            arrayField(\"persons\", \"Persons\", \"properties.persons\", \"relations\", \"Person IDs, one per line\"),\n            arrayField(\"specialization\", \"Specializations\", \"properties.specialization\", \"properties\", \"Specializations, one per line\"),\n            ...contactFields(\"properties.contacts\"),\n            jsonField(\"prices\", \"Prices\", \"properties.prices\", \"properties\", \"JSON map: service => price\")\n        ]\n    },\n    item: {\n        kind: ENTITY_KIND_MAP.item,\n        fields: [\n            numberField(\"price\", \"Price\", \"properties.price\", \"properties\", \"Price as number\"),\n            numberField(\"quantity\", \"Quantity\", \"properties.quantity\"),\n            arrayField(\"availability\", \"Availability\", \"properties.availability\", \"properties\", \"Availability notes, one per line\"),\n            jsonField(\"attributes\", \"Attributes\", \"properties.attributes\", \"properties\", \"Additional item attributes in JSON\")\n        ]\n    },\n    skill: {\n        kind: ENTITY_KIND_MAP.skill,\n        fields: [\n            stringField(\"level\", \"Level\", \"properties.level\", \"properties\", \"e.g. beginner, intermediate\"),\n            arrayField(\"category\", \"Categories\", \"properties.category\", \"properties\", \"Categories, one per line\"),\n            arrayField(\"related\", \"Related\", \"properties.related\", \"relations\", \"Related skill or entity IDs\")\n        ]\n    },\n    vendor: {\n        kind: ENTITY_KIND_MAP.vendor,\n        fields: [\n            locationField(\"location\", \"properties.location\"),\n            ...contactFields(\"properties.contacts\"),\n            arrayField(\"services\", \"Services\", \"properties.services\", \"relations\", \"Service IDs, one per line\")\n        ]\n    },\n    place: {\n        kind: ENTITY_KIND_MAP.place,\n        fields: [\n            locationField(\"location\", \"properties.location\", \"properties\"),\n            arrayField(\"services\", \"Services\", \"properties.services\", \"relations\", \"Related service IDs\"),\n            ...contactFields(\"properties.contacts\")\n        ]\n    },\n    factor: {\n        kind: ENTITY_KIND_MAP.factor,\n        fields: [\n            selectField(\"affect\", \"Affect\", \"properties.affect\", AFFECT_OPTIONS, \"properties\", \"Overall impact\"),\n            arrayField(\"actions\", \"Actions\", \"properties.actions\", \"relations\", \"Action IDs, one per line\"),\n            locationField(\"location\", \"properties.location\", \"properties\")\n        ]\n    },\n    person: {\n        kind: ENTITY_KIND_MAP.person,\n        fields: [\n            locationField(\"home\", \"properties.home\", \"properties\", \"Home location\"),\n            arrayField(\"jobs\", \"Jobs\", \"properties.jobs\", \"properties\", \"Job locations, one per line\"),\n            ...biographyFields(\"properties.biography\"),\n            arrayField(\"tasks\", \"Tasks\", \"properties.tasks\", \"relations\", \"Task IDs, one per line\"),\n            ...contactFields(\"properties.contacts\"),\n            arrayField(\"services\", \"Services\", \"properties.services\", \"relations\", \"Service IDs, one per line\"),\n            jsonField(\"prices\", \"Prices\", \"properties.prices\", \"properties\", \"JSON map: service => price\")\n        ]\n    },\n    bonus: {\n        kind: ENTITY_KIND_MAP.bonus,\n        fields: [\n            stringField(\"code\", \"Code\", \"properties.code\", \"properties\", \"Readable bonus code\"),\n            arrayField(\"usableFor\", \"Usable for\", \"properties.usableFor\", \"relations\", \"Entity IDs, one per line\"),\n            arrayField(\"usableIn\", \"Usable in\", \"properties.usableIn\", \"relations\", \"Location IDs, one per line\"),\n            numberField(\"availability.count\", \"Availability count\", \"properties.availability.count\", \"properties\"),\n            arrayField(\"availability.time\", \"Availability time\", \"properties.availability.time\", \"properties\", \"Time ranges, one per line\"),\n            arrayField(\"availability.days\", \"Availability days\", \"properties.availability.days\", \"properties\", \"Day names, one per line\"),\n            jsonField(\"requirements\", \"Requirements\", \"properties.requirements\", \"properties\", \"JSON array of requirements\"),\n            jsonField(\"additionalProperties\", \"Additional properties\", \"properties.additionalProperties\", \"properties\", \"JSON map of extra properties\"),\n            jsonField(\"profits\", \"Profits\", \"properties.profits\", \"properties\", \"JSON map: target => profit value\")\n        ]\n    }\n};\n\n\n//\nexport const detectEntityTypeByJSON = (unknownJSON: any) => {\n    let mostSuitableType = \"unknown\";\n\n    //\n    unknownJSON = typeof unknownJSON == \"string\" ? JSOX.parse(unknownJSON) as any : unknownJSON;\n    if (typeof unknownJSON != \"object\") { return mostSuitableType; }\n\n    // direct type detection\n    if (unknownJSON.type && unknownJSON.properties && unknownJSON.kind) return unknownJSON.type;\n\n    // attempt 1 - detect possible types by 'KIND_MAP' enums\n    let types: Set<any> = new Set();\n    for (const type in ENTITY_KIND_MAP) {\n        if (ENTITY_KIND_MAP[type].includes(unknownJSON.kind)) {\n            types.add(type);\n        }\n    }\n\n    // filter all entities, which has no required kinds\n    const allEntities = [...Object.entries(ENTITY_SCHEMAS)]?.filter?.(([key, _]: any) => types.has(key))\n\n    // attempt 2.1 - detect by specific fields and properties (events, time based)\n    let timeTypes: Set<any> = new Set();\n    if (unknownJSON?.properties?.begin_time != null || unknownJSON?.properties?.end_time != null) {\n        allEntities?.forEach(([type, scheme]: any) => {\n            if (scheme.properties?.begin_time != null && scheme.properties?.end_time != null) {\n                timeTypes.add(type);\n            }\n        });\n    }\n\n    // attempt 2.2 - detect by specific fields and properties (location based)\n    let locationTypes: Set<any> = new Set();\n    if (unknownJSON?.properties?.location != null) {\n        allEntities?.forEach(([type, scheme]: any) => {\n            if (scheme.properties?.location != null) {\n                locationTypes.add(type);\n            }\n        });\n    }\n\n    // attempt 2.3 - detect by specific fields and properties (prices factors)\n    let pricesTypes: Set<any> = new Set();\n    if (unknownJSON?.properties?.prices != null) {\n        allEntities?.forEach(([type, scheme]: any) => {\n            if (scheme.properties?.prices != null) {\n                pricesTypes.add(type);\n            }\n        });\n    }\n\n    // attempt 2.4 - detect by specific fields and properties (contacts factors)\n    let contactsTypes: Set<any> = new Set();\n    if (unknownJSON?.properties?.contacts != null) {\n        allEntities?.forEach(([type, scheme]: any) => {\n            if (scheme.properties?.contacts != null) {\n                contactsTypes.add(type);\n            }\n        });\n    }\n\n    //\n    const countMap = new Map<any, number>();\n    [...contactsTypes, ...locationTypes, ...pricesTypes, ...timeTypes].forEach((type) => {\n        countMap.set(type, (countMap.get(type) || 0) + 1);\n    });\n\n    //\n    mostSuitableType = countMap.size == 0 ? [...types]?.[0] : [...countMap.entries()].reduce((a, b) => a[1] > b[1] ? a : b)[0];\n    return (mostSuitableType || \"unknown\");\n}\n\n// for multiple entities (array)\nexport const detectEntityTypesByJSONs = (unknownJSONs: any[] | any) => {\n    unknownJSONs = typeof unknownJSONs == \"string\" ? JSOX.parse(unknownJSONs) as any : unknownJSONs;\n    return (Array.isArray(unknownJSONs) ? unknownJSONs?.map?.((unknownJSON) => detectEntityTypeByJSON(unknownJSON)) || [] : [detectEntityTypeByJSON(unknownJSONs)]);\n}\n","// NOTE: backend-friendly minimal time parsing helpers.\n// We intentionally keep this file free of heavy/browser-only dependencies (e.g. `fest/*`).\ntype TimeType = { timestamp?: number; iso_date?: string; date?: string };\n\nexport function parseDateCorrectly(str?: Date | TimeType | string | number | null | undefined): Date | null {\n    if (str == null) return null;\n    if (str instanceof Date) return Number.isFinite(str.getTime()) ? str : null;\n    if (typeof str === \"number\") {\n        const d = new Date(str);\n        return Number.isFinite(d.getTime()) ? d : null;\n    }\n    if (typeof str === \"object\") {\n        const anyObj: any = str as any;\n        if (anyObj.timestamp != null) return parseDateCorrectly(anyObj.timestamp);\n        if (anyObj.iso_date != null) return parseDateCorrectly(anyObj.iso_date);\n        if (anyObj.date != null) return parseDateCorrectly(anyObj.date);\n    }\n    if (typeof str === \"string\") {\n        const trimmed = str.trim();\n        if (!trimmed) return null;\n        // Try numeric timestamp in string form\n        if (/^\\d+$/.test(trimmed)) {\n            const num = Number(trimmed);\n            const d = new Date(num);\n            if (Number.isFinite(d.getTime())) return d;\n        }\n        const d = new Date(trimmed);\n        return Number.isFinite(d.getTime()) ? d : null;\n    }\n    return null;\n}\n\nexport function parseAndGetCorrectTime(str?: Date | TimeType | string | number | null | undefined): number {\n    return parseDateCorrectly(str)?.getTime?.() ?? Date.now();\n}\n\nexport type EntityLike = {\n    id?: string | null;\n    type?: string | null;\n    kind?: string | null;\n    name?: string | null;\n    title?: string | null;\n    properties?: Record<string, any> | null;\n};\n\nexport type GenerateEntityIdOptions = {\n    existingIds?: Set<string> | string[];\n    fallback?: string;\n    maxLength?: number;\n    prefer?: Array<string | null | undefined>;\n    mutateExistingIds?: boolean;\n};\n\nexport type FixEntityIdOptions = GenerateEntityIdOptions & {\n    mutate?: boolean;\n    rebuild?: boolean; // <- добавляем\n};\n\nconst DEFAULT_MAX_LENGTH = 96;\nconst CODE_SUFFIX_PREFIX = \"CODE\";\n\nconst BASIC_ALLOWED_PATTERN = /^[a-z0-9\\-_&#\\+]+$/;\nconst CODE_ALLOWED_PATTERN = /^[a-z0-9\\-_&#\\+]+(?:_CODE[0-9A-Z]*)?$/;\n\nconst removeDiacritics = (value: string): string => value.normalize(\"NFKD\").replace(/[\\u0300-\\u036f]/g, \"\");\n\nconst toStringOrNull = (value: unknown): string | null => {\n    if (value == null) return null;\n    if (typeof value === \"string\" && value.trim().length > 0) return value;\n    if (typeof value === \"number\" || typeof value === \"bigint\") return String(value);\n    return null;\n};\n\nconst slugifySegment = (segment: string | null | undefined): string => {\n    if (!segment) return \"\";\n    const withoutDiacritics = removeDiacritics(segment);\n    const lowercase = withoutDiacritics.toLowerCase();\n    const collapsedWhitespace = lowercase.replace(/[\\s]+/g, \"-\");\n    const sanitized = collapsedWhitespace.replace(/[^a-z0-9\\-_&#\\+]+/g, \"-\");\n    const condensedHyphen = sanitized.replace(/-{2,}/g, \"-\").replace(/_{2,}/g, \"_\");\n    const trimmed = condensedHyphen.replace(/^-+|-+$/g, \"\").replace(/^_+|_+$/g, \"\");\n    return trimmed;\n};\n\nconst sanitizeCodeSuffix = (rawCode: unknown): string => {\n    const asString = toStringOrNull(rawCode);\n    if (!asString) return \"\";\n    const normalized = removeDiacritics(asString).replace(/\\s+/g, \"\");\n    const sanitized = normalized.replace(/[^A-Za-z0-9\\-_&#\\+]+/g, \"\");\n    if (!sanitized) return \"\";\n    const upper = sanitized.toUpperCase();\n    return upper.startsWith(CODE_SUFFIX_PREFIX) ? upper : `${CODE_SUFFIX_PREFIX}${upper}`;\n};\n\nconst isCodeSuffixAllowed = (entity: EntityLike): boolean => {\n    if (!entity) return false;\n    if (entity.type === \"bonus\") return true;\n    const code = entity?.properties && (entity.properties as any)?.code;\n    return typeof code === \"string\" && code.trim().length > 0;\n};\n\nconst extractLocationName = (value: unknown): string | null => {\n    if (typeof value === \"string\") return value;\n    if (value && typeof value === \"object\") {\n        const address = (value as any).address;\n        if (typeof address === \"string\") return address;\n        if (address && typeof address === \"object\") {\n            const parts: Array<string> = [];\n            [\"street\", \"house\", \"flat\", \"room\"].forEach((key) => {\n                const part = toStringOrNull((address as any)[key]);\n                if (part) parts.push(part);\n            });\n            if (parts.length > 0) return parts.join(\"-\");\n        }\n        const coordinate = (value as any).coordinate;\n        if (coordinate && typeof coordinate === \"object\") {\n            const lat = toStringOrNull((coordinate as any).latitude);\n            const lon = toStringOrNull((coordinate as any).longitude);\n            if (lat && lon) return `${lat}-${lon}`;\n        }\n        const name = toStringOrNull((value as any).name);\n        if (name) return name;\n        const title = toStringOrNull((value as any).title);\n        if (title) return title;\n    }\n    return null;\n};\n\nconst pushSegment = (collector: Set<string>, value: unknown) => {\n    if (value == null) return;\n    if (Array.isArray(value)) {\n        value.forEach((item) => pushSegment(collector, item));\n        return;\n    }\n    const stringValue = typeof value === \"object\" ? extractLocationName(value) : toStringOrNull(value);\n    const slug = slugifySegment(stringValue);\n    if (slug) collector.add(slug);\n};\n\nconst prepareExistingSet = (existing?: Set<string> | string[]): Set<string> | undefined => {\n    if (!existing) return undefined;\n    if (existing instanceof Set) return existing;\n    return new Set(existing);\n};\n\nconst composeId = (base: string, codeSuffix?: string, numericSuffix?: number): string => {\n    const suffixPart = numericSuffix != null ? `-${numericSuffix}` : \"\";\n    if (codeSuffix) {\n        if (base) return `${base}_${codeSuffix}${suffixPart}`;\n        return `${codeSuffix}${suffixPart}`;\n    }\n    return `${base}${suffixPart}`;\n};\n\nconst clampBaseLength = (base: string, maxLength: number, reservedLength: number): string => {\n    if (!base) return base;\n    if (base.length + reservedLength <= maxLength) return base;\n    const available = Math.max(0, maxLength - reservedLength);\n    if (available === 0) return \"\";\n    const truncated = base.slice(0, available);\n    return truncated.replace(/[-_]+$/g, \"\");\n};\n\nconst ensureUniqueId = (\n    base: string,\n    codeSuffix: string,\n    existing: Set<string> | undefined,\n    maxLength: number\n): string => {\n    const initial = composeId(base, codeSuffix);\n    if (!existing || !existing.has(initial)) return initial;\n\n    let attempt = 2;\n    while (attempt < 10_000) {\n        const candidate = composeId(base, codeSuffix, attempt);\n        if (!existing.has(candidate)) return candidate;\n        attempt += 1;\n    }\n    return initial;\n};\n\nconst sanitizeExistingIdValue = (value: string, allowCodeSuffix: boolean, maxLength: number): string => {\n    if (!value) return \"\";\n    let working = removeDiacritics(value);\n    working = working.replace(/[\\s]+/g, \"-\");\n\n    let codeSuffix = \"\";\n    if (allowCodeSuffix) {\n        const match = working.match(/(_CODE[0-9A-Za-z]*)$/i);\n        if (match) {\n            codeSuffix = sanitizeCodeSuffix(match[0].slice(1));\n            working = working.slice(0, match.index ?? 0);\n        }\n    }\n\n    const base = slugifySegment(working);\n    const sanitizedBase = base ? base : \"\";\n\n    if (!sanitizedBase && !codeSuffix) return \"\";\n\n    const reservedLength = codeSuffix ? codeSuffix.length + (sanitizedBase ? 1 : 0) : 0;\n    const clampedBase = clampBaseLength(sanitizedBase, maxLength, reservedLength);\n\n    const candidate = composeId(clampedBase, codeSuffix || undefined);\n    return candidate;\n};\n\nexport const isValidEntityId = (value: string | null | undefined, allowCodeSuffix = false): boolean => {\n    if (!value) return false;\n    return allowCodeSuffix ? CODE_ALLOWED_PATTERN.test(value) : BASIC_ALLOWED_PATTERN.test(value);\n};\n\nconst collectBaseSegments = (entity: EntityLike, options?: GenerateEntityIdOptions): string[] => {\n    const segments = new Set<string>();\n    if (!entity) return [];\n\n    options?.prefer?.forEach((candidate) => pushSegment(segments, candidate));\n\n    if (entity.type === \"person\") {\n        const biography = (entity.properties as any)?.biography ?? {};\n        const nameParts = [\n            toStringOrNull(biography?.firstName),\n            toStringOrNull(biography?.middleName),\n            toStringOrNull(biography?.lastName)\n        ].filter(Boolean);\n        if (nameParts.length > 0) {\n            pushSegment(segments, nameParts.join(\"-\"));\n        }\n        pushSegment(segments, biography?.nickName);\n        const jobs = (entity.properties as any)?.jobs;\n        if (jobs) pushSegment(segments, Array.isArray(jobs) ? jobs[0] : jobs);\n    }\n\n    if (entity.type === \"bonus\") {\n        const usableFor = (entity.properties as any)?.usableFor;\n        const usableIn = (entity.properties as any)?.usableIn;\n        if (usableFor) pushSegment(segments, Array.isArray(usableFor) ? usableFor[0] : usableFor);\n        if (usableIn) pushSegment(segments, Array.isArray(usableIn) ? usableIn[0] : usableIn);\n    }\n\n    pushSegment(segments, entity.name);\n    pushSegment(segments, entity.title);\n    pushSegment(segments, entity.kind);\n    pushSegment(segments, entity.type);\n\n    if (segments.size === 0) {\n        pushSegment(segments, options?.fallback ?? entity.type ?? \"entity\");\n    }\n\n    pushSegment(segments, entity.properties?.begin_time ? (parseDateCorrectly?.(entity.properties?.begin_time)?.toLocaleString?.(\"en-GB\", {\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hour12: false\n    })?.trim()?.toLowerCase?.()\n        ?.replace?.(/\\s+/g, '_')\n        ?.replace?.(/[\\,\\-\\_\\:\\.\\\\\\/]/g, '-')\n        ?.replace?.(/[\\\"\\'\\(\\)\\[\\]]/g, '')\n        ?.replace?.(/\\-\\-/g, '_')) : null);\n\n    //\n    return Array.from(segments).filter((segment) => segment.length > 0);\n};\n\nexport const generateEntityId = (entity: EntityLike, options: GenerateEntityIdOptions = {}): string => {\n    const maxLength = options.maxLength ?? DEFAULT_MAX_LENGTH;\n    const allowCodeSuffix = isCodeSuffixAllowed(entity);\n    const codeSuffix = allowCodeSuffix ? sanitizeCodeSuffix((entity.properties as any)?.code) : \"\";\n\n    const segments = collectBaseSegments(entity, options);\n    const base = segments.join(\"_\");\n\n    const reservedLength = codeSuffix ? codeSuffix.length + (base ? 1 : 0) : 0;\n    const clampedBase = clampBaseLength(base, maxLength, reservedLength);\n\n    const existingSet = prepareExistingSet(options.existingIds);\n    const candidate = ensureUniqueId(clampedBase, codeSuffix, existingSet, maxLength);\n\n    if (options.mutateExistingIds && existingSet) {\n        existingSet.add(candidate);\n    }\n\n    return candidate;\n};\n\nexport const fixEntityId = <T extends EntityLike>(\n    entity: T,\n    options: FixEntityIdOptions = { mutate: true, rebuild: true }\n): string => {\n    const maxLength = options.maxLength ?? DEFAULT_MAX_LENGTH;\n    const allowCodeSuffix = isCodeSuffixAllowed(entity);\n    const existingSet = prepareExistingSet(options.existingIds);\n\n    const forceRebuild = options.rebuild === true;\n\n    let currentId = toStringOrNull(entity?.id) ?? \"\";\n    let sanitizedId = sanitizeExistingIdValue(currentId, allowCodeSuffix, maxLength);\n\n    // Если просили пересобрать или текущий id пуст/невалидный — генерим заново\n    if (forceRebuild || !sanitizedId || !isValidEntityId(sanitizedId, allowCodeSuffix)) {\n        sanitizedId = generateEntityId(entity, { ...options, existingIds: existingSet });\n    }\n\n    // Гарантируем уникальность\n    if (existingSet && existingSet.has(sanitizedId)) {\n        const baseWithoutNumeric = sanitizedId.replace(/(?:-[0-9]+)?$/, \"\");\n        const baseWithoutCode = allowCodeSuffix ? baseWithoutNumeric.replace(/_CODE[0-9A-Z]*$/i, \"\") : baseWithoutNumeric;\n        sanitizedId = ensureUniqueId(\n            baseWithoutCode,\n            allowCodeSuffix ? sanitizeCodeSuffix((entity.properties as any)?.code) : \"\",\n            existingSet,\n            maxLength\n        );\n    }\n\n    if (options.mutateExistingIds && existingSet) existingSet.add(sanitizedId);\n    if (options.mutate !== false && entity) (entity as any).id = sanitizedId;\n\n    return sanitizedId;\n};","// Рекурсивное преобразование JSON-файлов в OPFS по пользовательской функции.\n// Требует Chromium-браузер с поддержкой OPFS: navigator.storage.getDirectory()\n\n/**\n * @typedef {Object} OpfsModifyOptions\n * @property {string} dirPath Относительный путь от корня OPFS (например, \"data/configs\")\n * @property {(data:any, ctx:{path:string,name:string,fullPath:string}) => any|Promise<any>} transform\n *           Функция-трансформация. Должна вернуть новый объект (или исходный, если без изменений).\n *           Можно вернуть undefined, чтобы пропустить запись.\n * @property {(name:string, fullPath:string) => boolean} [filter]\n *           Доп. фильтр по имени/пути (true — обрабатывать).\n * @property {number} [indent=2] Кол-во пробелов для JSOX.stringify\n * @property {boolean} [dryRun=false] Если true — только показывает, что было бы изменено, без записи.\n * @property {boolean} [prettyStable=true] Если true — сортирует ключи (стабильный вывод).\n */\n\nimport { JSOX } from \"jsox\";\n\n\n//\ninterface OpfsModifyOptions {\n    dirPath: string;\n    transform: (data: any, ctx: { path: string, name: string, fullPath: string }) => any | Promise<any>;\n    filter?: (name: string, fullPath: string) => boolean;\n    indent?: number;\n    dryRun?: boolean;\n    prettyStable?: boolean;\n}\n\n//\nexport async function opfsModifyJson(options: OpfsModifyOptions) {\n    const {\n        dirPath,\n        transform,\n        filter,\n        indent = 2,\n        dryRun = false,\n        prettyStable = true,\n    } = options;\n    assertOpfs();\n\n    const root = await navigator.storage.getDirectory()?.catch?.(console.warn.bind(console)); // Нормализуем путь один раз\n    const normDirPath = normalizePath(dirPath);\n    const dir = await getDirByPath(root, normDirPath);\n\n    let processed = 0;\n    let changed = 0;\n    let errors = 0;\n\n    for await (const { handle, name, fullPath } of walk(dir, normDirPath)) {\n        if (handle.kind !== 'file' || !name.toLowerCase().endsWith('.json')) continue;\n        if (filter && !filter(name, fullPath)) continue;\n\n        try {\n            const file = await handle.getFile();\n            const originalText = await file.text();\n\n            let data;\n            try {\n                data = originalText.trim() === '' ? null : JSOX.parse(originalText) as any;\n            } catch (_) {\n                try {\n                    data = originalText.trim() === '' ? null : JSON.parse(originalText) as any;\n                } catch (e) {\n                    console.warn(`JSON parse error: ${fullPath}`, e);\n                    errors++;\n                    continue;\n                }\n            }\n\n            const result = await transform(data, { path: normDirPath, name, fullPath });\n\n            if (typeof result === 'undefined') {\n                processed++;\n                continue;\n            }\n\n            const newText = serializeJSON(result as any, { indent, prettyStable });\n\n            if (normalizeEol(newText) === normalizeEol(originalText)) {\n                processed++;\n                continue;\n            }\n\n            if (dryRun) {\n                console.log(`[dry-run] Would update: ${fullPath}`);\n            } else {\n                const writable = await handle.createWritable();\n                await writable.truncate(0);\n                await writable.write(newText);\n                await writable.close();\n                console.log(`Updated: ${fullPath}`);\n            }\n            processed++;\n            changed++;\n        } catch (e) {\n            console.error(`Failed on ${fullPath}:`, e);\n            errors++;\n        }\n    }\n\n    return { processed, changed, errors };\n}\n\nfunction normalizePath(p?: string): string {\n    if (!p || p === '/' || p === '.') return '';\n    return p.split('/').filter(Boolean).join('/');\n}\n\n// ===== Helpers =====\n\nfunction assertOpfs() {\n    if (!('storage' in navigator) || typeof navigator.storage.getDirectory !== 'function') {\n        throw new Error('OPFS is not available in this browser/context. Need navigator.storage.getDirectory().');\n    }\n}\n\n//\nasync function getDirByPath(rootDirHandle, path) {\n    if (!path || path === '/' || path === '.') return rootDirHandle;\n    const parts = path.split('/').map(s => s.trim()).filter(Boolean);\n    let dir = rootDirHandle;\n    for (const part of parts) {\n        dir = await dir?.getDirectoryHandle?.(part, { create: false });\n    }\n    return dir;\n}\n\n// Асинхронный генератор для рекурсивного обхода\nasync function* walk(dirHandle, basePath = '') {\n    for await (const [name, handle] of dirHandle.entries()) {\n        const fullPath = basePath ? `${basePath}/${name}` : name;\n        if (handle.kind === 'directory') {\n            yield* walk(handle, fullPath);\n        } else {\n            yield { handle, name, fullPath };\n        }\n    }\n}\n\nfunction serializeJSON(obj, { indent = 2, prettyStable = true } = {}) {\n    const replacer = prettyStable ? stableReplacer : undefined;\n    return JSON.stringify(obj as any, replacer, indent) + '\\n';\n}\n\n// Стабильная сортировка ключей для детерминированного вывода\nfunction stableReplacer(key, value) {\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n        const out = {};\n        for (const k of Object.keys(value).sort()) {\n            out[k] = value[k];\n        }\n        return out;\n    }\n    return value;\n}\n\nfunction normalizeEol(s) {\n    return s.replace(/\\r\\n/g, '\\n');\n}\n","import { BASE64_PREFIX, convertImageToJPEG, DEFAULT_ENTITY_TYPE, MAX_BASE64_SIZE } from \"@rs-core/workers/ImageProcess\";\nimport { dumpAndClear } from \"@rs-com/store/IDBQueue\";\nimport { getDirectoryHandle, getFileHandle, decodeBase64ToBytes, stringToFile, parseDataUrl } from \"fest/lure\";\nimport { detectEntityTypeByJSON } from \"@rs-com/template/EntityUtils\";\nimport { fixEntityId } from \"@rs-com/template/EntityId\";\nimport { opfsModifyJson } from \"./OPFSMod\";\nimport { writeFileSmart } from \"./WriteFileSmart-v2\";\nimport { TIMELINE_DIR } from \"@rs-com/service/service/MakeTimeline\";\nimport { JSOX } from \"jsox\";\nimport { showSuccess } from \"@rs-frontend/items/Toast\";\nimport { showError } from \"@rs-frontend/items/Toast\";\n\n//\n/*\n// Always writes by full sanitized path. Accepts a directory or a full path.\nexport const writeFileSmart = async (\n    root: any | null,\n    dirOrPath: string,\n    file: File | Blob,\n    options: WriteSmartOptions = {}\n) => {\n    const { forceExt, ensureJson, toLower = true, sanitize = true } = options;\n\n    // Determine desired base name and directory\n    let raw = String(dirOrPath || \"\").trim();\n    const isDirHint = raw.endsWith('/');\n    const hasFileToken = !isDirHint && splitPath(raw).length > 0 && raw.includes('.');\n\n    let dirPath = isDirHint ? raw : (hasFileToken ? raw.split('/').slice(0, -1).join('/') : raw);\n    let desiredName = hasFileToken ? raw.split('/').pop() || '' : (file as any)?.name || '';\n\n    // Fallbacks\n    dirPath = dirPath || '/';\n    desiredName = desiredName || (Date.now() + '');\n\n    // Extract name/ext\n    const lastDot = desiredName.lastIndexOf('.');\n    let base = lastDot > 0 ? desiredName.slice(0, lastDot) : desiredName;\n    let ext = (forceExt || (ensureJson ? 'json' : (lastDot > 0 ? desiredName.slice(lastDot + 1) : inferExtFromMime((file as any)?.type || '')))) || '';\n\n    if (sanitize) {\n        dirPath = sanitizePathSegments(dirPath);\n        base = toSlug(base, toLower);\n    }\n\n    const finalName = ext ? `${base}.${ext}` : base;\n    const fullPath = ensureDir(dirPath) + finalName;\n\n    // Ensure File object with correct name\n    let toWrite: File;\n    if (file instanceof File) {\n        // If name matches and type present, keep; else recreate with corrected name\n        if (file.name === finalName) {\n            toWrite = file;\n        } else {\n            const type = (file as any).type || (ext ? `application/${ext}` : 'application/octet-stream');\n            const buf = await file.arrayBuffer();\n            toWrite = new File([buf], finalName, { type });\n        }\n    } else {\n        const type = (file as any).type || (ext ? `application/${ext}` : 'application/octet-stream');\n        const blob = file as Blob;\n        toWrite = new File([await blob.arrayBuffer()], finalName, { type });\n    }\n\n    //\n    const promised = writeFile(root, fullPath, toWrite);\n    if (typeof document !== \"undefined\")\n        document?.dispatchEvent?.(new CustomEvent(\"rs-fs-changed\", { detail: await promised?.catch?.(console.warn.bind(console)), bubbles: true, composed: true, cancelable: true, }));\n    return promised;\n};*/\n\n//\nexport const writeFilesToDir = async (dir: string, files: File[] | FileList) => {\n    const items = Array.from(files as any as File[]);\n    for (const file of items) {\n        dir = dir?.trim?.();\n        dir = dir?.endsWith?.('/') ? dir : (dir + '/');\n        await writeFileSmart(null, dir, file);\n    }\n    return items.length;\n}\n\n//\nexport const getMarkDownFromFile = async (handle: any) => {\n    const markdown = await handle?.getFile?.();\n    return await markdown?.text?.() || \"\";\n}\n\n//\nexport const getJSONFromFile = async (handle: any) => {\n    if (Array.isArray(handle)) handle = handle?.[0];\n    if (!handle) return null;\n    const json = await handle?.getFile?.();\n    return parseJsonSafely(await json?.text?.() || \"{}\");\n}\n\n//\nexport const hasCriteriaInText = async (text: string, criteria: string[]) => {\n    return criteria?.some?.(async (criterion) => text?.includes?.(criterion));\n}\n\n//\nexport const readJSONs = async (dir: any | null) => {\n    const dirHandle = typeof dir === \"string\" ? await getDirectoryHandle(null, dir) : dir;\n    const factors = await Array.fromAsync(dirHandle?.entries?.() ?? []);\n    return Promise.all(factors?.map?.((factor) => getJSONFromFile(factor)));\n};\n\n//\nexport const readJSONsFiltered = async (dir: any | null, filterFiles?: string[] | null) => {\n    const dirHandle = typeof dir === \"string\" ? await getDirectoryHandle(null, dir) : dir;\n    const factors = await Array.fromAsync(dirHandle?.entries?.() ?? []);\n    return Promise.all(factors?.map?.((factor) => getJSONFromFile(factor)));\n};\n\n//\nexport const readMarkDownsFiltered = async (dir: any | null, filterFiles?: string[] | null) => {\n    const dirHandle = typeof dir === \"string\" ? await getDirectoryHandle(null, dir) : dir;\n    const preferences = await Array.fromAsync(dirHandle?.entries?.() ?? []);\n    return Promise.all(preferences?.map?.(async (preferences) => (await getMarkDownFromFile(preferences)))\n        ?.filter?.(async (fileData) => (!filterFiles || await hasCriteriaInText(await fileData, filterFiles))));\n}\n\n//\nexport const readMarkDowns = async (dir: any | null) => {\n    const dirHandle = typeof dir === \"string\" ? await getDirectoryHandle(null, dir) : dir;\n    const preferences = await Array.fromAsync(dirHandle?.entries?.() ?? []);\n    return Promise.all(preferences?.map?.((preference) => getMarkDownFromFile(preference?.[1])));\n}\n\n//\nexport const readOneMarkDown = async (path: string) => {\n    const markdown = await getFileHandle(null, path);\n    if (!markdown) return \"\";\n    if (markdown?.type?.startsWith?.(\"image/\")) return \"\";\n    return await markdown?.text?.();\n}\n\n//\nexport const suitableDirsByEntityTypes = (entityTypes: string[]) => {\n    return entityTypes?.map?.((entityType) => {\n        return (entityType == \"timeline\" || entityType == \"task\") ? \"/timeline/\" : `/data/${entityType}/`;\n    });\n}\n\n//\nexport const writeJSON = async (data: any | any[], dir: any | null = null) => {\n    if (!data) return;\n    const writeOne = async (obj: any, index = 0) => {\n        if (!obj) return;\n        obj = parseJsonSafely(obj);\n        if (!obj) return;\n\n        // if entity type is not registered, trying to detect it\n        const entityType = obj?.type ?? detectEntityTypeByJSON(obj) ?? \"unknown\";\n\n        // if directory is not provided, using default directory\n        if (!dir) dir = suitableDirsByEntityTypes([entityType])?.[0]; dir = dir?.trim?.();\n        let fileName = (fixEntityId(obj) || obj?.name || `${Date.now()}`)?.toString?.()?.toLowerCase?.()?.replace?.(/\\s+/g, '-')?.replace?.(/[^a-z0-9_\\-+#&]/g, '-');\n        fileName = fileName?.trim?.(); fileName = fileName?.endsWith?.(\".json\") ? fileName : (fileName + \".json\");\n        return writeFileSmart(null, `${dir}${fileName}`, new File([JSOX.stringify(obj as any) as string], fileName, { type: 'application/json' }))?.catch?.(console.warn.bind(console));\n    };\n\n    //\n    let results: any = await (Array.isArray(data) ? Promise.all(data.map((item, index) => writeOne(item, index))) : writeOne(data, 0))?.catch?.(console.warn.bind(console));\n    if (typeof document !== \"undefined\")\n        document?.dispatchEvent?.(new CustomEvent(\"rs-fs-changed\", { detail: results, bubbles: true, composed: true, cancelable: true, }));\n    return results;\n}\n\n//\nexport const writeMarkDown = async (data: any, path: any | null = null) => {\n    if (!data) return; path = path?.trim?.();\n    let filename = (`${Date.now()}`?.toString?.()?.toLowerCase?.()?.replace?.(/\\s+/g, '-')?.replace?.(/[^a-z0-9_\\-+#&]/g, '-')?.trim?.() || `${Date.now()}`) + \".md\";\n\n    //\n    if (!path) { path = \"/docs/preferences/\"; } else { filename = path?.split?.('/')?.pop?.() || filename; }\n    filename = filename?.endsWith?.(\".md\") ? filename : (filename + \".md\");\n\n    //\n    let results: any = await writeFileSmart(null, path, data instanceof File ? data : new File([data], filename, { type: 'text/markdown' }))?.catch?.(console.warn.bind(console));\n    if (typeof document !== \"undefined\")\n        document?.dispatchEvent?.(new CustomEvent(\"rs-fs-changed\", { detail: results, bubbles: true, composed: true, cancelable: true, }));\n    return results;\n}\n\n//\nexport interface shareTargetFormData {\n    text?: string;\n    url?: string;\n    file?: File | Blob;\n}\n\n//\nexport const handleDataByType = async (item: File | string | Blob, handler: (payload: shareTargetFormData) => Promise<void>) => {\n    if (typeof item === 'string') {\n        if (item?.startsWith?.(\"data:image/\") && item?.includes?.(\";base64,\")) {\n            const parts = parseDataUrl(item);\n            const mimeType = parts?.mimeType || \"image/png\";\n            const file = await stringToFile(item, \"clipboard-image\", { mimeType, uriComponent: true });\n            return handler({ url: item, file } as any);\n        } else\n            if (URL.canParse(item?.trim?.() || \"\", typeof (typeof window != \"undefined\" ? window : globalThis)?.location == \"undefined\" ? undefined : ((typeof window != \"undefined\" ? window : globalThis)?.location?.origin || \"\"))) { return handler({ url: item } as any); }\n    } else\n        if (item instanceof File || item instanceof Blob) {\n            return handler({ file: item } as any);\n        }\n}\n\n//\nexport const handleDataTransferFiles = async (files: (File | Blob)[] | FileList, handler: (payload: shareTargetFormData) => Promise<void>) => {\n    // @ts-ignore\n    for (const file of files) {\n        handleDataByType(file, handler);\n    }\n}\n\n//\nexport const handleDataTransferItemList = async (items: DataTransferItemList, handler: (payload: shareTargetFormData) => Promise<void>) => {\n    // @ts-ignore\n    for (const item of items) {\n        handleDataByType(item, handler);\n    }\n}\n\n//\nexport const handleClipboardItems = async (items: ClipboardItem[], handler: (payload: shareTargetFormData) => Promise<void>) => {\n    for (const item of items) {\n        for (const type of item?.types ?? []) {\n            if (type.startsWith('text/')) {\n                const text = await (await item?.getType?.(type))?.text?.();\n                return handleDataByType(text, handler);\n            }\n            if (type.startsWith('image/')) {\n                const blob = await item?.getType?.(type);\n                return handleDataByType(blob, handler);\n            }\n        }\n    }\n}\n\n//\nexport const handleDataTransferInputEvent = (dataTransfer: DataTransfer | null, handler: (payload: shareTargetFormData) => Promise<void>) => {\n    const items = dataTransfer?.items;\n    const files = dataTransfer?.files ?? [];\n\n    if (items) {\n        handleDataTransferItemList(items, handler);\n    }\n\n    if (files && (files?.length > 0)) {\n        handleDataTransferFiles(files, handler);\n    }\n}\n\n//\nconst parseJsonSafely = (text: string | null | undefined | any) => {\n    if (!text) return null;\n    if (typeof text != \"string\") { return text; };\n    try {\n        return JSOX.parse(text) as any; } catch (_) { try { return JSON.parse(text) as any; } catch (_) { console.warn(\"Failed to parse JSON\", text); return text; } }\n}\n\n// one of handler\nexport const postCommitAnalyze = async (payload: shareTargetFormData, API_ENDPOINT = '/commit-analyze') => {\n    const fd = new FormData();\n    if (payload.text) fd.append('text', payload.text);\n    if (payload.url) fd.append('url', payload.url);\n    if (payload.file) fd.append('files', payload.file as any, (payload.file as any)?.name || 'pasted');\n\n    //\n    const resp = await fetch(API_ENDPOINT, { method: 'POST', priority: 'auto', keepalive: true, body: fd })?.catch?.(console.warn.bind(console)); if (!resp) return [];\n    const json = parseJsonSafely(await resp?.text?.()?.catch?.(console.warn.bind(console)) || \"{}\"); if (!json) return [];\n    return json?.results?.map?.((res) => res?.data)?.filter?.((data) => (!!data?.trim?.()));\n};\n\n//\nexport const postCommitRecognize = (targetDir: string = \"/docs/preferences/\") => {\n    return async (payload: shareTargetFormData, API_ENDPOINT = '/commit-recognize') => {\n        const fd = new FormData();\n        if (payload.text) fd.append('text', payload.text);\n        if (payload.url) fd.append('url', payload.url);\n        if (payload.file) fd.append('files', payload.file as any, (payload.file as any)?.name || 'pasted');\n        fd.append('targetDir', targetDir);\n\n        //\n        const resp = await fetch(API_ENDPOINT, { method: 'POST', priority: 'auto', keepalive: true, body: fd })?.catch?.(console.warn.bind(console));\n        if (!resp) return [];\n        const json = parseJsonSafely(await resp?.text?.()?.catch?.(console.warn.bind(console)) || \"{}\");\n        if (!json) return [];\n        return json?.results?.filter?.((data) => (!!data?.data?.trim?.()))?.map?.((res) => res?.data);\n    }\n}\n\n//\nexport type IntakeOptions = {\n    entityType?: string;\n    beforeSend?: (payload: shareTargetFormData) => Promise<shareTargetFormData> | shareTargetFormData;\n};\n\n//\nexport const normalizePayload = async (payload: shareTargetFormData): Promise<shareTargetFormData> => {\n    if (payload.file instanceof File || payload.file instanceof Blob) {\n        if (payload.file instanceof File && payload.file.size > MAX_BASE64_SIZE && payload.file.type.startsWith(\"image/\")) {\n            return { ...payload, file: await convertImageToJPEG(payload.file) };\n        }\n        return payload;\n    }\n\n    const text = payload.text || payload.url;\n    if (typeof text === \"string\") {\n        const match = text.match(BASE64_PREFIX);\n        if (match && match.groups) {\n            const { mime, data } = match.groups;\n            const byteLen = Math.ceil((data.length * 3) / 4);\n            if (byteLen > MAX_BASE64_SIZE) {\n                const bytes = decodeBase64ToBytes(data, { alphabet: \"base64\", lastChunkHandling: \"loose\" });\n                const blob = new Blob([bytes], { type: mime });\n                const converted = await convertImageToJPEG(blob);\n                return { file: converted };\n            }\n        }\n    }\n\n    return payload;\n};\n\n//\nconst writeTextDependsByPossibleType = async (payload: string | null | undefined, entityType: string) => {\n    if (!payload) return;\n    if (URL.canParse(payload?.trim?.() || \"\", typeof (typeof window != \"undefined\" ? window : globalThis)?.location == \"undefined\" ? undefined : ((typeof window != \"undefined\" ? window : globalThis)?.location?.origin || \"\"))) payload = (await fetch(payload).then(res => res.text())?.catch?.(console.warn.bind(console))) || \"\";\n    if (!payload) return;\n\n    //\n    let json = {} as any;\n    json = parseJsonSafely(payload || \"{}\");\n    if (!json) return;\n\n    //\n    try {\n        if (!entityType) entityType = detectEntityTypeByJSON(json);\n        return writeJSON(json, (entityType == 'task' || entityType == 'timeline') ? '/timeline/' : `data/${entityType}/`);\n    } catch (e) {\n        return writeMarkDown(payload, `docs/${entityType}/`);\n    }\n}\n\n//\nexport const sendToEntityPipeline = async (payload: shareTargetFormData, options: IntakeOptions = {}) => {\n    const entityType = options.entityType || DEFAULT_ENTITY_TYPE;\n    const normalized = await normalizePayload(payload);\n    const next = options.beforeSend ? await options.beforeSend(normalized) : normalized;\n    if (!next.file && (next.text || next.url)) return writeTextDependsByPossibleType(next.text || next.url, entityType);\n    return handleDataTransferFiles(next.file ? [next.file] : [], postCommitAnalyze);\n};\n\n//\nexport const loadTimelineSources = async (dir: string = \"/docs/preferences\") => {\n    try {\n        const root = await getDirectoryHandle(null, dir)?.catch(() => null);\n        if (!root) return [] as string[];\n        const entries = await Array.fromAsync(root.entries?.() ?? []);\n        return entries\n            .map((entry: any) => entry?.[0])\n            .filter((name: string) => typeof name === \"string\" && name.trim().length)\n            .map((name: string) => name.replace(/\\.md$/i, \"\"));\n    } catch (e) {\n        console.warn(e);\n        return [];\n    }\n};\n\n//\nexport const extractRecognizedData = (unknownData: any) => {\n    // potentially JSON string\n    try { unknownData = typeof unknownData == \"string\" ? JSON.parse(unknownData?.trim?.() || \"[]\") : unknownData; } catch (e) {}\n    if (unknownData?.recognized_data) { return extractRecognizedData(unknownData?.recognized_data); };\n\n    //\n    if (typeof unknownData == \"string\" && unknownData?.trim?.()) {\n        return unknownData?.trim?.();\n    } else\n    if (Array.isArray(unknownData) && unknownData?.length) {\n        return unknownData?.map?.((item: any) => extractRecognizedData(item))?.filter?.((item: any) => (item && typeof item === \"string\"))?.join?.(\"\\n\") || \"\";\n    }\n    return \"\";\n}\n\n//\nexport const controlChannel = new BroadcastChannel('rs-sw');\ncontrolChannel.addEventListener('message', (event: MessageEvent) => {\n    const payload = event?.data as any;\n    if (!payload || (payload?.type !== 'commit-result' && payload?.type !== 'commit-to-clipboard')) return;\n    if (payload?.type === 'commit-result') {\n        flushQueueIntoOPFS?.()?.then?.(() => {\n            showSuccess(\"Data has been saved to the filesystem.\");\n        })?.catch?.((e) => {\n            console.warn(\"Failed to save data to filesystem.\", e, payload);\n            showError(\"Failed to save data to filesystem.\");\n        });\n    } else\n        if (payload?.type === 'commit-to-clipboard') {\n            const data = payload?.results\n                ?.map?.((result: any) => extractRecognizedData(result?.data?.recognized_data || result?.data))\n                ?.filter?.((result: any) => (result && typeof result === \"string\"))?.join?.(\"\\n\") || \"\";\n            if (data?.trim?.()) {\n                navigator?.clipboard?.writeText?.(data)?.then?.(() => {\n                    showSuccess(\"Data has been copied to clipboard.\");\n                })?.catch?.((e) => {\n                    console.warn(\"Failed to copy data to clipboard.\", e, data);\n                    showError(\"Failed to copy data to clipboard. Data is not copied.\");\n                });\n            } else\n                { showError(\"Failed to copy data to clipboard. Data is empty.\"); }\n        }\n});\n\n// Try recover from previous session\nif (typeof navigator !== \"undefined\" && 'storage' in navigator && typeof navigator.storage.getDirectory === 'function') {\n    if (typeof requestIdleCallback === 'function') {\n        requestIdleCallback?.(() => {\n            flushQueueIntoOPFS();\n        });\n    } else {\n        setTimeout(() => {\n            flushQueueIntoOPFS();\n        }, 1000);\n    }\n}\n\n//\nexport async function flushQueueIntoOPFS() {\n    const results = await dumpAndClear();\n    return Promise.all(results.map((result) => {\n        const { data, name, dataType, directory } = result as any;\n        if (dataType === \"json\") {\n            let jsonData = parseJsonSafely(data);\n            if (!jsonData) return;\n            return writeJSON(jsonData, directory?.trim?.());\n        } else {\n            return writeMarkDown(data, directory?.trim?.() + name?.trim?.());\n        }\n    }));\n}\n\n//\ntry {\n    opfsModifyJson({\n    dirPath: \"/data/\",\n    transform: (data) => {\n        if (data && typeof data === \"object\") { fixEntityId(data, { mutate: true }); };\n        return data;\n    }\n    })?.catch?.(console.warn.bind(console));\n} catch (e) {\n    console.warn(e);\n}\n\n//\ntry {\n    opfsModifyJson({\n        dirPath: \"/timeline/\",\n        transform: (data) => {\n            if (data && typeof data === \"object\") { fixEntityId(data, { mutate: true }); };\n            return data;\n        }\n    })?.catch?.(console.warn.bind(console));\n} catch (e) {\n    console.warn(e);\n}\n\n\n\n//\nexport const writeTimelineTask = async (task: any) => {\n    const name = task?.id || task?.name || task?.desc?.name || `${Date.now()}`;\n\n    //\n    let fileName = name || \"timeline.json\"\n    fileName = fileName?.endsWith?.(\".json\") ? fileName : (fileName + \".json\");\n\n    //\n    const filePath = `${TIMELINE_DIR}${fileName}`;\n    const file = new File([JSOX.stringify(task as any) as string], fileName, { type: 'application/json' });\n    return writeFileSmart(null, filePath, file)?.catch?.(console.error.bind(console));\n}\n\n//\nexport const writeTimelineTasks = async (tasks: any[]) => {\n    return Promise.all(tasks?.map?.(async (task) => writeTimelineTask(task)) || []);\n}\n\n//\nexport const loadAllTimelines = async (DIR: string = TIMELINE_DIR) => {\n    const dirHandle = await getDirectoryHandle(null, DIR)?.catch?.(console.warn.bind(console));\n    const timelines = await Array.fromAsync(dirHandle?.entries?.() ?? []);\n    return (await Promise.all(timelines?.map?.(async ([name, fileHandle]: any) => {\n        if (name?.endsWith?.(\".crswap\")) return;\n        if (!name?.trim?.()?.endsWith?.(\".json\")) return;\n\n        //\n        const file = await fileHandle.getFile();\n        let item = null\n        item = parseJsonSafely(await file?.text?.() || \"{}\");\n        if (!item) return;\n        (item as any).__name = name;\n        (item as any).__path = `${DIR}${name}`;\n        return item;\n    })))?.filter?.((e) => e);\n}\n","import { observe, iterated, safe } from \"fest/object\";\nimport { Promised } from \"fest/core\";\nimport { JSOX } from \"jsox\";\n\n//\nconst STORE = \"cache\";\nconst idbOpen = async () => {\n    return new Promise<IDBDatabase>((res, rej) => {\n        const req = indexedDB.open(STORE, 1);\n        req.onupgradeneeded = () => req.result.createObjectStore(STORE, { keyPath: 'key' });\n        req.onsuccess = () => res(req.result);\n        req.onerror = () => rej(req.error);\n    });\n}\n\n//\nconst idbGet = async (key: string): Promise<any> => {\n    const db = await idbOpen();\n    return new Promise((res, rej) => {\n        const tx = db.transaction(STORE, 'readonly');\n        const req = tx.objectStore(STORE).get(key);\n        req.onsuccess = () => { res(req.result?.value); db.close(); }\n        req.onerror = () => { rej(req.error); db.close(); };\n    });\n}\n\n//\nconst idbPut = async (key: string, value: any): Promise<void> => {\n    const db = await idbOpen();\n    return new Promise((res, rej) => {\n        const tx = db.transaction(STORE, 'readwrite');\n        tx.objectStore(STORE).put({ key, value });\n        tx.oncomplete = () => { res(void 0); db.close(); };\n        tx.onerror = () => { rej(tx.error); db.close(); };\n    });\n}\n\n//\nexport const realtimeStates = observe({\n    time: new Date(),\n    timestamp: Date.now(),\n    coords: {},\n    otherProps: new Map([]),\n\n    // for payments, id is card id, value is card balance (if available), or additional info\n    cards: new Map([])\n});\n\n//\nconst editableArray = (category: any, items: any[]) => {\n    const wrapped = observe(items);\n    let timeout: any;\n    iterated(wrapped, (item, index) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            idbPut(category?.id, JSOX.stringify(safe(wrapped) as any))?.catch?.(console.warn.bind(console));\n        }, 100);\n    });\n    return wrapped;\n}\n\n// associated with IndexedDB for service workers\nconst observeCategory = (category: any) => {\n    Object.defineProperty(category, \"items\", {\n        get: () => { // get will get new array from indexedDB, for prevent data corruption\n            return Promised((async () => editableArray(category, JSOX.parse(await idbGet(category?.id) ?? \"[]\") as any))());\n        },\n        set: (value: any) => {\n            idbPut(category?.id, JSOX.stringify(safe(value) as any))?.catch?.(console.warn.bind(console));\n        }\n    });\n    return category;\n}\n\n//\nconst $wrapCategory = (category: any): any => {\n    return observe(observeCategory(category));\n}\n\n//\nexport const tasksCategories = observe([\n    $wrapCategory({\n        label: \"Tasks\",\n        id: \"task\"\n    })\n]);\n\n// `items` is cached file maps... is directly associated with IndexedDB for service workers\n// also, may be used as arrays with simpler data for sending to AI\nexport const dataCategories = observe([\n    $wrapCategory({\n        label: \"Items\",\n        id: \"item\"\n    }),\n    $wrapCategory({\n        label: \"Bonuses\",\n        id: \"bonus\"\n    }),\n    $wrapCategory({\n        label: \"Services\",\n        id: \"service\"\n    }),\n    $wrapCategory({\n        label: \"Locations\",\n        id: \"location\"\n    }),\n    $wrapCategory({\n        label: \"Events\",\n        id: \"events\"\n    }),\n    $wrapCategory({\n        label: \"Factors\",\n        id: \"factor\"\n    }),\n    $wrapCategory({\n        label: \"Entertainments\",\n        id: \"entertainment\"\n    }),\n    $wrapCategory({\n        label: \"Markets\",\n        id: \"market\"\n    }),\n    $wrapCategory({\n        label: \"Places\",\n        id: \"place\"\n    }),\n    $wrapCategory({\n        label: \"Vendors\",\n        id: \"vendor\"\n    }),\n    $wrapCategory({\n        label: \"Persons\",\n        id: \"person\"\n    }),\n    $wrapCategory({\n        label: \"Skills\",\n        id: \"skill\"\n    }),\n    /*$wrapCategory({\n        label: \"Entertainments\",\n        id: \"entertainment\"\n    }),*/\n    $wrapCategory({\n        label: \"Vehicles\",\n        id: \"vehicle\"\n    }),\n    $wrapCategory({\n        label: \"Rewards\",\n        id: \"reward\"\n    }),\n    $wrapCategory({\n        label: \"Fines\",\n        id: \"fine\"\n    }),\n    $wrapCategory({\n        label: \"Actions\",\n        id: \"action\"\n    }),\n    $wrapCategory({\n        label: \"Lotteries\",\n        id: \"lottery\"\n    })\n]);\n\n//\nconst broadcastChannel = new BroadcastChannel('geolocation');\nbroadcastChannel.addEventListener('message', (e) => {\n    if (e.data.coords) {\n        (realtimeStates as any).coords = (typeof e.data.coords == \"string\" ? JSOX.parse(e.data.coords) as any : e.data.coords) || {};\n        (realtimeStates as any).timestamp = Date.now();\n        (realtimeStates as any).time = new Date();\n    }\n});\n\n//\nsetInterval(() => {\n    (realtimeStates as any).time = new Date();\n}, 1000);\n","export default \"# Entities Spec V2\\n\\nFor understanding and for AI generation.\\n\\n## Output Format\\n\\n`{ \\\"entities\\\": ENTITY[], \\\"keywords\\\"?: STRING[], \\\"short_description\\\"?: MARKDOWN }`\\n\\n---\\n\\n## Entity Structure\\n\\n```\\nENTITY={\\n    \\\"type\\\": ENUM:TYPE,\\n    \\\"id\\\": UNIQUE[ID],\\n    \\\"kind\\\": ENUM:KIND[OF:TYPE],\\n    \\\"name\\\"?: STRING,\\n    \\\"title\\\"?: STRING,\\n    \\\"icon\\\"?: PHOSPHOR_ICON_ID,\\n    \\\"properties\\\": PROPERTIES[OF:TYPE]|{},\\n    \\\"description\\\": MARKDOWN,\\n    \\\"image\\\": URL,\\n    \\\"variant\\\": ENUM:COLOR\\n}\\n```\\n\\n---\\n\\n## Data Types\\n\\n- `MARKDOWN=STRING|STRING[]`\\n- `URL=STRING|{\\\"url\\\": STRING, \\\"type\\\": ENUM:URL_TYPE}`\\n- `DATE={\\\"timestamp\\\"?: NUMBER, \\\"iso_date\\\"?: STRING}`\\n- `CONTACT={\\\"email\\\"?: STRING[], \\\"phone\\\"?: STRING[], \\\"links\\\"?: STRING[]}`\\n- `LOCATION=STRING|{ \\\"coordinate\\\"?: COORDINATE, \\\"address\\\"?: ADDRESS }`\\n- `COORDINATE={ \\\"latitude\\\": NUMBER, \\\"longitude\\\": NUMBER }`\\n- `ADDRESS={ \\\"street\\\"?: STRING, \\\"house\\\"?: STRING, \\\"flat\\\"?: STRING, \\\"floor\\\"?: NUMBER, \\\"room\\\"?: NUMBER, \\\"square\\\"?: NUMBER, \\\"price\\\"?: NUMBER }`\\n- `ID=KEY[STRING|NUMBER]`\\n- `BIOGRAPHY={ \\\"firstName\\\"?: STRING, \\\"lastName\\\"?: STRING, \\\"middleName\\\"?: STRING, \\\"nickName\\\"?: STRING, \\\"birthdate\\\"?: DATE, \\\"gender\\\"?: ENUM:GENDER }`\\n\\n---\\n\\n## Enums\\n\\n- `TYPE=\\\"task\\\"|\\\"event\\\"|\\\"action\\\"|\\\"service\\\"|\\\"item\\\"|\\\"skill\\\"|\\\"vendor\\\"|\\\"place\\\"|\\\"factor\\\"|\\\"person\\\"|\\\"bonus\\\"`\\n- `COLOR=\\\"red\\\"|\\\"green\\\"|\\\"blue\\\"|\\\"yellow\\\"|\\\"orange\\\"|\\\"purple\\\"|\\\"brown\\\"|\\\"gray\\\"|\\\"black\\\"|\\\"white\\\"`\\n- `TASK_STATUS=\\\"under_consideration\\\"|\\\"pending\\\"|\\\"in_progress\\\"|\\\"completed\\\"|\\\"failed\\\"|\\\"delayed\\\"|\\\"canceled\\\"|\\\"other\\\"`\\n- `AFFECT=\\\"positive\\\"|\\\"negative\\\"|\\\"neutral\\\"`\\n- `GENDER=\\\"male\\\"|\\\"female\\\"|\\\"other\\\"`\\n- `URL_TYPE=\\\"website\\\"|\\\"email\\\"|\\\"phone\\\"|\\\"social\\\"|\\\"other\\\"`\\n\\n### Kinds\\n\\n```\\nKIND=MAPPED_BY[TYPE][\\n    [\\\"task\\\", ENUM=\\\"job\\\"|\\\"action\\\"|\\\"other\\\"],\\n    [\\\"event\\\", ENUM=\\\"education\\\"|\\\"lecture\\\"|\\\"conference\\\"|\\\"meeting\\\"|\\\"seminar\\\"|\\\"workshop\\\"|\\\"presentation\\\"|\\\"celebration\\\"|\\\"opening\\\"|\\\"other\\\"],\\n    [\\\"action\\\", ENUM=\\\"thinking\\\"|\\\"imagination\\\"|\\\"remembering\\\"|\\\"speaking\\\"|\\\"learning\\\"|\\\"listening\\\"|\\\"reading\\\"|\\\"writing\\\"|\\\"moving\\\"|\\\"traveling\\\"|\\\"speech\\\"|\\\"physically\\\"|\\\"crafting\\\"|\\\"following\\\"|\\\"other\\\"],\\n    [\\\"service\\\", ENUM=\\\"product\\\"|\\\"consultation\\\"|\\\"advice\\\"|\\\"medical\\\"|\\\"mentoring\\\"|\\\"training\\\"|\\\"item\\\"|\\\"thing\\\"|\\\"other\\\"],\\n    [\\\"item\\\", ENUM=\\\"currency\\\"|\\\"book\\\"|\\\"electronics\\\"|\\\"furniture\\\"|\\\"medicine\\\"|\\\"tools\\\"|\\\"software\\\"|\\\"consumables\\\"|\\\"other\\\"],\\n    [\\\"skill\\\", ENUM=\\\"skill\\\"|\\\"knowledge\\\"|\\\"ability\\\"|\\\"trait\\\"|\\\"experience\\\"|\\\"other\\\"],\\n    [\\\"vendor\\\", ENUM=\\\"vendor\\\"|\\\"company\\\"|\\\"organization\\\"|\\\"institution\\\"|\\\"other\\\"],\\n    [\\\"place\\\", ENUM=\\\"placement\\\"|\\\"place\\\"|\\\"school\\\"|\\\"university\\\"|\\\"service\\\"|\\\"clinic\\\"|\\\"pharmacy\\\"|\\\"hospital\\\"|\\\"library\\\"|\\\"market\\\"|\\\"location\\\"|\\\"shop\\\"|\\\"restaurant\\\"|\\\"cafe\\\"|\\\"bar\\\"|\\\"hotel\\\"|\\\"other\\\"],\\n    [\\\"factor\\\", ENUM=\\\"weather\\\"|\\\"health\\\"|\\\"family\\\"|\\\"relationships\\\"|\\\"job\\\"|\\\"traffic\\\"|\\\"business\\\"|\\\"economy\\\"|\\\"politics\\\"|\\\"news\\\"|\\\"other\\\"],\\n    [\\\"person\\\", ENUM=\\\"specialist\\\"|\\\"consultant\\\"|\\\"coach\\\"|\\\"mentor\\\"|\\\"dear\\\"|\\\"helper\\\"|\\\"assistant\\\"|\\\"friend\\\"|\\\"family\\\"|\\\"relative\\\"|\\\"other\\\"]\\n]\\n```\\n\\n---\\n\\n## Data Maps\\n\\n```\\nPROPERTIES=MAPPED_BY[TYPE][\\n    [\\\"task\\\", TASK_STRUCTURE],\\n    [\\\"event\\\", EVENT_STRUCTURE],\\n    [\\\"action\\\", ACTION_STRUCTURE],\\n    [\\\"service\\\", SERVICE_STRUCTURE],\\n    [\\\"item\\\", ITEM_STRUCTURE],\\n    [\\\"skill\\\", SKILL_STRUCTURE],\\n    [\\\"vendor\\\", VENDOR_STRUCTURE],\\n    [\\\"place\\\", PLACE_STRUCTURE],\\n    [\\\"factor\\\", FACTOR_STRUCTURE],\\n    [\\\"person\\\", PERSON_STRUCTURE]\\n]\\n```\\n\\n---\\n\\n## Properties Structures\\n\\n### Task\\n\\nImportant: Task can't be recognized directly from data source, but can be created by preference or user/prompt desire.\\n\\n```\\nTASK_STRUCTURE={\\n    \\\"status\\\": ENUM:TASK_STATUS,\\n    \\\"begin_time\\\": DATE,\\n    \\\"end_time\\\": DATE,\\n    \\\"location\\\"?: LOCATION,\\n    \\\"contacts\\\"?: CONTACT,\\n    \\\"members\\\"?: ID[],\\n    \\\"events\\\"?: ID[],\\n}\\n```\\n\\n### Event\\n\\n```\\nEVENT_STRUCTURE={\\n    \\\"begin_time\\\": DATE,\\n    \\\"end_time\\\": DATE,\\n    \\\"location\\\": LOCATION,\\n    \\\"contacts\\\": CONTACT\\n}\\n```\\n\\n### Person\\n\\n```\\nPERSON_STRUCTURE={\\n    \\\"home\\\": LOCATION,\\n    \\\"jobs\\\": LOCATION[],\\n    \\\"biography\\\": BIOGRAPHY,\\n    \\\"tasks\\\": ID[],\\n    \\\"contacts\\\": CONTACT,\\n    \\\"services\\\": ID[],\\n    \\\"prices\\\": MAP<STRING,NUMBER>\\n}\\n```\\n\\n### Service\\n\\n```\\nSERVICE_STRUCTURE={\\n    \\\"location\\\": LOCATION,\\n    \\\"persons\\\": ID[],\\n    \\\"specialization\\\": STRING[],\\n    \\\"contacts\\\": CONTACT,\\n    \\\"prices\\\": MAP<STRING,NUMBER>\\n}\\n```\\n\\n### Factor\\n\\n```\\nFACTOR_STRUCTURE={\\n    \\\"affect\\\": ENUM:AFFECT,\\n    \\\"actions\\\": ID[],\\n    \\\"location\\\": LOCATION,\\n}\\n```\\n\\n### Bonus\\n\\n```\\nBONUS_STRUCTURE={\\n    \\\"code\\\"?: STRING,\\n    \\\"usableFor\\\"?: ID[],\\n    \\\"usableIn\\\"?: ID[],\\n    \\\"availability\\\"?: {\\n        \\\"count: NUMBER,\\n        \\\"time\\\": STRING[],\\n        \\\"days\\\": STRING[]\\n    },\\n    \\\"requirements\\\"?: ANY[],\\n    \\\"additionalProperties\\\"?: MAP<STRING,UNKNOWN>,\\n    \\\"profits\\\"?: MAP<STRING,NUMBER>\\n}\\n```\\n\\n### OTHER\\n\\nTODO: Planned to explain later.\\n\\n---\\n\\n## Other types\\n\\nTODO: Planned to explain later.\\n\\n---\\n\\n## Appendix: Name Generation\\n\\n```\\n\\\"Give potential IDs for entities in following rules:\\\",\\n\\nRules for generating entity IDs ('id' fields, ID type):\\n- Letters or numbers (only in lowercase)\\n- Allowed symbols, such as '-', '_', '&', '#', '+'\\n- Whitespace not allowed\\n- No emojis or special symbols\\n- No Cyrillic or Latin letters\\n- Only promo-codes or codes may has uppercase letters\\n\\nHow generates entity IDs:\\n- If known person names (biography), use formatted their names, location or job also can be used.\\n- Prefixed by service, market or vendor (if bonus entity, such as promo, discount, bonus, etc.)\\n- Name, type or kind (if no name declared) of entity encodes into ID by conversion spaces into '-', etc.\\n- CODE suffix is used for unique code of entity, such as promo-code, discount-code, etc.\\n\\nFor example:\\n\\n/*\\n   - [in bonuses list] zdravia-clinic_therapist_CODE123 - promo-code for therapist of zdravia-clinic\\n   - [in persons list] alena-victorovna_additional-identifier - person of Alena Viktorovna, for additional identifier may be used service, skill, email or phone number\\n   - [in items list] book_the-best-book - book of the best book\\n*/\\n\\nSuch idea used for make simpler search, filtering and sorting of entities.\\n```\\n\"","/**\n * Time Utilities\n *\n * Consolidated time/date handling utilities.\n */\n\nimport { observe } from \"fest/object\";\nimport type { ChapterDescriptor, DayDescriptor } from \"@rs-core/utils/Types\";\nimport type { EntityInterface, TimeType } from \"@rs-com/template/EntityInterface\";\n\n// ============================================================================\n// TIME ZONE\n// ============================================================================\n\n/**\n * Get current timezone\n */\nexport const getTimeZone = (): string => {\n    return Intl.DateTimeFormat().resolvedOptions().timeZone;\n};\n\n// ============================================================================\n// DATE PARSING\n// ============================================================================\n\n/**\n * Check if string is pure HH:MM format\n */\nexport function isPureHHMM(str?: TimeType | string | number | null | undefined): boolean {\n    if (!str) return false;\n    return /^([01]\\d|2[0-3]):([0-5]\\d)$/.test(String(str).trim());\n}\n\n/**\n * Parse date from various formats\n */\nexport function parseDateCorrectly(str?: Date | TimeType | string | number | null | undefined): Date | null {\n    if (!str) return new Date();\n    if (str instanceof Date) return new Date(str);\n    if (typeof str == \"object\" && str?.timestamp) return parseDateCorrectly(str.timestamp);\n    if (typeof str == \"object\" && str?.iso_date) return parseDateCorrectly(str.iso_date);\n    if (typeof str == \"object\" && str?.date) return parseDateCorrectly(str.date);\n\n    if (typeof str == \"number\") {\n        if (str >= 1000000000000) return new Date(str);\n        const multiplier = Math.pow(10, 11 - (String(str | 0)?.length || 11)) | 0;\n        return new Date(str * multiplier);\n    }\n\n    if (typeof str == \"string\" && isPureHHMM(str)) {\n        const m = /^([01]\\d|2[0-3]):([0-5]\\d)$/.exec(str.trim());\n        if (!m) return new Date();\n        const [, hh, mm] = m;\n        const now = new Date();\n        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), Number(hh), Number(mm), 0, 0);\n    }\n\n    return new Date(String(str));\n}\n\n/**\n * Parse and get time as number\n */\nexport function parseAndGetCorrectTime(str?: Date | TimeType | string | number | null | undefined): number {\n    if (!str) return Date.now();\n    if (typeof str == \"number\") {\n        if (str >= 1000000000000) return str;\n        const multiplier = Math.pow(10, 11 - (String(str | 0)?.length || 11)) | 0;\n        return str * multiplier;\n    }\n    if (str instanceof Date) return str.getTime();\n    return parseDateCorrectly(str)?.getTime?.() ?? Date.now();\n}\n\n/**\n * Get comparable time value from various formats\n */\nexport const getComparableTimeValue = (value?: TimeType | Date | string | number | null | undefined): number => {\n    if (value == null) return Number.NaN;\n    if (typeof value === \"number\" && Number.isFinite(value)) return value;\n\n    const date = parseDateCorrectly(value);\n    if (date && !Number.isNaN(date?.getTime())) return date?.getTime() ?? 0;\n\n    const match = String(value).match(/^(\\d{1,2})(?::(\\d{2}))?(?::(\\d{2}))?/);\n    if (match) {\n        const hours = Number(match[1]) || 0;\n        const minutes = Number(match[2]) || 0;\n        const seconds = Number(match[3]) || 0;\n        return ((hours * 60 + minutes) * 60 + seconds) * 1000;\n    }\n\n    const numeric = Number(value);\n    return Number.isFinite(numeric) ? numeric : Number.NaN;\n};\n\n// ============================================================================\n// DATE VALIDATION\n// ============================================================================\n\n/**\n * Check if value is a valid date\n */\nexport const isDate = (date: any): boolean => {\n    const firstStep = date instanceof Date || (typeof date == \"string\" && date.match(/^\\d{4}-\\d{2}-\\d{2}$/));\n    let secondStep = false;\n    try {\n        secondStep = getComparableTimeValue(date) > 0;\n    } catch {\n        secondStep = false;\n    }\n    return firstStep && secondStep;\n};\n\n// ============================================================================\n// TIME RANGE CHECKS\n// ============================================================================\n\n/**\n * Check if time is within range\n */\nexport const checkInTimeRange = (beginTime: Date, endTime: Date, currentTime: Date): boolean => {\n    if (beginTime && endTime) {\n        return getComparableTimeValue(beginTime) < getComparableTimeValue(currentTime) &&\n               getComparableTimeValue(currentTime) < getComparableTimeValue(endTime);\n    }\n    if (beginTime) return getComparableTimeValue(beginTime) < getComparableTimeValue(currentTime);\n    if (endTime) return getComparableTimeValue(currentTime) < getComparableTimeValue(endTime);\n    return false;\n};\n\n/**\n * Check remaining time within max days\n */\nexport const checkRemainsTime = (beginTime: Date, endTime: Date, currentTime: Date, maxDays = 7): boolean => {\n    let factorMasked = true;\n    if (beginTime) factorMasked &&= getComparableTimeValue(currentTime) <= getComparableTimeValue(beginTime);\n    if (endTime) factorMasked &&= getComparableTimeValue(currentTime) < getComparableTimeValue(endTime);\n    if (maxDays) {\n        const dateLimit = getComparableTimeValue(currentTime) + maxDays * 24 * 60 * 60 * 1000;\n        factorMasked &&= getComparableTimeValue(beginTime) < getComparableTimeValue(dateLimit);\n    }\n    return factorMasked;\n};\n\n// ============================================================================\n// DAY DESCRIPTORS\n// ============================================================================\n\n/**\n * Get ISO week number\n */\nexport const getISOWeekNumber = (input: Date | null | undefined): number | null => {\n    if (!input) return null;\n    const target = new Date(Date.UTC(input.getFullYear(), input.getMonth(), input.getDate()));\n    const dayNumber = target.getUTCDay() || 7;\n    target.setUTCDate(target.getUTCDate() + 4 - dayNumber);\n    const yearStart = new Date(Date.UTC(target.getUTCFullYear(), 0, 1));\n    return Math.ceil((((target.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);\n};\n\n/**\n * Create a day descriptor from date\n */\nexport const createDayDescriptor = (input: Date | null | undefined, partial: Record<string, any> = {}): DayDescriptor | null => {\n    if (!input) return null;\n\n    const timeZone = getTimeZone();\n    const dayBegin = new Date(input.getTime());\n    dayBegin.setHours(0, 0, 0, 0);\n\n    const dayEnd = new Date(input.getTime());\n    dayEnd.setHours(23, 59, 59, 999);\n\n    const dayDay = dayBegin.toLocaleDateString(\"en-GB\", { day: \"numeric\", timeZone });\n    const dayWeekday = dayBegin.toLocaleDateString(\"en-GB\", { weekday: \"short\", timeZone });\n    const dayMonth = dayBegin.toLocaleDateString(\"en-GB\", { month: \"short\", timeZone });\n    const dayTitle = `${dayDay} ${dayMonth} ${dayWeekday}`;\n\n    const dayDayForId = dayBegin.toLocaleDateString(\"en-GB\", { day: \"numeric\", timeZone });\n    const dayMonthForId = dayBegin.toLocaleDateString(\"en-GB\", { month: \"numeric\", timeZone });\n    const dayYearForId = dayBegin.toLocaleDateString(\"en-GB\", { year: \"numeric\", timeZone });\n    const dayId = `${dayDayForId}_${dayMonthForId}_${dayYearForId}`;\n\n    const fullDay = dayBegin.toLocaleDateString(\"en-GB\", {\n        timeZone,\n        weekday: \"long\",\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    });\n\n    const weekNumber = getISOWeekNumber(dayBegin);\n    const separatorTitle = weekNumber ? `${fullDay} · Week ${weekNumber}` : fullDay;\n\n    return {\n        id: dayId,\n        title: dayTitle,\n        begin_time: dayBegin.toISOString(),\n        end_time: dayEnd.toISOString(),\n        separatorTitle,\n        weekNumber,\n        ...partial\n    };\n};\n\n/**\n * Check if entity is inside of day descriptor\n */\nexport const insideOfDay = <\n    E extends EntityInterface<any, any> = EntityInterface<any, any>,\n    T extends DayDescriptor = DayDescriptor\n>(item: E, dayDesc: T): boolean => {\n    const kind = typeof dayDesc == \"string\" ? dayDesc : (dayDesc as any)?.kind;\n    const status = typeof dayDesc == \"string\" ? dayDesc : dayDesc?.status;\n    const begin_time = typeof dayDesc == \"string\" ? dayDesc : dayDesc?.begin_time;\n    const end_time = typeof dayDesc == \"string\" ? dayDesc : dayDesc?.end_time;\n\n    const inRange = (\n        (!begin_time || (getComparableTimeValue(item?.properties?.begin_time) >= getComparableTimeValue(begin_time)) || String(begin_time)?.toLowerCase?.()?.trim?.() == \"all\") &&\n        (!end_time || (getComparableTimeValue(item?.properties?.end_time) <= getComparableTimeValue(end_time)) || String(end_time)?.toLowerCase?.()?.trim?.() == \"all\")\n    );\n\n    const kindMatch = (kind ? (item?.kind == kind || kind == \"all\") : false) || !item?.kind;\n    const statusMatch = (status ? (item?.properties?.status == status || status == \"all\") : (!kindMatch)) || !item?.properties?.status;\n\n    return inRange || statusMatch || kindMatch;\n};\n\n/**\n * Check if entity is not in the past\n */\nexport const notInPast = <\n    E extends EntityInterface<any, any> = EntityInterface<any, any>,\n    T extends DayDescriptor = DayDescriptor\n>(item: E, dayDesc: T | null = null): boolean => {\n    const kind = typeof dayDesc == \"string\" ? dayDesc : (dayDesc as any)?.kind;\n    const status = typeof dayDesc == \"string\" ? dayDesc : dayDesc?.status;\n    const end_time = typeof dayDesc == \"string\" ? dayDesc : dayDesc?.end_time;\n    const now_time = getComparableTimeValue();\n\n    const inRange = !end_time || getComparableTimeValue(end_time) >= now_time;\n    const kindMatch = (kind ? (item?.kind == kind || kind == \"all\") : false) || !item?.kind;\n    const statusMatch = (status ? (item?.properties?.status == status || status == \"all\") : (!kindMatch)) || !item?.properties?.status;\n    return inRange || statusMatch || kindMatch;\n};\n\n// ============================================================================\n// TIMELINE UTILITIES\n// ============================================================================\n\n/**\n * Split timelines by days\n */\nexport const SplitTimelinesByDays = async (timelineMap: any, daysDesc: any[] | null = null) => {\n    daysDesc ??= observe([] as any[]) as any[];\n    if (!timelineMap) return daysDesc;\n\n    for (const timeline of (await timelineMap) ?? []) {\n        if (timeline?.properties?.begin_time && timeline?.properties?.end_time) {\n            const beginTime = parseDateCorrectly(timeline?.properties?.begin_time);\n            const endTime = parseDateCorrectly(timeline?.properties?.end_time);\n\n            let day = daysDesc?.find?.(day => {\n                return getComparableTimeValue(beginTime) >= getComparableTimeValue(day?.begin_time) &&\n                       getComparableTimeValue(endTime) <= getComparableTimeValue(day?.end_time);\n            }) ?? null;\n\n            if (!day && (getComparableTimeValue(endTime) >= getComparableTimeValue())) {\n                const dayDescriptor = createDayDescriptor(beginTime, { status: \"\" });\n                if (dayDescriptor) {\n                    daysDesc?.push?.(day ??= dayDescriptor);\n                }\n            }\n        }\n    }\n\n    return daysDesc;\n};\n\n/**\n * Compute timeline order in general\n */\nexport const computeTimelineOrderInGeneral = (timeOfDay: TimeType | string | number | null | undefined, minTimestamp?: number): number | null => {\n    const dayStart = getComparableTimeValue(timeOfDay) || 0;\n    const normalized = (Number.isFinite(dayStart) ? dayStart : 0) - (minTimestamp || 0);\n    return Math.round(normalized / (24 * 60 * 60 * 1000));\n};\n\n/**\n * Compute timeline order inside of day\n */\nexport const computeTimelineOrderInsideOfDay = (item: EntityInterface<any, any>, dayDesc?: ChapterDescriptor | null): number | null => {\n    const beginTime = getComparableTimeValue(item?.properties?.begin_time) || 0;\n    const endTime = getComparableTimeValue(item?.properties?.end_time) || 0;\n    const fallback = Number.isFinite(beginTime) ? beginTime : endTime;\n    if (!Number.isFinite(fallback)) return 0;\n\n    if (!dayDesc || !(dayDesc as any)?.begin_time) {\n        dayDesc = createDayDescriptor(parseDateCorrectly(fallback ?? null));\n    }\n\n    const dayStart = getComparableTimeValue((dayDesc as any)?.begin_time) || 0;\n    const normalized = (Number.isFinite(dayStart) ? (fallback - dayStart) : fallback);\n    return Math.round(normalized / (60 * 1000));\n};\n\n// ============================================================================\n// FORMATTING\n// ============================================================================\n\n/**\n * Normalize schedule to TimeType\n */\nexport const normalizeSchedule = (value: TimeType | string | number | null | undefined): TimeType | null => {\n    if (!value) return null;\n    if (typeof value === \"object\" && (value.date || value.iso_date || value.timestamp)) {\n        return value;\n    }\n    return { iso_date: String(value) };\n};\n\n/**\n * Format as time string (HH:MM)\n */\nexport const formatAsTime = (time: TimeType | string | number | null | undefined): string => {\n    const normalized = normalizeSchedule(time);\n    if (!normalized) return \"\";\n    return parseDateCorrectly(normalized)?.toLocaleTimeString?.(\"en-GB\", {\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hour12: false,\n        timeZone: getTimeZone()\n    }) || \"\";\n};\n\n/**\n * Format as date string\n */\nexport const formatAsDate = (date: TimeType | string | number | null | undefined): string => {\n    return parseDateCorrectly(date)?.toLocaleDateString?.(\"en-GB\", {\n        day: \"numeric\",\n        month: \"long\",\n        weekday: \"long\",\n        year: \"numeric\",\n        timeZone: getTimeZone()\n    }) || \"\";\n};\n\n/**\n * Format as date time string\n */\nexport const formatDateTime = (timestamp: number): string => {\n    const date = new Date(timestamp);\n    if (Number.isNaN(date.getTime())) return \"\";\n    return date.toLocaleString(undefined, {\n        year: \"numeric\",\n        month: \"short\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\"\n    });\n};\n","/*\n * This code makes detailed plan by AI for N day or days (aka. Timeline).\n * Used data: preferences, shortlist of data, some entity set (recognized by preferences context), etc.\n * Info detailed by: description, steps, locations, actions, time, etc.\n * Has few steps:\n * - 0. Send existing timeline data to AI for context (is exists and needed)\n * - 1. Send described preferences data to AI for additional context\n *      - Give current time and date for context, and location for context\n *      - Give factors and events for improve details of plan\n *      - Get optionally suitable entities sets (by shortlist of entities, if exists and needed)\n * - 2. Optional, present some details of entities sets to AI for make plan (if needed and exists)\n *      - Used for recommendations and tips, and improve quality of plan\n * - 3. Get new or modified plan from AI\n * - 4. Handle and save new or modified plan to timeline data\n */\n\n//\nimport { encode } from \"@toon-format/toon\";\n\n//\nimport { GPTResponses } from \"../model/GPT-Responses\";\nimport { readJSONs, readOneMarkDown } from \"@rs-core/storage/FileSystem\";\nimport { realtimeStates } from \"../misc/Cache\";\n\n// @ts-ignore\nimport AI_OUTPUT_SCHEMA from \"@rs-com/template/Entities-v2.md?raw\";\n\n//\nimport { checkRemainsTime } from \"@rs-core/time\";\nimport { fixEntityId } from \"@rs-com/template/EntityId\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport { parseAIResponseSafe } from \"@rs-core/document/AIResponseParser\";\n\n//\nexport const TIMELINE_DIR = \"/timeline/\";\n\n//\nexport const PREFERENCES_DIR = \"/docs/preferences/\";\nexport const PLANS_DIR = \"/docs/plans/\";\n\n//\nexport const FACTORS_DIR = \"/data/factors/\";\nexport const EVENTS_DIR = \"/data/events/\";\n\n\n\n// get only today and future tasks, and tasks in the past, but not ended (not finished)\nexport const filterTasks = (timeline: any[], currentTime: Date, maxDays: number = 7) => {\n    return timeline?.filter?.((task) => checkRemainsTime(task?.properties?.begin_time, task?.properties?.end_time, currentTime, maxDays));\n}\n\n// get only today and future factors, and factors in the past, but not ended (not finished)\nexport const filterFactors = (factors: any[], currentTime: Date, maxDays: number = 7) => {\n    return factors?.filter?.((factor) => checkRemainsTime(factor?.properties?.begin_time, factor?.properties?.end_time, currentTime, maxDays));\n}\n\n// get only today and future events, and events in the past, but not ended (not finished)\nexport const filterEvents = (events: any[], currentTime: Date, maxDays: number = 7) => {\n    return events?.filter?.((event) => checkRemainsTime(event?.properties?.begin_time, event?.properties?.end_time, currentTime, maxDays));\n}\n\n\n\n//\nexport const createTimelineGenerator = async (sourcePath: string | null = null, speechPrompt: string | null = null) => {\n    const settings = await loadSettings();\n    if (!settings || !settings?.ai || !settings.ai?.apiKey) return;\n\n    //\n    const gptResponses = new GPTResponses(settings.ai?.apiKey || \"\", settings.ai?.baseUrl || \"https://api.proxyapi.ru/openai/v1\", \"\", settings.ai?.model || \"gpt-5.2\");\n    console.log(gptResponses);\n\n    // attach some factors (except finished)\n    await gptResponses?.giveForRequest?.(`factors: \\`${encode(filterFactors(await readJSONs(FACTORS_DIR), (realtimeStates as any)?.time) as any)}\\`\\n`);\n\n    // attach some events (except finished)\n    await gptResponses?.giveForRequest?.(`events: \\`${encode(filterEvents(await readJSONs(EVENTS_DIR), (realtimeStates as any)?.time))}\\`\\n`);\n\n    //\n    if (sourcePath) {\n        await gptResponses?.giveForRequest?.(`preferences: \\`\\`\\`${encode(await readOneMarkDown(sourcePath))}\\`\\`\\`\\n`);\n    } else\n\n    // if no both source path and speech prompt, so make generic working plan for next 7 days\n    if (!speechPrompt?.trim?.() || !speechPrompt?.trim?.()?.length) {\n        await gptResponses?.giveForRequest?.(`preferences: Make generic working plan for next 7 days...\\n`);\n    }\n\n    // additional speech prompt\n    if (speechPrompt?.trim?.() && speechPrompt?.trim?.()?.length) {\n        await gptResponses?.giveForRequest?.(`speech_prompt: \\`${encode(speechPrompt)}\\`\\n`);\n    }\n\n    //\n    await gptResponses?.askToDoAction?.([`primary_request:`,\n        \"Analyze starting and existing data, and get be ready to make a new timeline (preferences data will be attached later)...\",\n        \"Also, can you provide markdown pre-formatted verbose data about what you have analyzed and what you will do?\",\n        \"Give ready status in JSON format: \\`{ ready: boolean, reason: string, verbose_data: string }\\`\"\n    ]?.join?.(\"\\n\"));\n\n    // load all of those into context\n    const readyStatus = parseAIResponseSafe<{ ready: boolean; reason: string; verbose_data: string }>(await gptResponses?.sendRequest?.(\"high\", \"high\") || \"{ ready: false, reason: \\\"No attached data\\\", verbose_data: \\\"\\\" }\");\n    if (!readyStatus?.ok) {\n        console.error(\"timeline\", readyStatus?.error || \"Failed to parse AI response\");\n        return { timeline: [], keywords: [] };\n    }\n    return readyStatus?.data;\n}\n\n\n\n//\nexport const requestNewTimeline = async (gptResponses: GPTResponses, existsTimeline: any | null = null) => {\n    if (!gptResponses) return { timeline: [], keywords: [] };\n\n    // attach exists timeline\n    if (existsTimeline) {\n        await gptResponses?.giveForRequest?.(`current_timeline: \\`${encode(existsTimeline)}\\`\\n`);\n    }\n\n    //\n    const userTimeZone = Intl?.DateTimeFormat?.()?.resolvedOptions?.()?.timeZone || \"UTC\";\n    const timezoneOffset = new Date()?.getTimezoneOffset?.() || 0;\n    const encodedRealtimeState = encode({\n        time: (realtimeStates as any).time?.toISOString?.(),\n        timestamp: (realtimeStates as any).timestamp,\n        coords: (realtimeStates as any).coords?.toJSON?.(),\n        otherProps: (realtimeStates as any).otherProps,\n        cards: (realtimeStates as any).cards,\n        language: navigator?.language || \"ru-RU\",\n        timezone: userTimeZone,\n        timezoneOffset: timezoneOffset\n    });\n\n    // use real-time state (oriented on current time and location)\n    await gptResponses?.giveForRequest?.(`current_states: \\`${encodedRealtimeState}\\`\\n`);\n    await gptResponses?.giveForRequest?.(AI_OUTPUT_SCHEMA);\n    await gptResponses?.askToDoAction?.([\n        \"Make timeline plan in JSON format, according to given schema. Follow by our preferences is was presented...\",\n        \"Write in JSON format, \\`[ array of entity of \\\"task\\\" type ]\\`, according to given schema.\"\n    ].join?.(\"\\n\"));\n\n    //\n    const existsResponseId = gptResponses?.getResponseId?.();\n    const raw = await gptResponses?.sendRequest?.()?.catch?.(console.warn.bind(console));\n    const timelines = raw ? parseAIResponseSafe<any>(raw) as any : \"{ ready: false, reason: \\\"No attached data\\\", keywords: [] }\";\n    gptResponses?.beginFromResponseId?.(existsResponseId as string | null);\n\n    //\n    timelines?.forEach?.((entity: any) => fixEntityId(entity));\n\n    // log timeline\n    console.log(\"timeline\", timelines);\n\n    // return timeline (writing is handled by the router via ServiceHelper queue)\n    return timelines;\n}\n"],"names":["STORE","idbOpen","parseDateCorrectly","d","_"],"mappings":"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"}