{"version":3,"mappings":"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","names":["result"],"ignoreList":[],"sources":["../../src/com/service/shared/gpt-utils.ts","../../src/com/service/platform/adapters.ts","../../src/com/config/RuntimeSettings.ts","../../src/com/service/processing/settings.ts","../../src/com/service/recognition/core.ts","../../src/com/service/processing/core.ts","../../src/com/service/recognition/cache.ts","../../src/com/service/processing/unified.ts"],"sourcesContent":["import { loadSettings } from \"@rs-com/config/Settings\";\nimport { GPTResponses, createGPTInstance } from \"../model/GPT-Responses\";\nimport type { AIConfig, OutputFormat } from \"./types\";\n\nconst DEFAULT_MODEL = \"gpt-5.2\";\nconst DEFAULT_API_URL = \"https://api.proxyapi.ru/openai/v1\";\n\nexport { DEFAULT_MODEL, DEFAULT_API_URL };\n\nexport const getGPTInstance = async (config?: AIConfig): Promise<GPTResponses | null> => {\n\tconst settings = await loadSettings();\n\tconst apiKey = config?.apiKey || settings?.ai?.apiKey;\n\n\tif (!apiKey) {\n\t\treturn null;\n\t}\n\n\tconst baseUrl = config?.baseUrl || settings?.ai?.baseUrl || DEFAULT_API_URL;\n\tconst model = config?.model || settings?.ai?.model || DEFAULT_MODEL;\n\n\treturn createGPTInstance(apiKey, baseUrl, model);\n};\n\nexport function unwrapUnwantedCodeBlocks(content: string): string {\n\tif (!content) return content;\n\n\tconst codeBlockRegex = /^```(?:katex|md|markdown|html|xml|json|text)?\\n([\\s\\S]*?)\\n```$/;\n\n\tconst match = content.trim().match(codeBlockRegex);\n\tif (match) {\n\t\tconst unwrapped = match[1].trim();\n\t\tconst lines = unwrapped.split(\"\\n\");\n\n\t\tif (lines.length === 1 ||\n\t\t\tunwrapped.includes(\"<math\") ||\n\t\t\tunwrapped.includes('<span class=\"katex') ||\n\t\t\tunwrapped.includes(\"<content\") ||\n\t\t\tunwrapped.startsWith(\"<\") && unwrapped.endsWith(\">\") ||\n\t\t\t/^\\s*<[^>]+>/.test(unwrapped)) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (lines.length > 3 ||\n\t\t\tlines.some(line => line.match(/^\\s{4,}/) || line.includes(\"function\") || line.includes(\"const \") || line.includes(\"let \"))) {\n\t\t\treturn content;\n\t\t}\n\n\t\treturn unwrapped;\n\t}\n\n\treturn content;\n}\n\nexport function isImageData(data: any): boolean {\n\treturn (data instanceof File && data.type.startsWith(\"image/\")) ||\n\t\t(data instanceof Blob && data.type?.startsWith(\"image/\")) ||\n\t\t(typeof data === \"string\" && (data.startsWith(\"data:image/\") || data.startsWith(\"http\") || data.startsWith(\"https://\")));\n}\n\nexport function getResponseFormat(format: OutputFormat): \"json\" | \"text\" {\n\tconst jsonFormats: OutputFormat[] = [\"json\", \"xml\", \"yaml\"];\n\treturn jsonFormats.includes(format) ? \"json\" : \"text\";\n}\n\nexport const pickFirstError = (raw: any): string | undefined => {\n\tif (!raw) return undefined;\n\tif (typeof raw.error === \"string\" && raw.error.trim()) return raw.error;\n\tif (Array.isArray(raw.errors) && typeof raw.errors[0] === \"string\" && raw.errors[0].trim()) return raw.errors[0];\n\treturn undefined;\n};\n\nexport const extractText = (raw: any): string | undefined => {\n\tif (!raw) return undefined;\n\n\tif (typeof raw.data === \"string\") {\n\t\tconst t = raw.data.trim();\n\t\tif (t) return t;\n\t}\n\n\tif (typeof raw.verbose_data === \"string\") {\n\t\tconst t = raw.verbose_data.trim();\n\t\tif (t) return t;\n\t}\n\n\tconst rd = raw.recognized_data;\n\tif (typeof rd === \"string\") {\n\t\tconst t = rd.trim();\n\t\tif (t) return t;\n\t}\n\n\tif (Array.isArray(rd)) {\n\t\tconst parts: string[] = [];\n\t\tfor (const item of rd) {\n\t\t\tif (typeof item === \"string\") {\n\t\t\t\tif (item.trim()) parts.push(item.trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst maybe = (item?.output ?? item?.text ?? item?.content ?? item?.value) as unknown;\n\t\t\tif (typeof maybe === \"string\" && maybe.trim()) parts.push(maybe.trim());\n\t\t}\n\t\tconst joined = parts.join(\"\\n\").trim();\n\t\tif (joined) return joined;\n\t}\n\n\treturn undefined;\n};\n\nexport const toCrxResult = (raw: any): { ok: boolean; data?: string; error?: string; raw?: any } => {\n\tconst ok = !!raw?.ok;\n\tconst data = extractText(raw);\n\tconst error = pickFirstError(raw) ?? (ok && !data ? \"No data recognized\" : undefined);\n\n\treturn {\n\t\tok: ok && !!data,\n\t\tdata,\n\t\terror,\n\t\traw,\n\t};\n};\n","import type { ClipboardResult, ImageProcessingOptions, PlatformAdapter } from \"../shared/types\";\n\nconst createPwaAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tconst { writeText } = await import(\"@rs-core/modules/Clipboard\");\n\t\t\treturn (await writeText(data)) as ClipboardResult;\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync processImage(dataUrl: string): Promise<string> {\n\t\treturn dataUrl;\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\ttry {\n\t\t\timport(\"@rs-frontend/items/Toast\").then(({ showToast }) => {\n\t\t\t\tshowToast({\n\t\t\t\t\tmessage,\n\t\t\t\t\tkind: options?.type || \"info\",\n\t\t\t\t\tduration: options?.duration || 3000,\n\t\t\t\t});\n\t\t\t});\n\t\t} catch {\n\t\t\tconsole.log(message);\n\t\t}\n\t},\n});\n\nconst createCrxAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tconst { requestCopyViaCRX } = await import(\"@rs-core/modules/Clipboard\");\n\t\t\tconst result = await requestCopyViaCRX(data);\n\t\t\treturn { ok: result.ok, data: result.data as string | undefined };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) as string | undefined };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync processImage(dataUrl: string): Promise<string> {\n\t\ttry {\n\t\t\tconst isServiceWorker = typeof window === \"undefined\" || !window.document;\n\n\t\t\tif (isServiceWorker) {\n\t\t\t\tconsole.warn(\"[RecognizeData] Image processing not available in service worker context\");\n\t\t\t\treturn dataUrl;\n\t\t\t}\n\n\t\t\tconst { encodeWithJSquash, removeAnyPrefix } = await import(\"@rs-core/workers/ImageProcess\");\n\t\t\tconst SIZE_THRESHOLD = 2 * 1024 * 1024;\n\t\t\tif (dataUrl.length <= SIZE_THRESHOLD) return dataUrl;\n\n\t\t\ttry {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst binary = Uint8Array.fromBase64(removeAnyPrefix(dataUrl), { alphabet: \"base64\" });\n\t\t\t\tconst blob = new Blob([binary], { type: \"image/png\" });\n\t\t\t\tconst bitmap = await createImageBitmap(blob);\n\t\t\t\tconst arrayBuffer = await encodeWithJSquash(bitmap);\n\t\t\t\tbitmap?.close?.();\n\n\t\t\t\tif (arrayBuffer) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst base64 = new Uint8Array(arrayBuffer).toBase64({ alphabet: \"base64\" });\n\t\t\t\t\treturn `data:image/jpeg;base64,${base64}`;\n\t\t\t\t}\n\t\t\t} catch (processingError) {\n\t\t\t\tconsole.warn(\"[RecognizeData] Image compression failed:\", processingError);\n\t\t\t}\n\n\t\t\treturn dataUrl;\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"[RecognizeData] Image processing failed:\", e);\n\t\t\treturn dataUrl;\n\t\t}\n\t},\n\n\tasync captureScreenshot(rect?: {\n\t\tx: number;\n\t\ty: number;\n\t\twidth: number;\n\t\theight: number;\n\t}): Promise<string> {\n\t\ttry {\n\t\t\tif (typeof chrome !== \"undefined\" && chrome.tabs?.captureVisibleTab) {\n\t\t\t\tconst captureOptions: any = { format: \"png\", scale: 1 };\n\t\t\t\tif (rect) {\n\t\t\t\t\tcaptureOptions.rect = rect;\n\t\t\t\t}\n\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tchrome.tabs.captureVisibleTab(captureOptions, (dataUrl) => {\n\t\t\t\t\t\tif (chrome.runtime.lastError) {\n\t\t\t\t\t\t\treject(new Error(chrome.runtime.lastError.message));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(dataUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow new Error(\"Screenshot capture not available\");\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Screenshot capture failed: ${e}`);\n\t\t}\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\tconsole.log(`[${options?.type || \"info\"}] ${message}`);\n\t},\n});\n\nconst createCoreAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.writeText) {\n\t\t\t\tawait navigator.clipboard.writeText(data);\n\t\t\t\treturn { ok: true, data, method: \"clipboard-api\" };\n\t\t\t}\n\n\t\t\tconst textArea = document.createElement(\"textarea\");\n\t\t\ttextArea.value = data;\n\t\t\ttextArea.style.cssText = \"position:fixed;left:-9999px;top:-9999px;opacity:0;\";\n\t\t\tdocument.body.appendChild(textArea);\n\t\t\ttextArea.select();\n\n\t\t\tconst success = document.execCommand(\"copy\");\n\t\t\ttextArea.remove();\n\n\t\t\treturn success ? { ok: true, data, method: \"legacy\" } : { ok: false, error: \"Copy failed\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\tconsole.log(`[${options?.type || \"info\"}] ${message}`);\n\t},\n});\n\nexport const detectPlatform = (): \"pwa\" | \"crx\" | \"core\" | \"unknown\" => {\n\ttry {\n\t\tif (typeof chrome !== \"undefined\" && chrome?.runtime?.id) {\n\t\t\treturn \"crx\";\n\t\t}\n\n\t\tif (typeof self !== \"undefined\" && \"ServiceWorkerGlobalScope\" in self) {\n\t\t\treturn \"pwa\";\n\t\t}\n\n\t\tif (typeof navigator !== \"undefined\" && \"standalone\" in navigator) {\n\t\t\treturn \"pwa\";\n\t\t}\n\n\t\treturn \"core\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n};\n\nexport const getPlatformAdapter = (): PlatformAdapter => {\n\tconst platform = detectPlatform();\n\n\tswitch (platform) {\n\t\tcase \"crx\":\n\t\t\treturn createCrxAdapter();\n\t\tcase \"pwa\":\n\t\t\treturn createPwaAdapter();\n\t\tcase \"core\":\n\t\tdefault:\n\t\t\treturn createCoreAdapter();\n\t}\n};\n","import { loadSettings } from \"./Settings\";\r\nimport type { AppSettings } from \"./SettingsTypes\";\r\nimport { DEFAULT_SETTINGS } from \"./SettingsTypes\";\r\n\r\nexport type RuntimeSettingsProvider = () => Promise<AppSettings> | AppSettings;\r\n\r\nlet provider: RuntimeSettingsProvider = loadSettings;//async () => DEFAULT_SETTINGS;\r\n\r\n/**\r\n * Allows non-browser runtimes (Node/Deno backend) to supply settings without IndexedDB/chrome storage.\r\n * Frontend apps can also set this to bridge to their existing settings storage.\r\n */\r\nexport const setRuntimeSettingsProvider = (next: RuntimeSettingsProvider) => {\r\n    provider = next;\r\n};\r\n\r\nexport const getRuntimeSettings = async (): Promise<AppSettings> => {\r\n    try {\r\n        const value = await provider();\r\n        return value || DEFAULT_SETTINGS;\r\n    } catch {\r\n        return DEFAULT_SETTINGS;\r\n    }\r\n};\r\n","import { getRuntimeSettings } from \"@rs-com/config/RuntimeSettings\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport type { ResponseLanguage } from \"@rs-com/config/SettingsTypes\";\nimport { detectPlatform } from \"../platform/adapters\";\nimport { SVG_GRAPHICS_ADDON, LANGUAGE_INSTRUCTIONS, TRANSLATE_INSTRUCTION } from \"../instructions/utils\";\n\nexport const loadAISettings = async () => {\n\tconst platform = detectPlatform();\n\n\ttry {\n\t\tif (platform === \"crx\") {\n\t\t\treturn await loadSettings();\n\t\t} else {\n\t\t\treturn await getRuntimeSettings();\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(`[AI-Service] Failed to load settings for platform ${platform}:`, e);\n\t\treturn null;\n\t}\n};\n\nexport const getActiveCustomInstruction = async (): Promise<string> => {\n\ttry {\n\t\tconst { getActiveInstructionText } = await import(\"../misc/CustomInstructions\");\n\t\treturn await getActiveInstructionText();\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n\nexport const getLanguageInstruction = async (): Promise<string> => {\n\ttry {\n\t\tconst settings = await loadAISettings();\n\t\tconst lang = (settings?.ai?.responseLanguage || \"auto\") as ResponseLanguage;\n\t\tconst translate = settings?.ai?.translateResults || false;\n\n\t\tlet instruction = LANGUAGE_INSTRUCTIONS[lang] || \"\";\n\t\tif (translate && lang !== \"auto\") {\n\t\t\tinstruction += TRANSLATE_INSTRUCTION;\n\t\t}\n\t\treturn instruction;\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n\nexport const getSvgGraphicsAddon = async (): Promise<string> => {\n\ttry {\n\t\tconst settings = await loadAISettings();\n\t\treturn settings?.ai?.generateSvgGraphics ? SVG_GRAPHICS_ADDON : \"\";\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n","import { getUsableData } from \"@rs-com/service/model/GPT-Responses\";\nimport { detectDataKindFromContent, type DataContext, type DataKind } from \"@rs-com/service/model/GPT-Config\";\nimport { extractJSONFromAIResponse } from \"@rs-core/document/AIResponseParser\";\nimport { getGPTInstance } from \"@rs-com/service/shared/gpt-utils\";\nimport { CORE_IMAGE_INSTRUCTION, CORE_DATA_CONVERSION_INSTRUCTION, CORE_ENTITY_EXTRACTION_INSTRUCTION } from \"@rs-com/service/instructions/core\";\nimport type {\n\tAIConfig,\n\tRecognitionMode,\n\tRecognitionResult,\n\tBatchRecognitionResult,\n\tRecognizeByInstructionsOptions,\n} from \"@rs-com/service/shared/types\";\n\nexport const recognizeImageData = async (\n\tinput: any,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst { recognizeByInstructions } = await import(\"@rs-com/service/processing/unified\");\n\treturn recognizeByInstructions(input, CORE_IMAGE_INSTRUCTION, sendResponse, config, options);\n};\n\nexport const convertTextualData = async (\n\tinput: any,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst { recognizeByInstructions } = await import(\"@rs-com/service/processing/unified\");\n\treturn recognizeByInstructions(input, CORE_DATA_CONVERSION_INSTRUCTION, sendResponse, config, options);\n};\n\nexport const analyzeRecognizeUnified = async (\n\trawData: File | Blob | string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst content = await getUsableData({ dataSource: rawData });\n\tconst input = [\n\t\t{\n\t\t\ttype: \"message\",\n\t\t\trole: \"user\",\n\t\t\tcontent: [content],\n\t\t},\n\t];\n\treturn (content?.[0]?.type === \"input_image\" || content?.type === \"input_image\")\n\t\t? recognizeImageData(input, sendResponse, config, options)\n\t\t: convertTextualData(input, sendResponse, config, options);\n};\n\nexport const recognizeWithContext = async (\n\tdata: File | Blob | string,\n\tcontext?: DataContext,\n\tmode: RecognitionMode = \"auto\",\n\tconfig?: AIConfig,\n): Promise<RecognitionResult> => {\n\tconst startTime = performance.now();\n\n\tconst result: RecognitionResult = {\n\t\tok: false,\n\t\trecognized_data: [],\n\t\tkeywords_and_tags: [],\n\t\tverbose_data: \"\",\n\t\tsuggested_type: null,\n\t\tconfidence: 0,\n\t\tsource_kind: \"input_text\",\n\t\tprocessing_time_ms: 0,\n\t\terrors: [],\n\t\twarnings: [],\n\t};\n\n\ttry {\n\t\tconst gpt = await getGPTInstance(config);\n\t\tif (!gpt) {\n\t\t\tresult.errors.push(\"No GPT instance available\");\n\t\t\treturn result;\n\t\t}\n\n\t\tgpt.setContext(context || null);\n\n\t\tlet dataKind: DataKind = \"input_text\";\n\t\tif (data instanceof File || data instanceof Blob) {\n\t\t\tif (data.type.startsWith(\"image/\")) {\n\t\t\t\tdataKind = \"input_image\";\n\t\t\t} else if (data.type.includes(\"json\")) {\n\t\t\t\tdataKind = \"json\";\n\t\t\t}\n\t\t} else if (typeof data === \"string\") {\n\t\t\tdataKind = detectDataKindFromContent(data);\n\t\t}\n\t\tresult.source_kind = dataKind;\n\n\t\tif (mode === \"image\") dataKind = \"input_image\";\n\t\telse if (mode === \"text\") dataKind = \"input_text\";\n\t\telse if (mode === \"structured\") dataKind = \"json\";\n\n\t\tif (Array.isArray(data) && (data?.[0]?.type === \"message\" || data?.[0]?.[\"role\"])) {\n\t\t\tawait gpt?.getPending?.()?.push?.(...data);\n\t\t} else {\n\t\t\tawait gpt?.attachToRequest?.(data, dataKind);\n\t\t}\n\n\t\tconst instruction =\n\t\t\tdataKind === \"input_image\" ? CORE_IMAGE_INSTRUCTION : CORE_DATA_CONVERSION_INSTRUCTION;\n\n\t\tconst contextAddition = context?.entityType ? `\\n\\nExpected entity type context: ${context?.entityType}` : \"\";\n\t\tconst searchAddition = context?.searchTerms?.length\n\t\t\t? `\\n\\nFocus on finding: ${context?.searchTerms?.join?.(\", \")}`\n\t\t\t: \"\";\n\n\t\tawait gpt.askToDoAction(instruction + contextAddition + searchAddition);\n\n\t\tconst raw = await gpt.sendRequest(context?.priority === \"high\" ? \"high\" : \"medium\", \"medium\", null, {\n\t\t\tresponseFormat: \"json\",\n\t\t\ttemperature: 0.3,\n\t\t});\n\n\t\tif (!raw) {\n\t\t\tresult.errors.push(\"No response from AI\");\n\t\t\treturn result;\n\t\t}\n\n\t\tconst parseResult = extractJSONFromAIResponse<any>(raw);\n\t\tif (!parseResult.ok) {\n\t\t\tresult.errors.push(parseResult.error || \"Failed to parse AI response\");\n\t\t\tresult.verbose_data = raw;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst parsed = parseResult.data;\n\t\tresult.ok = true;\n\t\tresult.recognized_data = parsed?.recognized_data || [parsed?.verbose_data || raw];\n\t\tresult.keywords_and_tags = parsed?.keywords_and_tags || parsed?.keywords || [];\n\t\tresult.verbose_data = parsed?.verbose_data || \"\";\n\t\tresult.suggested_type = parsed?.document_type || parsed?.source_format || null;\n\t\tresult.confidence = parsed?.confidence || 0.7;\n\t} catch (e) {\n\t\tresult.errors.push(String(e));\n\t}\n\n\tresult.processing_time_ms = performance.now() - startTime;\n\treturn result;\n};\n\nexport const batchRecognize = async (\n\titems: (File | Blob | string)[],\n\tcontext?: DataContext,\n\tconcurrency: number = 3,\n\tconfig?: AIConfig,\n): Promise<BatchRecognitionResult> => {\n\tconst startTime = performance.now();\n\n\tconst result: BatchRecognitionResult = {\n\t\tok: true,\n\t\tresults: [],\n\t\ttotal_processed: items.length,\n\t\ttotal_successful: 0,\n\t\ttotal_failed: 0,\n\t\tcombined_keywords: [],\n\t\tprocessing_time_ms: 0,\n\t};\n\n\tconst keywordSet = new Set<string>();\n\n\tfor (let i = 0; i < items.length; i += concurrency) {\n\t\tconst batch = items.slice(i, i + concurrency);\n\n\t\tconst promises = batch.map((item) => recognizeWithContext(item, context || {}, \"auto\", config));\n\n\t\tconst batchResults = await Promise.all(promises);\n\n\t\tfor (const r of batchResults) {\n\t\t\tresult.results.push(r);\n\n\t\t\tif (r.ok) {\n\t\t\t\tresult.total_successful++;\n\t\t\t\tr.keywords_and_tags.forEach((k) => keywordSet.add(k));\n\t\t\t} else {\n\t\t\t\tresult.total_failed++;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.ok = result.total_failed === 0;\n\tresult.combined_keywords = Array.from(keywordSet);\n\tresult.processing_time_ms = performance.now() - startTime;\n\n\treturn result;\n};\n","import { SOLVE_AND_ANSWER_INSTRUCTION, WRITE_CODE_INSTRUCTION, EXTRACT_CSS_INSTRUCTION } from \"../instructions/core\";\nimport { getGPTInstance } from \"../shared/gpt-utils\";\nimport { getActiveCustomInstruction, getLanguageInstruction, getSvgGraphicsAddon } from \"./settings\";\nimport type { DataKind } from \"../model/GPT-Config\";\nimport type { RecognitionResult, RecognizeByInstructionsOptions } from \"../shared/types\";\n\nconst emptyResult = (errors: string[], processingTime: number): RecognitionResult => ({\n\tok: false,\n\trecognized_data: [],\n\tkeywords_and_tags: [],\n\tverbose_data: \"\",\n\tsuggested_type: null,\n\tconfidence: 0,\n\tsource_kind: \"unknown\" as unknown as DataKind,\n\tprocessing_time_ms: processingTime,\n\terrors,\n\twarnings: [],\n});\n\nconst runInstructionTask = async (\n\tinput: any,\n\tinstructionConst: string,\n\tresultTags: string[],\n\tresultType: string,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\tconst gpt = await getGPTInstance();\n\tif (!gpt) return emptyResult([\"AI service not available\"], 0);\n\n\tconst startTime = Date.now();\n\n\ttry {\n\t\tconst languageInstruction = await getLanguageInstruction();\n\t\tconst svgAddon = await getSvgGraphicsAddon();\n\t\tconst instruction = instructionConst + languageInstruction + svgAddon;\n\n\t\tlet customInstruction = \"\";\n\t\tif (options?.customInstruction) {\n\t\t\tcustomInstruction = options.customInstruction;\n\t\t} else if (options?.useActiveInstruction) {\n\t\t\tcustomInstruction = await getActiveCustomInstruction();\n\t\t}\n\n\t\tif (customInstruction) {\n\t\t\tawait gpt.askToDoAction(customInstruction);\n\t\t}\n\n\t\tawait gpt.askToDoAction(instruction);\n\t\tawait gpt.giveForRequest(input);\n\n\t\tconst rawResponse = await gpt.sendRequest(\"high\", \"medium\");\n\t\tconst processingTime = Date.now() - startTime;\n\n\t\tif (rawResponse) {\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\trecognized_data: [rawResponse],\n\t\t\t\tkeywords_and_tags: resultTags,\n\t\t\t\tverbose_data: rawResponse,\n\t\t\t\tsuggested_type: resultType,\n\t\t\t\tconfidence: 0.9,\n\t\t\t\tsource_kind: \"text\" as unknown as DataKind,\n\t\t\t\tprocessing_time_ms: processingTime,\n\t\t\t\terrors: [],\n\t\t\t\twarnings: [],\n\t\t\t};\n\t\t} else {\n\t\t\treturn emptyResult([`Failed to get ${resultType} response`], processingTime);\n\t\t}\n\t} catch (e) {\n\t\treturn emptyResult([String(e)], Date.now() - startTime);\n\t}\n};\n\nexport const solveAndAnswer = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, SOLVE_AND_ANSWER_INSTRUCTION, [\"solution\", \"answer\"], \"solution\", options);\n};\n\nexport const writeCode = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, WRITE_CODE_INSTRUCTION, [\"code\", \"programming\"], \"code\", options);\n};\n\nexport const extractCSS = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, EXTRACT_CSS_INSTRUCTION, [\"css\", \"styles\", \"stylesheet\"], \"css\", options);\n};\n\nexport const solveEquation = solveAndAnswer;\nexport const answerQuestion = solveAndAnswer;\n","import type { OutputFormat, RecognitionCacheEntry } from \"@rs-com/service/shared/types\";\n\nexport class RecognitionCache {\n\tprivate cache = new Map<string, RecognitionCacheEntry>();\n\tprivate maxEntries = 100;\n\tprivate ttl = 24 * 60 * 60 * 1000;\n\n\tprivate generateDataHash(data: any): string {\n\t\tif (data instanceof File) {\n\t\t\treturn `${data.name}-${data.size}-${data.lastModified}`;\n\t\t}\n\t\tif (typeof data === \"string\") {\n\t\t\treturn btoa(data).substring(0, 32);\n\t\t}\n\t\treturn JSON.stringify(data).substring(0, 32);\n\t}\n\n\tget(data: any, format?: OutputFormat): RecognitionCacheEntry | null {\n\t\tconst hash = this.generateDataHash(data);\n\t\tconst entry = this.cache.get(hash);\n\n\t\tif (!entry) return null;\n\n\t\tif (Date.now() - entry.timestamp > this.ttl) {\n\t\t\tthis.cache.delete(hash);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (format && entry.recognizedAs !== format) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry;\n\t}\n\n\tset(\n\t\tdata: any,\n\t\trecognizedData: string,\n\t\trecognizedAs: OutputFormat,\n\t\tresponseId: string,\n\t\tmetadata?: Record<string, any>,\n\t): void {\n\t\tconst hash = this.generateDataHash(data);\n\n\t\tif (this.cache.size >= this.maxEntries) {\n\t\t\tconst oldestKey = Array.from(this.cache.entries()).sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];\n\t\t\tthis.cache.delete(oldestKey);\n\t\t}\n\n\t\tthis.cache.set(hash, {\n\t\t\tdataHash: hash,\n\t\t\trecognizedData,\n\t\t\trecognizedAs,\n\t\t\ttimestamp: Date.now(),\n\t\t\tresponseId,\n\t\t\tmetadata,\n\t\t});\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n\n\tgetStats() {\n\t\treturn {\n\t\t\tentries: this.cache.size,\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tttl: this.ttl,\n\t\t};\n\t}\n}\n","import { loadSettings } from \"@rs-com/config/Settings\";\nimport { createGPTInstance } from \"@rs-com/service/model/GPT-Responses\";\nimport { buildInstructionPrompt, getOutputFormatInstruction, getIntermediateRecognitionInstruction } from \"@rs-com/service/instructions/utils\";\nimport { DEFAULT_API_URL, DEFAULT_MODEL, isImageData, unwrapUnwantedCodeBlocks, getResponseFormat } from \"@rs-com/service/shared/gpt-utils\";\nimport { loadAISettings, getActiveCustomInstruction, getLanguageInstruction, getSvgGraphicsAddon } from \"@rs-com/service/processing/settings\";\nimport { RecognitionCache } from \"@rs-com/service/recognition/cache\";\nimport { detectPlatform, getPlatformAdapter } from \"@rs-com/service/platform/adapters\";\nimport { solveAndAnswer, writeCode, extractCSS } from \"@rs-com/service/processing/core\";\nimport { extractEntities } from \"@rs-com/service/processing/entities\";\nimport { smartRecognize } from \"@rs-com/service/recognition/smart\";\nimport type {\n\tAIConfig,\n\tProcessDataWithInstructionOptions,\n\tProcessDataWithInstructionResult,\n\tRecognizeByInstructionsOptions,\n} from \"@rs-com/service/shared/types\";\n\nconst recognitionCache = new RecognitionCache();\n\nexport const processDataWithInstruction = async (\n\tinput: any,\n\toptions: ProcessDataWithInstructionOptions = {},\n\tsendResponse?: (result: ProcessDataWithInstructionResult) => void,\n): Promise<ProcessDataWithInstructionResult> => {\n\tconst settings = (await loadSettings())?.ai;\n\n\tconst {\n\t\tinstruction = \"\",\n\t\toutputFormat = \"auto\",\n\t\toutputLanguage = \"auto\",\n\t\tenableSVGImageGeneration = \"auto\",\n\t\tintermediateRecognition,\n\t\tprocessingEffort = \"low\",\n\t\tprocessingVerbosity = \"low\",\n\t\tcustomInstruction,\n\t\tuseActiveInstruction = false,\n\t\tincludeImageRecognition,\n\t\tdataType,\n\t} = options;\n\n\tconst token = settings?.apiKey;\n\tif (!token) {\n\t\tconst result: ProcessDataWithInstructionResult = { ok: false, error: \"No API key available\" };\n\t\tsendResponse?.(result);\n\t\treturn result;\n\t}\n\n\tif (!input) {\n\t\tconst result: ProcessDataWithInstructionResult = { ok: false, error: \"No input provided\" };\n\t\tsendResponse?.(result);\n\t\treturn result;\n\t}\n\n\tlet finalInstruction = instruction;\n\n\tif (customInstruction) {\n\t\tfinalInstruction = buildInstructionPrompt(finalInstruction, customInstruction);\n\t} else if (useActiveInstruction) {\n\t\tconst activeInstruction = await getActiveCustomInstruction();\n\t\tif (activeInstruction) {\n\t\t\tfinalInstruction = buildInstructionPrompt(finalInstruction, activeInstruction);\n\t\t}\n\t}\n\n\tconst languageInstruction = await getLanguageInstruction();\n\tif (languageInstruction) {\n\t\tfinalInstruction += languageInstruction;\n\t}\n\n\tconst shouldEnableSVG =\n\t\tenableSVGImageGeneration === true || (enableSVGImageGeneration === \"auto\" && outputFormat === \"html\");\n\tif (shouldEnableSVG) {\n\t\tconst svgAddon = await getSvgGraphicsAddon();\n\t\tif (svgAddon) {\n\t\t\tfinalInstruction += svgAddon;\n\t\t}\n\t}\n\n\tif (outputFormat !== \"auto\") {\n\t\tconst formatInstruction = getOutputFormatInstruction(outputFormat);\n\t\tif (formatInstruction) {\n\t\t\tfinalInstruction += formatInstruction;\n\t\t}\n\t}\n\n\tconst gpt = createGPTInstance(token, settings?.baseUrl || DEFAULT_API_URL, settings?.model || DEFAULT_MODEL);\n\tgpt.clearPending();\n\n\tlet processingStages = 1;\n\tlet recognizedImages = false;\n\tconst intermediateRecognizedData: ProcessDataWithInstructionResult[\"intermediateRecognizedData\"] = [];\n\n\tif (Array.isArray(input) && (input?.[0]?.type === \"message\" || input?.[0]?.[\"role\"])) {\n\t\tawait gpt.getPending()?.push(...input);\n\t} else {\n\t\tconst inputData = Array.isArray(input) ? input : [input];\n\n\t\tfor (const item of inputData) {\n\t\t\tlet processedItem = item;\n\n\t\t\tif (\n\t\t\t\t(typeof item === \"string\" && dataType === \"svg\") ||\n\t\t\t\t(typeof item === \"string\" && item.trim().startsWith(\"<svg\"))\n\t\t\t) {\n\t\t\t\tprocessedItem = item;\n\t\t\t} else if (isImageData(item)) {\n\t\t\t\trecognizedImages = true;\n\n\t\t\t\tconst useIntermediateRecognition =\n\t\t\t\t\tintermediateRecognition?.enabled !== false &&\n\t\t\t\t\t(intermediateRecognition?.enabled || includeImageRecognition);\n\n\t\t\t\tif (useIntermediateRecognition) {\n\t\t\t\t\tprocessingStages = 2;\n\n\t\t\t\t\tconst cachedResult = !intermediateRecognition?.forceRefresh\n\t\t\t\t\t\t? recognitionCache.get(item, intermediateRecognition?.outputFormat)\n\t\t\t\t\t\t: null;\n\n\t\t\t\t\tlet recognizedContent: string;\n\t\t\t\t\tlet recognitionResponseId: string;\n\n\t\t\t\t\tif (cachedResult) {\n\t\t\t\t\t\trecognizedContent = cachedResult.recognizedData;\n\t\t\t\t\t\trecognitionResponseId = cachedResult.responseId;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst recognitionInstruction =\n\t\t\t\t\t\t\tintermediateRecognition?.dataPriorityInstruction ||\n\t\t\t\t\t\t\tgetIntermediateRecognitionInstruction(intermediateRecognition?.outputFormat || \"markdown\");\n\n\t\t\t\t\t\tconst recognitionResult = await recognizeByInstructions(\n\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\trecognitionInstruction,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t{ apiKey: token, baseUrl: settings?.baseUrl, model: settings?.model },\n\t\t\t\t\t\t\t{ customInstruction: undefined, useActiveInstruction: false },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (!recognitionResult.ok || !recognitionResult.data) {\n\t\t\t\t\t\t\trecognizedContent = \"\";\n\t\t\t\t\t\t\trecognitionResponseId = \"\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trecognizedContent = recognitionResult.data;\n\t\t\t\t\t\t\trecognitionResponseId = recognitionResult.responseId || \"\";\n\n\t\t\t\t\t\t\tif (intermediateRecognition?.cacheResults !== false) {\n\t\t\t\t\t\t\t\tconst recognizedAs = intermediateRecognition?.outputFormat || \"markdown\";\n\t\t\t\t\t\t\t\trecognitionCache.set(item, recognizedContent, recognizedAs, recognitionResponseId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tintermediateRecognizedData.push({\n\t\t\t\t\t\toriginalData: item,\n\t\t\t\t\t\trecognizedData: recognizedContent,\n\t\t\t\t\t\trecognizedAs: intermediateRecognition?.outputFormat || \"markdown\",\n\t\t\t\t\t\tresponseId: recognitionResponseId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (recognizedContent) {\n\t\t\t\t\t\tprocessedItem = recognizedContent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (processedItem !== null && processedItem !== undefined) {\n\t\t\t\tawait gpt?.attachToRequest?.(processedItem);\n\t\t\t}\n\t\t}\n\t}\n\n\tawait gpt.askToDoAction(finalInstruction);\n\n\tlet response: any;\n\tlet error: string | undefined;\n\ttry {\n\t\tresponse = await gpt?.sendRequest?.(processingEffort, processingVerbosity, null, {\n\t\t\tresponseFormat: getResponseFormat(outputFormat),\n\t\t\ttemperature: 0.3,\n\t\t});\n\t} catch (e) {\n\t\terror = String(e);\n\t}\n\n\tlet parsedResponse = response;\n\tif (typeof response === \"string\") {\n\t\ttry {\n\t\t\tparsedResponse = JSON.parse(response);\n\t\t} catch {\n\t\t\tparsedResponse = null;\n\t\t}\n\t}\n\n\tconst responseContent = parsedResponse?.choices?.[0]?.message?.content;\n\tlet cleanedResponse = responseContent ? unwrapUnwantedCodeBlocks(responseContent.trim()) : null;\n\n\tlet finalData = cleanedResponse;\n\tif (cleanedResponse && instruction?.includes(\"Recognize data from image\")) {\n\t\ttry {\n\t\t\tconst parsedJson = JSON.parse(cleanedResponse);\n\t\t\tif (parsedJson?.recognized_data) {\n\t\t\t\tif (Array.isArray(parsedJson.recognized_data)) {\n\t\t\t\t\tfinalData = parsedJson.recognized_data.join(\"\\n\");\n\t\t\t\t} else if (typeof parsedJson.recognized_data === \"string\") {\n\t\t\t\t\tfinalData = parsedJson.recognized_data;\n\t\t\t\t} else {\n\t\t\t\t\tfinalData = JSON.stringify(parsedJson.recognized_data);\n\t\t\t\t}\n\t\t\t} else if (parsedJson?.ok === false) {\n\t\t\t\tfinalData = null;\n\t\t\t} else {\n\t\t\t\tfinalData = cleanedResponse;\n\t\t\t}\n\t\t} catch {\n\t\t\tfinalData = cleanedResponse;\n\t\t}\n\t}\n\n\tconst result: ProcessDataWithInstructionResult = {\n\t\tok: !!finalData && !error,\n\t\tdata: finalData || undefined,\n\t\terror: error || (!finalData ? \"No data recognized\" : undefined),\n\t\tresponseId: parsedResponse?.id || gpt?.getResponseId?.(),\n\t\tprocessingStages,\n\t\trecognizedImages,\n\t\tintermediateRecognizedData: intermediateRecognizedData.length > 0 ? intermediateRecognizedData : undefined,\n\t};\n\n\tsendResponse?.(result);\n\treturn result;\n};\n\nexport const recognizeByInstructions = async (\n\tinput: any,\n\tinstructions: string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string; responseId?: string }> => {\n\tconst result = await processDataWithInstruction(input, {\n\t\tinstruction: instructions,\n\t\tcustomInstruction: options?.customInstruction,\n\t\tuseActiveInstruction: options?.useActiveInstruction,\n\t\tprocessingEffort: options?.recognitionEffort || \"low\",\n\t\tprocessingVerbosity: options?.recognitionVerbosity || \"low\",\n\t\toutputFormat: \"auto\",\n\t\toutputLanguage: \"auto\",\n\t\tenableSVGImageGeneration: \"auto\",\n\t});\n\n\tconst legacyResult = {\n\t\tok: result.ok,\n\t\tdata: result.data,\n\t\terror: result.error,\n\t\tresponseId: result.responseId,\n\t};\n\n\tsendResponse?.(legacyResult);\n\treturn legacyResult;\n};\n\nexport const processDataByInstruction = async (\n\tinput: any,\n\tinstructions: string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: ProcessDataWithInstructionOptions,\n): Promise<{\n\tok: boolean;\n\tdata?: string;\n\terror?: string;\n\tresponseId?: string;\n\tprocessingStages?: number;\n\trecognizedImages?: boolean;\n}> => {\n\tconst result = await processDataWithInstruction(input, {\n\t\tinstruction: instructions,\n\t\t...options,\n\t\toutputFormat: options?.outputFormat || \"auto\",\n\t\toutputLanguage: options?.outputLanguage || \"auto\",\n\t\tenableSVGImageGeneration: options?.enableSVGImageGeneration || \"auto\",\n\t});\n\n\tconst legacyResult = {\n\t\tok: result.ok,\n\t\tdata: result.data,\n\t\terror: result.error,\n\t\tresponseId: result.responseId,\n\t\tprocessingStages: result.processingStages,\n\t\trecognizedImages: result.recognizedImages,\n\t};\n\n\tsendResponse?.(legacyResult);\n\treturn legacyResult;\n};\n\nexport const UnifiedAIService = {\n\tdetectPlatform,\n\tgetPlatformAdapter,\n\tloadAISettings,\n\tgetLanguageInstruction,\n\tgetSvgGraphicsAddon,\n\tgetActiveCustomInstruction,\n\tprocessDataWithInstruction,\n\tclearRecognitionCache: () => recognitionCache.clear(),\n\tgetRecognitionCacheStats: () => recognitionCache.getStats(),\n\trecognizeByInstructions,\n\tprocessDataByInstruction,\n\tsolveAndAnswer,\n\twriteCode,\n\textractCSS,\n\textractEntities,\n\tsmartRecognize,\n};\n\nexport default UnifiedAIService;\n"],"file":"RecognizeData.js"}