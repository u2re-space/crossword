{"version":3,"file":"index.js","sources":["../../src/core/storage/index.ts"],"sourcesContent":["/**\n * Storage Module\n *\n * Unified storage utilities for persistent state.\n * Provides wrappers for localStorage, sessionStorage, and IndexedDB.\n */\n\n// ============================================================================\n// STORAGE KEYS\n// ============================================================================\n\n/**\n * Common storage keys used across the app\n */\nexport const StorageKeys = {\n    // User preferences\n    FRONTEND_CHOICE: \"rs-frontend-choice\",\n    FRONTEND_REMEMBER: \"rs-frontend-choice-remember\",\n    THEME: \"rs-theme\",\n    SETTINGS: \"rs-settings\",\n\n    // Boot preferences\n    BOOT_STYLE: \"rs-boot-style\",\n    BOOT_SHELL: \"rs-boot-shell\",\n    BOOT_VIEW: \"rs-boot-view\",\n    BOOT_REMEMBER: \"rs-boot-remember\",\n\n    // Shell preferences\n    SHELL_CHOICE: \"rs-shell-choice\",\n    SHELL_REMEMBER: \"rs-shell-remember\",\n\n    // View state\n    WORKCENTER_STATE: \"rs-workcenter-state\",\n    VIEWER_STATE: \"rs-viewer-state\",\n    EDITOR_STATE: \"rs-editor-state\",\n    EXPLORER_STATE: \"view-explorer-state\",\n    EXPLORER_PATH: \"view-explorer-path\",\n\n    // Content\n    LAST_MARKDOWN: \"rs-last-markdown\",\n    HISTORY: \"rs-history\",\n    RECENT_FILES: \"rs-recent-files\",\n\n    // AI Config\n    AI_CONFIG: \"rs-ai-config\"\n} as const;\n\nexport type StorageKey = typeof StorageKeys[keyof typeof StorageKeys];\n\n// ============================================================================\n// LOCAL STORAGE\n// ============================================================================\n\n/**\n * Get item from localStorage with type safety\n */\nexport function getItem<T>(key: string, defaultValue: T): T {\n    try {\n        const stored = localStorage.getItem(key);\n        if (stored === null) return defaultValue;\n        return JSON.parse(stored) as T;\n    } catch {\n        return defaultValue;\n    }\n}\n\n/**\n * Set item in localStorage\n */\nexport function setItem<T>(key: string, value: T): boolean {\n    try {\n        localStorage.setItem(key, JSON.stringify(value));\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Remove item from localStorage\n */\nexport function removeItem(key: string): boolean {\n    try {\n        localStorage.removeItem(key);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Get raw string from localStorage\n */\nexport function getString(key: string, defaultValue = \"\"): string {\n    try {\n        return localStorage.getItem(key) || defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\n/**\n * Set raw string to localStorage\n */\nexport function setString(key: string, value: string): boolean {\n    try {\n        localStorage.setItem(key, value);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Check if localStorage is available\n */\nexport function isLocalStorageAvailable(): boolean {\n    try {\n        const test = \"__storage_test__\";\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n// ============================================================================\n// SESSION STORAGE\n// ============================================================================\n\n/**\n * Get item from sessionStorage\n */\nexport function getSessionItem<T>(key: string, defaultValue: T): T {\n    try {\n        const stored = sessionStorage.getItem(key);\n        if (stored === null) return defaultValue;\n        return JSON.parse(stored) as T;\n    } catch {\n        return defaultValue;\n    }\n}\n\n/**\n * Set item in sessionStorage\n */\nexport function setSessionItem<T>(key: string, value: T): boolean {\n    try {\n        sessionStorage.setItem(key, JSON.stringify(value));\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Remove item from sessionStorage\n */\nexport function removeSessionItem(key: string): boolean {\n    try {\n        sessionStorage.removeItem(key);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n// ============================================================================\n// INDEXED DB - Simple Key-Value\n// ============================================================================\n\nconst DEFAULT_DB_NAME = \"crossword-storage\";\nconst DEFAULT_STORE_NAME = \"keyvalue\";\nconst DB_VERSION = 1;\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\n\n/**\n * Get IndexedDB database instance\n */\nfunction getDB(dbName = DEFAULT_DB_NAME, storeName = DEFAULT_STORE_NAME): Promise<IDBDatabase> {\n    if (dbPromise) return dbPromise;\n\n    dbPromise = new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, DB_VERSION);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n\n        request.onupgradeneeded = () => {\n            const db = request.result;\n            if (!db.objectStoreNames.contains(storeName)) {\n                db.createObjectStore(storeName);\n            }\n        };\n    });\n\n    return dbPromise;\n}\n\n/**\n * Get value from IndexedDB\n */\nexport async function getIDBItem<T>(key: string): Promise<T | null> {\n    try {\n        const db = await getDB();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(DEFAULT_STORE_NAME, \"readonly\");\n            const store = tx.objectStore(DEFAULT_STORE_NAME);\n            const request = store.get(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(request.result ?? null);\n        });\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Set value in IndexedDB\n */\nexport async function setIDBItem<T>(key: string, value: T): Promise<boolean> {\n    try {\n        const db = await getDB();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(DEFAULT_STORE_NAME, \"readwrite\");\n            const store = tx.objectStore(DEFAULT_STORE_NAME);\n            const request = store.put(value, key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(true);\n        });\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Remove value from IndexedDB\n */\nexport async function removeIDBItem(key: string): Promise<boolean> {\n    try {\n        const db = await getDB();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(DEFAULT_STORE_NAME, \"readwrite\");\n            const store = tx.objectStore(DEFAULT_STORE_NAME);\n            const request = store.delete(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(true);\n        });\n    } catch {\n        return false;\n    }\n}\n\n// ============================================================================\n// INDEXED DB - Structured Storage Class\n// ============================================================================\n\n/**\n * IndexedDB wrapper for structured object storage\n */\nexport class IDBStorage {\n    private dbName: string;\n    private storeName: string;\n    private db: IDBDatabase | null = null;\n\n    constructor(dbName: string, storeName: string) {\n        this.dbName = dbName;\n        this.storeName = storeName;\n    }\n\n    async open(): Promise<IDBDatabase> {\n        if (this.db) return this.db;\n\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, 1);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(this.storeName)) {\n                    db.createObjectStore(this.storeName, { keyPath: \"id\" });\n                }\n            };\n        });\n    }\n\n    async get<T>(id: string): Promise<T | null> {\n        const db = await this.open();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([this.storeName], \"readonly\");\n            const store = tx.objectStore(this.storeName);\n            const request = store.get(id);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(request.result || null);\n        });\n    }\n\n    async set<T extends object>(id: string, value: T): Promise<void> {\n        const db = await this.open();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([this.storeName], \"readwrite\");\n            const store = tx.objectStore(this.storeName);\n            const request = store.put({ id, ...value });\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve();\n        });\n    }\n\n    async delete(id: string): Promise<void> {\n        const db = await this.open();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([this.storeName], \"readwrite\");\n            const store = tx.objectStore(this.storeName);\n            const request = store.delete(id);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve();\n        });\n    }\n\n    async getAll<T>(): Promise<T[]> {\n        const db = await this.open();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([this.storeName], \"readonly\");\n            const store = tx.objectStore(this.storeName);\n            const request = store.getAll();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(request.result || []);\n        });\n    }\n\n    async clear(): Promise<void> {\n        const db = await this.open();\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([this.storeName], \"readwrite\");\n            const store = tx.objectStore(this.storeName);\n            const request = store.clear();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve();\n        });\n    }\n\n    close(): void {\n        this.db?.close();\n        this.db = null;\n    }\n}\n\n// ============================================================================\n// PRE-CONFIGURED STORAGE INSTANCES\n// ============================================================================\n\n/** WorkCenter data storage */\nexport const workCenterStorage = new IDBStorage(\"rs-workcenter\", \"data\");\n\n/** History entries storage */\nexport const historyStorage = new IDBStorage(\"rs-history\", \"entries\");\n\n/** Settings/config storage */\nexport const settingsStorage = new IDBStorage(\"rs-settings\", \"config\");\n"],"names":[],"mappings":"AAwDO,SAAS,OAAA,CAAW,KAAa,YAAA,EAAoB;AACxD,EAAA,IAAI;AACA,IAAA,MAAM,MAAA,GAAS,YAAA,CAAa,OAAA,CAAQ,GAAG,CAAA;AACvC,IAAA,IAAI,MAAA,KAAW,MAAM,OAAO,YAAA;AAC5B,IAAA,OAAO,IAAA,CAAK,MAAM,MAAM,CAAA;AAAA,EAC5B,CAAA,CAAA,MAAQ;AACJ,IAAA,OAAO,YAAA;AAAA,EACX;AACJ;AAKO,SAAS,OAAA,CAAW,KAAa,KAAA,EAAmB;AACvD,EAAA,IAAI;AACA,IAAA,YAAA,CAAa,OAAA,CAAQ,GAAA,EAAK,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA;AAC/C,IAAA,OAAO,IAAA;AAAA,EACX,CAAA,CAAA,MAAQ;AACJ,IAAA,OAAO,KAAA;AAAA,EACX;AACJ;AAiBO,SAAS,SAAA,CAAU,GAAA,EAAa,YAAA,GAAe,EAAA,EAAY;AAC9D,EAAA,IAAI;AACA,IAAA,OAAO,YAAA,CAAa,OAAA,CAAQ,GAAG,CAAA,IAAK,YAAA;AAAA,EACxC,CAAA,CAAA,MAAQ;AACJ,IAAA,OAAO,YAAA;AAAA,EACX;AACJ;AAKO,SAAS,SAAA,CAAU,KAAa,KAAA,EAAwB;AAC3D,EAAA,IAAI;AACA,IAAA,YAAA,CAAa,OAAA,CAAQ,KAAK,KAAK,CAAA;AAC/B,IAAA,OAAO,IAAA;AAAA,EACX,CAAA,CAAA,MAAQ;AACJ,IAAA,OAAO,KAAA;AAAA,EACX;AACJ;;;;"}