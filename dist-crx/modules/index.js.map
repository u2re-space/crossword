{"version":3,"mappings":"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","names":["WStatus","WType","WReflectAction","detectTransportType","isObject","result","createBidirectionalChannel","wrapProxyDescriptor","coreExecuteAction","coreBuildResponse","options","getWorkerChannel","isReflectAction","loadWorker","RemoteChannelHelper","ChannelHandler","ChromeRuntimeObservable","ChromeTabsObservable","ChromePortObservable","e","createOrUseExistingChannel","createChannelContext","getOrCreateContext","createChannelsInContext","importModuleInContext","createHostChannel","wrapChannel","SELF_CHANNEL"],"ignoreList":[],"sources":["../../../../modules/projects/uniform.ts/src/newer/next/types/Interface.ts","../../../../modules/projects/uniform.ts/src/newer/core/TransportCore.ts","../../../../modules/projects/core.ts/src/utils/PromiseTry.ts","../../../../modules/projects/core.ts/src/utils/PromiseUtils.ts","../../../../modules/projects/core.ts/src/utils/ChannelUtils.ts","../../../../modules/projects/core.ts/src/utils/Upsert.ts","../../../../modules/projects/core.ts/src/utils/Primitive.ts","../../../../modules/projects/core.ts/src/utils/Object.ts","../../../../modules/projects/core.ts/src/utils/Promised.ts","../../../../modules/projects/core.ts/src/utils/WRef.ts","../../../../modules/projects/core.ts/src/utils/Convert.ts","../../../../modules/projects/core.ts/src/utils/GridItemUtils.ts","../../../../modules/projects/uniform.ts/src/newer/next/observable/Observable.ts","../../../../modules/projects/uniform.ts/src/newer/next/proxy/Invoker.ts","../../../../modules/projects/uniform.ts/src/newer/next/proxy/Proxy.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/internal/ConnectionModel.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/UnifiedChannel.ts","../../../../modules/projects/uniform.ts/src/newer/next/proxy/RequestProxy.ts","../../../../modules/projects/uniform.ts/src/newer/core/Alias.ts","../../../../modules/projects/uniform.ts/src/newer/core/Useful.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/Channels.ts","../../../../modules/projects/uniform.ts/src/newer/next/storage/DataBase.ts","../../../../modules/projects/uniform.ts/src/newer/core/RequestHandler.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/Connection.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/Transport.ts","../../../../modules/projects/uniform.ts/src/newer/next/storage/Storage.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/ChannelContext.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/TransportObservable.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/Worker.ts","../../../../modules/projects/uniform.ts/src/newer/next/observable/ChromeObservable.ts","../../../../modules/projects/uniform.ts/src/newer/next/observable/SocketIOObservable.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/SharedWorkerTransport.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/AtomicsTransport.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/RTCDataChannelTransport.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/PortTransport.ts","../../../../modules/projects/uniform.ts/src/newer/next/storage/TransferableStorage.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/ServiceWorkerHost.ts","../../../../modules/projects/uniform.ts/src/newer/next/transport/UnifiedTransport.ts","../../../../modules/projects/uniform.ts/src/newer/next/storage/Queued.ts","../../../../modules/projects/uniform.ts/src/newer/messaging/MessageQueue.ts","../../../../modules/projects/uniform.ts/src/newer/next/utils/Env.ts","../../../../modules/projects/uniform.ts/src/newer/next/utils/Wrappers.ts","../../../../modules/projects/uniform.ts/src/newer/next/utils/Utils.ts","../../../../modules/projects/uniform.ts/src/newer/messaging/UnifiedMessaging.ts","../../../../modules/projects/uniform.ts/src/newer/messaging/ServiceChannelManager.ts","../../../../modules/projects/uniform.ts/src/newer/next/channel/ChannelMessageHandler.ts","../../../../modules/projects/uniform.ts/src/newer/index.ts"],"sourcesContent":["/**\n * Unified Types & Interfaces\n *\n * All shared types for uniform.ts in one place.\n */\n\n// ============================================================================\n// ENUMS\n// ============================================================================\n\nexport enum WStatus { SUCCESS = \"success\", ERROR = \"error\" }\n\nexport enum WType {\n    PRIMITIVE = \"primitive\", NUMBER = \"number\", STRING = \"string\",\n    BOOLEAN = \"boolean\", BIGINT = \"bigint\", UNDEFINED = \"undefined\",\n    NULL = \"null\", OBJECT = \"object\", FUNCTION = \"function\",\n    ARRAY = \"array\", MAP = \"map\", SET = \"set\", SYMBOL = \"symbol\",\n    WEAK_REF = \"weakRef\", PROMISE = \"promise\", UNKNOWN = \"unknown\"\n}\n\nexport enum WReflectAction {\n    GET = \"get\", SET = \"set\", CALL = \"call\", APPLY = \"apply\",\n    CONSTRUCT = \"construct\", DELETE = \"delete\", DELETE_PROPERTY = \"deleteProperty\",\n    HAS = \"has\", OWN_KEYS = \"ownKeys\",\n    GET_OWN_PROPERTY_DESCRIPTOR = \"getOwnPropertyDescriptor\",\n    GET_PROPERTY_DESCRIPTOR = \"getPropertyDescriptor\",\n    GET_PROTOTYPE_OF = \"getPrototypeOf\", SET_PROTOTYPE_OF = \"setPrototypeOf\",\n    IS_EXTENSIBLE = \"isExtensible\", PREVENT_EXTENSIONS = \"preventExtensions\",\n    TRANSFER = \"transfer\", IMPORT = \"import\", DISPOSE = \"dispose\"\n}\n\n// ============================================================================\n// REQUEST/RESPONSE TYPES\n// ============================================================================\n\nexport interface WReflectDescriptor<T = any> {\n    $isDescriptor?: boolean;\n    path: string[];\n    channel: string;\n    owner: string;\n    primitive: boolean;\n    writable: boolean;\n    enumerable: boolean;\n    configurable: boolean;\n    argumentCount: number;\n}\n\nexport interface WReq<T = any> {\n    channel: string;\n    sender: string;\n    path: string[];\n    action: WReflectAction | string;\n    reqId?: string;\n    args: any[] | any;\n    params?: Record<string, T>;\n    data?: any;\n}\n\nexport interface WError<T = any> { message: string; }\nexport interface WSuccess<T = any> { message: string; }\n\nexport interface WResp<T = any> {\n    status?: number;\n    reason?: WError<T> | WSuccess<T>;\n    message?: string;\n    result?: T | null;\n    received?: T | null;\n    descriptor?: WReflectDescriptor | null;\n    type?: WType | string | null;\n    error?: string | null;\n}\n\n/**\n * Compact cross-transport binary/text payload descriptor.\n * Designed for File/Blob/base64/data-url/url values normalized to hash-named data.\n */\nexport interface DataAssetEnvelope {\n    hash: string;\n    name: string;\n    mimeType: string;\n    size: number;\n    source?: \"file\" | \"blob\" | \"data-url\" | \"base64\" | \"url\" | \"uri\" | \"text\";\n    data?: string | ArrayBuffer;\n}\n\n// ============================================================================\n// OBSERVABLE TYPES\n// ============================================================================\n\n/** Observer interface (WICG-like) */\nexport interface Observer<T = any> {\n    next?: (value: T) => void;\n    error?: (err: Error) => void;\n    complete?: () => void;\n}\n\n/** Subscription handle */\nexport interface Subscription {\n    unsubscribe(): void;\n    readonly closed: boolean;\n}\n\n/** Subscribable interface */\nexport interface Subscribable<T = any> {\n    subscribe(observer: Observer<T> | ((value: T) => void)): Subscription;\n}\n\n/** Subscriber (passed to Observable producer) */\nexport interface Subscriber<T = any> {\n    next(value: T): void;\n    error(err: Error): void;\n    complete(): void;\n    signal: AbortSignal;\n    readonly active: boolean;\n}\n\n/** Observable producer function */\nexport type Producer<T = any> = (subscriber: Subscriber<T>) => (() => void) | void;\n\n// ============================================================================\n// CHANNEL TYPES\n// ============================================================================\n\n/** Channel message envelope */\nexport interface ChannelMessage<T = any> {\n    id: string;\n    channel: string;\n    sender: string;\n    type: \"request\" | \"response\" | \"event\" | \"signal\" | \"exchange\";\n    payload?: T;\n    reqId?: string;\n    timestamp?: number;\n    transferable?: Transferable[];\n}\n\n/** Channel state */\nexport type ChannelState = \"disconnected\" | \"connecting\" | \"connected\" | \"closed\";\n\n/** Channel metadata */\nexport interface ChannelMeta {\n    id?: string;\n    name: string;\n    state?: ChannelState;\n    isHost?: boolean;\n    transport?: TransportType;\n    target?: string;\n    options?: Record<string, any>;\n    connectedChannels?: Set<string>;\n}\n\n// ============================================================================\n// TRANSPORT TYPES\n// ============================================================================\n\n/** Transport type identifier */\nexport type TransportType =\n    | \"worker\"\n    | \"shared-worker\"\n    | \"service-worker\"\n    | \"broadcast\"\n    | \"message-port\"\n    | \"websocket\"\n    | \"chrome-runtime\"\n    | \"chrome-tabs\"\n    | \"chrome-port\"\n    | \"chrome-external\"\n    | \"socket-io\"\n    | \"rtc-data\"\n    | \"atomics\"\n    | \"ring-buffer\"\n    | \"self\"\n    | \"internal\";\n\n/** Transport target (runtime objects or string identifiers) */\nexport type TransportTarget =\n    | Worker\n    | MessagePort\n    | BroadcastChannel\n    | WebSocket\n    | RTCDataChannel\n    | \"chrome-runtime\"\n    | \"chrome-tabs\"\n    | \"chrome-port\"\n    | \"chrome-external\"\n    | \"service-worker-client\"\n    | \"service-worker-host\"\n    | \"shared-worker\"\n    | \"rtc-data\"\n    | \"atomics\"\n    | \"self\";\n\n/** Connection options */\nexport interface ConnectionOptions {\n    timeout?: number;\n    autoReconnect?: boolean;\n    reconnectInterval?: number;\n    maxReconnectAttempts?: number;\n    bufferMessages?: boolean;\n    bufferSize?: number;\n    metadata?: Record<string, any>;\n}\n\n// ============================================================================\n// ADVANCED TRANSPORT TYPES\n// ============================================================================\n\n/** SharedArrayBuffer configuration */\nexport interface AtomicsConfig {\n    bufferSize?: number;\n    maxMessageSize?: number;\n    compression?: boolean;\n    waitTimeout?: number;\n    useAsyncWait?: boolean;\n}\n\n/** WebRTC DataChannel configuration */\nexport interface RTCConfig {\n    iceServers?: RTCIceServer[];\n    dataChannelOptions?: RTCDataChannelInit;\n    connectionTimeout?: number;\n    binaryFormat?: \"json\" | \"cbor\" | \"msgpack\";\n}\n\n/** SharedWorker configuration */\nexport interface SharedWorkerConfig {\n    name?: string;\n    credentials?: RequestCredentials;\n    type?: WorkerType;\n    autoConnect?: boolean;\n}\n\n/** MessagePort configuration */\nexport interface PortConfig {\n    autoStart?: boolean;\n    timeout?: number;\n    retryOnError?: boolean;\n    maxRetries?: number;\n    keepAlive?: boolean;\n    keepAliveInterval?: number;\n}\n\n/** Transferable storage configuration */\nexport interface TransferableConfig {\n    dbName: string;\n    storeName?: string;\n    version?: number;\n    enableChangeTracking?: boolean;\n    autoCleanupExpired?: boolean;\n}\n\n/** Transport capability flags */\nexport interface TransportCapabilities {\n    transfer: boolean;\n    binary: boolean;\n    bidirectional: boolean;\n    broadcast: boolean;\n    persistent: boolean;\n    ordered: boolean;\n    reliable: boolean;\n}\n\n// ============================================================================\n// HANDLER TYPES\n// ============================================================================\n\n/** Response function */\nexport type ResponderFn<T = any> = (result: T, transfer?: Transferable[]) => void;\n\n/** Invoker handler */\nexport type InvokerHandler<T = ChannelMessage> = (\n    data: T,\n    respond: ResponderFn<T>,\n    subscriber: Subscriber<T>\n) => void | Promise<void>;\n\n/** Message handler callback */\nexport type MessageHandler<T = ChannelMessage> = (\n    data: T,\n    respond: ResponderFn<T>\n) => void | Promise<void>;\n\n/** Send function */\nexport type SendFn<T = any> = (msg: T, transfer?: Transferable[]) => void;\n\n// ============================================================================\n// PENDING REQUEST\n// ============================================================================\n\nexport interface PendingRequest<T = any> {\n    resolve: (value: T) => void;\n    reject: (error: Error) => void;\n    timestamp: number;\n}\n","/**\n * Transport Core - Unified transport send/listen utilities\n *\n * Consolidates all transport-specific send and listen logic\n * into reusable functions to eliminate code duplication.\n *\n * Supports:\n * - Worker / SharedWorker / ServiceWorker\n * - WebSocket\n * - BroadcastChannel\n * - MessagePort / MessageChannel\n * - Chrome Extension API\n * - Socket.IO\n * - SharedArrayBuffer (via specialized transport)\n * - WebRTC DataChannel (via specialized transport)\n */\n\n/// <reference lib=\"webworker\" />\n\ndeclare const clients: Clients | undefined;\n\nimport type { ChannelMessage } from \"../next/observable/Observable\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type TransportTarget =\n    | Worker\n    | SharedWorker\n    | MessagePort\n    | BroadcastChannel\n    | WebSocket\n    | \"chrome-runtime\"\n    | \"chrome-tabs\"\n    | \"chrome-port\"\n    | \"chrome-external\"\n    | \"socket-io\"\n    | \"service-worker-client\"\n    | \"service-worker-host\"\n    | \"shared-worker\"\n    | \"rtc-data\"\n    | \"atomics\"\n    | \"self\";\n\nexport type TransportType =\n    | \"worker\"\n    | \"shared-worker\"\n    | \"service-worker\"\n    | \"broadcast\"\n    | \"message-port\"\n    | \"websocket\"\n    | \"chrome-runtime\"\n    | \"chrome-tabs\"\n    | \"chrome-port\"\n    | \"chrome-external\"\n    | \"socket-io\"\n    | \"rtc-data\"\n    | \"atomics\"\n    | \"self\"\n    | \"internal\";\n\nexport type SendFn<T = any> = (msg: T, transfer?: Transferable[]) => void;\nexport type ListenFn = (handler: (data: any) => void) => () => void;\n\nexport interface TransportMeta {\n    type: TransportType;\n    supports: {\n        transfer: boolean;\n        binary: boolean;\n        bidirectional: boolean;\n        broadcast: boolean;\n        persistent: boolean;\n    };\n}\n\n// ============================================================================\n// TRANSPORT DETECTION\n// ============================================================================\n\nexport function detectTransportType(transport: TransportTarget): TransportType {\n    if (transport instanceof Worker) return \"worker\";\n    if (typeof SharedWorker !== \"undefined\" && transport instanceof SharedWorker) return \"shared-worker\";\n    if (transport instanceof MessagePort) return \"message-port\";\n    if (transport instanceof BroadcastChannel) return \"broadcast\";\n    if (transport instanceof WebSocket) return \"websocket\";\n    if (\n        typeof chrome !== \"undefined\" &&\n        transport &&\n        typeof transport === \"object\" &&\n        typeof (transport as any).postMessage === \"function\" &&\n        (transport as any).onMessage?.addListener\n    ) {\n        return \"chrome-port\";\n    }\n    if (transport === \"chrome-runtime\") return \"chrome-runtime\";\n    if (transport === \"chrome-tabs\") return \"chrome-tabs\";\n    if (transport === \"chrome-port\") return \"chrome-port\";\n    if (transport === \"chrome-external\") return \"chrome-external\";\n    if (transport === \"socket-io\") return \"socket-io\";\n    if (transport === \"service-worker-client\") return \"service-worker\";\n    if (transport === \"service-worker-host\") return \"service-worker\";\n    if (transport === \"shared-worker\") return \"shared-worker\";\n    if (transport === \"rtc-data\") return \"rtc-data\";\n    if (transport === \"atomics\") return \"atomics\";\n    if (transport === \"self\") return \"self\";\n    return \"internal\";\n}\n\nexport function getTransportMeta(transport: TransportTarget): TransportMeta {\n    const type = detectTransportType(transport);\n\n    const meta: Record<TransportType, TransportMeta[\"supports\"]> = {\n        \"worker\": { transfer: true, binary: true, bidirectional: true, broadcast: false, persistent: true },\n        \"shared-worker\": { transfer: true, binary: true, bidirectional: true, broadcast: true, persistent: true },\n        \"service-worker\": { transfer: true, binary: true, bidirectional: true, broadcast: true, persistent: true },\n        \"broadcast\": { transfer: false, binary: false, bidirectional: false, broadcast: true, persistent: false },\n        \"message-port\": { transfer: true, binary: true, bidirectional: true, broadcast: false, persistent: false },\n        \"websocket\": { transfer: false, binary: true, bidirectional: true, broadcast: false, persistent: true },\n        \"chrome-runtime\": { transfer: false, binary: false, bidirectional: true, broadcast: true, persistent: false },\n        \"chrome-tabs\": { transfer: false, binary: false, bidirectional: true, broadcast: false, persistent: false },\n        \"chrome-port\": { transfer: false, binary: false, bidirectional: true, broadcast: false, persistent: true },\n        \"chrome-external\": { transfer: false, binary: false, bidirectional: true, broadcast: false, persistent: false },\n        \"socket-io\": { transfer: false, binary: true, bidirectional: true, broadcast: true, persistent: true },\n        \"rtc-data\": { transfer: false, binary: true, bidirectional: true, broadcast: false, persistent: true },\n        \"atomics\": { transfer: false, binary: true, bidirectional: true, broadcast: false, persistent: true },\n        \"self\": { transfer: true, binary: true, bidirectional: true, broadcast: false, persistent: true },\n        \"internal\": { transfer: false, binary: false, bidirectional: true, broadcast: false, persistent: false }\n    };\n\n    return { type, supports: meta[type] };\n}\n\n// ============================================================================\n// UNIFIED SEND\n// ============================================================================\n\n/**\n * Create send function for any transport type\n */\nexport function createTransportSender(\n    transport: TransportTarget,\n    options?: {\n        tabId?: number;\n        clientId?: string;\n        portName?: string;\n        externalId?: string;\n        socketEvent?: string;\n    }\n): SendFn<ChannelMessage> {\n    return (msg, transfer) => {\n        const transferable = transfer ?? (msg as any)?.transferable ?? [];\n        const { transferable: _, ...data } = msg as any;\n\n        // Worker\n        if (transport instanceof Worker) {\n            transport.postMessage(data, { transfer: transferable });\n            return;\n        }\n\n        // SharedWorker - send via port\n        if (typeof SharedWorker !== \"undefined\" && transport instanceof SharedWorker) {\n            transport.port.postMessage(data, { transfer: transferable });\n            return;\n        }\n\n        // MessagePort\n        if (transport instanceof MessagePort) {\n            transport.postMessage(data, { transfer: transferable });\n            return;\n        }\n\n        // BroadcastChannel (no transfer support)\n        if (transport instanceof BroadcastChannel) {\n            transport.postMessage(data);\n            return;\n        }\n\n        // WebSocket\n        if (transport instanceof WebSocket) {\n            if (transport.readyState === WebSocket.OPEN) {\n                // Support binary if ArrayBuffer\n                if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n                    transport.send(data as ArrayBuffer);\n                } else {\n                    transport.send(JSON.stringify(data));\n                }\n            }\n            return;\n        }\n\n        // Chrome Runtime\n        if (transport === \"chrome-runtime\") {\n            if (typeof chrome !== \"undefined\" && chrome.runtime) {\n                chrome.runtime.sendMessage(data);\n            }\n            return;\n        }\n\n        // Chrome Tabs\n        if (transport === \"chrome-tabs\") {\n            if (typeof chrome !== \"undefined\" && chrome.tabs) {\n                const tabId = options?.tabId ?? (msg as any)?._tabId;\n                if (tabId != null) chrome.tabs.sendMessage(tabId, data);\n            }\n            return;\n        }\n\n        // Chrome Port\n        if (transport === \"chrome-port\") {\n            if (typeof chrome !== \"undefined\" && chrome.runtime) {\n                const portName = options?.portName ?? (msg as any)?._portName;\n                if (portName) {\n                    const tabId = options?.tabId ?? (msg as any)?._tabId;\n                    const port = tabId != null && chrome.tabs?.connect\n                        ? chrome.tabs.connect(tabId, { name: portName })\n                        : chrome.runtime.connect({ name: portName });\n                    port.postMessage(data);\n                }\n            }\n            return;\n        }\n\n        // Chrome External (send to another extension/app)\n        if (transport === \"chrome-external\") {\n            if (typeof chrome !== \"undefined\" && chrome.runtime) {\n                const externalId = options?.externalId ?? (msg as any)?._externalId;\n                if (externalId) chrome.runtime.sendMessage(externalId, data);\n            }\n            return;\n        }\n\n        // Service Worker Client (from page to SW)\n        if (transport === \"service-worker-client\") {\n            if (\"serviceWorker\" in navigator) {\n                navigator.serviceWorker.ready.then((reg) => {\n                    reg.active?.postMessage(data, transferable);\n                });\n            }\n            return;\n        }\n\n        // Service Worker Host (from SW to client)\n        if (transport === \"service-worker-host\") {\n            if (typeof clients !== \"undefined\") {\n                const clientId = options?.clientId ?? (msg as any)?._clientId;\n                if (clientId) {\n                    clients.get(clientId).then((c) => c?.postMessage(data, transferable));\n                } else {\n                    clients.matchAll({ includeUncontrolled: true }).then((all) => {\n                        all.forEach((c) => c.postMessage(data, transferable));\n                    });\n                }\n            }\n            return;\n        }\n\n        // Self (Worker/SW context)\n        if (transport === \"self\") {\n            if (typeof self !== \"undefined\" && \"postMessage\" in self) {\n                (self as any).postMessage(data, { transfer: transferable });\n            }\n            return;\n        }\n    };\n}\n\n// ============================================================================\n// UNIFIED LISTEN\n// ============================================================================\n\n/**\n * Create listener setup for any transport type\n * Returns cleanup function\n */\nexport function createTransportListener(\n    transport: TransportTarget,\n    onMessage: (data: any) => void,\n    onError?: (err: Error) => void,\n    onClose?: () => void,\n    options?: {\n        portName?: string;\n        tabId?: number;\n        socketEvents?: string[];\n    }\n): () => void {\n    const msgHandler = (e: MessageEvent) => {\n        if (transport instanceof WebSocket && typeof e.data === \"string\") {\n            try { onMessage(JSON.parse(e.data)); }\n            catch (err) { onError?.(err as Error); }\n        } else if (transport instanceof WebSocket && e.data instanceof ArrayBuffer) {\n            onMessage(e.data);\n        } else {\n            onMessage(e.data);\n        }\n    };\n\n    const errHandler = (e: ErrorEvent | Event) => {\n        onError?.(new Error((e as ErrorEvent).message ?? \"Transport error\"));\n    };\n\n    const closeHandler = () => onClose?.();\n\n    // Worker\n    if (transport instanceof Worker) {\n        transport.addEventListener(\"message\", msgHandler);\n        transport.addEventListener(\"error\", errHandler);\n        return () => {\n            transport.removeEventListener(\"message\", msgHandler);\n            transport.removeEventListener(\"error\", errHandler);\n        };\n    }\n\n    // SharedWorker\n    if (typeof SharedWorker !== \"undefined\" && transport instanceof SharedWorker) {\n        transport.port.addEventListener(\"message\", msgHandler);\n        transport.port.addEventListener(\"messageerror\", errHandler as any);\n        transport.port.start();\n        return () => {\n            transport.port.removeEventListener(\"message\", msgHandler);\n            transport.port.removeEventListener(\"messageerror\", errHandler as any);\n            transport.port.close();\n        };\n    }\n\n    // MessagePort\n    if (transport instanceof MessagePort) {\n        transport.addEventListener(\"message\", msgHandler);\n        transport.start();\n        return () => {\n            transport.removeEventListener(\"message\", msgHandler);\n            transport.close();\n        };\n    }\n\n    // BroadcastChannel\n    if (transport instanceof BroadcastChannel) {\n        transport.addEventListener(\"message\", msgHandler);\n        return () => {\n            transport.removeEventListener(\"message\", msgHandler);\n            transport.close();\n        };\n    }\n\n    // WebSocket\n    if (transport instanceof WebSocket) {\n        transport.addEventListener(\"message\", msgHandler);\n        transport.addEventListener(\"error\", errHandler);\n        transport.addEventListener(\"close\", closeHandler);\n        return () => {\n            transport.removeEventListener(\"message\", msgHandler);\n            transport.removeEventListener(\"error\", errHandler);\n            transport.removeEventListener(\"close\", closeHandler);\n            if (transport.readyState === WebSocket.OPEN) {\n                transport.close();\n            }\n        };\n    }\n\n    // Chrome Runtime\n    if (transport === \"chrome-runtime\") {\n        if (typeof chrome !== \"undefined\" && chrome.runtime) {\n            const listener = (msg: any) => { onMessage(msg); return false; };\n            chrome.runtime.onMessage.addListener(listener);\n            return () => chrome.runtime.onMessage.removeListener(listener);\n        }\n    }\n\n    // Chrome Tabs (tab-filtered runtime messages)\n    if (transport === \"chrome-tabs\") {\n        if (typeof chrome !== \"undefined\" && chrome.runtime) {\n            const tabId = options?.tabId;\n            if (tabId != null) {\n                return createChromeTabsListener(tabId, (msg) => onMessage(msg));\n            }\n            const listener = (msg: any) => { onMessage(msg); return false; };\n            chrome.runtime.onMessage.addListener(listener);\n            return () => chrome.runtime.onMessage.removeListener(listener);\n        }\n    }\n\n    // Chrome Port\n    if (transport === \"chrome-port\") {\n        if (typeof chrome !== \"undefined\" && chrome.runtime) {\n            const portName = options?.portName;\n            if (portName) {\n                const port = chrome.runtime.connect({ name: portName });\n                port.onMessage.addListener(onMessage);\n                port.onDisconnect.addListener(closeHandler);\n                return () => port.disconnect();\n            }\n        }\n    }\n\n    // Chrome External (messages from external extension/app)\n    if (transport === \"chrome-external\") {\n        if (typeof chrome !== \"undefined\" && chrome.runtime?.onMessageExternal) {\n            const listener = (msg: any) => { onMessage(msg); return false; };\n            chrome.runtime.onMessageExternal.addListener(listener);\n            return () => chrome.runtime.onMessageExternal.removeListener(listener);\n        }\n    }\n\n    // Service Worker Client\n    if (transport === \"service-worker-client\") {\n        if (\"serviceWorker\" in navigator) {\n            navigator.serviceWorker.addEventListener(\"message\", msgHandler);\n            return () => navigator.serviceWorker.removeEventListener(\"message\", msgHandler);\n        }\n    }\n\n    // Service Worker Host / Self\n    if (transport === \"service-worker-host\" || transport === \"self\") {\n        const handler = (e: MessageEvent) => {\n            const clientId = transport === \"service-worker-host\" ? (e.source as any)?.id : undefined;\n            onMessage(clientId ? { ...e.data, _clientId: clientId } : e.data);\n        };\n        self.addEventListener(\"message\", handler as any);\n        return () => self.removeEventListener(\"message\", handler as any);\n    }\n\n    return () => {};\n}\n\n// ============================================================================\n// CHROME LISTENER WITH SEND RESPONSE\n// ============================================================================\n\nexport function createChromeListener(\n    onMessage: (msg: any, sendResponse: (resp: any) => void, sender?: chrome.runtime.MessageSender) => boolean | void,\n    options?: { external?: boolean }\n): () => void {\n    if (typeof chrome === \"undefined\" || !chrome.runtime) return () => {};\n\n    const listener = (\n        message: any,\n        sender: chrome.runtime.MessageSender,\n        sendResponse: (response?: any) => void\n    ) => onMessage(message, sendResponse, sender);\n\n    if (options?.external && chrome.runtime.onMessageExternal) {\n        chrome.runtime.onMessageExternal.addListener(listener);\n        return () => chrome.runtime.onMessageExternal.removeListener(listener);\n    }\n\n    chrome.runtime.onMessage.addListener(listener);\n    return () => chrome.runtime.onMessage.removeListener(listener);\n}\n\n// ============================================================================\n// CHROME TABS LISTENER\n// ============================================================================\n\nexport function createChromeTabsListener(\n    tabId: number,\n    onMessage: (msg: any, sender?: chrome.runtime.MessageSender) => void\n): () => void {\n    if (typeof chrome === \"undefined\" || !chrome.runtime) return () => {};\n\n    const listener = (msg: any, sender: chrome.runtime.MessageSender) => {\n        if (sender.tab?.id === tabId) {\n            onMessage(msg, sender);\n        }\n    };\n\n    chrome.runtime.onMessage.addListener(listener);\n    return () => chrome.runtime.onMessage.removeListener(listener);\n}\n\n// ============================================================================\n// WEBSOCKET ENHANCED\n// ============================================================================\n\nexport interface WebSocketOptions {\n    protocols?: string | string[];\n    binaryType?: BinaryType;\n    reconnect?: boolean;\n    reconnectInterval?: number;\n    maxReconnectAttempts?: number;\n}\n\nexport function createWebSocketTransport(\n    url: string,\n    options: WebSocketOptions = {}\n): {\n    socket: WebSocket;\n    send: SendFn;\n    listen: (handler: (data: any) => void) => () => void;\n    reconnect: () => void;\n    close: () => void;\n} {\n    let socket = new WebSocket(url, options.protocols);\n    if (options.binaryType) socket.binaryType = options.binaryType;\n\n    let reconnectAttempts = 0;\n    let reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n\n    const send: SendFn = (msg, transfer) => {\n        if (socket.readyState !== WebSocket.OPEN) return;\n\n        if (msg instanceof ArrayBuffer || ArrayBuffer.isView(msg)) {\n            socket.send(msg as ArrayBuffer);\n        } else {\n            socket.send(JSON.stringify(msg));\n        }\n    };\n\n    const reconnect = () => {\n        if (reconnectAttempts >= (options.maxReconnectAttempts ?? 5)) return;\n\n        reconnectAttempts++;\n        socket = new WebSocket(url, options.protocols);\n        if (options.binaryType) socket.binaryType = options.binaryType;\n    };\n\n    const close = () => {\n        if (reconnectTimer) clearTimeout(reconnectTimer);\n        socket.close();\n    };\n\n    if (options.reconnect) {\n        socket.addEventListener(\"close\", () => {\n            reconnectTimer = setTimeout(reconnect, options.reconnectInterval ?? 3000);\n        });\n    }\n\n    return {\n        socket,\n        send,\n        listen: (handler) => {\n            const h = (e: MessageEvent) => {\n                if (typeof e.data === \"string\") {\n                    try { handler(JSON.parse(e.data)); } catch {}\n                } else {\n                    handler(e.data);\n                }\n            };\n            socket.addEventListener(\"message\", h);\n            return () => socket.removeEventListener(\"message\", h);\n        },\n        reconnect,\n        close\n    };\n}\n\n// ============================================================================\n// BROADCAST CHANNEL ENHANCED\n// ============================================================================\n\nexport function createBroadcastTransport(channelName: string): {\n    channel: BroadcastChannel;\n    send: SendFn;\n    listen: (handler: (data: any) => void) => () => void;\n    close: () => void;\n} {\n    const channel = new BroadcastChannel(channelName);\n\n    return {\n        channel,\n        send: (msg) => channel.postMessage(msg),\n        listen: (handler) => {\n            const h = (e: MessageEvent) => handler(e.data);\n            channel.addEventListener(\"message\", h);\n            return () => channel.removeEventListener(\"message\", h);\n        },\n        close: () => channel.close()\n    };\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const TransportCoreFactory = {\n    createSender: createTransportSender,\n    createListener: createTransportListener,\n    detectType: detectTransportType,\n    getMeta: getTransportMeta,\n    chrome: {\n        createListener: createChromeListener,\n        createTabsListener: createChromeTabsListener\n    },\n    websocket: createWebSocketTransport,\n    broadcast: createBroadcastTransport\n};\n","declare global {\n    interface PromiseConstructor {\n        /**\n         * Executes the provided callback and wraps its result in a resolved promise.\n         * If the callback throws, the returned promise is rejected with that error.\n         * When a non-function value is provided, it is wrapped in Promise.resolve.\n         */\n        try<T>(callback: (...args: any[]) => T | PromiseLike<T>, ...args: any[]): Promise<T>;\n        try<T>(value: T): Promise<T>;\n    }\n}\n\n// Ensure the polyfill is applied exactly once in any environment.\nif (typeof Promise !== \"undefined\" && typeof Promise.try !== \"function\") {\n    Promise.try = function <T>(\n        callbackOrValue: ((...args: any[]) => T | PromiseLike<T>) | T,\n        ...args: any[]\n    ): Promise<T> {\n        try {\n            if (typeof callbackOrValue === \"function\") {\n                return Promise.resolve((callbackOrValue as (...args: any[]) => T)(...args));\n            }\n            return Promise.resolve(callbackOrValue as T);\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    };\n}\n\nexport {};\n\n","/**\n * Promise utilities for advanced async operations\n */\n\n/**\n * Create a promised value that resolves when set\n */\nexport function createDeferred<T = any>(): {\n    promise: Promise<T>;\n    resolve: (value: T) => void;\n    reject: (error: any) => void;\n    isResolved: boolean;\n    isRejected: boolean;\n} {\n    let resolve: (value: T) => void;\n    let reject: (error: any) => void;\n    let isResolved = false;\n    let isRejected = false;\n\n    const promise = new Promise<T>((res, rej) => {\n        resolve = (value) => {\n            if (!isResolved && !isRejected) {\n                isResolved = true;\n                res(value);\n            }\n        };\n        reject = (error) => {\n            if (!isResolved && !isRejected) {\n                isRejected = true;\n                rej(error);\n            }\n        };\n    });\n\n    return {\n        promise,\n        resolve: resolve!,\n        reject: reject!,\n        get isResolved() { return isResolved; },\n        get isRejected() { return isRejected; }\n    };\n}\n\n/**\n * Queue async operations and process them sequentially\n */\nexport class AsyncQueue {\n    private queue: Array<() => Promise<any>> = [];\n    private processing = false;\n\n    async add<T>(operation: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await operation();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n\n            this.process();\n        });\n    }\n\n    private async process(): Promise<void> {\n        if (this.processing || this.queue.length === 0) return;\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const operation = this.queue.shift()!;\n            await operation();\n        }\n\n        this.processing = false;\n    }\n\n    get length(): number {\n        return this.queue.length;\n    }\n\n    get isProcessing(): boolean {\n        return this.processing;\n    }\n}\n\n/**\n * Create a timeout promise that rejects after specified time\n */\nexport function withTimeout<T>(promise: Promise<T>, timeoutMs: number, timeoutMessage = 'Operation timed out'): Promise<T> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => reject(new Error(timeoutMessage)), timeoutMs);\n    });\n\n    return Promise.race([promise, timeoutPromise]);\n}\n\n/**\n * Retry an async operation with exponential backoff\n */\nexport async function retry<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n    initialDelay: number = 1000,\n    backoffMultiplier: number = 2\n): Promise<T> {\n    let lastError: Error;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n            return await operation();\n        } catch (error) {\n            lastError = error as Error;\n\n            if (attempt < maxRetries) {\n                const delay = initialDelay * Math.pow(backoffMultiplier, attempt);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n\n    throw lastError!;\n}\n\n/**\n * Execute operations concurrently with a limit\n */\nexport async function concurrentLimit<T>(\n    operations: Array<() => Promise<T>>,\n    limit: number\n): Promise<T[]> {\n    const results: T[] = [];\n    const executing: Promise<void>[] = [];\n\n    for (let i = 0; i < operations.length; i++) {\n        const operation = operations[i];\n        const promise = Promise.resolve().then(async () => {\n            try {\n                const result = await operation();\n                results[i] = result;\n            } catch (error) {\n                throw error;\n            }\n        });\n\n        results[i] = undefined as any; // Placeholder\n        executing.push(promise);\n\n        if (executing.length >= limit) {\n            await Promise.race(executing);\n            executing.splice(executing.findIndex(p => p === promise), 1);\n        }\n    }\n\n    await Promise.all(executing);\n    return results;\n}","/**\n * Channel utilities for managing communication channels\n */\n\n/**\n * Channel registry for managing multiple channels\n */\nexport class ChannelRegistry {\n    private channels = new Map<string, any>();\n    private listeners = new Map<string, Set<Function>>();\n\n    /**\n     * Register a channel\n     */\n    register<T>(name: string, channel: T): T {\n        this.channels.set(name, channel);\n\n        // Notify listeners\n        const listeners = this.listeners.get(name);\n        if (listeners) {\n            for (const listener of listeners) {\n                try {\n                    listener(channel);\n                } catch (error) {\n                    console.error(`[ChannelRegistry] Listener error for ${name}:`, error);\n                }\n            }\n        }\n\n        return channel;\n    }\n\n    /**\n     * Get a registered channel\n     */\n    get<T>(name: string): T | undefined {\n        return this.channels.get(name);\n    }\n\n    /**\n     * Check if a channel is registered\n     */\n    has(name: string): boolean {\n        return this.channels.has(name);\n    }\n\n    /**\n     * Unregister a channel\n     */\n    unregister(name: string): boolean {\n        const existed = this.channels.delete(name);\n        if (existed) {\n            // Notify listeners that channel was removed\n            const listeners = this.listeners.get(name);\n            if (listeners) {\n                for (const listener of listeners) {\n                    try {\n                        listener(null);\n                    } catch (error) {\n                        console.error(`[ChannelRegistry] Unregister listener error for ${name}:`, error);\n                    }\n                }\n            }\n        }\n        return existed;\n    }\n\n    /**\n     * Listen for channel registration/unregistration\n     */\n    onChannelChange(name: string, listener: (channel: any) => void): () => void {\n        if (!this.listeners.has(name)) {\n            this.listeners.set(name, new Set());\n        }\n\n        const listeners = this.listeners.get(name)!;\n        listeners.add(listener);\n\n        // If channel already exists, notify immediately\n        if (this.channels.has(name)) {\n            try {\n                listener(this.channels.get(name));\n            } catch (error) {\n                console.error(`[ChannelRegistry] Initial listener error for ${name}:`, error);\n            }\n        }\n\n        // Return unsubscribe function\n        return () => {\n            listeners.delete(listener);\n            if (listeners.size === 0) {\n                this.listeners.delete(name);\n            }\n        };\n    }\n\n    /**\n     * Get all registered channel names\n     */\n    getChannelNames(): string[] {\n        return Array.from(this.channels.keys());\n    }\n\n    /**\n     * Clear all channels and listeners\n     */\n    clear(): void {\n        this.channels.clear();\n        this.listeners.clear();\n    }\n}\n\n/**\n * Singleton channel registry instance\n */\nexport const globalChannelRegistry = new ChannelRegistry();\n\n/**\n * Create a typed channel proxy\n */\nexport function createChannelProxy<T extends Record<string, any>>(\n    channel: any,\n    methods: (keyof T)[]\n): T {\n    const proxy = {} as T;\n\n    for (const method of methods) {\n        (proxy as any)[method] = (...args: any[]) => {\n            return channel.request(method as string, args);\n        };\n    }\n\n    return proxy;\n}\n\n/**\n * Channel health monitoring\n */\nexport class ChannelHealthMonitor {\n    private healthChecks = new Map<string, () => Promise<boolean>>();\n    private intervals = new Map<string, number>();\n    private healthStatus = new Map<string, boolean>();\n\n    /**\n     * Register a health check for a channel\n     */\n    registerHealthCheck(\n        channelName: string,\n        healthCheck: () => Promise<boolean>,\n        intervalMs: number = 30000\n    ): void {\n        this.healthChecks.set(channelName, healthCheck);\n\n        // Clear existing interval\n        const existingInterval = this.intervals.get(channelName);\n        if (existingInterval) {\n            clearInterval(existingInterval);\n        }\n\n        // Start health monitoring\n        const interval = setInterval(async () => {\n            try {\n                const isHealthy = await healthCheck();\n                this.healthStatus.set(channelName, isHealthy);\n\n                if (!isHealthy) {\n                    console.warn(`[ChannelHealth] Channel '${channelName}' is unhealthy`);\n                }\n            } catch (error) {\n                console.error(`[ChannelHealth] Health check failed for '${channelName}':`, error);\n                this.healthStatus.set(channelName, false);\n            }\n        }, intervalMs);\n\n        this.intervals.set(channelName, interval);\n\n        // Initial check\n        healthCheck().then(isHealthy => {\n            this.healthStatus.set(channelName, isHealthy);\n        }).catch(() => {\n            this.healthStatus.set(channelName, false);\n        });\n    }\n\n    /**\n     * Get health status of a channel\n     */\n    isHealthy(channelName: string): boolean {\n        return this.healthStatus.get(channelName) ?? false;\n    }\n\n    /**\n     * Get all health statuses\n     */\n    getAllHealthStatuses(): Record<string, boolean> {\n        const result: Record<string, boolean> = {};\n        for (const [name, status] of this.healthStatus) {\n            result[name] = status;\n        }\n        return result;\n    }\n\n    /**\n     * Stop monitoring a channel\n     */\n    stopMonitoring(channelName: string): void {\n        const interval = this.intervals.get(channelName);\n        if (interval) {\n            clearInterval(interval);\n            this.intervals.delete(channelName);\n        }\n\n        this.healthChecks.delete(channelName);\n        this.healthStatus.delete(channelName);\n    }\n\n    /**\n     * Stop all monitoring\n     */\n    stopAllMonitoring(): void {\n        for (const interval of this.intervals.values()) {\n            clearInterval(interval);\n        }\n\n        this.intervals.clear();\n        this.healthChecks.clear();\n        this.healthStatus.clear();\n    }\n}\n\n/**\n * Singleton health monitor instance\n */\nexport const globalChannelHealthMonitor = new ChannelHealthMonitor();","\n// @ts-ignore\nWeakMap.prototype.getOrInsert ??= function (key, defaultValue) {\n    if (!this.has(key)) { this.set(key, defaultValue); }\n    return this.get(key);\n};\n\n// @ts-ignore\nWeakMap.prototype.getOrInsertComputed ??= function (key, callbackFunction) {\n    if (!this.has(key)) { this.set(key, callbackFunction(key)); }\n    return this.get(key);\n};\n\n// @ts-ignore\nMap.prototype.getOrInsert ??= function (key, defaultValue) {\n    if (!this.has(key)) { this.set(key, defaultValue); }\n    return this.get(key);\n};\n\n// @ts-ignore\nMap.prototype.getOrInsertComputed ??= function (key, callbackFunction) {\n    if (!this.has(key)) { this.set(key, callbackFunction(key)); }\n    return this.get(key);\n};\n\n/**\n * Get a value from a Map, or insert a default value if the key doesn't exist.\n * @template K - The key type\n * @template V - The value type\n * @param map - The Map to get or insert into\n * @param key - The key to look up\n * @param defaultValue - A function that returns the default value to insert if the key doesn't exist\n * @returns The value from the map (existing or newly inserted)\n */\nexport const getOrInsert = <K, V>(map: Map<K, V>, key: K, defaultValue: () => V = () => (null as unknown as V)) => {\n    if (!map?.has?.(key)) { map?.set?.(key, defaultValue?.()); }\n    return map?.get?.(key) as V;\n};\n\n/**\n * Get a value from a Map, or insert a computed value if the key doesn't exist.\n * @template K - The key type\n * @template V - The value type\n * @param map - The Map to get or insert into\n * @param key - The key to look up\n * @param callbackFunction - A function that computes the value to insert based on the key\n * @returns The value from the map (existing or newly computed and inserted)\n */\nexport const getOrInsertComputed = <K, V>(map: Map<K, V>, key: K, callbackFunction: (key: K) => V = () => (null as unknown as V)) => {\n    if (!map?.has?.(key)) { map?.set?.(key, callbackFunction?.(key)); }\n    return map?.get?.(key) as V;\n};\n","export const $fxy = Symbol.for(\"@fix\");\n\n//\nexport const isHasPrimitives = (observable: any) => {\n    return observable?.some?.(isPrimitive);\n}\n\n//\nexport const isObservable = (observable: any) => {\n    return Array.isArray(observable) || observable instanceof Set || observable instanceof Map;\n};\n\n/**\n * Check if a value is a primitive type (null, string, number, boolean, bigint, or undefined).\n * @param obj - The value to check\n * @returns True if the value is a primitive type, false otherwise\n */\nexport const isPrimitive = (obj: any)=>{\n    return typeof obj == \"string\" || typeof obj == \"number\" || typeof obj == \"boolean\" || typeof obj == \"bigint\" || typeof obj == \"undefined\" || obj == null;\n}\n\n//\nexport const tryParseByHint = (value: any, hint?: any)=>{\n    if (!isPrimitive(value)) return null;\n    if (hint == \"number\") { return Number(value) || 0; }\n    if (hint == \"string\") { return String(value) || \"\"; }\n    if (hint == \"boolean\") { return !!value; }\n    return value;\n}\n\n//\nexport const hasProperty = (v: any, prop: string = \"value\") => {\n    return ((typeof v == \"object\" || typeof v == \"function\") && v != null && ((prop in v) || v?.[prop] != null));\n}\n\n//\nexport const hasValue = (v: any) => { return hasProperty(v, \"value\"); }\n\n//\nexport const $getValue = ($objOrPlain: any) => {\n    if (isPrimitive($objOrPlain)) return $objOrPlain;\n    return hasValue($objOrPlain) ? $objOrPlain?.value : $objOrPlain;\n}\n\n//\nexport const unwrap = (obj, fallback?: null|undefined|((...args: any[])=>any))=>{\n    return (obj?.[$fxy] ?? (fallback ?? obj));\n}\n\n//\nexport const deref = (obj: any) => {\n    if (obj != null && (typeof obj == \"object\" || typeof obj == \"function\") && (obj instanceof WeakRef || typeof obj?.deref == \"function\")) {\n        return deref(obj?.deref?.());\n    };\n    return obj;\n}\n\n//\nexport const fixFx = (obj) => { if (typeof obj == \"function\" || obj == null) return obj; const fx = function(){}; fx[$fxy] = obj; return fx; }\nexport const $set = (rv, key, val)=>{\n    rv = deref(rv);\n    if (rv != null && (typeof rv == \"object\" || typeof rv == \"function\")) {\n        return (rv[key] = $getValue(val = deref(val)));\n    };\n    return rv;\n}\n\n//\nexport const getRandomValues = (array: Uint8Array) => { return crypto?.getRandomValues ? crypto?.getRandomValues?.(array) : (()=>{\n    const values = new Uint8Array(array.length);\n    for (let i = 0; i < array.length; i++) {\n        values[i] = Math.floor(Math.random() * 256);\n    }\n    return values;\n})(); };\n\n//\nexport const clamp  = (min, val, max) => Math.max(min, Math.min(val, max));\nexport const withCtx = (target, got)=>{ if (typeof got == \"function\") { return got?.bind?.(target) ?? got; }; return got; }\n\n//\nexport const UUIDv4 = () => (crypto?.randomUUID ? crypto?.randomUUID?.() : (\"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, c => (+c ^ (getRandomValues?.(new Uint8Array(1))?.[0] & (15 >> (+c / 4)))).toString(16))));\n\n//\nexport const camelToKebab = (str: string) => { if (!str) return str; return str?.replace?.(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(); }\nexport const kebabToCamel = (str: string) => { if (!str) return str; return str?.replace?.(/-([a-z])/g, (_, char) => char.toUpperCase()); }\n\n//\nexport const toFiniteNumber = (value: any, fallback = 0) => {\n    const number = Number(value);\n    return Number.isFinite(number) ? number : fallback;\n};\n\n//\nexport const clampDimension = (value: number, max: number) => {\n    if (!Number.isFinite(max) || max <= 0) { return 0; }\n    if (!Number.isFinite(value)) { return 0; }\n    return Math.min(Math.max(value, 0), max);\n};\n\n//\nexport const roundNearest = (number: number, N = 1): number => (Math.round(number * N) / N);\nexport const floorNearest = (number: number, N = 1): number => (Math.floor(number * N) / N);\nexport const ceilNearest = (number: number, N = 1): number => (Math.ceil(number * N) / N);\n\n//\nexport const isValueUnit = (val: any) => (typeof CSSStyleValue !== \"undefined\" && val instanceof CSSStyleValue);\nexport const isVal = (v: any) => v != null && (typeof v == \"boolean\" ? v !== false : true) && (typeof v != \"object\" && typeof v != \"function\");\nexport type DatasetValue = string | number | boolean | null | undefined | { value?: string | number | boolean | null | undefined };\n\n//\nexport const normalizePrimitive = (val: any) => {\n    return (typeof val == \"boolean\" ? (val ? \"\" : null) : (typeof val == \"number\" ? String(val) : val));\n}\n\n//\nexport const $triggerLock  = Symbol.for(\"@trigger-lock\");\nexport const $avoidTrigger = (ref: any, cb: ()=>any, $prop: string = \"value\")=>{\n    if (hasProperty(ref, $prop)) ref[$triggerLock] = true;\n    let result;\n    try {\n        result = cb?.();\n    } finally {\n        if (hasProperty(ref, $prop)) { delete ref[$triggerLock]; }\n    }\n    return result;\n}\n\n//\nexport const tryStringAsNumber = (val: string): number | null => {\n    if (typeof val != \"string\") return null;\n    const matches = [...val?.matchAll?.(/^\\d+(\\.\\d+)?$/g)];\n    if (matches?.length != 1) return null;\n    const triedToParse = parseFloat(matches[0][0]);\n    if (!Number.isNaN(triedToParse) && Number.isFinite(triedToParse)) { return triedToParse; };\n    return null;\n}\n\n//\nexport const INTEGER_REGEXP = /^\\d+$/g;\n\n//\nexport const tryStringAsInteger = (val: string): number | null => {\n    if (typeof val != \"string\") return null;\n    val = val?.trim?.(); if (val == \"\" || val == null) return null;\n    const matches = [...val?.matchAll?.(INTEGER_REGEXP)];\n    if (matches?.length != 1) return null;\n    const triedToParse = parseInt(matches[0][0]);\n    if (!Number.isNaN(triedToParse) && Number.isInteger(triedToParse)) { return triedToParse; };\n    return null;\n}\n\n//\nexport const isValidNumber = (val: any) => {\n    return typeof val == \"number\" && !Number.isNaN(val);\n}\n\n//\nexport const canBeInteger = (value: any) => {\n    if (typeof value == \"string\") {\n        return tryStringAsInteger(value) != null;\n    } else\n        return typeof value == \"number\" && Number.isInteger(value) && value >= 0;\n}\n\n//\nexport const isArrayOrIterable = (obj) => Array.isArray(obj) || (obj != null && typeof obj == \"object\" && typeof obj[Symbol.iterator] == \"function\");\nexport const handleListeners = (root: any, fn: string, handlers: any) => { root = (root instanceof WeakRef ? root.deref() : root); const usubs = [...Object.entries(handlers)]?.map?.(([name, cb]) => root?.[fn]?.call?.(root, name, cb)); return ()=>{ usubs?.forEach?.((unsub)=>unsub?.()); }; }\n\n//\nexport const isRef = (ref: any) => { return ref instanceof WeakRef || typeof ref?.deref == \"function\"; }\nexport const unref = (ref: any) => { return isRef(ref) ? deref(ref) : ref; }\nexport const toRef = (ref: any) => { return ref != null ? (isRef(ref) ? ref : ((typeof ref == \"function\" || typeof ref == \"object\") ? new WeakRef(ref) : ref)) : ref; }\n\n//\nexport const isValueRef = (exists) => {\n    return (typeof exists == \"object\" || typeof exists == \"function\") && (exists?.value != null || (exists != null && \"value\" in exists))\n}\n\n//\nexport const isObject = (exists) => {\n    return exists != null && (typeof exists == \"object\" || typeof exists == \"function\");\n}\n\n/**\n * Get the value from a value reference or return the value itself.\n * @param val - The value or value reference to extract from\n * @returns The extracted value\n */\nexport const getValue = (val: any) => {\n    return (hasValue(val) ? val?.value : val);\n}\n\n\n\n//\nexport const potentiallyAsync = (promise, cb)=>{\n    if (promise instanceof Promise || typeof promise?.then == \"function\")\n        { return promise?.then?.(cb); } else\n        { return cb?.(promise); }\n    return promise;\n}\n\n//\nexport const potentiallyAsyncMap = (promise, cb)=>{\n    if (promise instanceof Promise || typeof promise?.then == \"function\")\n        { return promise?.then?.(cb); } else\n        { return cb?.(promise); }\n    return promise;\n}\n\n//\nexport const makeTriggerLess = function(self){\n    return (cb)=>{\n        self[$triggerLock] = true;\n        let result;\n        try {\n            result = cb?.();\n        } finally {\n            self[$triggerLock] = false;\n        }\n        return result;\n    }\n}\n\n//\nexport const unwrapArray = (arr: any[])=>{\n    if (Array.isArray(arr)) {\n        return arr?.flatMap?.((el)=>{\n            if (Array.isArray(el)) return unwrapArray(el);\n            return el;\n        })\n    } else {\n        return arr;\n    }\n}\n\n/*\n//\nexport const isNotComplexArray = (arr: any[])=>{\n    return unwrapArray(arr).every(isPrimitive);\n}*/\n\n//\nexport const isNotComplexArray = (arr: any[])=>{\n    return unwrapArray(arr)?.every?.(isCanJustReturn);\n}\n\n\n// TODO: review cases when arrays isn't primitive\nexport const isCanJustReturn = (obj: any)=>{\n    return isPrimitive(obj) || (typeof SharedArrayBuffer == \"function\" && obj instanceof SharedArrayBuffer) || isTypedArray(obj) || (Array.isArray(obj) && isNotComplexArray(obj));\n}\n\n//\nexport const isTypedArray = (value: any)=>{\n    return ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\n//\nexport const isSymbol = (sym: unknown) => (typeof sym === 'symbol' || typeof sym == 'object' && Object.prototype.toString.call(sym) == '[object Symbol]');\nexport const isPromise = <T extends object | Function | unknown>(target: T | Promise<T>): boolean => {\n    return target instanceof Promise || typeof (target as any)?.then == \"function\";\n}\n\n//\nexport const isCanTransfer = (obj: any)=>{\n    return isPrimitive(obj) ||\n        (typeof ArrayBuffer == \"function\" && obj instanceof ArrayBuffer) ||\n        (typeof MessagePort == \"function\" && obj instanceof MessagePort) ||\n        (typeof ReadableStream == \"function\" && obj instanceof ReadableStream) ||\n        (typeof WritableStream == \"function\" && obj instanceof WritableStream) ||\n        (typeof TransformStream == \"function\" && obj instanceof TransformStream) ||\n        (typeof ImageBitmap == \"function\" && obj instanceof ImageBitmap) ||\n        (typeof VideoFrame == \"function\" && obj instanceof VideoFrame) ||\n        (typeof OffscreenCanvas == \"function\" && obj instanceof OffscreenCanvas) ||\n        (typeof RTCDataChannel == \"function\" && obj instanceof RTCDataChannel) || // @ts-ignore\n        (typeof AudioData == \"function\" && obj instanceof AudioData) || // @ts-ignore\n        (typeof WebTransportReceiveStream == \"function\" && obj instanceof WebTransportReceiveStream) || // @ts-ignore\n        (typeof WebTransportSendStream == \"function\" && obj instanceof WebTransportSendStream) || // @ts-ignore\n        (typeof WebTransportReceiveStream == \"function\" && obj instanceof WebTransportReceiveStream); // @ts-ignore\n}\n\n//\nexport const defaultByType = (a)=>{\n    switch(typeof a) {\n        case \"number\": return 0;\n        case \"string\": return \"\";\n        case \"boolean\": return false;\n        case \"object\": return null;\n        case \"function\": return null;\n        case \"symbol\": return null;\n        case \"bigint\": return 0n;\n    }\n    return undefined;\n}\n","import { isCanJustReturn } from \"./Primitive\";\n\n//\nexport type WeakKey = object | Function;\nexport type keyType = string | number | symbol;\n\n//\nexport const isIterable = (obj) => (typeof obj?.[Symbol.iterator] == \"function\");\nexport const isKeyType  = (prop: keyType | any) => ([\"symbol\", \"string\", \"number\"].indexOf(typeof prop) >= 0);\nexport const isValidObj = (obj?: any)=> { return obj != null && (typeof obj == \"function\" || typeof obj == \"object\") && !(obj instanceof WeakRef); };\nexport const mergeByKey = (items: any[]|Set<any>, key = \"id\")=>{\n    const entries = Array.from(items?.values?.()).map((I)=>[I?.[key],I]);\n    const map = new Map(entries as any);\n    return Array.from(map?.values?.() || []);\n}\n\n//\nexport const removeExtra = (target, value, name: keyType | null = null)=>{\n    const exists = name != null && (typeof target == \"object\" || typeof target == \"function\") ? (target?.[name] ?? target) : target; let entries: any = [];\n    if (value instanceof Set || value instanceof Map || Array.isArray(value) || isIterable(value)) { entries = ((exists instanceof Set || exists instanceof WeakSet) ? value?.values?.() : value?.entries?.()) || ((Array.isArray(value) || isIterable(value)) ? value : []); } else\n    if (typeof value == \"object\" || typeof value == \"function\") { entries = (exists instanceof Set || exists instanceof WeakSet) ? Object.values(value) : Object.entries(value); }\n\n    //\n    let exEntries: any = []; if (Array.isArray(exists)) { exEntries = exists.entries(); } else // @ts-ignore\n    if (exists instanceof Map || exists instanceof WeakMap) { exEntries = exists?.entries?.(); } else // @ts-ignore\n    if (exists instanceof Set || exists instanceof WeakSet) { exEntries = exists?.values?.(); } else\n    if (typeof exists == \"object\" || typeof exists == \"function\") { exEntries = Object.entries(exists); }\n\n    //\n    const keys = new Set(Array.from(entries).map((e)=>e?.[0]));\n    const exe  = new Set(Array.from(exEntries).map((e)=>e?.[0]));\n\n    // @ts-ignore // REQUIRES NEW ECMASCRIPT!!!\n    const exclude = keys?.difference?.(exe);\n\n    //\n    if (Array.isArray(exists)) { const nw = exists.filter((_,I)=>!exclude.has(I)); exists.splice(0, exists.length); exists.push(...nw); } else\n    if ((exists instanceof Map || exists instanceof Set) || (exists instanceof WeakMap || exists instanceof WeakSet)) { for (const k of exclude) { exists.delete(k); }; } else\n    if (typeof exists == \"function\" || typeof exists == \"object\") { for (const k of exclude) { delete exists[k]; }; }; return exists;\n}\n\n//\nexport const objectAssign = (target, value, name: keyType | null = null, removeNotExists = true, mergeKey = \"id\") => {\n    const exists = name != null && (typeof target == \"object\" || typeof target == \"function\") ? (target?.[name] ?? target) : target;\n    let entries: any = null; if (removeNotExists) { removeExtra(exists, value); }\n\n    //\n    if (value instanceof Set || value instanceof Map || Array.isArray(value) || isIterable(value)) { entries = ((exists instanceof Set || exists instanceof WeakSet) ? value?.values?.() : value?.entries?.()) || ((Array.isArray(value) || isIterable(value)) ? value : []); } else\n    if (typeof value == \"object\" || typeof value == \"function\") { entries = (exists instanceof Set || exists instanceof WeakSet) ? Object.values(value) : Object.entries(value); }\n\n    //\n    if (exists && entries && (typeof entries == \"object\" || typeof entries == \"function\")) {\n        if (exists instanceof Map || exists instanceof WeakMap) // @ts-ignore\n            { for (const E of entries) { exists.set(...E); }; return exists; }\n\n        //\n        if (exists instanceof Set || exists instanceof WeakSet)\n            { for (const E of entries) { // @ts-ignore\n                const mergeObj = E?.[mergeKey] ? Array.from(exists?.values?.() || []).find((I)=>!isNotEqual?.(I?.[mergeKey], E?.[mergeKey])) : null;\n                if (mergeObj != null) { objectAssign(mergeObj, E, null, removeNotExists, mergeKey); } else { exists.add(E); }\n            } return exists; }\n\n        //\n        if (typeof exists == \"object\" || typeof exists == \"function\") {\n            if (Array.isArray(exists) || isIterable(exists)) {\n                let I = 0; for (const E of entries)\n                    { if (I < exists.length) { exists[I++] = E?.[1]; } else { exists?.push?.(E?.[1]); }; }\n                return exists;\n            }\n            return Object.assign(exists, Object.fromEntries([...(entries||[])].filter((K)=>(typeof K != \"symbol\"))));\n        }\n    }\n\n    //\n    if (name != null) { Reflect.set(target, name, value); return target; } else\n    if (typeof value == \"object\" || typeof value == \"function\")\n        { return Object.assign(target, value); }; return value;\n}\n\n\n//\nexport const bindFx = (target, fx)=>{\n    // !experimental `getOrInsert` feature!\n    // @ts-ignore\n    const be = boundCtx.getOrInsert(target, new WeakMap());\n    return be.getOrInsert(fx, fx?.bind?.(target));\n}\n\n//\nexport const bindCtx    = (target, fx) => ((typeof fx == \"function\" ? bindFx(target, fx) : fx) ?? fx);\n\n//\nexport const callByProp = (unwrap, prop: keyType, cb, ctx) => {\n    if (prop == Symbol.iterator) { return callByAllProp(unwrap, cb, ctx); };\n\n    //\n    if (\n        prop == null ||\n        //(prop == $extractKey$ || prop == $originalKey$ || prop == $registryKey$) ||\n        (typeof prop == \"symbol\" || typeof prop == \"object\" || typeof prop == \"function\")\n    ) return;\n\n    //\n    const callIfNotNull = (v, ...args)=>{\n        if (v != null) { return cb?.(v, ...args); }\n    }\n\n    //\n    if (unwrap instanceof Map || unwrap instanceof WeakMap) {\n        if (unwrap.has(prop as any)) { return callIfNotNull?.(unwrap.get(prop as any), prop, null, \"@set\"); }\n    } else\n        if (unwrap instanceof Set || unwrap instanceof WeakSet) {\n            if (unwrap.has(prop as any)) { return callIfNotNull?.(prop, prop, null, \"@add\"); }\n        } else\n            if (Array.isArray(unwrap) && (typeof prop == \"string\" && [...prop?.matchAll?.(/^\\d+$/g)]?.length == 1) && Number.isInteger(typeof prop == \"string\" ? parseInt(prop) : prop)) {\n                const index = typeof prop == \"string\" ? parseInt(prop) : prop;\n                return callIfNotNull?.(unwrap?.[index], index, null, \"@add\");\n            } else\n                if (typeof unwrap == \"function\" || typeof unwrap == \"object\") { return callIfNotNull?.(unwrap?.[prop], prop, null, \"@set\"); }\n}\n\n//\nexport const objectAssignNotEqual = (dst, src = {})=>{ Object.entries(src)?.forEach?.(([k,v])=>{ if (isNotEqual(v, dst[k])) { dst[k] = v; }; }); return dst; }\nexport const callByAllProp = (unwrap, cb, ctx)=>{\n    if (unwrap == null) return;\n\n    //\n    let keys: any = [];\n\n    if (unwrap instanceof Set || unwrap instanceof Map || typeof unwrap?.keys == \"function\") {\n        return [...(unwrap?.keys?.() || keys)]?.forEach?.((prop: keyType | any) => callByProp(unwrap, prop, cb, ctx));\n    }\n\n    if (Array.isArray(unwrap) || isIterable(unwrap)) {\n        return [...unwrap]?.forEach?.((v, I) => callByProp(unwrap, I, cb, ctx));\n    }\n\n    if (typeof unwrap == \"object\" || typeof unwrap == \"function\") {\n        return [...(Object.keys(unwrap) || keys)]?.forEach?.((prop: keyType | any) => callByProp(unwrap, prop, cb, ctx));\n    }\n}\n\n//\nexport const isObjectNotEqual = (a, b)=>{\n    if (a == null && b == null) return false;\n    if (a == null || b == null) return true; // @ts-ignore\n    if (a instanceof Map || a instanceof WeakMap) { return a.size != b.size || Array.from(a.entries()).some(([k, v]) => !b.has(k) || !isNotEqual(v, b.get(k))); } // @ts-ignore\n    if (a instanceof Set || a instanceof WeakSet) { return a.size != b.size || Array.from(a.values()).some((v) => !b.has(v)); } // @ts-ignore\n    if (Array.isArray(a) || Array.isArray(b)) { return a.length != b.length || a.some((v, i) => !isNotEqual(v, b[i])); }\n    if (typeof a == \"object\" || typeof b == \"object\") { return JSON.stringify(a) != JSON.stringify(b); }\n    return a != b;\n}\n\n//\nexport const isNotEqual = (a, b)=>{\n    if (a == null && b == null) return false;\n    if (a == null || b == null) return true;\n    if (typeof a == \"boolean\" && typeof b == \"boolean\") {\n        return a != b;\n    }\n    if (typeof a == \"number\" && typeof b == \"number\") {\n        return !(a == b || (Math.abs(a - b) < 1e-9));\n    }\n    if (typeof a == \"string\" && typeof b == \"string\") {\n        return ((a != \"\" && b != \"\") && a != b) || a !== b;\n    }\n    if ((typeof a) != (typeof b)) {\n        return a !== b;\n    }\n    return (a && b && a != b) || a !== b;\n}\n\n//\nexport const boundCtx  = new WeakMap();\n\n//\nexport const isArrayInvalidKey = (key: keyType | null | undefined | any, src?: any) => {\n    const invalidForArray = key == null || (key as any) < 0 || typeof key != \"number\" || (key as any) == Symbol.iterator || (src != null ? key >= (src?.length || 0) : false);\n    return (src != null ? Array.isArray(src) && invalidForArray : false);\n};\n\n//\nexport const inProxy = new WeakMap();\nexport const contextify = (pc: any, name: any) => { return (typeof pc?.[name] == \"function\" ? pc?.[name]?.bind?.(pc) : pc?.[name]); }\n\n//\nexport const deepOperateAndClone = (obj: any, operation: (el: any, key: number|string, obj: any)=>any, $prev?: [any, number|string]|null)=>{\n    if (Array.isArray(obj)) {\n        if (obj.every(isCanJustReturn)) return obj.map(operation);\n        return obj.map((value, index) => deepOperateAndClone(value, operation, [obj, index] as [any, number|string]));\n    }\n    if (obj instanceof Map) {\n        const entries = Array.from(obj.entries());\n        const values = entries.map(([key, value]) => value);\n        if (values.every(isCanJustReturn)) return new Map(entries.map(([key, value]) => [key, operation(value, key, obj)]));\n        return new Map(entries.map(([key, value]) => [key, deepOperateAndClone(value, operation, [obj, key] as [any, number|string])]));\n    }\n    if (obj instanceof Set) {\n        const entries = Array.from(obj.entries());\n        const values = entries.map(([key, value]) => value);\n        if (entries.every(isCanJustReturn)) return new Set(values.map(operation));\n        return new Set(values.map(value => deepOperateAndClone(value, operation, [obj, value] as [any, number|string])));\n    }\n    if (typeof obj == \"object\" && (obj?.constructor == Object && Object.prototype.toString.call(obj) == \"[object Object]\")) {\n        const entries = Array.from(Object.entries(obj));\n        const values = entries.map(([key, value]) => value);\n        if (values.every(isCanJustReturn)) return Object.fromEntries(entries.map(([key, value]) => [key, operation(value, key, obj)]));\n        return Object.fromEntries(entries.map(([key, value]) => [key, deepOperateAndClone(value, operation, [obj, key] as [any, number|string])]));\n    }\n    return operation(obj, $prev?.[1] ?? \"\", $prev?.[0] ?? null);\n}\n\n//\nexport const bindEvent = (on: any, key: string, value: any)=>{\n    if (on?.[key] != null) {\n        const exists = on[key];\n        if (Array.isArray(value)) { exists.add(...value); } else if (typeof value == \"function\") { exists.add(value); }\n        return on;\n    }\n    on[key] ??= Array.isArray(value) ? new Set(value) : (typeof value == \"function\" ? new Set([value]) : value);\n    return on;\n}\n","import { unwrap, isPrimitive, tryParseByHint, fixFx } from \"./Primitive\";\n\n//\nconst resolvedMap = new WeakMap(), handledMap = new WeakMap();\nconst actWith = (promiseOrPlain, cb)=>{\n    if (promiseOrPlain instanceof Promise || typeof promiseOrPlain?.then == \"function\") {\n        if (resolvedMap?.has?.(promiseOrPlain)) { return cb(resolvedMap?.get?.(promiseOrPlain)); }\n        // @ts-ignore\n        return Promise.try?.(async ()=>{\n            const item = await promiseOrPlain;\n            resolvedMap?.set?.(promiseOrPlain, item);\n            return item;\n        })?.then?.(cb);\n    }\n    return cb(promiseOrPlain);\n}\n\n//\nclass PromiseHandler {\n    #resolve?: ((...args: any[])=>void)|null;\n    #reject?: ((...args: any[])=>void)|null;\n\n    //\n    constructor(resolve?: ((...args: any[])=>void)|null, reject?: ((...args: any[])=>void)|null) {\n        this.#resolve = resolve;\n        this.#reject = reject;\n    }\n\n    //\n    defineProperty(target, prop, descriptor) {\n        if (unwrap(target) instanceof Promise) return Reflect.defineProperty(target, prop, descriptor);\n        return actWith(unwrap(target), (obj)=>Reflect.defineProperty(obj, prop, descriptor));\n    }\n\n    //\n    deleteProperty(target, prop) {\n        if (unwrap(target) instanceof Promise) return Reflect.deleteProperty(target, prop);\n        return actWith(unwrap(target), (obj)=>Reflect.deleteProperty(obj, prop));\n    }\n\n    //\n    getPrototypeOf(target) {\n        if (unwrap(target) instanceof Promise) return Reflect.getPrototypeOf(target);\n        return actWith(unwrap(target), (obj)=>Reflect.getPrototypeOf(obj));\n    }\n\n    //\n    setPrototypeOf(target, proto) {\n        if (unwrap(target) instanceof Promise) return Reflect.setPrototypeOf(target, proto);\n        return actWith(unwrap(target), (obj)=>Reflect.setPrototypeOf(obj, proto));\n    }\n\n    //\n    isExtensible(target) {\n        if (unwrap(target) instanceof Promise) return Reflect.isExtensible(target);\n        return actWith(unwrap(target), (obj)=>Reflect.isExtensible(obj));\n    }\n\n    //\n    preventExtensions(target) {\n        if (unwrap(target) instanceof Promise) return Reflect.ownKeys(target);\n        return actWith(unwrap(target), (obj)=>Reflect.preventExtensions(obj));\n    }\n\n    //\n    ownKeys(target) {\n        const uwp = unwrap(target);\n        if (uwp instanceof Promise) return Object.keys(uwp);\n        const keys = actWith(uwp, (obj)=>{ return (typeof obj == \"object\" || typeof obj == \"function\") && obj != null ? Object.keys(obj) : [] });\n        return keys ?? [];\n    }\n\n    //\n    getOwnPropertyDescriptor(target, prop) {\n        if (unwrap(target) instanceof Promise) return Reflect.getOwnPropertyDescriptor(target, prop);\n        return actWith(unwrap(target), (obj)=>Reflect.getOwnPropertyDescriptor(obj, prop));\n    }\n\n    //\n    construct(target, args, newTarget) {\n        return actWith(unwrap(target), (ct)=>Reflect.construct(ct, args, newTarget));\n    }\n\n    //\n    has(target, prop) {\n        if (unwrap(target) instanceof Promise) return Reflect.has(target, prop);\n        return actWith(unwrap(target), (obj)=>Reflect.has(obj, prop));\n    }\n\n    //\n    get(target, prop, receiver) {\n        target = unwrap(target);\n\n        //\n        if (prop == 'promise') { return target; } // @ts-ignore\n        if (prop == 'resolve' && this.#resolve) { return (...args)=>{ const result = this.#resolve?.(...args); this.#resolve = null; return result; }; } // @ts-ignore\n        if (prop == 'reject'  && this.#reject ) { return (...args)=>{ const result = this.#reject?.(...args);  this.#reject  = null; return result; }; } // @ts-ignore\n        if (prop == 'then' || prop == 'catch' || prop == 'finally') {\n            if (target instanceof Promise) {\n                return target?.[prop]?.bind?.(target);\n            } else {\n                const $tmp = Promise.try(()=>target);\n                return $tmp?.[prop]?.bind?.($tmp);\n            }\n        }\n\n        // @ts-ignore\n        const result = Promised(actWith(target, async (obj)=>{\n            if (unwrap(obj) instanceof Promise) return Reflect.get(obj, prop, receiver);\n            if (isPrimitive(obj)) { return (prop == Symbol.toPrimitive || prop == Symbol.toStringTag) ? obj : undefined; }\n            let value: any = undefined;\n            try { value = Reflect.get(obj, prop, receiver); } catch (e) { value = target?.[prop]; }\n            if (typeof value == 'function') { return value?.bind?.(obj); }\n            return value;\n        }));\n\n        //\n        if (prop == Symbol.toStringTag) {\n            if (isPrimitive(result)) { return String(result ?? \"\") || \"\"; };\n            return result?.[Symbol.toStringTag]?.() || String(result ?? \"\") || \"\";\n        }\n\n        //\n        if (prop == Symbol.toPrimitive) { return (hint?)=>{\n            if (isPrimitive(result)) { return tryParseByHint(result, hint); };\n            return null;//tryParseByHint(result?.[Symbol.toPrimitive]?.());\n        }}\n\n        //\n        return result;\n    }\n\n    //\n    set(target, prop, value) {\n        return actWith(unwrap(target), (obj)=>Reflect.set(obj, prop, value));\n    }\n\n    //\n    apply(target, thisArg, args) { // @ts-ignore\n        if (this.#resolve) { const result = this.#resolve?.(...args); this.#resolve = null; return result; }\n        return actWith(unwrap(target, this.#resolve), (obj) => {\n            if (typeof obj == \"function\") {\n                if (unwrap(obj) instanceof Promise) return Reflect.apply(obj, thisArg, args);\n                return Reflect.apply(obj, thisArg, args);\n            }\n        });\n    }\n}\n\n/**\n * Type alias for Promise-like values (Promise or any value).\n * @template T - The resolved value type\n */\nexport type PromiseLike<T=any> = Promise<T>|any;\n\n/**\n * Wrap a promise or value in a Proxy that allows synchronous property access.\n * For resolved promises, this enables accessing properties as if the promise was already resolved.\n * @template T - The resolved value type\n * @param promise - The promise or value to wrap\n * @param resolve - Optional resolve callback\n * @param reject - Optional reject callback\n * @returns A proxy that allows synchronous-style access to promise values\n */\nexport function Promised<T=any>(promise: PromiseLike<T>, resolve?: ((...args: any[])=>void)|null, reject?: ((...args: any[])=>void)|null) {\n    if (!(promise instanceof Promise || typeof promise?.then == \"function\")) { return promise; }\n    if (resolvedMap?.has?.(promise)) { return resolvedMap?.get?.(promise); };\n    if (!handledMap?.has?.(promise)) { promise?.then?.((item)=>resolvedMap?.set?.(promise, item)); } // @ts-ignore\n    return handledMap?.getOrInsertComputed?.(promise, ()=>new Proxy<PromiseLike<T>>(fixFx(promise), new PromiseHandler(resolve, reject)));\n}\n\n//if ([\"then\", \"catch\", \"finally\"].includes(prop as string)) { return (typeof withUpdate?.[prop] == \"function\" ? withUpdate?.[prop]?.bind?.(withUpdate) : withUpdate?.[prop]); }\n","//\nconst existsMap = new WeakMap<any, WR<any>>();\n\n//\nexport type WRef<T> = {\n    [K in keyof T]: T[K] extends (...args: infer A) => infer R\n        ? (...args: A) => WRef<R> | null\n        : T[K] | null;\n};\n\n//\nclass WeakRefProxyHandler<T extends object|Function> implements ProxyHandler<object> {\n    private _deref(target): T | undefined { return (target instanceof WeakRef || typeof target?.deref == \"function\") ? (target?.deref?.()) : target; } // @ts-ignore\n\n    //\n    get(tg: object, prop: PropertyKey, _receiver: any): any {\n        const obj = this._deref(tg), value = (obj as any)?.[prop];\n\n        // libraries specific (LUR.E/object.ts)\n        if ((prop == \"element\" || prop == \"value\") && obj && (value == null || !(prop in obj))) { return obj; }\n        // wrap-away deref from side-effects\n        if (prop == \"deref\") { return ()=>this._deref(tg); };\n        // if function, workaround callable\n        if (typeof value == 'function') {\n            return (...args: any[]) => {\n                const realObj = this._deref(tg);\n                return (realObj as any)?.[prop]?.(...args);\n            };\n        };\n        return value;\n    }\n\n    set(tg: object, prop: PropertyKey, value: any, _receiver: any): boolean {\n        const obj = this._deref(tg); if (obj) return Reflect.set(obj, prop, value);\n        return true;\n    }\n\n    has(tg: object, prop: PropertyKey): boolean {\n        const obj = this._deref(tg); if (!obj) return false;\n        return prop in obj;\n    }\n\n    ownKeys(tg: object): ArrayLike<string | symbol> {\n        const obj = this._deref(tg); if (!obj) return [];\n        return Reflect.ownKeys(obj);\n    }\n\n    getOwnPropertyDescriptor(tg: object, prop: PropertyKey): PropertyDescriptor | undefined {\n        const obj = this._deref(tg); if (!obj) return undefined;\n        return Object.getOwnPropertyDescriptor(obj, prop);\n    }\n\n    deleteProperty(tg: object, prop: PropertyKey): boolean {\n        const obj = this._deref(tg); if (!obj) return true;\n        return Reflect.deleteProperty(obj, prop);\n    }\n\n    defineProperty(tg: object, prop: PropertyKey, descriptor: PropertyDescriptor): boolean {\n        const obj = this._deref(tg); if (!obj) return true;\n        return Reflect.defineProperty(obj, prop, descriptor);\n    }\n\n    getPrototypeOf(tg: object): object | null {\n        const obj = this._deref(tg); if (!obj) return null;\n        return Object.getPrototypeOf(obj);\n    }\n\n    setPrototypeOf(tg: object, proto: any): boolean {\n        const obj = this._deref(tg); if (!obj) return true;\n        return Reflect.setPrototypeOf(obj, proto);\n    }\n\n    isExtensible(tg: object): boolean {\n        const obj = this._deref(tg); if (!obj) return false;\n        return Reflect.isExtensible(obj);\n    }\n\n    preventExtensions(tg: object): boolean {\n        const obj = this._deref(tg); if (!obj) return true;\n        return Reflect.preventExtensions(obj);\n    }\n}\n\n//\nexport type WR<T> = {\n    [K in keyof T]: T[K] extends (...args: infer A) => infer R\n        ? (...args: A) => WR<R> | null\n        : T[K] | null;\n};\n\n/**\n * Create a WeakRef wrapper proxy that allows safe access to weakly referenced objects.\n * The proxy automatically dereferences WeakRefs when accessing properties and handles\n * function calls on weakly referenced objects.\n * @template T - The type of the target object (must be object or Function)\n * @param target - The target object or WeakRef to wrap\n * @returns A proxy that safely accesses the weakly referenced object\n */\nexport function WRef<T extends object|Function>(target: T|WeakRef<T>): WR<T> {\n    if (!(typeof target == \"object\" || typeof target == \"function\") || typeof target == \"symbol\") return target as WR<T>;\n    const isWeakRef = (target instanceof WeakRef || typeof (target as any)?.deref == \"function\");\n    target = (isWeakRef ? (target as any)?.deref?.() : target) as unknown as T;\n    if (target != null && existsMap.has(target)) { return existsMap.get(target) as WR<T>; }\n\n    //\n    const handler = new WeakRefProxyHandler<T>(); // !here may be dead WeakRef\n    const pm: WR<T> = new Proxy(isWeakRef ? target : new WeakRef(target), handler as ProxyHandler<WeakRef<T>>) as WR<T>;\n    existsMap.set(target, pm); return pm;\n}\n","/**\n * Convert position from client space to orientation space.\n * @param pos_in_cs - Position in client space [x, y]\n * @param size_in_cs - Size in client space [width, height]\n * @param or_i - Orientation index (0=normal, 1=90 swapped, 2=180, 3=270 swapped)\n * @returns Position in orientation space [x, y]\n */\nexport const cvt_cs_to_os = (pos_in_cs: [number, number], size_in_cs: [number, number], or_i: number = 0): [number, number] => {\n    const size_in_os = [...size_in_cs];\n    const pos_in_swap: [number, number] = [...pos_in_cs];\n\n    // compute swap\n    if (or_i%2) { pos_in_swap.reverse(); size_in_os.reverse(); }\n\n    // compute rotation\n    return [\n        ((or_i==0 || or_i==3) ? pos_in_swap[0] : (size_in_os[0] - pos_in_swap[0])) || 0,\n        ((or_i==0 || or_i==1) ? pos_in_swap[1] : (size_in_os[1] - pos_in_swap[1])) || 0\n    ];\n};\n\n//\nexport const cvt_os_to_cs = (pos_in_os: [number, number], size_in_cs: [number, number], or_i: number = 0): [number, number] => {\n    const size_in_os = [...size_in_cs];\n    const pos_in_cp: [number, number] = [...pos_in_os];\n\n    // use orientation space for size\n    if (or_i%2) { size_in_os.reverse(); }\n\n    // back-reversion in orientation space\n    const pos_in_cs: [number, number] = [\n        ((or_i==0 || or_i==3) ? pos_in_cp[0] : (size_in_os[0] - pos_in_cp[0])) || 0,\n        ((or_i==0 || or_i==1) ? pos_in_cp[1] : (size_in_os[1] - pos_in_cp[1])) || 0\n    ];\n\n    // back-swap to client-space\n    if (or_i%2) { pos_in_cs.reverse(); }\n    return pos_in_cs;\n};\n\n\n\n// for dragging relative (from zero)\nexport const cvt_rel_cs_to_os = (rel_in_cs: [number, number], or_i: number = 0): [number, number] => {\n    const rel_in_swap: [number, number] = [...rel_in_cs];\n\n    // compute swap\n    if (or_i%2) { rel_in_swap.reverse(); }\n\n    // compute rotation\n    return [\n        ((or_i==0 || or_i==3) ? rel_in_swap[0] : -rel_in_swap[0]) || 0,\n        ((or_i==0 || or_i==1) ? rel_in_swap[1] : -rel_in_swap[1]) || 0\n    ];\n};\n\n// for dragging relative (from zero)\nexport const cvt_rel_os_to_cs = (rel_in_os: [number, number], or_i: number = 0): [number, number] => {\n    const rel_in_cp: [number, number] = [...rel_in_os];\n\n    // back-reversion in orientation space\n    const pos_in_cs: [number, number] = [\n        ((or_i==0 || or_i==3) ? rel_in_cp[0] : -rel_in_cp[0]) || 0,\n        ((or_i==0 || or_i==1) ? rel_in_cp[1] : -rel_in_cp[1]) || 0\n    ];\n\n    // back-swap to client-space\n    if (or_i%2) { pos_in_cs.reverse(); }\n    return pos_in_cs;\n};\n","import { cvt_cs_to_os } from \"./Convert\";\nimport { roundNearest } from \"./Primitive\";\nimport type { GridArgsType, GridItemType } from \"./Types\";\n\n//\nconst get = (items, id)=>{ if (typeof items?.get == \"function\") { const item = items?.get?.(id); if (item) { return item; }; }; return Array.from(items?.values?.()||items||[])?.find?.((item: any)=>(item?.id == id || item == id)); }\n\n//\nexport const getSpan = (el, ax)=>{ const prop = el.style.getPropertyValue([\"--ox-c-span\", \"--ox-r-span\"][ax]), factor = ((parseFloat(prop || \"1\") || 1) - 1); return Math.min(Math.max(factor-1, 0), 1); }\n/**\n * Find a non-busy cell near the preferred cell in a grid layout.\n * If the preferred cell is busy, searches nearby cells to find an available one.\n * @param $preCell - Preferred cell coordinates [column, row]\n * @param gridArgs - Grid arguments containing items, layout, and size information\n * @returns Cell coordinates [column, row] that are not busy\n */\nexport const redirectCell = ($preCell: [number, number], gridArgs: GridArgsType): [number, number] => {\n    const icons: any = (gridArgs?.items || []);\n    const item = gridArgs?.item || {};\n    const checkBusy = (cell): boolean => {\n        return icons\n            ?.filter?.((e: GridItemType) => !(e == item || e?.id == item?.id))\n            ?.some?.((one) => ((one?.cell?.[0]||0) == (cell[0]||0) && (one?.cell?.[1]||0) == (cell[1]||0)));\n    };\n\n    //\n    const preCell: [number, number] = [...$preCell]; // make non-conflict copy\n    if (!checkBusy(preCell)) { return [...preCell]; }\n    const layout  = [...gridArgs?.layout];\n    const columns = layout[0] || 4;\n    const rows    = layout[1] || 8;\n    const variants: [number, number][] = [\n        [preCell[0] + 1, preCell[1]] as [number, number],\n        [preCell[0] - 1, preCell[1]] as [number, number],\n        [preCell[0], preCell[1] + 1] as [number, number],\n        [preCell[0], preCell[1] - 1] as [number, number],\n    ].filter((v) => { return v[0] >= 0 && v[0] < columns && v[1] >= 0 && v[1] < rows; }) || [];\n    const suitable = variants.find((v) => !checkBusy(v)); if (suitable) { return [...suitable]; }\n\n    //\n    let exceed = 0, busy = true, comp = [...preCell];\n    while (busy && exceed++ < columns * rows) {\n        if (!(busy = checkBusy(comp))) { return [...comp] as [number, number]; }; comp[0]++;\n        if (comp[0] >= columns) { comp[0] = 0; comp[1]++; if (comp[1] >= rows)  { comp[1] = 0; } }\n    }\n    return [...preCell];\n}\n\n\n\n/* LAST GENERATION... */\nexport const makeOrientInset = ($orientPx: [number, number], gridArgs: GridArgsType, orient: number = 0): [number, number] => {\n    const boxInPx = [...gridArgs.size];\n    const orientPx: [number, number] = [...$orientPx];\n    const layout = [...gridArgs.layout];\n    if (orient%2) { boxInPx.reverse(); };\n    return [\n        roundNearest(orientPx[0], boxInPx[0] / layout[0]),\n        roundNearest(orientPx[1], boxInPx[1] / layout[1])\n    ];\n}\n\n\n\n\n/* LAST GENERATION... */\nexport const convertOrientPxToCX = ($orientPx: [number, number], gridArgs: GridArgsType, orient: number = 0): [number, number] => {\n    const boxInPx = [...gridArgs.size];\n    const orientPx: [number, number] = [...$orientPx];\n    const layout = [...gridArgs.layout];\n    if (orient%2) { boxInPx.reverse(); };\n    const gridPxToCX = [layout[0] / boxInPx[0], layout[1] / boxInPx[1]];\n    return [orientPx[0] * gridPxToCX[0], orientPx[1] * gridPxToCX[1]]\n}\n\n// should be relative from grid-box (not absolute or fixed position)\nexport const floorInOrientPx = ($orientPx: [number, number], gridArgs: GridArgsType, orient: number = 0) => {\n    const orientPx: [number, number] = [...$orientPx];\n    const boxInPx = [...gridArgs.size];\n    const layout = [...gridArgs.layout];\n    if (orient%2) { boxInPx.reverse(); };\n    const inBox = [boxInPx[0] / layout[0], boxInPx[1] / layout[1]];\n    return [roundNearest(orientPx[0], inBox[0]), roundNearest(orientPx[1], inBox[1])];\n}\n\n//\nexport const floorInCX = ($CX: [number, number], gridArgs: GridArgsType): [number, number] => {\n    const layout = gridArgs.layout;\n    return [\n        Math.min(Math.max(roundNearest($CX[0]), 0), layout[0]-1),\n        Math.min(Math.max(roundNearest($CX[1]), 0), layout[1]-1)\n    ];\n}\n\n//\nexport const clientSpaceInOrientCX = ($clientPx, gridArgs: GridArgsType, orient: number = 0): [number, number] => {\n    const clientPx: [number, number] = [...$clientPx] as [number, number];\n    const size: [number, number] = [...gridArgs.size] as [number, number];\n    //if (orient%2) { size.reverse(); };\n    const orientPx = cvt_cs_to_os(clientPx, size, orient);\n    return [\n        Math.min(Math.max(roundNearest(orientPx[0] / size[0] * (gridArgs.layout[0]), 1), 0), gridArgs.layout[0]-1),\n        Math.min(Math.max(roundNearest(orientPx[1] / size[1] * (gridArgs.layout[1]), 1), 0), gridArgs.layout[1]-1)\n    ]\n};\n","/**\n * Observable Core - Unified WICG-aligned Observable implementation\n *\n * Single source of truth for all Observable primitives.\n * Reference: https://github.com/WICG/observable\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport {\n    createTransportSender,\n    createTransportListener,\n    type TransportTarget,\n    type SendFn\n} from \"../../core/TransportCore\";\nimport { handleRequest } from \"../../core/RequestHandler\";\nimport type {\n    Observer,\n    Subscription,\n    Subscribable,\n    Subscriber,\n    Producer,\n    ChannelMessage,\n    ResponderFn,\n    InvokerHandler,\n    PendingRequest\n} from \"../types/Interface\";\nimport type { WReq } from \"../types/Interface\";\n\n// Re-export types\nexport type { Observer, Subscription, Subscribable, Subscriber, Producer, ChannelMessage };\n\n// ============================================================================\n// BASE SUBSCRIPTION\n// ============================================================================\n\nclass BaseSubscription implements Subscription {\n    private _closed = false;\n    constructor(private _unsubscribe: () => void) {}\n    get closed(): boolean { return this._closed; }\n    unsubscribe(): void { if (!this._closed) { this._closed = true; this._unsubscribe(); } }\n}\n\n// ============================================================================\n// CORE OBSERVABLE (WICG-aligned)\n// ============================================================================\n\n/**\n * Core Observable with producer function\n */\nexport class Observable<T = any> implements Subscribable<T> {\n    constructor(private _producer: Producer<T>) {}\n\n    subscribe(observerOrNext?: Observer<T> | ((v: T) => void), opts?: { signal?: AbortSignal }): Subscription {\n        const observer: Observer<T> = typeof observerOrNext === \"function\"\n            ? { next: observerOrNext } : observerOrNext ?? {};\n\n        const ctrl = new AbortController();\n        opts?.signal?.addEventListener(\"abort\", () => ctrl.abort());\n\n        let active = true;\n        let cleanup: (() => void) | void;\n\n        const doCleanup = () => { active = false; ctrl.abort(); cleanup?.(); };\n\n        const subscriber: Subscriber<T> = {\n            next: (v) => active && observer.next?.(v),\n            error: (e) => { if (active) { observer.error?.(e); doCleanup(); } },\n            complete: () => { if (active) { observer.complete?.(); doCleanup(); } },\n            signal: ctrl.signal,\n            get active() { return active && !ctrl.signal.aborted; }\n        };\n\n        try { cleanup = this._producer(subscriber); }\n        catch (e) { subscriber.error(e as Error); }\n\n        return new BaseSubscription(doCleanup);\n    }\n\n    pipe<R>(...ops: Array<(s: Observable<any>) => Observable<R>>): Observable<R> {\n        return ops.reduce((s, op) => op(s), this as unknown as Observable<any>) as Observable<R>;\n    }\n}\n\n// ============================================================================\n// SUBJECT (Observable with push)\n// ============================================================================\n\nexport interface SubjectOptions { bufferSize?: number; replayOnSubscribe?: boolean; }\n\n/**\n * Subject - Observable that can be pushed to\n */\nexport class ChannelSubject<T = any> implements Subscribable<T> {\n    protected _subs = new Set<Observer<T>>();\n    private _buffer: T[] = [];\n    private _maxBuffer: number;\n    private _replay: boolean;\n\n    constructor(options: SubjectOptions = {}) {\n        this._maxBuffer = options.bufferSize ?? 0;\n        this._replay = options.replayOnSubscribe ?? false;\n    }\n\n    next(value: T): void {\n        if (this._maxBuffer > 0) {\n            this._buffer.push(value);\n            if (this._buffer.length > this._maxBuffer) this._buffer.shift();\n        }\n        for (const s of this._subs) {\n            try { s.next?.(value); } catch (e) { s.error?.(e as Error); }\n        }\n    }\n\n    error(err: Error): void { for (const s of this._subs) s.error?.(err); }\n    complete(): void { for (const s of this._subs) s.complete?.(); this._subs.clear(); }\n\n    subscribe(observerOrNext: Observer<T> | ((v: T) => void)): Subscription {\n        const obs: Observer<T> = typeof observerOrNext === \"function\" ? { next: observerOrNext } : observerOrNext;\n        this._subs.add(obs);\n\n        if (this._replay) {\n            for (const v of this._buffer) { try { obs.next?.(v); } catch (e) { obs.error?.(e as Error); } }\n        }\n\n        return new BaseSubscription(() => { this._subs.delete(obs); });\n    }\n\n    getValue(): T | undefined { return this._buffer.at(-1); }\n    getBuffer(): T[] { return [...this._buffer]; }\n    get subscriberCount(): number { return this._subs.size; }\n}\n\nexport class ReplayChannelSubject<T = any> extends ChannelSubject<T> {\n    constructor(bufferSize = 1) { super({ bufferSize, replayOnSubscribe: true }); }\n}\n\n// ============================================================================\n// CHANNEL OBSERVABLE (with transport + request/response)\n// ============================================================================\n\n/**\n * Channel Observable with bidirectional communication\n */\nexport class ChannelObservable implements Subscribable<ChannelMessage> {\n    private _send: SendFn<ChannelMessage>;\n    private _pending = new Map<string, PendingRequest>();\n    private _subs = new Set<Observer<ChannelMessage>>();\n    private _cleanup: (() => void) | null = null;\n    private _listening = false;\n\n    constructor(private _transport: TransportTarget, private _channelName: string) {\n        this._send = createTransportSender(_transport);\n    }\n\n    next(msg: ChannelMessage, transfer?: Transferable[]): void { this._send(msg, transfer); }\n\n    subscribe(observer: Observer<ChannelMessage> | ((v: ChannelMessage) => void)): Subscription {\n        const obs: Observer<ChannelMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        if (!this._listening) this._activate();\n        return new BaseSubscription(() => {\n            this._subs.delete(obs);\n            if (this._subs.size === 0) this._deactivate();\n        });\n    }\n\n    request(msg: Omit<ChannelMessage, \"reqId\"> & { reqId?: string }): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            this._pending.set(reqId, { resolve, reject, timestamp: Date.now() });\n            this.next({ ...msg, reqId } as ChannelMessage);\n        });\n    }\n\n    private _handle(data: ChannelMessage): void {\n        if (data.type === \"response\" && data.reqId) {\n            const p = this._pending.get(data.reqId);\n            if (p) { p.resolve(data.payload); this._pending.delete(data.reqId); }\n        }\n        for (const s of this._subs) { try { s.next?.(data); } catch (e) { s.error?.(e as Error); } }\n    }\n\n    private _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\n            this._transport,\n            (d) => this._handle(d),\n            (e) => this._subs.forEach((s) => s.error?.(e)),\n            () => this._subs.forEach((s) => s.complete?.())\n        );\n        this._listening = true;\n    }\n\n    private _deactivate(): void {\n        this._cleanup?.(); this._cleanup = null; this._listening = false;\n    }\n\n    close(): void { this._subs.forEach((s) => s.complete?.()); this._subs.clear(); this._deactivate(); }\n    get channelName(): string { return this._channelName; }\n    get isListening(): boolean { return this._listening; }\n}\n\n// ============================================================================\n// INVOKER OBSERVABLE\n// ============================================================================\n\nexport function createInvokerObservable(\n    transport: TransportTarget,\n    channelName: string,\n    handler?: InvokerHandler<ChannelMessage>\n): Observable<ChannelMessage> {\n    const send = createTransportSender(transport);\n    return new Observable((subscriber) => {\n        const onMessage = (data: ChannelMessage) => {\n            if (!subscriber.active) return;\n            const respond: ResponderFn<ChannelMessage> = (result, transfer) => {\n                send({ ...result, channel: data.sender, sender: channelName, type: \"response\", reqId: data.reqId }, transfer);\n            };\n            handler ? handler(data, respond, subscriber) : subscriber.next(data);\n        };\n        return createTransportListener(transport, onMessage, (e) => subscriber.error(e), () => subscriber.complete());\n    });\n}\n\nexport function createReflectHandler(channelName: string): InvokerHandler<ChannelMessage> {\n    return async (data, respond, subscriber) => {\n        if (data.type !== \"request\") { subscriber.next(data); return; }\n        const result = await handleRequest(data.payload as WReq, data.reqId!, channelName);\n        if (result) respond(result.response, result.transfer);\n        subscriber.next(data);\n    };\n}\n\n// ============================================================================\n// MESSAGE OBSERVABLE (filtered by type)\n// ============================================================================\n\nexport class MessageObservable extends ChannelSubject<ChannelMessage> {\n    constructor(source: Subscribable<ChannelMessage>, messageType?: string) {\n        super();\n        source.subscribe({\n            next: (msg) => { if (!messageType || msg.type === messageType) this.next(msg); },\n            error: (e) => this.error(e),\n            complete: () => this.complete()\n        });\n    }\n}\n\n// ============================================================================\n// OPERATORS\n// ============================================================================\n\nexport const filter = <T>(pred: (v: T) => boolean) => (src: Subscribable<T>): Observable<T> =>\n    new Observable((sub) => { const s = src.subscribe({ next: (v) => pred(v) && sub.next(v), error: (e) => sub.error(e), complete: () => sub.complete() }); return () => s.unsubscribe(); });\n\nexport const map = <T, R>(fn: (v: T) => R) => (src: Subscribable<T>): Observable<R> =>\n    new Observable((sub) => { const s = src.subscribe({ next: (v) => sub.next(fn(v)), error: (e) => sub.error(e), complete: () => sub.complete() }); return () => s.unsubscribe(); });\n\nexport const take = <T>(n: number) => (src: Subscribable<T>): Observable<T> =>\n    new Observable((sub) => { let c = 0; const s = src.subscribe({ next: (v) => { if (c++ < n) { sub.next(v); if (c >= n) sub.complete(); } }, error: (e) => sub.error(e), complete: () => sub.complete() }); return () => s.unsubscribe(); });\n\nexport const takeUntil = <T>(signal: Subscribable<any>) => (src: Subscribable<T>): Observable<T> =>\n    new Observable((sub) => { const ss = src.subscribe({ next: (v) => sub.next(v), error: (e) => sub.error(e), complete: () => sub.complete() }); const sig = signal.subscribe({ next: () => sub.complete() }); return () => { ss.unsubscribe(); sig.unsubscribe(); }; });\n\nexport const debounce = <T>(ms: number) => (src: Subscribable<T>): Observable<T> =>\n    new Observable((sub) => { let t: any; const s = src.subscribe({ next: (v) => { clearTimeout(t); t = setTimeout(() => sub.next(v), ms); }, error: (e) => sub.error(e), complete: () => sub.complete() }); return () => { clearTimeout(t); s.unsubscribe(); }; });\n\nexport const throttle = <T>(ms: number) => (src: Subscribable<T>): Observable<T> =>\n    new Observable((sub) => { let last = 0; const s = src.subscribe({ next: (v) => { const now = Date.now(); if (now - last >= ms) { last = now; sub.next(v); } }, error: (e) => sub.error(e), complete: () => sub.complete() }); return () => s.unsubscribe(); });\n\n// ============================================================================\n// UTILITIES\n// ============================================================================\n\nexport const fromEvent = <K extends keyof HTMLElementEventMap>(target: EventTarget, event: K): Observable<HTMLElementEventMap[K]> =>\n    new Observable((sub) => { const h = (e: Event) => sub.active && sub.next(e as HTMLElementEventMap[K]); target.addEventListener(event, h); return () => target.removeEventListener(event, h); });\n\nexport const fromPromise = <T>(promise: Promise<T>): Observable<T> =>\n    new Observable((sub) => { promise.then((v) => { sub.next(v); sub.complete(); }).catch((e) => sub.error(e)); });\n\nexport const delay = <T>(value: T, ms: number): Observable<T> =>\n    new Observable((sub) => { const t = setTimeout(() => { sub.next(value); sub.complete(); }, ms); return () => clearTimeout(t); });\n\nexport const interval = (ms: number): Observable<number> =>\n    new Observable((sub) => { let n = 0; const t = setInterval(() => sub.next(n++), ms); return () => clearInterval(t); });\n\nexport const merge = <T>(...sources: Subscribable<T>[]): Observable<T> =>\n    new Observable((sub) => { const subs = sources.map((s) => s.subscribe({ next: (v) => sub.next(v), error: (e) => sub.error(e) })); return () => subs.forEach((s) => s.unsubscribe()); });\n\nexport const createMessageId = (): string => UUIDv4();\n\n// ============================================================================\n// TRANSPORT INVOKER FACTORIES\n// ============================================================================\n\nconst makeInvoker = (transport: TransportTarget, handler?: InvokerHandler<ChannelMessage>) =>\n    (subscriber: Subscriber<ChannelMessage>): () => void => {\n        const send = createTransportSender(transport);\n        const respond: ResponderFn<ChannelMessage> = (result, transfer) => send(result, transfer);\n        return createTransportListener(\n            transport,\n            (data: ChannelMessage) => {\n                if (!subscriber.active) return;\n                handler ? handler(data, respond, subscriber) : subscriber.next(data);\n            },\n            (err) => subscriber.error(err),\n            () => subscriber.complete()\n        );\n    };\n\nexport const makeWorkerInvoker = (worker: Worker, handler?: InvokerHandler<ChannelMessage>) => makeInvoker(worker, handler);\nexport const makeMessagePortInvoker = (port: MessagePort, handler?: InvokerHandler<ChannelMessage>) => makeInvoker(port, handler);\nexport const makeBroadcastInvoker = (name: string, handler?: InvokerHandler<ChannelMessage>) => makeInvoker(new BroadcastChannel(name), handler);\nexport const makeWebSocketInvoker = (url: string | URL, protocols?: string | string[], handler?: InvokerHandler<ChannelMessage>) =>\n    makeInvoker(new WebSocket(typeof url === \"string\" ? url : url.href, protocols), handler);\nexport const makeChromeRuntimeInvoker = (handler?: InvokerHandler<ChannelMessage>) => makeInvoker(\"chrome-runtime\" as TransportTarget, handler);\nexport const makeServiceWorkerClientInvoker = (handler?: InvokerHandler<ChannelMessage>) => makeInvoker(\"service-worker-client\" as TransportTarget, handler);\nexport const makeServiceWorkerHostInvoker = (handler?: InvokerHandler<ChannelMessage>) => makeInvoker(\"service-worker-host\" as TransportTarget, handler);\nexport const makeSelfInvoker = (handler?: InvokerHandler<ChannelMessage>) => makeInvoker(\"self\" as TransportTarget, handler);\n\n// ============================================================================\n// BIDIRECTIONAL CHANNEL\n// ============================================================================\n\nexport interface BidirectionalChannel<T = ChannelMessage> {\n    inbound: Observable<T>;\n    outbound: { next(value: T, transfer?: Transferable[]): void };\n    subscribe(observer: Observer<T>): Subscription;\n    send(value: T, transfer?: Transferable[]): void;\n}\n\nexport function createBidirectionalChannel(\n    transport: TransportTarget,\n    channelName: string,\n    handler?: InvokerHandler<ChannelMessage>\n): BidirectionalChannel<ChannelMessage> {\n    const send = createTransportSender(transport);\n    const inbound = new Observable<ChannelMessage>((sub) => makeInvoker(transport, handler)(sub));\n    return {\n        inbound,\n        outbound: { next: send },\n        subscribe: (obs) => inbound.subscribe(obs),\n        send: (value, transfer) => send(value, transfer)\n    };\n}\n\n// ============================================================================\n// EVENT UTILITY\n// ============================================================================\n\nexport function when<K extends keyof HTMLElementEventMap>(target: EventTarget, eventName: K): Observable<HTMLElementEventMap[K]>;\nexport function when(target: EventTarget, eventName: string): Observable<Event>;\nexport function when(target: EventTarget, eventName: string): Observable<Event> {\n    return new Observable((sub) => {\n        const h = (e: Event) => sub.active && sub.next(e);\n        target.addEventListener(eventName, h);\n        return () => target.removeEventListener(eventName, h);\n    });\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const ObservableFactory = {\n    channel: (transport: TransportTarget, name: string) => new ChannelObservable(transport, name),\n    invoker: (transport: TransportTarget, name: string, handler?: InvokerHandler<ChannelMessage>) => createInvokerObservable(transport, name, handler),\n    handler: (transport: TransportTarget, name: string) => createInvokerObservable(transport, name, createReflectHandler(name)),\n    bidirectional: createBidirectionalChannel,\n    fromEvent,\n    fromPromise,\n    delay,\n    interval,\n    merge,\n    when\n};\n","/**\n * Invoker - Requestor/Responder Abstraction\n *\n * Thin wrapper around UnifiedChannel providing:\n * - Requestor: Invokes commands to remote channel objects/methods\n * - Responder: Listens, executes via Reflect, returns proxy-wrapped results\n * - Auto-detection of connection/transport type\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { UnifiedChannel, createUnifiedChannel, type UnifiedChannelConfig, type ConnectOptions } from \"../channel/UnifiedChannel\";\nimport type { Subscription, ChannelMessage } from \"../observable/Observable\";\nimport { WReflectAction, type WReflectDescriptor, type TransportType } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Detected context type */\nexport type ContextType =\n    | \"window\" | \"worker\" | \"shared-worker\" | \"service-worker\"\n    | \"chrome-content\" | \"chrome-background\" | \"chrome-popup\" | \"chrome-devtools\"\n    | \"node\" | \"deno\" | \"unknown\";\n\n/** Invoker configuration */\nexport interface InvokerConfig {\n    channel: string;\n    autoDetect?: boolean;\n    timeout?: number;\n    cacheResponses?: boolean;\n    reflectImpl?: ReflectLike;\n}\n\n/** ReflectLike interface */\nexport interface ReflectLike {\n    get?(target: any, prop: PropertyKey): any;\n    set?(target: any, prop: PropertyKey, value: any): boolean;\n    has?(target: any, prop: PropertyKey): boolean;\n    apply?(target: any, thisArg: any, args: any[]): any;\n    construct?(target: any, args: any[]): any;\n    deleteProperty?(target: any, prop: PropertyKey): boolean;\n    ownKeys?(target: any): (string | symbol)[];\n    getOwnPropertyDescriptor?(target: any, prop: PropertyKey): PropertyDescriptor | undefined;\n    getPrototypeOf?(target: any): object | null;\n    setPrototypeOf?(target: any, proto: object | null): boolean;\n    isExtensible?(target: any): boolean;\n    preventExtensions?(target: any): boolean;\n}\n\n/** Incoming invocation event */\nexport interface IncomingInvocation {\n    id: string;\n    channel: string;\n    sender: string;\n    action: WReflectAction | string;\n    path: string[];\n    args: any[];\n    timestamp: number;\n    contextType?: ContextType;\n}\n\n/** Outgoing response */\nexport interface InvocationResponse {\n    id: string;\n    channel: string;\n    sender: string;\n    result: any;\n    descriptor?: WReflectDescriptor;\n    error?: string;\n    timestamp: number;\n}\n\n// ============================================================================\n// CONTEXT DETECTION\n// ============================================================================\n\nexport function detectContextType(): ContextType {\n    if (typeof (globalThis as any).Deno !== \"undefined\") return \"deno\";\n    if (typeof (globalThis as any).process !== \"undefined\" && (globalThis as any).process?.versions?.node) return \"node\";\n    if (typeof ServiceWorkerGlobalScope !== \"undefined\" && self instanceof ServiceWorkerGlobalScope) return \"service-worker\";\n    if (typeof SharedWorkerGlobalScope !== \"undefined\" && self instanceof SharedWorkerGlobalScope) return \"shared-worker\";\n    if (typeof DedicatedWorkerGlobalScope !== \"undefined\" && self instanceof DedicatedWorkerGlobalScope) return \"worker\";\n\n    if (typeof chrome !== \"undefined\" && chrome.runtime?.id) {\n        if (typeof chrome.runtime.getBackgroundPage === \"function\" || (chrome.runtime.getManifest?.()?.background as any)?.service_worker) return \"chrome-background\";\n        if (typeof (chrome as any).devtools !== \"undefined\") return \"chrome-devtools\";\n        if (typeof document !== \"undefined\" && globalThis?.location?.protocol === \"chrome-extension:\") {\n            const views = chrome.extension?.getViews?.({ type: \"popup\" }) ?? [];\n            if (views.includes(globalThis as any)) return \"chrome-popup\";\n        }\n        if (typeof document !== \"undefined\" && globalThis?.location?.protocol !== \"chrome-extension:\") return \"chrome-content\";\n    }\n\n    if (typeof globalThis !== \"undefined\" && typeof document !== \"undefined\") return \"window\";\n    return \"unknown\";\n}\n\nexport function detectTransportType(source: Worker | MessagePort | BroadcastChannel | WebSocket | any): TransportType {\n    if (!source) return \"internal\";\n    if (typeof Worker !== \"undefined\" && source instanceof Worker) return \"worker\";\n    if (typeof SharedWorker !== \"undefined\" && source instanceof SharedWorker) return \"shared-worker\";\n    if (typeof MessagePort !== \"undefined\" && source instanceof MessagePort) return \"message-port\";\n    if (typeof BroadcastChannel !== \"undefined\" && source instanceof BroadcastChannel) return \"broadcast\";\n    if (typeof WebSocket !== \"undefined\" && source instanceof WebSocket) return \"websocket\";\n    if (typeof RTCDataChannel !== \"undefined\" && source instanceof RTCDataChannel) return \"rtc-data\";\n    if (source === \"chrome-runtime\" || source === \"chrome-tabs\" || source === \"chrome-port\" || source === \"chrome-external\") {\n        return source as TransportType;\n    }\n    if (\n        typeof chrome !== \"undefined\" &&\n        source &&\n        typeof source === \"object\" &&\n        typeof source.postMessage === \"function\" &&\n        source.onMessage?.addListener\n    ) {\n        return \"chrome-port\";\n    }\n    if (source === self || source === globalThis || source === \"self\") return \"self\";\n    return \"internal\";\n}\n\nexport function detectIncomingContextType(data: any): ContextType {\n    if (!data) return \"unknown\";\n    if (data.contextType) return data.contextType;\n    const sender = data.sender ?? \"\";\n    if (sender.includes(\"worker\")) return \"worker\";\n    if (sender.includes(\"sw\") || sender.includes(\"service\")) return \"service-worker\";\n    if (sender.includes(\"chrome\") || sender.includes(\"crx\")) return \"chrome-content\";\n    if (sender.includes(\"background\")) return \"chrome-background\";\n    return \"unknown\";\n}\n\n// ============================================================================\n// DEFAULT REFLECT\n// ============================================================================\n\nexport const DefaultReflect: ReflectLike = {\n    get: (target, prop) => Reflect.get(target, prop),\n    set: (target, prop, value) => Reflect.set(target, prop, value),\n    has: (target, prop) => Reflect.has(target, prop),\n    apply: (target, thisArg, args) => Reflect.apply(target, thisArg, args),\n    construct: (target, args) => Reflect.construct(target, args),\n    deleteProperty: (target, prop) => Reflect.deleteProperty(target, prop),\n    ownKeys: (target) => Reflect.ownKeys(target) as (string | symbol)[],\n    getOwnPropertyDescriptor: (target, prop) => Reflect.getOwnPropertyDescriptor(target, prop),\n    getPrototypeOf: (target) => Reflect.getPrototypeOf(target),\n    setPrototypeOf: (target, proto) => Reflect.setPrototypeOf(target, proto),\n    isExtensible: (target) => Reflect.isExtensible(target),\n    preventExtensions: (target) => Reflect.preventExtensions(target)\n};\n\n// ============================================================================\n// REQUESTOR (Wrapper around UnifiedChannel for sending)\n// ============================================================================\n\nexport class Requestor {\n    private _channel: UnifiedChannel;\n    private _contextType: ContextType;\n\n    constructor(config: InvokerConfig) {\n        this._contextType = config.autoDetect !== false ? detectContextType() : \"unknown\";\n        this._channel = createUnifiedChannel({\n            name: config.channel,\n            timeout: config.timeout,\n            autoListen: false\n        });\n    }\n\n    connect(target: Worker | MessagePort | BroadcastChannel | WebSocket | any, options?: ConnectOptions): this {\n        this._channel.connect(target, options);\n        return this;\n    }\n\n    invoke<T = any>(targetChannel: string, action: WReflectAction, path: string[], args: any[] = []): Promise<T> {\n        return this._channel.invoke(targetChannel, action, path, args);\n    }\n\n    get<T = any>(targetChannel: string, path: string[], prop: string): Promise<T> {\n        return this._channel.get(targetChannel, path, prop);\n    }\n\n    set(targetChannel: string, path: string[], prop: string, value: any): Promise<boolean> {\n        return this._channel.set(targetChannel, path, prop, value);\n    }\n\n    call<T = any>(targetChannel: string, path: string[], args: any[] = []): Promise<T> {\n        return this._channel.call(targetChannel, path, args);\n    }\n\n    construct<T = any>(targetChannel: string, path: string[], args: any[] = []): Promise<T> {\n        return this._channel.construct(targetChannel, path, args);\n    }\n\n    importModule<T = any>(targetChannel: string, url: string): Promise<T> {\n        return this._channel.import(url, targetChannel);\n    }\n\n    createProxy<T = any>(targetChannel: string, basePath: string[] = []): T {\n        return this._channel.proxy(targetChannel, basePath);\n    }\n\n    get onResponse() { return this._channel.onResponse; }\n    get contextType(): ContextType { return this._contextType; }\n    close(): void { this._channel.close(); }\n}\n\n// ============================================================================\n// RESPONDER (Wrapper around UnifiedChannel for receiving)\n// ============================================================================\n\nexport class Responder {\n    private _channel: UnifiedChannel;\n    private _contextType: ContextType;\n\n    constructor(config: InvokerConfig) {\n        this._contextType = config.autoDetect !== false ? detectContextType() : \"unknown\";\n        this._channel = createUnifiedChannel({\n            name: config.channel,\n            timeout: config.timeout,\n            autoListen: false\n        });\n    }\n\n    listen(source: Worker | MessagePort | BroadcastChannel | WebSocket | any, options?: ConnectOptions): this {\n        this._channel.listen(source, options);\n        return this;\n    }\n\n    expose(name: string, obj: any): this {\n        this._channel.expose(name, obj);\n        return this;\n    }\n\n    get onInvocation() { return this._channel.onInvocation; }\n    subscribeInvocations(handler: (inv: IncomingInvocation) => void): Subscription {\n        return this._channel.onInvocation.subscribe(handler as any);\n    }\n    get contextType(): ContextType { return this._contextType; }\n    close(): void { this._channel.close(); }\n}\n\n// ============================================================================\n// BIDIRECTIONAL INVOKER\n// ============================================================================\n\nexport class BidirectionalInvoker {\n    public readonly requestor: Requestor;\n    public readonly responder: Responder;\n    private _contextType: ContextType;\n\n    constructor(config: InvokerConfig) {\n        this._contextType = config.autoDetect !== false ? detectContextType() : \"unknown\";\n        this.requestor = new Requestor(config);\n        this.responder = new Responder(config);\n    }\n\n    connect(target: Worker | MessagePort | BroadcastChannel | WebSocket | any): this {\n        this.requestor.connect(target);\n        this.responder.listen(target);\n        return this;\n    }\n\n    expose(name: string, obj: any): this { this.responder.expose(name, obj); return this; }\n    createProxy<T = any>(targetChannel: string, basePath: string[] = []): T { return this.requestor.createProxy(targetChannel, basePath); }\n    importModule<T = any>(targetChannel: string, url: string): Promise<T> { return this.requestor.importModule(targetChannel, url); }\n    get contextType(): ContextType { return this._contextType; }\n    close(): void { this.requestor.close(); this.responder.close(); }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\nexport function createRequestor(channel: string, config?: Partial<InvokerConfig>): Requestor {\n    return new Requestor({ channel, ...config });\n}\n\nexport function createResponder(channel: string, config?: Partial<InvokerConfig>): Responder {\n    return new Responder({ channel, ...config });\n}\n\nexport function createInvoker(channel: string, config?: Partial<InvokerConfig>): BidirectionalInvoker {\n    return new BidirectionalInvoker({ channel, ...config });\n}\n\nexport function setupInvoker(\n    channel: string,\n    target: Worker | MessagePort | BroadcastChannel | WebSocket | any,\n    config?: Partial<InvokerConfig>\n): BidirectionalInvoker {\n    return createInvoker(channel, config).connect(target);\n}\n\nexport function autoInvoker(channel: string, config?: Partial<InvokerConfig>): BidirectionalInvoker {\n    const invoker = createInvoker(channel, { autoDetect: true, ...config });\n    const contextType = detectContextType();\n\n    switch (contextType) {\n        case \"worker\":\n        case \"service-worker\":\n        case \"shared-worker\":\n            invoker.connect(self);\n            break;\n        case \"chrome-content\":\n        case \"chrome-background\":\n        case \"chrome-popup\":\n            invoker.connect(\"chrome-runtime\" as any);\n            break;\n    }\n\n    return invoker;\n}\n","/**\n * Proxy - Unified Remote Proxy Creation\n *\n * Single source of truth for all proxy-related functionality:\n * - Remote object proxies (transparent RPC)\n * - Descriptor-based proxies\n * - Type-safe proxy creation\n * - Expose/listen patterns\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { WReflectAction, type WReflectDescriptor } from \"../types/Interface\";\nimport {\n    $descriptor,\n    $requestHandler,\n    descMap,\n    wrapMap\n} from \"../storage/DataBase\";\nimport { createObjectHandler, type ReflectLike as CoreReflectLike } from \"../../core/RequestHandler\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Proxy invoker function - sends requests to remote */\nexport type ProxyInvoker = (\n    action: WReflectAction | string,\n    path: string[],\n    args: any[]\n) => Promise<any>;\n\n/** Proxy descriptor with metadata */\nexport interface ProxyDescriptor {\n    /** Object path on remote */\n    path: string[];\n    /** Target channel name */\n    channel: string;\n    /** Owner channel */\n    owner?: string;\n    /** Is primitive value */\n    primitive?: boolean;\n}\n\n/** Proxy configuration */\nexport interface ProxyConfig {\n    /** Target channel for requests */\n    channel: string;\n    /** Base path for property access */\n    basePath?: string[];\n    /** Custom invoker function */\n    invoker?: ProxyInvoker;\n    /** Cache created proxies */\n    cache?: boolean;\n    /** Timeout for requests (ms) */\n    timeout?: number;\n}\n\n/** Convert object methods to Promise-returning versions */\nexport type ProxyMethods<T> = {\n    [K in keyof T]: T[K] extends (...args: infer A) => infer R\n        ? (...args: A) => Promise<Awaited<R>>\n        : Promise<T[K]>;\n};\n\n/** Remote proxy with metadata access */\nexport type RemoteProxy<T = any> = ProxyMethods<T> & {\n    /** Get the proxy path */\n    readonly $path: string[];\n    /** Get the target channel */\n    readonly $channel: string;\n    /** Get the descriptor */\n    readonly $descriptor: ProxyDescriptor;\n    /** Direct invoke method */\n    $invoke: ProxyInvoker;\n};\n\n/** Exposer handler for incoming requests */\nexport type ExposeHandler = (\n    action: string,\n    path: string[],\n    args: any[]\n) => Promise<any>;\n\n// ============================================================================\n// SYMBOLS\n// ============================================================================\n\n/** Symbol to identify proxy objects */\nexport const PROXY_MARKER = Symbol.for(\"uniform.proxy\");\n\n/** Symbol to access proxy internals */\nexport const PROXY_INTERNALS = Symbol.for(\"uniform.proxy.internals\");\n\n// ============================================================================\n// PROXY HANDLER\n// ============================================================================\n\n/**\n * RemoteProxyHandler - Unified proxy handler for remote invocation\n *\n * Handles all Reflect operations and forwards them to the invoker.\n */\nexport class RemoteProxyHandler implements ProxyHandler<Function> {\n    private _config: Required<ProxyConfig>;\n    private _childCache = new Map<string, any>();\n\n    constructor(\n        private _invoker: ProxyInvoker,\n        config: ProxyConfig\n    ) {\n        this._config = {\n            channel: config.channel,\n            basePath: config.basePath ?? [],\n            invoker: _invoker,\n            cache: config.cache ?? true,\n            timeout: config.timeout ?? 30000\n        };\n    }\n\n    /** Get property - returns nested proxy or invokes GET */\n    get(target: Function, prop: PropertyKey, receiver: any): any {\n        const propStr = String(prop);\n\n        // Handle special properties\n        if (prop === PROXY_MARKER) return true;\n        if (prop === PROXY_INTERNALS) return this._config;\n        if (prop === $requestHandler) return true;\n        if (prop === $descriptor) return this._getDescriptor();\n\n        // Promise methods - return undefined to allow await\n        if (prop === \"then\" || prop === \"catch\" || prop === \"finally\") return undefined;\n\n        // Symbol properties\n        if (typeof prop === \"symbol\") return undefined;\n\n        // Metadata accessors\n        if (prop === \"$path\") return this._config.basePath;\n        if (prop === \"$channel\") return this._config.channel;\n        if (prop === \"$descriptor\") return this._getDescriptor();\n        if (prop === \"$invoke\") return this._invoker;\n\n        // Create child proxy for nested access\n        const childPath = [...this._config.basePath, propStr];\n\n        if (this._config.cache && this._childCache.has(propStr)) {\n            return this._childCache.get(propStr);\n        }\n\n        const childProxy = createRemoteProxy(this._invoker, {\n            ...this._config,\n            basePath: childPath\n        });\n\n        if (this._config.cache) {\n            this._childCache.set(propStr, childProxy);\n        }\n\n        return childProxy;\n    }\n\n    /** Set property */\n    set(target: Function, prop: PropertyKey, value: any, receiver: any): boolean {\n        if (typeof prop === \"symbol\") return true;\n\n        this._invoker(\n            WReflectAction.SET,\n            [...this._config.basePath, String(prop)],\n            [value]\n        );\n        return true;\n    }\n\n    /** Apply function */\n    apply(target: Function, thisArg: any, args: any[]): any {\n        return this._invoker(\n            WReflectAction.APPLY,\n            this._config.basePath,\n            [args]\n        );\n    }\n\n    /** Construct new instance */\n    construct(target: Function, args: any[], newTarget: Function): object {\n        return this._invoker(\n            WReflectAction.CONSTRUCT,\n            this._config.basePath,\n            [args]\n        ) as any;\n    }\n\n    /** Check if property exists */\n    has(target: Function, prop: PropertyKey): boolean {\n        if (typeof prop === \"symbol\") return false;\n        return this._invoker(\n            WReflectAction.HAS,\n            this._config.basePath,\n            [prop]\n        ) as any;\n    }\n\n    /** Delete property */\n    deleteProperty(target: Function, prop: PropertyKey): boolean {\n        if (typeof prop === \"symbol\") return true;\n        return this._invoker(\n            WReflectAction.DELETE_PROPERTY,\n            [...this._config.basePath, String(prop)],\n            []\n        ) as any;\n    }\n\n    /** Get own keys */\n    ownKeys(target: Function): ArrayLike<string | symbol> {\n        return [];\n    }\n\n    /** Get property descriptor */\n    getOwnPropertyDescriptor(target: Function, prop: PropertyKey): PropertyDescriptor | undefined {\n        return { configurable: true, enumerable: true, writable: true };\n    }\n\n    /** Get prototype */\n    getPrototypeOf(target: Function): object | null {\n        return Function.prototype;\n    }\n\n    /** Set prototype */\n    setPrototypeOf(target: Function, proto: object | null): boolean {\n        return this._invoker(\n            WReflectAction.SET_PROTOTYPE_OF,\n            this._config.basePath,\n            [proto]\n        ) as any;\n    }\n\n    /** Check if extensible */\n    isExtensible(target: Function): boolean {\n        return true;\n    }\n\n    /** Prevent extensions */\n    preventExtensions(target: Function): boolean {\n        return this._invoker(\n            WReflectAction.PREVENT_EXTENSIONS,\n            this._config.basePath,\n            []\n        ) as any;\n    }\n\n    /** Get descriptor for this proxy */\n    private _getDescriptor(): ProxyDescriptor {\n        return {\n            path: this._config.basePath,\n            channel: this._config.channel,\n            primitive: false\n        };\n    }\n}\n\n// ============================================================================\n// DISPATCH HANDLER (Legacy compatible)\n// ============================================================================\n\n/**\n * DispatchProxyHandler - Delegates all operations to a dispatcher\n *\n * Used for backward compatibility with RequestProxyHandlerV2.\n */\nexport class DispatchProxyHandler implements ProxyHandler<Function> {\n    constructor(private _dispatch: (action: WReflectAction, args: any[]) => any) {}\n\n    get(...args: any[]) { return this._dispatch(WReflectAction.GET, args); }\n    set(...args: any[]) { return this._dispatch(WReflectAction.SET, args); }\n    has(...args: any[]) { return this._dispatch(WReflectAction.HAS, args); }\n    deleteProperty(...args: any[]) { return this._dispatch(WReflectAction.DELETE_PROPERTY, args); }\n    getOwnPropertyDescriptor(...args: any[]) { return this._dispatch(WReflectAction.GET_OWN_PROPERTY_DESCRIPTOR, args); }\n    getPrototypeOf(...args: any[]) { return this._dispatch(WReflectAction.GET_PROTOTYPE_OF, args); }\n    setPrototypeOf(...args: any[]) { return this._dispatch(WReflectAction.SET_PROTOTYPE_OF, args); }\n    isExtensible(...args: any[]) { return this._dispatch(WReflectAction.IS_EXTENSIBLE, args); }\n    preventExtensions(...args: any[]) { return this._dispatch(WReflectAction.PREVENT_EXTENSIONS, args); }\n    ownKeys(...args: any[]) { return this._dispatch(WReflectAction.OWN_KEYS, args) ?? []; }\n    apply(...args: any[]) { return this._dispatch(WReflectAction.APPLY, args); }\n    construct(...args: any[]) { return this._dispatch(WReflectAction.CONSTRUCT, args); }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create a remote proxy for transparent RPC\n *\n * @param invoker - Function to invoke remote operations\n * @param config - Proxy configuration\n * @returns Proxy object that forwards all operations to remote\n *\n * @example\n * const proxy = createRemoteProxy(\n *     (action, path, args) => channel.invoke(targetChannel, action, path, args),\n *     { channel: \"worker\" }\n * );\n *\n * // All operations are forwarded\n * await proxy.math.add(1, 2);\n * await proxy.user.name;\n * proxy.config.debug = true;\n */\nexport function createRemoteProxy<T = any>(\n    invoker: ProxyInvoker,\n    config: ProxyConfig\n): RemoteProxy<T> {\n    const fn: any = function() {};\n    const handler = new RemoteProxyHandler(invoker, config);\n    return new Proxy(fn, handler) as RemoteProxy<T>;\n}\n\n/**\n * Create proxy from descriptor\n *\n * Wraps a WReflectDescriptor into a usable proxy object.\n *\n * @param descriptor - Remote object descriptor\n * @param invoker - Function to invoke remote operations\n * @param targetChannel - Override channel from descriptor\n */\nexport function wrapDescriptor<T = any>(\n    descriptor: WReflectDescriptor,\n    invoker: ProxyInvoker,\n    targetChannel?: string\n): RemoteProxy<T> | T {\n    if (!descriptor || typeof descriptor !== \"object\") return descriptor as T;\n    if (descriptor.primitive) return descriptor as unknown as T;\n\n    // Check cache (use any for map compatibility)\n    const cached = descMap.get(descriptor);\n    if (cached) return cached as unknown as RemoteProxy<T>;\n\n    const proxy = createRemoteProxy<T>(invoker, {\n        channel: targetChannel ?? descriptor.channel ?? \"unknown\",\n        basePath: descriptor.path ?? []\n    });\n\n    // Cache the proxy\n    (descMap as Map<any, any>).set(descriptor, proxy);\n    (wrapMap as Map<any, any>).set(proxy, descriptor);\n\n    return proxy;\n}\n\n/**\n * Check if value is a remote proxy\n */\nexport function isRemoteProxy(value: any): value is RemoteProxy {\n    if (!value) return false;\n    if (typeof value !== \"object\" && typeof value !== \"function\") return false;\n    try {\n        // Access via Reflect to trigger proxy trap\n        return Reflect.get(value, PROXY_MARKER) === true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Get proxy descriptor if value is a proxy\n */\nexport function getProxyDescriptor(value: any): ProxyDescriptor | null {\n    if (!isRemoteProxy(value)) return null;\n    return value.$descriptor ?? null;\n}\n\n/**\n * Get proxy internals (config)\n */\nexport function getProxyInternals(value: any): ProxyConfig | null {\n    if (!isRemoteProxy(value)) return null;\n    try {\n        // Use Reflect to get symbol property\n        const internals = Reflect.get(value, PROXY_INTERNALS);\n        if (!internals || typeof internals !== \"object\") return null;\n        return internals as ProxyConfig;\n    } catch {\n        return null;\n    }\n}\n\n// ============================================================================\n// EXPOSE UTILITIES\n// ============================================================================\n\n/**\n * Create an expose handler for an object\n *\n * Uses the unified RequestHandler for consistent behavior.\n *\n * @param target - Object to expose\n * @param reflect - Optional custom Reflect implementation\n * @returns Handler function for incoming requests\n */\nexport function createExposeHandler<T extends object>(\n    target: T,\n    reflect?: CoreReflectLike\n): ExposeHandler {\n    return createObjectHandler(target, reflect);\n}\n\n// ============================================================================\n// PORT-BASED PROXY (Simplified)\n// ============================================================================\n\n/** Sender interface for port-based proxy */\nexport interface ProxySender {\n    request(msg: any): Promise<any>;\n    readonly channelName: string;\n    readonly senderId?: string;\n}\n\n/**\n * Create a proxy for remote object over a sender (MessagePort, etc.)\n *\n * @param sender - Object with request() method\n * @param basePath - Base path for property access\n */\nexport function createSenderProxy<T extends object>(\n    sender: ProxySender,\n    basePath: string[] = []\n): ProxyMethods<T> {\n    const invoker: ProxyInvoker = (action, path, args) => {\n        return sender.request({\n            id: UUIDv4(),\n            channel: sender.channelName,\n            sender: sender.senderId ?? \"proxy\",\n            type: \"request\",\n            payload: { action, path, args }\n        });\n    };\n\n    return createRemoteProxy<T>(invoker, {\n        channel: sender.channelName,\n        basePath\n    }) as ProxyMethods<T>;\n}\n\n// ============================================================================\n// PROXY BUILDER (Fluent API)\n// ============================================================================\n\n/**\n * ProxyBuilder - Fluent API for creating proxies\n *\n * @example\n * const proxy = new ProxyBuilder()\n *     .channel(\"worker\")\n *     .path([\"modules\", \"math\"])\n *     .invoker((action, path, args) => channel.invoke(...))\n *     .timeout(5000)\n *     .build();\n */\nexport class ProxyBuilder<T = any> {\n    private _config: Partial<ProxyConfig> = {};\n    private _invoker: ProxyInvoker | null = null;\n\n    /** Set target channel */\n    channel(name: string): this {\n        this._config.channel = name;\n        return this;\n    }\n\n    /** Set base path */\n    path(basePath: string[]): this {\n        this._config.basePath = basePath;\n        return this;\n    }\n\n    /** Set invoker function */\n    invoker(fn: ProxyInvoker): this {\n        this._invoker = fn;\n        return this;\n    }\n\n    /** Set timeout */\n    timeout(ms: number): this {\n        this._config.timeout = ms;\n        return this;\n    }\n\n    /** Enable/disable caching */\n    cache(enabled: boolean): this {\n        this._config.cache = enabled;\n        return this;\n    }\n\n    /** Build the proxy */\n    build(): RemoteProxy<T> {\n        if (!this._invoker) {\n            throw new Error(\"Invoker is required. Call .invoker() before .build()\");\n        }\n        if (!this._config.channel) {\n            throw new Error(\"Channel is required. Call .channel() before .build()\");\n        }\n        return createRemoteProxy<T>(this._invoker, this._config as ProxyConfig);\n    }\n}\n\n/**\n * Create a new proxy builder\n */\nexport function proxyBuilder<T = any>(): ProxyBuilder<T> {\n    return new ProxyBuilder<T>();\n}\n\n// ============================================================================\n// LEGACY EXPORTS (Backward Compatibility)\n// ============================================================================\n\n/** @deprecated Use RemoteProxyHandler */\nexport { RemoteProxyHandler as RequestProxyHandler };\n\n/** @deprecated Use createRemoteProxy */\nexport const makeProxy = createRemoteProxy;\n\n/** @deprecated Use wrapDescriptor */\nexport const makeRequestProxy = wrapDescriptor;\n","export type ConnectionDirection = \"incoming\" | \"outgoing\";\nexport type ConnectionStatus = \"active\" | \"closed\";\n\nexport interface ConnectionInfo<TTransport extends string = string> {\n    id: string;\n    localChannel: string;\n    remoteChannel: string;\n    sender: string;\n    transportType: TTransport;\n    direction: ConnectionDirection;\n    status: ConnectionStatus;\n    createdAt: number;\n    updatedAt: number;\n    lastNotifyAt?: number;\n    metadata?: Record<string, any>;\n}\n\nexport interface ConnectionEvent<TTransport extends string = string> {\n    type: \"connected\" | \"notified\" | \"disconnected\";\n    connection: ConnectionInfo<TTransport>;\n    timestamp: number;\n    payload?: any;\n}\n\nexport interface QueryConnectionsOptions<TTransport extends string = string> {\n    channel?: string;\n    localChannel?: string;\n    remoteChannel?: string;\n    sender?: string;\n    transportType?: TTransport;\n    direction?: ConnectionDirection;\n    status?: ConnectionStatus;\n    includeClosed?: boolean;\n}\n\nexport interface RegisterConnectionParams<TTransport extends string = string> {\n    localChannel: string;\n    remoteChannel: string;\n    sender: string;\n    transportType: TTransport;\n    direction: ConnectionDirection;\n    metadata?: Record<string, any>;\n}\n\nfunction createConnectionKey<TTransport extends string = string>(\n    params: RegisterConnectionParams<TTransport>\n): string {\n    return [\n        params.localChannel,\n        params.remoteChannel,\n        params.sender,\n        params.transportType,\n        params.direction\n    ].join(\"::\");\n}\n\nexport function queryConnections<TTransport extends string = string>(\n    connections: Iterable<ConnectionInfo<TTransport>>,\n    query: QueryConnectionsOptions<TTransport> = {}\n): ConnectionInfo<TTransport>[] {\n    const includeClosed = query.includeClosed ?? false;\n    const desiredStatus = query.status ?? (includeClosed ? undefined : \"active\");\n\n    return [...connections]\n        .filter((connection) => {\n            if (desiredStatus && connection.status !== desiredStatus) return false;\n            if (query.channel && connection.localChannel !== query.channel && connection.remoteChannel !== query.channel) return false;\n            if (query.localChannel && connection.localChannel !== query.localChannel) return false;\n            if (query.remoteChannel && connection.remoteChannel !== query.remoteChannel) return false;\n            if (query.sender && connection.sender !== query.sender) return false;\n            if (query.transportType && connection.transportType !== query.transportType) return false;\n            if (query.direction && connection.direction !== query.direction) return false;\n            return true;\n        })\n        .sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\nexport class ConnectionRegistry<TTransport extends string = string> {\n    private _connections = new Map<string, ConnectionInfo<TTransport>>();\n\n    constructor(\n        private _createId: () => string,\n        private _emitEvent?: (event: ConnectionEvent<TTransport>) => void\n    ) {}\n\n    register(params: RegisterConnectionParams<TTransport>): ConnectionInfo<TTransport> {\n        const key = createConnectionKey(params);\n        const now = Date.now();\n        const existing = this._connections.get(key);\n\n        if (existing) {\n            existing.updatedAt = now;\n            existing.status = \"active\";\n            existing.metadata = { ...existing.metadata, ...params.metadata };\n            return existing;\n        }\n\n        const connection: ConnectionInfo<TTransport> = {\n            id: this._createId(),\n            localChannel: params.localChannel,\n            remoteChannel: params.remoteChannel,\n            sender: params.sender,\n            transportType: params.transportType,\n            direction: params.direction,\n            status: \"active\",\n            createdAt: now,\n            updatedAt: now,\n            metadata: params.metadata\n        };\n\n        this._connections.set(key, connection);\n        this._emitEvent?.({\n            type: \"connected\",\n            connection,\n            timestamp: now\n        });\n        return connection;\n    }\n\n    markNotified(connection: ConnectionInfo<TTransport>, payload?: any): void {\n        const now = Date.now();\n        connection.lastNotifyAt = now;\n        connection.updatedAt = now;\n        this._emitEvent?.({\n            type: \"notified\",\n            connection,\n            timestamp: now,\n            payload\n        });\n    }\n\n    closeByChannel(channel: string): void {\n        const now = Date.now();\n        for (const connection of this._connections.values()) {\n            if (connection.localChannel !== channel && connection.remoteChannel !== channel) continue;\n            if (connection.status === \"closed\") continue;\n            connection.status = \"closed\";\n            connection.updatedAt = now;\n            this._emitEvent?.({\n                type: \"disconnected\",\n                connection,\n                timestamp: now\n            });\n        }\n    }\n\n    closeAll(): void {\n        const now = Date.now();\n        for (const connection of this._connections.values()) {\n            if (connection.status === \"closed\") continue;\n            connection.status = \"closed\";\n            connection.updatedAt = now;\n            this._emitEvent?.({\n                type: \"disconnected\",\n                connection,\n                timestamp: now\n            });\n        }\n    }\n\n    query(query: QueryConnectionsOptions<TTransport> = {}): ConnectionInfo<TTransport>[] {\n        return queryConnections(this._connections.values(), query);\n    }\n\n    values(): ConnectionInfo<TTransport>[] {\n        return [...this._connections.values()];\n    }\n\n    clear(): void {\n        this._connections.clear();\n    }\n}\n","/**\n * Unified Channel System\n *\n * Merges and unifies:\n * - RequestProxy (proxy creation and dispatch)\n * - Invoker (Requestor/Responder abstraction)\n * - ChannelContext (multi-channel management)\n * - ObservableChannels (Observable-based messaging)\n *\n * Single entry point for all channel communication patterns:\n * - `createChannel()` - Create a unified channel\n * - `channel.expose()` - Expose objects for remote invocation\n * - `channel.import()` - Import remote modules\n * - `channel.proxy()` - Create transparent proxy to remote\n * - `channel.connect()` - Connect to transport\n */\n\nimport { UUIDv4, Promised, deepOperateAndClone, isPrimitive, isCanJustReturn, isCanTransfer } from \"fest/core\";\nimport {\n    type ChannelMessage,\n    type Subscription,\n    ChannelSubject,\n    filter\n} from \"../observable/Observable\";\nimport { WReflectAction, type WReflectDescriptor, type WReq, type WResp, type TransportType } from \"../types/Interface\";\nimport {\n    hasNoPath,\n    readByPath,\n    registeredInPath,\n    writeByPath,\n    objectToRef\n} from \"../storage/DataBase\";\nimport {\n    detectContextType,\n    detectTransportType,\n    detectIncomingContextType,\n    DefaultReflect,\n    type ContextType,\n    type ReflectLike,\n    type IncomingInvocation,\n    type InvocationResponse\n} from \"../proxy/Invoker\";\nimport {\n    createRemoteProxy,\n    wrapDescriptor as wrapProxyDescriptor,\n    type ProxyInvoker,\n    type RemoteProxy\n} from \"../proxy/Proxy\";\nimport {\n    executeAction as coreExecuteAction,\n    buildResponse as coreBuildResponse,\n    type ExecuteOptions\n} from \"../../core/RequestHandler\";\nimport {\n    ConnectionRegistry,\n    type ConnectionDirection,\n    type ConnectionStatus,\n    type ConnectionInfo,\n    type ConnectionEvent,\n    type QueryConnectionsOptions\n} from \"./internal/ConnectionModel\";\nimport type { NativeChannelTransport } from \"./ChannelContext\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Unified channel configuration */\nexport interface UnifiedChannelConfig {\n    /** Channel name */\n    name: string;\n    /** Auto-detect context type */\n    autoDetect?: boolean;\n    /** Request timeout (ms) */\n    timeout?: number;\n    /** Custom Reflect implementation */\n    reflect?: ReflectLike;\n    /** Buffer size for observables */\n    bufferSize?: number;\n    /** Auto-start listening */\n    autoListen?: boolean;\n}\n\n/** Transport connection options */\nexport interface ConnectOptions {\n    /** Target channel name for requests */\n    targetChannel?: string;\n    /** Chrome tab id for chrome-tabs transport */\n    tabId?: number;\n    /** Chrome port name for chrome-port transport */\n    portName?: string;\n    /** External extension id for chrome-external transport */\n    externalId?: string;\n    /** Custom message handler */\n    onMessage?: (handler: (msg: any) => void) => (() => void);\n    /** Auto-start MessagePort */\n    autoStart?: boolean;\n}\n\nexport type UnifiedConnectionDirection = ConnectionDirection;\nexport type UnifiedConnectionStatus = ConnectionStatus;\nexport type UnifiedConnectionInfo = ConnectionInfo<TransportType>;\nexport type UnifiedConnectionEvent = ConnectionEvent<TransportType>;\nexport type UnifiedQueryConnectionsOptions = QueryConnectionsOptions<TransportType>;\n\n/** Exposed module entry */\ninterface ExposedEntry {\n    name: string;\n    obj: any;\n    path: string[];\n}\n\n// ============================================================================\n// UNIFIED CHANNEL\n// ============================================================================\n\n/**\n * UnifiedChannel - Single entry point for all channel communication\n *\n * Combines:\n * - Requestor functionality (invoke remote methods)\n * - Responder functionality (handle incoming requests)\n * - Proxy creation (transparent remote access)\n * - Observable messaging (subscribe/next pattern)\n * - Multi-transport support (Worker, Port, Broadcast, WebSocket, Chrome)\n */\nexport class UnifiedChannel {\n    private _name: string;\n    private _contextType: ContextType;\n    private _config: Required<UnifiedChannelConfig>;\n\n    // Transport management\n    private _transports = new Map<string, TransportBinding>();\n    private _defaultTransport: TransportBinding | null = null;\n    private _connectionEvents = new ChannelSubject<UnifiedConnectionEvent>({ bufferSize: 200 });\n    private _connectionRegistry = new ConnectionRegistry<TransportType>(\n        () => UUIDv4(),\n        (event) => this._connectionEvents.next(event)\n    );\n\n    // Request/Response tracking\n    // @ts-ignore\n    private _pending = new Map<string, PromiseWithResolvers<any>>();\n    private _subscriptions: Subscription[] = [];\n\n    // Observable subjects\n    private _inbound = new ChannelSubject<ChannelMessage>({ bufferSize: 100 });\n    private _outbound = new ChannelSubject<ChannelMessage>({ bufferSize: 100 });\n    private _invocations = new ChannelSubject<IncomingInvocation>({ bufferSize: 100 });\n    private _responses = new ChannelSubject<InvocationResponse>({ bufferSize: 100 });\n\n    // Exposed objects\n    private _exposed = new Map<string, ExposedEntry>();\n\n    // Proxy cache\n    private _proxyCache = new WeakMap<object, any>();\n\n    public __getPrivate(key: string): any {\n        return this[key];\n    }\n    \n    public __setPrivate(key: string, value: any): void {\n        this[key] = value;\n    }\n\n    constructor(config: UnifiedChannelConfig | string) {\n        const cfg = typeof config === \"string\" ? { name: config } : config;\n\n        this._name = cfg.name;\n        this._contextType = cfg.autoDetect !== false ? detectContextType() : \"unknown\";\n        this._config = {\n            name: cfg.name,\n            autoDetect: cfg.autoDetect ?? true,\n            timeout: cfg.timeout ?? 30000,\n            reflect: cfg.reflect ?? DefaultReflect,\n            bufferSize: cfg.bufferSize ?? 100,\n            autoListen: cfg.autoListen ?? true\n        };\n\n        // Auto-listen on self if in worker context\n        if (this._config.autoListen && this._isWorkerContext()) {\n            this.listen(self);\n        }\n    }\n\n    // ========================================================================\n    // TRANSPORT CONNECTION\n    // ========================================================================\n\n    /**\n     * Connect to a transport for sending requests\n     *\n     * @param target - Worker, MessagePort, BroadcastChannel, WebSocket, or string identifier\n     * @param options - Connection options\n     */\n    connect(\n        target: TransportBinding<NativeChannelTransport>,\n        options: ConnectOptions = {}\n    ): this {\n        const transportType = detectTransportType(target);\n        const targetChannel = options.targetChannel ?? this._inferTargetChannel(target, transportType);\n\n        const binding = this._createTransportBinding(target, transportType, targetChannel, options);\n\n        this._transports.set(targetChannel, binding);\n        if (!this._defaultTransport) {\n            this._defaultTransport = binding;\n        }\n        const connection = this._registerConnection({\n            localChannel: this._name,\n            remoteChannel: targetChannel,\n            sender: this._name,\n            transportType,\n            direction: \"outgoing\",\n            metadata: { phase: \"connect\" }\n        });\n        this._emitConnectionSignal(binding, \"connect\", {\n            connectionId: connection.id,\n            from: this._name,\n            to: targetChannel\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen on a transport for incoming requests\n     *\n     * @param source - Transport source to listen on\n     * @param options - Connection options\n     */\n    listen(\n        source: Worker | MessagePort | BroadcastChannel | WebSocket | any,\n        options: ConnectOptions = {}\n    ): this {\n        const transportType = detectTransportType(source);\n        const sourceChannel = options.targetChannel ?? this._inferTargetChannel(source, transportType);\n        const handler = (data: any) => this._handleIncoming(data);\n\n        const connection = this._registerConnection({\n            localChannel: this._name,\n            remoteChannel: sourceChannel,\n            sender: sourceChannel,\n            transportType,\n            direction: \"incoming\",\n            metadata: { phase: \"listen\" }\n        });\n\n        switch (transportType) {\n            case \"worker\":\n            case \"message-port\":\n            case \"broadcast\":\n                if (options.autoStart !== false && source.start) source.start();\n                source.addEventListener?.(\"message\", ((e: MessageEvent) => handler(e.data)) as EventListener);\n                break;\n\n            case \"websocket\":\n                source.addEventListener?.(\"message\", ((e: MessageEvent) => {\n                    try { handler(JSON.parse(e.data)); } catch {}\n                }) as EventListener);\n                break;\n\n            case \"chrome-runtime\":\n                chrome.runtime.onMessage?.addListener?.((msg: any, sender: any, sendResponse: any) => {\n                    handler(msg);\n                    return true;\n                });\n                break;\n\n            case \"chrome-tabs\":\n                chrome.runtime.onMessage?.addListener?.((msg: any, sender: any) => {\n                    if (options.tabId != null && sender?.tab?.id !== options.tabId) return false;\n                    handler(msg);\n                    return true;\n                });\n                break;\n\n            case \"chrome-port\":\n                source?.onMessage?.addListener?.((msg: any) => {\n                    handler(msg);\n                });\n                break;\n\n            case \"chrome-external\":\n                chrome.runtime.onMessageExternal?.addListener?.((msg: any) => {\n                    handler(msg);\n                    return true;\n                });\n                break;\n\n            case \"self\":\n                addEventListener?.(\"message\", ((e: MessageEvent) => handler(e.data)) as EventListener);\n                break;\n\n            default:\n                if (options.onMessage) {\n                    options.onMessage(handler);\n                }\n        }\n\n        this._sendSignalToTarget(source, transportType, {\n            connectionId: connection.id,\n            from: this._name,\n            to: sourceChannel,\n            tabId: options.tabId,\n            externalId: options.externalId\n        }, \"notify\");\n\n        return this;\n    }\n\n    /**\n     * Connect and listen on the same transport (bidirectional)\n     */\n    attach(\n        target: Worker | MessagePort | BroadcastChannel | WebSocket | any,\n        options: ConnectOptions = {}\n    ): this {\n        // connect() already installs inbound listeners for response/request flow.\n        // Avoid duplicate listeners and duplicate notify storms in attach mode.\n        return this.connect(target, options);\n    }\n\n    // ========================================================================\n    // EXPOSE / IMPORT\n    // ========================================================================\n\n    /**\n     * Expose an object for remote invocation\n     *\n     * @param name - Path name for the exposed object\n     * @param obj - Object to expose\n     */\n    expose(name: string, obj: any): this {\n        const path = [name];\n        writeByPath(path, obj);\n        this._exposed.set(name, { name, obj, path });\n        return this;\n    }\n\n    /**\n     * Expose multiple objects at once\n     */\n    exposeAll(entries: Record<string, any>): this {\n        for (const [name, obj] of Object.entries(entries)) {\n            this.expose(name, obj);\n        }\n        return this;\n    }\n\n    /**\n     * Import a module from a remote channel\n     *\n     * @param url - Module URL to import\n     * @param targetChannel - Target channel (defaults to first connected)\n     */\n    async import<T = any>(url: string, targetChannel?: string): Promise<T> {\n        return this.invoke(\n            targetChannel ?? this._getDefaultTarget(),\n            WReflectAction.IMPORT,\n            [],\n            [url]\n        );\n    }\n\n    // ========================================================================\n    // INVOKE / REQUEST\n    // ========================================================================\n\n    /**\n     * Invoke a method on a remote object\n     *\n     * @param targetChannel - Target channel name\n     * @param action - Reflect action\n     * @param path - Object path\n     * @param args - Arguments\n     */\n    invoke<T = any>(\n        targetChannel: string,\n        action: WReflectAction,\n        path: string[],\n        args: any[] = []\n    ): Promise<T> {\n        const id = UUIDv4();\n        // @ts-ignore\n        const resolvers = Promise.withResolvers<T>();\n        this._pending.set(id, resolvers);\n\n        // Setup timeout\n        const timeout = setTimeout(() => {\n            if (this._pending.has(id)) {\n                this._pending.delete(id);\n                resolvers.reject(new Error(`Request timeout: ${action} on ${path.join(\".\")}`));\n            }\n        }, this._config.timeout);\n\n        // Build and send message\n        const message: ChannelMessage = {\n            id,\n            channel: targetChannel,\n            sender: this._name,\n            type: \"request\",\n            payload: {\n                channel: targetChannel,\n                sender: this._name,\n                action,\n                path,\n                args\n            },\n            timestamp: Date.now()\n        };\n\n        this._send(targetChannel, message);\n        this._outbound.next(message);\n\n        return resolvers.promise.finally(() => clearTimeout(timeout));\n    }\n\n    /**\n     * Get property from remote object\n     */\n    get<T = any>(targetChannel: string, path: string[], prop: string): Promise<T> {\n        return this.invoke(targetChannel, WReflectAction.GET, path, [prop]);\n    }\n\n    /**\n     * Set property on remote object\n     */\n    set(targetChannel: string, path: string[], prop: string, value: any): Promise<boolean> {\n        return this.invoke(targetChannel, WReflectAction.SET, path, [prop, value]);\n    }\n\n    /**\n     * Call method on remote object\n     */\n    call<T = any>(targetChannel: string, path: string[], args: any[] = []): Promise<T> {\n        return this.invoke(targetChannel, WReflectAction.APPLY, path, [args]);\n    }\n\n    /**\n     * Construct new instance on remote\n     */\n    construct<T = any>(targetChannel: string, path: string[], args: any[] = []): Promise<T> {\n        return this.invoke(targetChannel, WReflectAction.CONSTRUCT, path, [args]);\n    }\n\n    // ========================================================================\n    // PROXY CREATION\n    // ========================================================================\n\n    /**\n     * Create a transparent proxy to a remote channel\n     *\n     * All operations on the proxy are forwarded to the remote.\n     *\n     * @param targetChannel - Target channel name\n     * @param basePath - Base path for the proxy\n     */\n    proxy<T = any>(targetChannel?: string, basePath: string[] = []): T {\n        const target = targetChannel ?? this._getDefaultTarget();\n        return this._createProxy(target, basePath) as T;\n    }\n\n    /**\n     * Create proxy for a specific exposed module on remote\n     *\n     * @param moduleName - Name of the exposed module\n     * @param targetChannel - Target channel\n     */\n    remote<T = any>(moduleName: string, targetChannel?: string): T {\n        return this.proxy<T>(targetChannel, [moduleName]);\n    }\n\n    /**\n     * Wrap a descriptor as a proxy\n     */\n    wrapDescriptor(descriptor: WReflectDescriptor, targetChannel?: string): any {\n        const invoker: ProxyInvoker = (action, path, args) => {\n            const channel = targetChannel ?? descriptor?.channel ?? this._getDefaultTarget();\n            return this.invoke(channel, action as WReflectAction, path, args);\n        };\n\n        return wrapProxyDescriptor(\n            descriptor,\n            invoker,\n            targetChannel ?? descriptor?.channel ?? this._getDefaultTarget()\n        );\n    }\n\n    // ========================================================================\n    // OBSERVABLE API\n    // ========================================================================\n\n    /**\n     * Subscribe to incoming messages\n     */\n    subscribe(handler: (msg: ChannelMessage) => void): Subscription {\n        return this._inbound.subscribe(handler);\n    }\n\n    /**\n     * Send a message (fire-and-forget)\n     */\n    next(message: ChannelMessage): void {\n        this._send(message.channel, message);\n        this._outbound.next(message);\n    }\n\n    /**\n     * Emit an event to a channel\n     */\n    emit(targetChannel: string, eventType: string, data: any): void {\n        const message: ChannelMessage = {\n            id: UUIDv4(),\n            channel: targetChannel,\n            sender: this._name,\n            type: \"event\",\n            payload: { type: eventType, data },\n            timestamp: Date.now()\n        };\n        this.next(message);\n    }\n\n    /**\n     * Emit connection-level signal to a specific connected channel.\n     * This is the canonical notify/connect API for facade layers.\n     */\n    notify(\n        targetChannel: string,\n        payload: Record<string, any> = {},\n        type: \"notify\" | \"connect\" = \"notify\"\n    ): boolean {\n        const binding = this._transports.get(targetChannel);\n        if (!binding) return false;\n        this._emitConnectionSignal(binding, type, {\n            from: this._name,\n            to: targetChannel,\n            ...payload\n        });\n        return true;\n    }\n\n    /** Observable: Incoming messages */\n    get onMessage() { return this._inbound; }\n\n    /** Observable: Outgoing messages */\n    get onOutbound() { return this._outbound; }\n\n    /** Observable: Incoming invocations */\n    get onInvocation() { return this._invocations; }\n\n    /** Observable: Outgoing responses */\n    get onResponse() { return this._responses; }\n\n    /** Observable: Connection events (connected/notified/disconnected) */\n    get onConnection() { return this._connectionEvents; }\n\n    subscribeConnections(handler: (event: UnifiedConnectionEvent) => void): Subscription {\n        return this._connectionEvents.subscribe(handler);\n    }\n\n    queryConnections(query: UnifiedQueryConnectionsOptions = {}): UnifiedConnectionInfo[] {\n        return this._connectionRegistry.query(query);\n    }\n\n    notifyConnections(payload: any = {}, query: UnifiedQueryConnectionsOptions = {}): number {\n        let sent = 0;\n        const targets = this.queryConnections({ ...query, status: \"active\", includeClosed: false });\n\n        for (const connection of targets) {\n            const binding = this._transports.get(connection.remoteChannel);\n            if (!binding) continue;\n\n            this._emitConnectionSignal(binding, \"notify\", {\n                connectionId: connection.id,\n                from: this._name,\n                to: connection.remoteChannel,\n                ...payload\n            });\n            sent++;\n        }\n\n        return sent;\n    }\n\n    // ========================================================================\n    // PROPERTIES\n    // ========================================================================\n\n    /** Channel name */\n    get name(): string { return this._name; }\n\n    /** Detected context type */\n    get contextType(): ContextType { return this._contextType; }\n\n    /** Configuration */\n    get config(): Readonly<Required<UnifiedChannelConfig>> { return this._config; }\n\n    /** Connected transport names */\n    get connectedChannels(): string[] { return [...this._transports.keys()]; }\n\n    /** Exposed module names */\n    get exposedModules(): string[] { return [...this._exposed.keys()]; }\n\n    // ========================================================================\n    // LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Close all connections and cleanup\n     */\n    close(): void {\n        this._subscriptions.forEach(s => s.unsubscribe());\n        this._subscriptions = [];\n        this._pending.clear();\n        this._markAllConnectionsClosed();\n        for (const binding of this._transports.values()) {\n            try { binding.cleanup?.(); } catch {}\n            // Release common channel-like transports so they do not keep event loop alive.\n            if (binding.transportType === \"message-port\" || binding.transportType === \"broadcast\") {\n                try { (binding.target as MessagePort)?.close?.(); } catch {}\n            }\n        }\n        this._transports.clear();\n        this._defaultTransport = null;\n        this._connectionRegistry.clear();\n        this._inbound.complete();\n        this._outbound.complete();\n        this._invocations.complete();\n        this._responses.complete();\n        this._connectionEvents.complete();\n    }\n\n    // ========================================================================\n    // PRIVATE: Message Handling\n    // ========================================================================\n\n    private _handleIncoming(data: any): void {\n        if (!data || typeof data !== \"object\") return;\n\n        // Emit to inbound observable\n        this._inbound.next(data as ChannelMessage);\n\n        switch (data.type) {\n            case \"request\":\n                if (data.channel === this._name) {\n                    this._handleRequest(data);\n                }\n                break;\n\n            case \"response\":\n                this._handleResponse(data);\n                break;\n\n            case \"event\":\n                // Events are handled via subscribe\n                break;\n\n            case \"signal\":\n                this._handleSignal(data);\n                break;\n        }\n    }\n\n    private _handleResponse(data: any): void {\n        const id = data.reqId ?? data.id;\n        const resolvers = this._pending.get(id);\n\n        if (resolvers) {\n            this._pending.delete(id);\n\n            if (data.payload?.error) {\n                resolvers.reject(new Error(data.payload.error));\n            } else {\n                const result = data.payload?.result;\n                const descriptor = data.payload?.descriptor;\n\n                if (result !== null && result !== undefined) {\n                    resolvers.resolve(result);\n                } else if (descriptor) {\n                    resolvers.resolve(this.wrapDescriptor(descriptor, data.sender));\n                } else {\n                    resolvers.resolve(undefined);\n                }\n            }\n\n            // Emit response event\n            this._responses.next({\n                id,\n                channel: data.channel,\n                sender: data.sender,\n                result: data.payload?.result,\n                descriptor: data.payload?.descriptor,\n                timestamp: Date.now()\n            });\n        }\n    }\n\n    private async _handleRequest(data: any): Promise<void> {\n        const payload = data.payload as WReq;\n        if (!payload) return;\n\n        const { action, path, args, sender } = payload;\n        const reqId = data.reqId ?? data.id;\n\n        // Emit invocation event\n        this._invocations.next({\n            id: reqId,\n            channel: this._name,\n            sender,\n            action,\n            path,\n            args: args ?? [],\n            timestamp: Date.now(),\n            contextType: detectIncomingContextType(data)\n        });\n\n        // Execute action\n        const { result, toTransfer, newPath } = await this._executeAction(action, path, args ?? [], sender);\n\n        // Send response\n        await this._sendResponse(reqId, action, sender, newPath, result, toTransfer);\n    }\n\n    private async _executeAction(\n        action: string,\n        path: string[],\n        args: any[],\n        sender: string\n    ): Promise<{ result: any; toTransfer: any[]; newPath: string[] }> {\n        // Use unified core executeAction\n        const { result, toTransfer, path: newPath } = coreExecuteAction(\n            action,\n            path,\n            args,\n            {\n                channel: this._name,\n                sender,\n                reflect: this._config.reflect\n            }\n        );\n\n        return { result: await result, toTransfer, newPath };\n    }\n\n    private async _sendResponse(\n        reqId: string,\n        action: string,\n        sender: string,\n        path: string[],\n        rawResult: any,\n        toTransfer: any[]\n    ): Promise<void> {\n        // Use unified core buildResponse\n        const { response: coreResponse, transfer } = await coreBuildResponse(\n            reqId, action, this._name, sender, path, rawResult, toTransfer\n        );\n\n        // Wrap as ChannelMessage with extra fields\n        const response: ChannelMessage = {\n            id: reqId,\n            ...coreResponse,\n            timestamp: Date.now(),\n            transferable: transfer\n        };\n\n        this._send(sender, response, transfer);\n    }\n\n    // ========================================================================\n    // PRIVATE: Transport Management\n    // ========================================================================\n\n    private _handleSignal(data: any): void {\n        const payload = data?.payload ?? {};\n        const remoteChannel = payload.from ?? data.sender ?? \"unknown\";\n        const transportType = data.transportType ?? this._transports.get(data.channel)?.transportType ?? \"internal\";\n\n        const connection = this._registerConnection({\n            localChannel: this._name,\n            remoteChannel,\n            sender: data.sender ?? remoteChannel,\n            transportType,\n            direction: \"incoming\"\n        });\n\n        this._markConnectionNotified(connection, payload);\n    }\n\n    private _registerConnection(params: {\n        localChannel: string;\n        remoteChannel: string;\n        sender: string;\n        transportType: TransportType;\n        direction: UnifiedConnectionDirection;\n        metadata?: Record<string, any>;\n    }): UnifiedConnectionInfo {\n        return this._connectionRegistry.register(params);\n    }\n\n    private _markConnectionNotified(connection: UnifiedConnectionInfo, payload?: any): void {\n        this._connectionRegistry.markNotified(connection, payload);\n    }\n\n    private _emitConnectionSignal(\n        binding: TransportBinding,\n        signalType: \"connect\" | \"notify\",\n        payload: Record<string, any> = {}\n    ): void {\n        const message = {\n            id: UUIDv4(),\n            type: \"signal\",\n            channel: binding.targetChannel,\n            sender: this._name,\n            transportType: binding.transportType,\n            payload: {\n                type: signalType,\n                from: this._name,\n                to: binding.targetChannel,\n                ...payload\n            },\n            timestamp: Date.now()\n        };\n\n        (binding?.sender ?? binding?.postMessage)?.call(binding, message);\n\n        const connection = this._registerConnection({\n            localChannel: this._name,\n            remoteChannel: binding.targetChannel,\n            sender: this._name,\n            transportType: binding.transportType,\n            direction: \"outgoing\"\n        });\n        this._markConnectionNotified(connection, message.payload);\n    }\n\n    private _sendSignalToTarget<TTransport = NativeChannelTransport>(\n        target: TTransport,\n        transportType: TransportType,\n        payload: Record<string, any>,\n        signalType: \"connect\" | \"notify\"\n    ): void {\n        const message = {\n            id: UUIDv4(),\n            type: \"signal\",\n            channel: payload.to ?? this._name,\n            sender: this._name,\n            transportType,\n            payload: {\n                type: signalType,\n                ...payload\n            },\n            timestamp: Date.now()\n        };\n\n        try {\n            if (transportType === \"websocket\") {\n                (target as WebSocket)?.send?.(JSON.stringify(message));\n                return;\n            }\n            if (transportType === \"chrome-runtime\") {\n                chrome.runtime?.sendMessage?.(message);\n                return;\n            }\n            if (transportType === \"chrome-tabs\") {\n                const tabId = payload.tabId;\n                if (tabId != null) chrome.tabs?.sendMessage?.(tabId, message);\n                return;\n            }\n            if (transportType === \"chrome-port\") {\n                (target as MessagePort)?.postMessage?.(message);\n                return;\n            }\n            if (transportType === \"chrome-external\") {\n                if (payload.externalId) chrome.runtime?.sendMessage?.(payload.externalId, message);\n                return;\n            }\n            (target as MessagePort)?.postMessage?.(message, { transfer: [] });\n        } catch {}\n    }\n\n    private _markAllConnectionsClosed(): void {\n        this._connectionRegistry.closeAll();\n    }\n\n    private _createTransportBinding(\n        target: any,\n        transportType: TransportType,\n        targetChannel: string,\n        options: ConnectOptions\n    ): TransportBinding {\n        let sender: (msg: any, transfer?: Transferable[]) => void;\n        let cleanup: (() => void) | undefined;\n\n        switch (transportType) {\n            case \"worker\":\n            case \"message-port\":\n            case \"broadcast\":\n                if (options.autoStart !== false && target.start) target.start();\n                sender = (msg, transfer) => target.postMessage(msg, { transfer });\n                {\n                    const listener = ((e: MessageEvent) => this._handleIncoming(e.data)) as EventListener;\n                    target.addEventListener?.(\"message\", listener);\n                    cleanup = () => target.removeEventListener?.(\"message\", listener);\n                }\n                break;\n\n            case \"websocket\":\n                sender = (msg) => target.send(JSON.stringify(msg));\n                {\n                    const listener = ((e: MessageEvent) => {\n                        try { this._handleIncoming(JSON.parse(e.data)); } catch {}\n                    }) as EventListener;\n                    target.addEventListener?.(\"message\", listener);\n                    cleanup = () => target.removeEventListener?.(\"message\", listener);\n                }\n                break;\n\n            case \"chrome-runtime\":\n                sender = (msg) => chrome.runtime.sendMessage(msg);\n                {\n                    const listener = (msg: any) => this._handleIncoming(msg);\n                    chrome.runtime.onMessage?.addListener?.(listener);\n                    cleanup = () => chrome.runtime.onMessage?.removeListener?.(listener);\n                }\n                break;\n\n            case \"chrome-tabs\":\n                sender = (msg) => {\n                    if (options.tabId != null) chrome.tabs?.sendMessage?.(options.tabId, msg);\n                };\n                {\n                    const listener = (msg: any, senderMeta: any) => {\n                        if (options.tabId != null && senderMeta?.tab?.id !== options.tabId) return false;\n                        this._handleIncoming(msg);\n                        return true;\n                    };\n                    chrome.runtime.onMessage?.addListener?.(listener);\n                    cleanup = () => chrome.runtime.onMessage?.removeListener?.(listener);\n                }\n                break;\n\n            case \"chrome-port\":\n                if (target?.postMessage && target?.onMessage?.addListener) {\n                    sender = (msg) => target.postMessage(msg);\n                    const listener = (msg: any) => this._handleIncoming(msg);\n                    target.onMessage.addListener(listener);\n                    cleanup = () => {\n                        try { target.onMessage.removeListener(listener); } catch {}\n                        try { target.disconnect?.(); } catch {}\n                    };\n                } else {\n                    const portName = options.portName ?? targetChannel;\n                    const port = options.tabId != null && chrome.tabs?.connect\n                        ? chrome.tabs.connect(options.tabId, { name: portName })\n                        : chrome.runtime.connect({ name: portName });\n                    sender = (msg) => port.postMessage(msg);\n                    const listener = (msg: any) => this._handleIncoming(msg);\n                    port.onMessage.addListener(listener);\n                    cleanup = () => {\n                        try { port.onMessage.removeListener(listener); } catch {}\n                        try { port.disconnect(); } catch {}\n                    };\n                }\n                break;\n\n            case \"chrome-external\":\n                sender = (msg) => {\n                    if (options.externalId) chrome.runtime.sendMessage(options.externalId, msg);\n                };\n                {\n                    const listener = (msg: any) => {\n                        this._handleIncoming(msg);\n                        return true;\n                    };\n                    chrome.runtime.onMessageExternal?.addListener?.(listener);\n                    cleanup = () => chrome.runtime.onMessageExternal?.removeListener?.(listener);\n                }\n                break;\n\n            case \"self\":\n                sender = (msg, transfer) => postMessage(msg, { transfer: transfer ?? [] });\n                {\n                    const listener = ((e: MessageEvent) => this._handleIncoming(e.data)) as EventListener;\n                    addEventListener?.(\"message\", listener);\n                    cleanup = () => removeEventListener?.(\"message\", listener);\n                }\n                break;\n\n            default:\n                if (options.onMessage) {\n                    cleanup = options.onMessage((msg) => this._handleIncoming(msg));\n                }\n                sender = (msg) => target?.postMessage?.(msg);\n        }\n\n        return {\n            target, targetChannel, transportType, sender, cleanup,\n            postMessage: (message: any, options?: any) => sender?.(message, options),\n            start: () => target?.start?.(),\n            close: () => target?.close?.()\n        };\n    }\n\n    private _send(targetChannel: string, message: ChannelMessage, transfer?: Transferable[]): void {\n        const binding = this._transports.get(targetChannel) ?? this._defaultTransport;\n        (binding?.sender ?? binding?.postMessage)?.call(binding, message, transfer);\n    }\n\n    private _getDefaultTarget(): string {\n        if (this._defaultTransport) {\n            return this._defaultTransport.targetChannel;\n        }\n        return \"worker\";\n    }\n\n    private _inferTargetChannel(target: any, transportType: TransportType): string {\n        if (transportType === \"worker\") return \"worker\";\n        if (transportType === \"broadcast\" && target.name) return target.name;\n        if (transportType === \"self\") return \"self\";\n        return `${transportType}-${UUIDv4().slice(0, 8)}`;\n    }\n\n    // ========================================================================\n    // PRIVATE: Proxy Creation\n    // ========================================================================\n\n    private _createProxy(targetChannel: string, basePath: string[]): RemoteProxy {\n        const invoker: ProxyInvoker = (action, path, args) => {\n            return this.invoke(targetChannel, action as WReflectAction, path, args);\n        };\n\n        return createRemoteProxy(invoker, {\n            channel: targetChannel,\n            basePath,\n            cache: true,\n            timeout: this._config.timeout\n        });\n    }\n\n    // ========================================================================\n    // PRIVATE: Utilities\n    // ========================================================================\n\n    private _isWorkerContext(): boolean {\n        return [\"worker\", \"shared-worker\", \"service-worker\"].includes(this._contextType);\n    }\n}\n\n/** Transport binding info */\nexport interface TransportBinding<TTransport = NativeChannelTransport> {\n    target: TTransport;\n    targetChannel: string;\n    transportType: TransportType;\n    sender: (msg: any, transfer?: Transferable[]) => void;\n    cleanup?: () => void;\n    postMessage: (message: any, options?: any) => void;\n    addEventListener?: (type: string, listener: EventListener) => void;\n    removeEventListener?: (type: string, listener: EventListener) => void;\n    start?: () => void;\n    close?: () => void;\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create a unified channel\n *\n * @example\n * // In worker\n * const channel = createUnifiedChannel(\"worker\");\n * channel.expose(\"calc\", { add: (a, b) => a + b });\n *\n * // In host\n * const channel = createUnifiedChannel(\"host\");\n * channel.connect(worker);\n * const calc = channel.proxy(\"worker\", [\"calc\"]);\n * await calc.add(2, 3); // 5\n */\nexport function createUnifiedChannel(config: UnifiedChannelConfig | string): UnifiedChannel {\n    return new UnifiedChannel(config);\n}\n\n/**\n * Quick setup: Create channel and connect to transport\n */\nexport function setupUnifiedChannel(\n    name: string,\n    target: Worker | MessagePort | BroadcastChannel | WebSocket | any,\n    options?: Partial<UnifiedChannelConfig> & ConnectOptions\n): UnifiedChannel {\n    return createUnifiedChannel({ name, ...options }).attach(target, options);\n}\n\n/**\n * Create a channel pair for bidirectional communication\n */\nexport function createUnifiedChannelPair(\n    name1: string,\n    name2: string,\n    options?: Partial<UnifiedChannelConfig>\n): { channel1: UnifiedChannel; channel2: UnifiedChannel; messageChannel: MessageChannel } {\n    const mc = new MessageChannel();\n    mc.port1.start();\n    mc.port2.start();\n\n    const channel1 = createUnifiedChannel({ name: name1, autoListen: false, ...options }).attach(mc.port1, { targetChannel: name2 });\n    const channel2 = createUnifiedChannel({ name: name2, autoListen: false, ...options }).attach(mc.port2, { targetChannel: name1 });\n\n    return { channel1, channel2, messageChannel: mc };\n}\n\n// ============================================================================\n// GLOBAL CHANNEL REGISTRY\n// ============================================================================\n\nconst CHANNEL_REGISTRY = new Map<string, UnifiedChannel>();\n\n/**\n * Get or create a named channel (singleton per name)\n */\nexport function getUnifiedChannel(name: string, config?: Partial<UnifiedChannelConfig>): UnifiedChannel {\n    if (!CHANNEL_REGISTRY.has(name)) {\n        CHANNEL_REGISTRY.set(name, createUnifiedChannel({ name, ...config }));\n    }\n    return CHANNEL_REGISTRY.get(name)!;\n}\n\n/**\n * Get all registered channel names\n */\nexport function getUnifiedChannelNames(): string[] {\n    return [...CHANNEL_REGISTRY.keys()];\n}\n\n/**\n * Close and remove a channel from registry\n */\nexport function closeUnifiedChannel(name: string): boolean {\n    const channel = CHANNEL_REGISTRY.get(name);\n    if (channel) {\n        channel.close();\n        return CHANNEL_REGISTRY.delete(name);\n    }\n    return false;\n}\n\n// ============================================================================\n// AUTO-INIT FOR WORKERS\n// ============================================================================\n\nlet WORKER_CHANNEL: UnifiedChannel | null = null;\n\n/**\n * Get the worker's unified channel (auto-created in worker context)\n */\nexport function getWorkerChannel(): UnifiedChannel {\n    if (!WORKER_CHANNEL) {\n        const contextType = detectContextType();\n        if ([\"worker\", \"shared-worker\", \"service-worker\"].includes(contextType)) {\n            WORKER_CHANNEL = createUnifiedChannel({ name: \"worker\", autoListen: true });\n        } else {\n            WORKER_CHANNEL = createUnifiedChannel({ name: \"host\", autoListen: false });\n        }\n    }\n    return WORKER_CHANNEL;\n}\n\n/**\n * Expose an object from the worker channel\n */\nexport function exposeFromUnified(name: string, obj: any): void {\n    getWorkerChannel().expose(name, obj);\n}\n\n/**\n * Create a proxy to a remote channel from the worker\n */\nexport function remoteFromUnified<T = any>(moduleName: string, targetChannel?: string): T {\n    return getWorkerChannel().remote<T>(moduleName, targetChannel);\n}\n","/**\n * Request Proxy - Re-exports from Unified Proxy Module\n *\n * @deprecated Use Proxy.ts directly for new code.\n * This file is kept for backward compatibility.\n */\n\nimport { WReflectAction, type WReflectDescriptor } from \"../types/Interface\";\nimport type { ChannelMessage, ChannelObservable } from \"../observable/Observable\";\nimport { UnifiedChannel, createUnifiedChannel, getWorkerChannel } from \"../channel/UnifiedChannel\";\n\n// Re-export from unified Proxy module\nexport {\n    // Types\n    type ProxyInvoker,\n    type ProxyDescriptor,\n    type ProxyConfig,\n    type ProxyMethods,\n    type RemoteProxy,\n    type ExposeHandler,\n    type ProxySender,\n\n    // Symbols\n    PROXY_MARKER,\n    PROXY_INTERNALS,\n\n    // Classes\n    RemoteProxyHandler,\n    DispatchProxyHandler,\n    ProxyBuilder,\n\n    // Factory functions\n    createRemoteProxy,\n    wrapDescriptor,\n    isRemoteProxy,\n    getProxyDescriptor,\n    getProxyInternals,\n    createExposeHandler,\n    createSenderProxy,\n    proxyBuilder,\n\n    // Legacy aliases\n    RequestProxyHandler,\n    makeProxy,\n    makeRequestProxy\n} from \"./Proxy\";\n\n// Re-export types from Observable\nexport type { ChannelMessage };\n\n// ============================================================================\n// LEGACY TYPES\n// ============================================================================\n\nexport interface ChannelSender<T = ChannelMessage> {\n    next(message: T, transfer?: Transferable[]): void;\n    request?(message: T): Promise<any>;\n}\n\n// ============================================================================\n// LEGACY CLASSES\n// ============================================================================\n\n/**\n * @deprecated Use createRemoteProxy from Proxy.ts instead\n */\nexport class RequestProxyHandlerV2 {\n    private _channel: UnifiedChannel;\n\n    constructor(\n        public hostChannelInstance: any = null,\n        public options: any = {}\n    ) {\n        this._channel = getWorkerChannel();\n    }\n\n    dispatch(action: WReflectAction, args: any[]) {\n        const targetChannel = this.options?.connectChannel ?? \"worker\";\n        const path = args?.[1] ?? [];\n        return this._channel.invoke(targetChannel, action, path, args.slice(2) ?? []);\n    }\n}\n\n/**\n * @deprecated Use createRemoteProxy from Proxy.ts instead\n */\nexport class ObservableRequestProxyHandler extends RequestProxyHandlerV2 {}\n\n// ============================================================================\n// LEGACY FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * @deprecated Use UnifiedChannel.proxy() instead\n */\nexport const wrapChannel = (connectChannel: string, host: any = null): any => {\n    const channel = getWorkerChannel();\n    return channel.proxy(connectChannel);\n};\n\n/**\n * @deprecated Use UnifiedChannel.proxy() instead\n */\nexport const wrapObservableChannel = (channelObs: ChannelObservable, connectChannel: string, options: any = {}): any =>\n    wrapChannel(connectChannel, null);\n\n/**\n * @deprecated Use UnifiedChannel.wrapDescriptor() instead\n */\nexport const makeObservableRequestProxy = (\n    descriptor: WReflectDescriptor,\n    channelObs: ChannelObservable,\n    options: any = {}\n): any => {\n    const channel = getWorkerChannel();\n    return channel.wrapDescriptor(descriptor, descriptor?.channel ?? options?.connectChannel);\n};\n\n/**\n * @deprecated Use createUnifiedChannel instead\n */\nexport function createObservableChannel(\n    transport: Worker | MessagePort | BroadcastChannel | WebSocket | \"chrome-runtime\" | \"service-worker-client\" | \"self\",\n    channelName: string\n) {\n    const channel = createUnifiedChannel({ name: channelName, autoListen: false });\n    channel.connect(transport, { targetChannel: channelName });\n\n    return {\n        observable: channel,\n        wrap: (connectChannel: string, opts?: any) => channel.proxy(connectChannel),\n        subscribe: (obs: any) => channel.subscribe(obs),\n        send: (msg: any) => channel.next(msg),\n        request: (msg: any) => channel.invoke(channelName, WReflectAction.CALL, [], [msg])\n    };\n}\n","// deno-lint-ignore-file no-explicit-any\nexport const PMS: any = Promise;\nexport const TS: any = {\n    rjb: \"rejectBy\",\n    rvb: \"resolveBy\",\n    rj: \"reject\",\n    rv: \"resolve\",\n    cr: \"create\",\n    cs: \"createSync\",\n    a: \"array\",\n    ta: \"typedarray\",\n    udf: \"undefined\"\n};\nexport default TS;\n","// deno-lint-ignore-file no-explicit-any ban-types\nimport { isPromise } from \"fest/core\";\nimport { TS } from \"./Alias\";\n\n//\nexport type dT = object | Function;\nexport type rT = WeakRef<dT>;\nexport type MPromise<T extends unknown> = Promise<T> | T | null;\nexport type IWrap<T extends unknown> = {\n    [pT in keyof T]: MPromise<pT> | IWrap<pT>;\n};\n\n//\nexport type ExChanger = any;\n\n/*\n * Internal types of meta\n * [\"@meta\"|\"@data\"]: {\n *   !type: string, // interpretation type (how will resolved)\n *   !uuid: string, // located in remote storage pool\n *   !payload: any, // additional descriptions\n *   !index: number // located in transferable list\n * }\n */\n\n// If someone not in list, will just copy or sharing\n// @ts-ignore \"Transferable list for web workers (automatic)\"\nexport const Transferable = [\n    /* @ts-ignore \"\" */ typeof ArrayBuffer != TS.udf ? ArrayBuffer : null,\n    /* @ts-ignore \"\" */ typeof MessagePort != TS.udf ? MessagePort : null,\n    /* @ts-ignore \"\" */ typeof ReadableStream != TS.udf ? ReadableStream : null,\n    /* @ts-ignore \"\" */ typeof WritableStream != TS.udf ? WritableStream : null,\n    /* @ts-ignore \"\" */ typeof TransformStream != TS.udf ? TransformStream : null,\n    /* @ts-ignore \"\" */ typeof WebTransportReceiveStream != TS.udf ? WebTransportReceiveStream : null,\n    /* @ts-ignore \"\" */ typeof WebTransportSendStream != TS.udf ? WebTransportSendStream : null,\n    /* @ts-ignore \"\" */ typeof AudioData != TS.udf ? AudioData : null,\n    /* @ts-ignore \"\" */ typeof ImageBitmap != TS.udf ? ImageBitmap : null,\n    /* @ts-ignore \"\" */ typeof VideoFrame != TS.udf ? VideoFrame : null,\n    /* @ts-ignore \"\" */ typeof OffscreenCanvas != TS.udf ? OffscreenCanvas : null,\n    /* @ts-ignore \"\" */ typeof RTCDataChannel != TS.udf ? RTCDataChannel : null\n].filter((E) => (E != null));\n\n//\nexport const FORBIDDEN_KEYS = new Set([\"bind\", \"toString\", \"then\", \"catch\", \"finally\"]);\nexport const doOnlyAfterResolve = <T extends unknown | any>(meta: MPromise<T>, cb: (u: T) => MPromise<T> | null | void): MPromise<any> | null | void => {\n    if (isPromise(meta)) {\n        const chain = (meta as any)?.then?.(cb)?.catch?.(console.trace.bind(console)) ?? cb(meta as T);\n        //console.trace(chain);\n        return chain;\n    }\n    return cb(meta as T);\n}\n","/**\n * Channel Handler - Legacy Re-exports\n *\n * @deprecated Use UnifiedChannel instead.\n * This file is kept for backward compatibility.\n */\n\nimport { UUIDv4, Promised } from \"fest/core\";\nimport { WReflectAction, type WReflectDescriptor, type WReq } from \"../types/Interface\";\nimport { UnifiedChannel, createUnifiedChannel, getWorkerChannel } from \"./UnifiedChannel\";\nimport { handleRequest } from \"../../core/RequestHandler\";\n\n// ============================================================================\n// LEGACY GLOBALS (for backward compatibility)\n// ============================================================================\n\nexport const RemoteChannels = new Map<string, any>();\n\nexport const SELF_CHANNEL = {\n    name: \"unknown\",\n    instance: null as ChannelHandler | null\n};\n\nexport const CHANNEL_MAP = new Map<string, ChannelHandler | null>();\n\n// ============================================================================\n// HELPERS\n// ============================================================================\n\nconst isReflectAction = (action: any): action is WReflectAction =>\n    [...Object.values(WReflectAction)].includes(action);\n\nexport const loadWorker = (WX: any): Worker | null => {\n    if (WX instanceof Worker) return WX;\n    if (WX instanceof URL) return new Worker(WX.href, { type: \"module\" });\n    if (typeof WX === \"function\") {\n        try { return new WX({ type: \"module\" }); }\n        catch { return WX({ type: \"module\" }); }\n    }\n    if (typeof WX === \"string\") {\n        if (WX.startsWith(\"/\")) return new Worker(new URL(WX.replace(/^\\//, \"./\"), import.meta.url).href, { type: \"module\" });\n        if (URL.canParse(WX) || WX.startsWith(\"./\")) return new Worker(new URL(WX, import.meta.url).href, { type: \"module\" });\n        return new Worker(URL.createObjectURL(new Blob([WX], { type: \"application/javascript\" })), { type: \"module\" });\n    }\n    if (WX instanceof Blob || WX instanceof File) return new Worker(URL.createObjectURL(WX), { type: \"module\" });\n    return WX ?? (typeof self !== \"undefined\" ? self : null) as unknown as Worker;\n};\n\n// ============================================================================\n// REMOTE CHANNEL HELPER (Legacy wrapper)\n// ============================================================================\n\n/** @deprecated Use UnifiedChannel.remote() instead */\nexport class RemoteChannelHelper {\n    private _channel: UnifiedChannel;\n\n    constructor(private channelName: string, private options: any = {}) {\n        this._channel = getWorkerChannel();\n    }\n\n    request(path: string[] | WReflectDescriptor, action: WReflectAction | any[], args: any[] | any, options: any = {}): Promise<any> | null {\n        if (typeof path === \"string\") path = [path];\n        if (Array.isArray(action) && isReflectAction(path)) {\n            options = args; args = action;\n            action = path as unknown as WReflectAction; path = [];\n        }\n        return this._channel.invoke(this.channelName, action as WReflectAction, path as string[], args);\n    }\n\n    doImportModule(url: string, options: any): Promise<any> | null {\n        return this._channel.import(url, this.channelName);\n    }\n}\n\n// ============================================================================\n// CHANNEL HANDLER (Legacy wrapper)\n// ============================================================================\n\n/** @deprecated Use UnifiedChannel instead */\nexport class ChannelHandler {\n    private _unified: UnifiedChannel;\n    private broadcasts: Record<string, Worker | BroadcastChannel | MessagePort> = {};\n\n    constructor(private channel: string, private options: any = {}) {\n        this._unified = createUnifiedChannel({ name: channel, autoListen: false });\n        SELF_CHANNEL.name = channel;\n        SELF_CHANNEL.instance = this;\n    }\n\n    createRemoteChannel(channel: string, options: any = {}, broadcast?: Worker | BroadcastChannel | MessagePort | null) {\n        if (broadcast) {\n            this._unified.attach(broadcast, { targetChannel: channel });\n            this.broadcasts[channel] = broadcast;\n        }\n        return Promise.resolve(new RemoteChannelHelper(channel, options));\n    }\n\n    getChannel(): string { return this.channel; }\n\n    request(path: string[] | WReflectAction, action: WReflectAction | any[], args: any[] | any, options: any | string = {}, toChannel: string = \"worker\"): Promise<any> | null {\n        if (typeof path === \"string\") path = [path];\n        if (Array.isArray(action) && isReflectAction(path)) {\n            toChannel = options as string; options = args;\n            args = action; action = path as unknown as WReflectAction; path = [];\n        }\n        return this._unified.invoke(toChannel, action as WReflectAction, path as string[], args);\n    }\n\n    resolveResponse(reqId: string, result: any) { return Promise.resolve(result); }\n\n    async handleAndResponse(request: WReq, reqId: string, responseFn?: (result: any, transfer: any[]) => void) {\n        const result = await handleRequest(request, reqId, this.channel);\n        if (!result) return;\n        responseFn?.(result.response, result.transfer);\n    }\n\n    close(): void { this._unified.close(); }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS (Legacy)\n// ============================================================================\n\n/** @deprecated Use createUnifiedChannel instead */\nexport const initChannelHandler = (channel: string = \"$host$\"): ChannelHandler | null => {\n    if (SELF_CHANNEL?.instance && channel === \"$host$\") return SELF_CHANNEL.instance;\n    if (CHANNEL_MAP.has(channel)) return CHANNEL_MAP.get(channel) ?? null;\n    const $channel = new ChannelHandler(channel);\n    if (channel === \"$host$\") { SELF_CHANNEL.name = channel; SELF_CHANNEL.instance = $channel; }\n    CHANNEL_MAP.set(channel, $channel);\n    return $channel;\n};\n\n/** @deprecated Use createUnifiedChannel instead */\nexport const createHostChannel = (channel: string = \"$host$\") => initChannelHandler(channel);\n\n/** @deprecated Use UnifiedChannel.attach() instead */\nexport const createOrUseExistingChannel = (\n    channel: string,\n    options: any = {},\n    broadcast: Worker | BroadcastChannel | MessagePort | null = (typeof self !== \"undefined\" ? self : null) as any\n) => {\n    const $host = createHostChannel(channel ?? \"$host$\");\n    return $host?.createRemoteChannel?.(channel, options, broadcast) ?? $host;\n};\n\n/** @deprecated Internal use */\nexport const $createOrUseExistingChannel = (channel: string, options: any = {}, broadcast?: Worker | BroadcastChannel | MessagePort | null) => {\n    if (channel == null || broadcast) return;\n    if (RemoteChannels.has(channel)) return RemoteChannels.get(channel);\n    const result = { channel, instance: SELF_CHANNEL.instance, remote: Promise.resolve(new RemoteChannelHelper(channel, options)) };\n    RemoteChannels.set(channel, result);\n    return result;\n};\n","// deno-lint-ignore-file no-explicit-any\nimport { type WReflectDescriptor } from \"../types/Interface\";\nimport { makeRequestProxy } from \"../proxy/RequestProxy\";\nimport { type dT, type rT } from \"../../core/Useful\";\nimport { UUIDv4, deref, isCanJustReturn, isNotComplexArray } from \"fest/core\";\nimport { isPrimitive } from \"fest/core\";\nimport { SELF_CHANNEL } from \"../channel/Channels\";\n\n//\nconst rg = \"register\";\n\n//\n// TODO: planned promised...\nexport default class UUIDMap<T = dT> {\n    #weakMap = new WeakMap<dT, string>();\n    #refMap = new Map<string, rT>();\n    #registry = new FinalizationRegistry<string>((_: string) => { });\n    #linked = new Map<dT, number>();\n\n    //\n    constructor() {\n        this.#linked = new Map<dT, number>();\n        this.#weakMap = new WeakMap<dT, string>();\n        this.#refMap = new Map<string, rT>();\n        this.#registry = new FinalizationRegistry<string>((key: string) => {\n            this.#refMap.delete(key);\n        });\n    }\n\n    // when transfer out required\n    delete<R extends dT | string>(key: R): unknown {\n        if (typeof key == \"object\" || typeof key == \"function\") {\n            return this.#weakMap.delete(<dT>(<unknown>key));\n        }\n        return this.#refMap.delete(<string>(<unknown>key));\n    }\n\n    //\n    add(obj: dT, id: string = \"\", force = false) {\n        obj = (obj instanceof WeakRef ? obj?.deref?.() : obj) as any;\n        if (!(typeof obj == \"object\" || typeof obj == \"function\")) return obj;\n\n        // never override already added, except transfer cases\n        if (id && this.#refMap.has(id) && !force) { return id; };\n        if (this.#weakMap.has(obj)) { return this.#weakMap.get(obj); };\n\n        //\n        this.#weakMap.set(obj, (id ||= UUIDv4()));\n        this.#refMap.set(id, new WeakRef<dT>(this.count(obj) ?? obj));\n        this.#registry?.[rg]?.(obj, id);\n\n        //\n        return id;\n    }\n\n    //\n    discount(obj?: rT): dT | undefined {\n        obj = (obj instanceof WeakRef ? obj?.deref?.() : obj) as any;\n        obj = (typeof obj == \"object\" || typeof obj == \"function\") ? obj : this.#refMap.get(<string>(<unknown>obj));\n        obj = (obj instanceof WeakRef ? obj?.deref?.() : obj) as any;\n        if (!obj) return obj;\n        const hold = this.#linked?.get?.(obj) || 0;\n        if (hold <= 1) { this.#linked.delete(obj); } else { this.#linked.set(obj, hold - 1); }\n        return obj;\n    }\n\n    //\n    count(obj?: dT): dT | undefined {\n        obj = obj instanceof WeakRef ? obj?.deref?.() : obj;\n        if (!obj) return obj;\n        const hold = this.#linked.get(obj);\n        if (!hold) { this.#linked.set(obj, 1); } else { this.#linked.set(obj, hold + 1); }\n        return obj;\n    }\n\n    //\n    has<R extends dT | string>(key: R): boolean {\n        if (typeof key == \"object\" || typeof key == \"function\") {\n            return this.#weakMap.has(<dT>(<unknown>key));\n        }\n        return this.#refMap.has(<string>(<unknown>key));\n    }\n\n    //\n    get<R extends dT | string>(key: R): unknown {\n        if (typeof key == \"object\" || typeof key == \"function\") {\n            return this.#weakMap.get(<dT>this.count(<any>key));\n        }\n        return deref(this.#refMap.get(<string>(<unknown>key)));\n    }\n}\n\n\n//\nexport const handMap = new WeakMap<Function, WReflectDescriptor>();\nexport const wrapMap = new WeakMap<Function, WReflectDescriptor>();\nexport const descMap = new WeakMap<WReflectDescriptor, Function>();\n\n//\nexport const READ = <T=any>(target: any, key: string): T => {\n    return handMap.get(target)?.[key];\n}\n\n//\nexport const objectToRef = (obj: any, channel: string = SELF_CHANNEL?.name, toTransfer?: any[]): WReflectDescriptor|any|null|undefined =>{\n    if ((typeof obj == \"object\" && obj != null) || typeof obj == \"function\" && obj != null) {\n        if (wrapMap.has(obj)) return wrapMap.get(obj);\n        if (handMap.has(obj)) return handMap.get(obj);\n        if (isNotComplexArray(obj)) return obj;\n        if (toTransfer?.includes?.(obj)) return obj;\n        if (channel == SELF_CHANNEL?.name) return obj;\n        return {\n            $isDescriptor: true,\n            path: registeredInPath.get(obj) ?? (()=>{\n                const path: string[] = [UUIDv4()];\n                writeByPath(path, obj);\n                return path;\n            })(),\n            owner: SELF_CHANNEL?.name,\n            channel: channel,\n            primitive: isPrimitive(obj),\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            argumentCount: obj instanceof Function ? obj.length : -1\n        } as WReflectDescriptor;\n    }\n    return isCanJustReturn(obj) ? obj : null;\n}\n\n//\nexport const $requestHandler = Symbol.for(\"@requestHandler\");\nexport const $descriptor = Symbol.for(\"@descriptor\");\n\n// wrap back to usable proxies\nexport const normalizeRef = (v: any)=>{\n    if (isCanJustReturn(v)) return v;\n    if (v?.[$descriptor]) return v;\n    if (v?.$isDescriptor) return makeRequestProxy(v, {});\n    if (isNotComplexArray(v)) return v;\n    return null;\n}\n\n//\nexport const unwrapDescriptorFromProxy = (target: any)=>{\n    if ((typeof target != \"function\" && typeof target != \"object\") || target == null) { return target; }\n    return wrapMap.get(target) ?? handMap.get(target) ?? target;\n}\n\n// unwrap in arrays, objects keys, values, etc. recursively\nexport const unwrapDescriptorFromProxyRecursive = (target: any)=>{\n    if ((typeof target != \"object\" && typeof target != \"function\") || target == null) { return target; }\n    target = unwrapDescriptorFromProxy(target);\n    if ((typeof target != \"object\" && typeof target != \"function\") || target == null) { return target; }\n\n    if (Array.isArray(target)) {\n        return target.map(unwrapDescriptorFromProxyRecursive);\n    }\n    if (target instanceof Map) {\n        return new Map(Array.from(target.entries()).map(([key, value]) => [key, unwrapDescriptorFromProxyRecursive(value)]));\n    }\n    if (target instanceof Set) {\n        return new Set(Array.from(target.values()).map(unwrapDescriptorFromProxyRecursive));\n    }\n    if (typeof target == \"object\") {\n        for (const key of Object.keys(target)) {\n            target[key] = unwrapDescriptorFromProxyRecursive(target[key]);\n        }\n    }\n    return target;\n}\n\n//\nexport const storedData = new Map();\nexport const registeredInPath = new WeakMap();\n\n//\nexport const traverseByPath = (obj: any, path: string[]) => {\n    if (path != null && !Array.isArray(path)) { path = [path]; }\n    if (path == null || path?.length < 1) { return obj; }\n\n    // if descriptor exists, unwrap it...\n    const $desc = obj?.[$descriptor] ?? (obj?.$isDescriptor ? obj : null);\n    if ($desc && $desc?.owner == SELF_CHANNEL?.name) {\n        obj = readByPath($desc?.path) ?? obj;\n    }\n\n    if (isPrimitive(obj)) { return obj; }\n    for (const key of path) { obj = obj?.[key]; if (obj == null) { return obj; } }\n    return obj;\n}\n\n// TODO: async support\nexport const readByPath = (path: string[]) => {\n    if (path != null && !Array.isArray(path)) { path = [path]; }\n    if (path == null || path?.length < 1) { return null; }\n    const root = storedData?.get?.(path?.[0]) ?? null;\n    return root != null ? traverseByPath(root, path?.slice?.(1)) : null;\n}\n\n// TODO: async support\nexport const writeByPath = (path: string[], data: any) => {\n    // if descriptor exists, unwrap it...\n    const $desc = data?.[$descriptor] ?? (data?.$isDescriptor ? data : null);\n    if ($desc && $desc?.owner == SELF_CHANNEL?.name) {\n        data = readByPath($desc?.path) ?? data;\n    }\n\n    //\n    if (path != null && !Array.isArray(path)) { path = [path]; }\n    if (path == null || path?.length < 1) { return null; }\n    const root = storedData?.get?.(path?.[0]) ?? null;\n    if (path?.length > 1) { traverseByPath(root, path?.slice?.(1, -1))[path?.[path?.length - 1]] = data; } else { storedData?.set?.(path?.[0], data); }\n    if (typeof data == \"object\" || typeof data == \"function\") { registeredInPath?.set?.(data, path); }\n    return data;\n}\n\n//\nexport const removeByPath = (path: string[]) => {\n    if (path != null && !Array.isArray(path)) { path = [path]; }\n    if (path == null || path?.length < 1) { return false; }\n    const root = storedData?.get?.(path?.[0]) ?? null;\n    if (!root && path?.length <= 1) { storedData?.delete?.(path?.[0]); return true; } else { return false; }\n    delete traverseByPath(root, path?.slice?.(1, -1))[path?.[path?.length - 1]];\n    if ((typeof root == \"object\" || typeof root == \"function\") && path?.length <= 1) { registeredInPath?.delete?.(root); }\n    return true;\n}\n\n//\nexport const removeByData = (data: any) => {\n    // if descriptor exists, unwrap it...\n    const $desc = data?.[$descriptor] ?? (data?.$isDescriptor ? data : null);\n    if ($desc && $desc?.owner == SELF_CHANNEL?.name) {\n        data = readByPath($desc?.path) ?? data;\n    }\n\n    //\n    const path = registeredInPath?.get?.(data) ?? $desc?.path;\n    if (path == null || path?.length < 1) { return false; }; removeByPath(path);\n    if (typeof data == \"object\" || typeof data == \"function\") { registeredInPath?.delete?.(data); }\n    return true;\n}\n\n//\nexport const hasNoPath = (data: any) => {\n    const $desc = data?.[$descriptor] ?? (data?.$isDescriptor ? data : null);\n    return (registeredInPath?.get?.(data) ?? $desc?.path) == null;\n}\n","/**\n * Request Handler Core - Unified Reflect Action Handling\n *\n * Single source of truth for all action execution:\n * - UnifiedChannel, ChannelContext, Proxy module\n * - Supports both DataBase-backed and direct object targets\n * - Supports custom Reflect implementations\n */\n\nimport { UUIDv4, deepOperateAndClone, isPrimitive, isCanJustReturn, isCanTransfer } from \"fest/core\";\nimport type { WReflectDescriptor, WReq, WResp } from \"../next/types/Interface\";\nimport { WReflectAction } from \"../next/types/Interface\";\nimport {\n    hasNoPath,\n    readByPath,\n    registeredInPath,\n    removeByData,\n    removeByPath,\n    writeByPath,\n    normalizeRef,\n    objectToRef\n} from \"../next/storage/DataBase\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface RequestContext {\n    channel: string;\n    sender: string;\n    path: string[];\n    action: string;\n    args: any[];\n}\n\nexport interface ResponseBuilder {\n    result: any;\n    path: string[];\n    toTransfer: any[];\n    canBeReturn: boolean;\n}\n\n/** Reflect-like interface for custom implementations */\nexport interface ReflectLike {\n    get?(target: any, prop: PropertyKey): any;\n    set?(target: any, prop: PropertyKey, value: any): boolean;\n    has?(target: any, prop: PropertyKey): boolean;\n    apply?(target: any, thisArg: any, args: any[]): any;\n    construct?(target: any, args: any[]): any;\n    deleteProperty?(target: any, prop: PropertyKey): boolean;\n    ownKeys?(target: any): (string | symbol)[];\n    getOwnPropertyDescriptor?(target: any, prop: PropertyKey): PropertyDescriptor | undefined;\n    getPrototypeOf?(target: any): object | null;\n    setPrototypeOf?(target: any, proto: object | null): boolean;\n    isExtensible?(target: any): boolean;\n    preventExtensions?(target: any): boolean;\n}\n\n/** Action execution options */\nexport interface ExecuteOptions {\n    /** Channel name for transfer checks */\n    channel?: string;\n    /** Sender name for transfer checks */\n    sender?: string;\n    /** Custom Reflect implementation */\n    reflect?: ReflectLike;\n    /** Direct target object (bypasses DataBase) */\n    target?: any;\n    /** Context object for function binding */\n    context?: any;\n}\n\n/** Action execution result */\nexport interface ExecuteResult {\n    result: any;\n    toTransfer: any[];\n    path: string[];\n}\n\n// ============================================================================\n// HELPERS\n// ============================================================================\n\nconst isObject = (obj: any): obj is object =>\n    (typeof obj === \"object\" || typeof obj === \"function\") && obj != null;\n\nconst defaultReflect: ReflectLike = {\n    get: (t, p) => t?.[p],\n    set: (t, p, v) => { t[p] = v; return true; },\n    has: (t, p) => p in t,\n    apply: (t, ctx, args) => t.apply(ctx, args),\n    construct: (t, args) => new t(...args),\n    deleteProperty: (t, p) => delete t[p],\n    ownKeys: (t) => Object.keys(t),\n    getOwnPropertyDescriptor: (t, p) => Object.getOwnPropertyDescriptor(t, p),\n    getPrototypeOf: (t) => Object.getPrototypeOf(t),\n    setPrototypeOf: (t, p) => Object.setPrototypeOf(t, p),\n    isExtensible: (t) => Object.isExtensible(t),\n    preventExtensions: (t) => Object.preventExtensions(t)\n};\n\n// ============================================================================\n// UNIFIED ACTION EXECUTOR\n// ============================================================================\n\n/**\n * Execute a reflect action\n *\n * Unified implementation used by all channel/proxy handlers.\n * Supports both DataBase-backed paths and direct object targets.\n *\n * @param action - Action to execute (WReflectAction or string)\n * @param path - Object path\n * @param args - Action arguments\n * @param options - Execution options\n */\nexport function executeAction(\n    action: WReflectAction | string,\n    path: string[],\n    args: any[],\n    options: ExecuteOptions = {}\n): ExecuteResult {\n    const { channel = \"\", sender = \"\", reflect = defaultReflect } = options;\n\n    // Get target: from options or DataBase\n    const obj = options.target ?? readByPath(path);\n    const toTransfer: any[] = [];\n    let result: any = null;\n    let newPath = path;\n\n    // Normalize action string\n    const act = String(action).toLowerCase();\n\n    switch (act) {\n        case \"import\":\n        case WReflectAction.IMPORT:\n            result = import(args?.[0]);\n            break;\n\n        case \"transfer\":\n        case WReflectAction.TRANSFER:\n            if (isCanTransfer(obj) && channel !== sender) {\n                toTransfer.push(obj);\n            }\n            result = obj;\n            break;\n\n        case \"get\":\n        case WReflectAction.GET: {\n            const prop = args?.[0];\n            const got = reflect.get?.(obj, prop) ?? obj?.[prop];\n            result = typeof got === \"function\" && obj != null ? got.bind(obj) : got;\n            newPath = [...path, String(prop)];\n            break;\n        }\n\n        case \"set\":\n        case WReflectAction.SET: {\n            const [prop, value] = args;\n            const normalizedValue = deepOperateAndClone(value, normalizeRef);\n            if (options.target) {\n                result = reflect.set?.(obj, prop, normalizedValue) ?? (obj[prop] = normalizedValue, true);\n            } else {\n                result = reflect.set?.(obj, prop, normalizedValue) ??\n                    writeByPath([...path, String(prop)], normalizedValue);\n            }\n            break;\n        }\n\n        case \"apply\":\n        case \"call\":\n        case WReflectAction.APPLY:\n        case WReflectAction.CALL: {\n            if (typeof obj === \"function\") {\n                const ctx = options.context ?? (options.target ? undefined : readByPath(path.slice(0, -1)));\n                const normalizedArgs = deepOperateAndClone(args?.[0] ?? args ?? [], normalizeRef);\n                result = reflect.apply?.(obj, ctx, normalizedArgs) ?? obj.apply(ctx, normalizedArgs);\n\n                if (isCanTransfer(result) && path?.at(-1) === \"transfer\" && channel !== sender) {\n                    toTransfer.push(result);\n                }\n            }\n            break;\n        }\n\n        case \"construct\":\n        case WReflectAction.CONSTRUCT: {\n            if (typeof obj === \"function\") {\n                const normalizedArgs = deepOperateAndClone(args?.[0] ?? args ?? [], normalizeRef);\n                result = reflect.construct?.(obj, normalizedArgs) ?? new obj(...normalizedArgs);\n            }\n            break;\n        }\n\n        case \"delete\":\n        case \"deleteproperty\":\n        case \"dispose\":\n        case WReflectAction.DELETE:\n        case WReflectAction.DELETE_PROPERTY:\n        case WReflectAction.DISPOSE:\n            if (options.target) {\n                const prop = path[path.length - 1];\n                result = reflect.deleteProperty?.(obj, prop) ?? delete obj[prop];\n            } else {\n                result = path?.length > 0 ? removeByPath(path) : removeByData(obj);\n                if (result) newPath = registeredInPath.get(obj) ?? [];\n            }\n            break;\n\n        case \"has\":\n        case WReflectAction.HAS:\n            result = reflect.has?.(obj, args?.[0]) ?? (isObject(obj) ? args?.[0] in obj : false);\n            break;\n\n        case \"ownkeys\":\n        case WReflectAction.OWN_KEYS:\n            result = reflect.ownKeys?.(obj) ?? (isObject(obj) ? Object.keys(obj) : []);\n            break;\n\n        case \"getownpropertydescriptor\":\n        case \"getpropertydescriptor\":\n        case WReflectAction.GET_OWN_PROPERTY_DESCRIPTOR:\n        case WReflectAction.GET_PROPERTY_DESCRIPTOR:\n            result = reflect.getOwnPropertyDescriptor?.(obj, args?.[0] ?? path?.at(-1) ?? \"\") ??\n                (isObject(obj) ? Object.getOwnPropertyDescriptor(obj, args?.[0] ?? path?.at(-1) ?? \"\") : undefined);\n            break;\n\n        case \"getprototypeof\":\n        case WReflectAction.GET_PROTOTYPE_OF:\n            result = reflect.getPrototypeOf?.(obj) ?? (isObject(obj) ? Object.getPrototypeOf(obj) : null);\n            break;\n\n        case \"setprototypeof\":\n        case WReflectAction.SET_PROTOTYPE_OF:\n            result = reflect.setPrototypeOf?.(obj, args?.[0]) ??\n                (isObject(obj) ? Object.setPrototypeOf(obj, args?.[0]) : false);\n            break;\n\n        case \"isextensible\":\n        case WReflectAction.IS_EXTENSIBLE:\n            result = reflect.isExtensible?.(obj) ?? (isObject(obj) ? Object.isExtensible(obj) : true);\n            break;\n\n        case \"preventextensions\":\n        case WReflectAction.PREVENT_EXTENSIONS:\n            result = reflect.preventExtensions?.(obj) ??\n                (isObject(obj) ? Object.preventExtensions(obj) : false);\n            break;\n    }\n\n    return { result, toTransfer, path: newPath };\n}\n\n/**\n * Execute action with async result resolution\n */\nexport async function executeActionAsync(\n    action: WReflectAction | string,\n    path: string[],\n    args: any[],\n    options: ExecuteOptions = {}\n): Promise<ExecuteResult> {\n    const { result, toTransfer, path: newPath } = executeAction(action, path, args, options);\n    return { result: await result, toTransfer, path: newPath };\n}\n\n// ============================================================================\n// RESPONSE BUILDER\n// ============================================================================\n\n/**\n * Build response object with descriptor\n */\nexport async function buildResponse(\n    reqId: string,\n    action: string,\n    channel: string,\n    sender: string,\n    path: string[],\n    rawResult: any,\n    toTransfer: any[]\n): Promise<{ response: any; transfer: any[] }> {\n    const result = await rawResult;\n\n    const canBeReturn = (isCanTransfer(result) && toTransfer.includes(result)) || isCanJustReturn(result);\n\n    // Generate temp path if needed\n    let finalPath = path;\n    if (!canBeReturn && action !== \"get\" && action !== WReflectAction.GET &&\n        (typeof result === \"object\" || typeof result === \"function\")) {\n        if (hasNoPath(result)) {\n            finalPath = [UUIDv4()];\n            writeByPath(finalPath, result);\n        } else {\n            finalPath = registeredInPath.get(result) ?? [];\n        }\n    }\n\n    const ctx = readByPath(finalPath);\n    const ctxKey = (action === \"get\" || action === WReflectAction.GET) ? finalPath?.at(-1) : undefined;\n    const obj = readByPath(path);\n\n    const payload = deepOperateAndClone(result, (el) => objectToRef(el, channel, toTransfer)) ?? result;\n\n    return {\n        response: {\n            channel: sender,\n            sender: channel,\n            reqId,\n            action,\n            type: \"response\",\n            payload: {\n                result: canBeReturn ? payload : null,\n                type: typeof result,\n                channel: sender,\n                sender: channel,\n                descriptor: {\n                    $isDescriptor: true,\n                    path: finalPath,\n                    owner: channel,\n                    channel,\n                    primitive: isPrimitive(result),\n                    writable: true,\n                    enumerable: true,\n                    configurable: true,\n                    argumentCount: obj instanceof Function ? obj.length : -1,\n                    ...(isObject(ctx) && ctxKey != null ? Object.getOwnPropertyDescriptor(ctx, ctxKey) : {})\n                } as WReflectDescriptor<any>\n            } as WResp<any>\n        },\n        transfer: toTransfer\n    };\n}\n\n// ============================================================================\n// UNIFIED REQUEST HANDLER\n// ============================================================================\n\n/**\n * Handle request and return response (unified handler)\n */\nexport async function handleRequest(\n    request: WReq,\n    reqId: string,\n    channelName: string,\n    options?: ExecuteOptions\n): Promise<{ response: any; transfer: any[] } | null> {\n    const { channel, sender, path, action, args } = request;\n\n    if (channel !== channelName) return null;\n\n    const { result, toTransfer, path: newPath } = executeAction(\n        action,\n        path,\n        args,\n        { channel, sender, ...options }\n    );\n\n    return buildResponse(reqId, action, channelName, sender, newPath, result, toTransfer);\n}\n\n// ============================================================================\n// SIMPLE EXPOSE HANDLER (For Proxy module)\n// ============================================================================\n\n/**\n * Create a simple expose handler for an object\n *\n * Unlike the full executeAction, this works directly on the target\n * without DataBase integration. Used by Proxy.ts createExposeHandler.\n *\n * @param target - Object to expose\n * @param reflect - Optional custom Reflect implementation\n */\nexport function createObjectHandler<T extends object>(\n    target: T,\n    reflect: ReflectLike = defaultReflect\n): (action: string, path: string[], args: any[]) => Promise<any> {\n    return async (action, path, args) => {\n        // Navigate to the parent of the final property\n        let parent: any = target;\n        let current: any = target;\n\n        for (let i = 0; i < path.length; i++) {\n            parent = current;\n            current = current?.[path[i]];\n            if (current === undefined && i < path.length - 1) {\n                throw new Error(`Path segment '${path[i]}' not found`);\n            }\n        }\n\n        const prop = path[path.length - 1];\n        const act = String(action).toLowerCase();\n\n        // Handle actions directly on the resolved target\n        switch (act) {\n            case \"get\":\n            case WReflectAction.GET:\n                return current;\n\n            case \"set\":\n            case WReflectAction.SET:\n                parent[prop] = args[0];\n                return true;\n\n            case \"call\":\n            case \"apply\":\n            case WReflectAction.APPLY:\n            case WReflectAction.CALL:\n                if (typeof current === \"function\") {\n                    const callArgs = Array.isArray(args[0]) ? args[0] : args;\n                    return await current.apply(parent, callArgs);\n                }\n                throw new Error(`'${prop}' is not a function`);\n\n            case \"construct\":\n            case WReflectAction.CONSTRUCT:\n                if (typeof current === \"function\") {\n                    const ctorArgs = Array.isArray(args[0]) ? args[0] : args;\n                    return new current(...ctorArgs);\n                }\n                throw new Error(`'${prop}' is not a constructor`);\n\n            case \"has\":\n            case WReflectAction.HAS:\n                return prop in parent;\n\n            case \"delete\":\n            case \"deleteproperty\":\n            case WReflectAction.DELETE_PROPERTY:\n                return delete parent[prop];\n\n            case \"ownkeys\":\n            case WReflectAction.OWN_KEYS:\n                return Object.keys(current ?? parent);\n\n            default:\n                return current;\n        }\n    };\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport { defaultReflect, isObject };\n","/**\n * Channel Connection - Connection abstraction layer\n *\n * Provides connection pooling, state management, and message routing.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { ChannelSubject, MessageObservable, filter } from \"../observable/Observable\";\nimport type {\n    ChannelMessage,\n    ChannelState,\n    ChannelMeta,\n    Observer,\n    Subscription,\n    TransportType,\n    ConnectionOptions,\n    PendingRequest\n} from \"../types/Interface\";\n\n// Re-export types\nexport type { TransportType, ConnectionOptions };\n\n// ============================================================================\n// CONNECTION STATS\n// ============================================================================\n\nexport interface ConnectionStats {\n    messagesSent: number;\n    messagesReceived: number;\n    bytesTransferred: number;\n    latencyMs: number;\n    uptime: number;\n    reconnectCount: number;\n}\n\n// ============================================================================\n// CHANNEL CONNECTION\n// ============================================================================\n\nexport class ChannelConnection {\n    private _id = UUIDv4();\n    private _state: ChannelState = \"disconnected\";\n    private _inbound = new ChannelSubject<ChannelMessage>({ bufferSize: 1000 });\n    private _outbound = new ChannelSubject<ChannelMessage>({ bufferSize: 1000 });\n    private _stateChanges = new ChannelSubject<ChannelState>();\n    private _connectedPeers = new Map<string, ChannelMeta>();\n    private _subs: Subscription[] = [];\n    private _stats: ConnectionStats = { messagesSent: 0, messagesReceived: 0, bytesTransferred: 0, latencyMs: 0, uptime: 0, reconnectCount: 0 };\n    private _startTime = 0;\n    // @ts-ignore\n    private _pending = new Map<string, PromiseWithResolvers<any>>();\n    private _buffer: ChannelMessage[] = [];\n    private _opts: Required<ConnectionOptions>;\n\n    constructor(\n        private _name: string,\n        private _transportType: TransportType = \"internal\",\n        options: ConnectionOptions = {}\n    ) {\n        this._opts = {\n            timeout: 30000,\n            autoReconnect: true,\n            reconnectInterval: 1000,\n            maxReconnectAttempts: 5,\n            bufferMessages: true,\n            bufferSize: 1000,\n            metadata: {},\n            ...options\n        };\n        this._setupSubscriptions();\n    }\n\n    // Observable API\n    subscribe(observer: Observer<ChannelMessage> | ((msg: ChannelMessage) => void), fromChannel?: string): Subscription {\n        const src = fromChannel ? filter((m: ChannelMessage) => m.sender === fromChannel)(this._inbound) : this._inbound;\n        return src.subscribe(typeof observer === \"function\" ? { next: observer } : observer);\n    }\n\n    next(message: ChannelMessage): void {\n        if (this._state !== \"connected\") {\n            if (this._opts.bufferMessages && this._buffer.length < this._opts.bufferSize) {\n                this._buffer.push(message);\n            }\n            return;\n        }\n        this._outbound.next(message);\n        this._stats.messagesSent++;\n    }\n\n    async request<T = any>(toChannel: string, payload: any, opts: { timeout?: number; action?: string; path?: string[] } = {}): Promise<T> {\n        const reqId = UUIDv4();\n        // @ts-ignore\n        const resolvers = Promise.withResolvers<T>();\n        this._pending.set(reqId, resolvers);\n\n        const timeout = setTimeout(() => {\n            if (this._pending.has(reqId)) {\n                this._pending.delete(reqId);\n                resolvers.reject(new Error(`Request timeout`));\n            }\n        }, opts.timeout ?? this._opts.timeout);\n\n        this.next({\n            id: UUIDv4(), channel: toChannel, sender: this._name, type: \"request\",\n            reqId, payload: { ...payload, action: opts.action, path: opts.path }, timestamp: Date.now()\n        });\n\n        return resolvers.promise.finally(() => clearTimeout(timeout));\n    }\n\n    respond(original: ChannelMessage, payload: any): void {\n        this.next({ id: UUIDv4(), channel: original.sender, sender: this._name, type: \"response\", reqId: original.reqId, payload, timestamp: Date.now() });\n    }\n\n    emit(toChannel: string, eventType: string, data: any): void {\n        this.next({ id: UUIDv4(), channel: toChannel, sender: this._name, type: \"event\", payload: { type: eventType, data }, timestamp: Date.now() });\n    }\n\n    subscribeOutbound(observer: Observer<ChannelMessage> | ((msg: ChannelMessage) => void)): Subscription {\n        return this._outbound.subscribe(typeof observer === \"function\" ? { next: observer } : observer);\n    }\n\n    pushInbound(message: ChannelMessage): void {\n        this._stats.messagesReceived++;\n        if (message.type === \"response\" && message.reqId) {\n            const r = this._pending.get(message.reqId);\n            if (r) { this._pending.delete(message.reqId); r.resolve(message.payload); return; }\n        }\n        this._inbound.next(message);\n    }\n\n    // Connection lifecycle\n    async connect(): Promise<void> {\n        if (this._state === \"connected\") return;\n        this._setState(\"connecting\");\n        this._startTime = Date.now();\n        this._setState(\"connected\");\n        this._flushBuffer();\n    }\n\n    disconnect(): void {\n        if (this._state === \"disconnected\" || this._state === \"closed\") return;\n        this._setState(\"disconnected\");\n        this._subs.forEach((s) => s.unsubscribe());\n        this._subs = [];\n    }\n\n    close(): void {\n        this.disconnect();\n        this._setState(\"closed\");\n        this._inbound.complete();\n        this._outbound.complete();\n        this._stateChanges.complete();\n    }\n\n    markConnected(): void { this._setState(\"connected\"); this._flushBuffer(); }\n    markDisconnected(): void { this._setState(\"disconnected\"); }\n\n    // State management\n    private _setState(state: ChannelState): void {\n        if (this._state !== state) { this._state = state; this._stateChanges.next(state); }\n    }\n\n    private _flushBuffer(): void {\n        for (const msg of this._buffer) this._outbound.next(msg);\n        this._buffer = [];\n    }\n\n    private _setupSubscriptions(): void {\n        this._subs.push(this._inbound.subscribe({\n            next: (msg) => {\n                if (msg.type === \"signal\" && msg.payload?.type === \"connect\") {\n                    this._connectedPeers.set(msg.sender, { name: msg.sender, state: \"connected\", isHost: false });\n                }\n            }\n        }));\n    }\n\n    // Getters\n    get id(): string { return this._id; }\n    get name(): string { return this._name; }\n    get state(): ChannelState { return this._state; }\n    get transportType(): TransportType { return this._transportType; }\n    get stats(): ConnectionStats { return { ...this._stats, uptime: this._startTime ? Date.now() - this._startTime : 0 }; }\n    get stateChanges() { return this._stateChanges; }\n    get connectedPeers(): string[] { return [...this._connectedPeers.keys()]; }\n    get meta(): ChannelMeta { return { id: this._id, name: this._name, state: this._state, isHost: false, connectedChannels: new Set(this._connectedPeers.keys()) }; }\n}\n\n// ============================================================================\n// CONNECTION POOL\n// ============================================================================\n\nexport class ConnectionPool {\n    private _connections = new Map<string, ChannelConnection>();\n    private static _instance: ConnectionPool | null = null;\n\n    static getInstance(): ConnectionPool {\n        if (!ConnectionPool._instance) ConnectionPool._instance = new ConnectionPool();\n        return ConnectionPool._instance;\n    }\n\n    getOrCreate(name: string, transportType: TransportType = \"internal\", options: ConnectionOptions = {}): ChannelConnection {\n        if (!this._connections.has(name)) {\n            this._connections.set(name, new ChannelConnection(name, transportType, options));\n        }\n        return this._connections.get(name)!;\n    }\n\n    get(name: string): ChannelConnection | undefined { return this._connections.get(name); }\n    has(name: string): boolean { return this._connections.has(name); }\n    delete(name: string): boolean { this._connections.get(name)?.close(); return this._connections.delete(name); }\n    clear(): void { this._connections.forEach((c) => c.close()); this._connections.clear(); }\n    get size(): number { return this._connections.size; }\n    get names(): string[] { return [...this._connections.keys()]; }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\nexport const getConnectionPool = (): ConnectionPool => ConnectionPool.getInstance();\nexport const getConnection = (name: string, transportType?: TransportType, options?: ConnectionOptions): ChannelConnection =>\n    getConnectionPool().getOrCreate(name, transportType, options);\nexport const getHostConnection = (name: string = \"$host$\", options?: ConnectionOptions): ChannelConnection =>\n    getConnection(name, \"internal\", { ...options, metadata: { ...options?.metadata, isHost: true } });\n","/**\n * Transport Adapters - Unified transport implementations\n *\n * Uses core/TransportCore for consistent send/listen patterns.\n * Supports observing incoming channel connections.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport {\n    createTransportSender,\n    createTransportListener,\n    type TransportTarget\n} from \"../../core/TransportCore\";\nimport type {\n    ChannelMessage,\n    Subscription,\n    Observer,\n    TransportType,\n    ConnectionOptions,\n    SendFn\n} from \"../types/Interface\";\nimport { ChannelSubject, type Subscribable } from \"../observable/Observable\";\n\n// ============================================================================\n// INCOMING CONNECTION TYPES\n// ============================================================================\n\n/** Incoming channel connection event */\nexport interface TransportIncomingConnection {\n    /** Connection ID */\n    id: string;\n    /** Channel name being requested */\n    channel: string;\n    /** Sender identifier */\n    sender: string;\n    /** Transport type */\n    transportType: TransportType;\n    /** MessagePort if applicable */\n    port?: MessagePort;\n    /** Original message data */\n    data?: any;\n    /** Timestamp */\n    timestamp: number;\n}\n\n/** Connection accepted callback */\nexport type AcceptConnectionCallback = (\n    connection: TransportIncomingConnection\n) => boolean | Promise<boolean>;\n\n// ============================================================================\n// BASE TRANSPORT\n// ============================================================================\n\nexport abstract class TransportAdapter {\n    protected _subscriptions: Subscription[] = [];\n    protected _isAttached = false;\n    protected _inbound = new ChannelSubject<ChannelMessage>({ bufferSize: 100 });\n    protected _outbound = new ChannelSubject<ChannelMessage>({ bufferSize: 100 });\n\n    // Incoming connection observability\n    protected _incomingConnections = new ChannelSubject<TransportIncomingConnection>({ bufferSize: 50 });\n    protected _acceptCallback: AcceptConnectionCallback | null = null;\n\n    constructor(\n        protected _channelName: string,\n        protected _transportType: TransportType,\n        protected _options: ConnectionOptions = {}\n    ) {}\n\n    abstract attach(): void;\n\n    detach(): void {\n        this._subscriptions.forEach((s) => s.unsubscribe());\n        this._subscriptions = [];\n        this._isAttached = false;\n    }\n\n    /** Subscribe to incoming messages */\n    subscribe(observer: Observer<ChannelMessage> | ((v: ChannelMessage) => void)): Subscription {\n        return this._inbound.subscribe(observer);\n    }\n\n    /** Send message */\n    send(msg: ChannelMessage, transfer?: Transferable[]): void {\n        this._outbound.next({ ...msg, transferable: transfer });\n    }\n\n    // ========================================================================\n    // INCOMING CONNECTION OBSERVABILITY\n    // ========================================================================\n\n    /**\n     * Observable: Incoming connection requests\n     */\n    get onIncomingConnection(): Subscribable<TransportIncomingConnection> {\n        return this._incomingConnections;\n    }\n\n    /**\n     * Subscribe to incoming connection requests\n     */\n    subscribeIncoming(\n        handler: (conn: TransportIncomingConnection) => void\n    ): Subscription {\n        return this._incomingConnections.subscribe(handler);\n    }\n\n    /**\n     * Set callback to auto-accept/reject connections\n     */\n    setAcceptCallback(callback: AcceptConnectionCallback | null): void {\n        this._acceptCallback = callback;\n    }\n\n    /**\n     * Emit incoming connection event\n     * Called by subclasses when a new connection request is detected\n     */\n    protected _emitIncomingConnection(connection: TransportIncomingConnection): void {\n        this._incomingConnections.next(connection);\n    }\n\n    /**\n     * Check if connection should be accepted (via callback)\n     */\n    protected async _shouldAcceptConnection(connection: TransportIncomingConnection): Promise<boolean> {\n        if (!this._acceptCallback) return true;\n        return this._acceptCallback(connection);\n    }\n\n    // ========================================================================\n    // GETTERS\n    // ========================================================================\n\n    get channelName(): string { return this._channelName; }\n    get isAttached(): boolean { return this._isAttached; }\n    get inbound(): Subscribable<ChannelMessage> { return this._inbound; }\n    get outbound(): Subscribable<ChannelMessage> { return this._outbound; }\n}\n\n// ============================================================================\n// WORKER TRANSPORT\n// ============================================================================\n\nexport class WorkerTransport extends TransportAdapter {\n    private _worker: Worker | null = null;\n    private _cleanup: (() => void) | null = null;\n    private _ownWorker = false;\n\n    constructor(\n        channelName: string,\n        private _workerSource: Worker | URL | string | (() => Worker),\n        options: ConnectionOptions = {}\n    ) {\n        super(channelName, \"worker\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        this._worker = this._resolveWorker();\n        const send = createTransportSender(this._worker);\n\n        this._cleanup = createTransportListener(\n            this._worker,\n            (data) => this._handleIncoming(data),\n            (err) => this._inbound.error(err)\n        );\n\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg, msg.transferable)));\n        this._isAttached = true;\n    }\n\n    detach(): void {\n        this._cleanup?.();\n        if (this._ownWorker && this._worker) this._worker.terminate();\n        this._worker = null;\n        super.detach();\n    }\n\n    /**\n     * Request a new channel in the worker\n     */\n    requestChannel(\n        channel: string,\n        sender: string,\n        options?: ConnectionOptions,\n        port?: MessagePort\n    ): void {\n        const transfer = port ? [port] : [];\n        this._worker?.postMessage({\n            type: \"createChannel\",\n            channel,\n            sender,\n            options,\n            messagePort: port,\n            reqId: UUIDv4()\n        }, { transfer });\n    }\n\n    /**\n     * Connect to an existing channel in the worker\n     */\n    connectChannel(\n        channel: string,\n        sender: string,\n        port?: MessagePort,\n        options?: ConnectionOptions\n    ): void {\n        const transfer = port ? [port] : [];\n        this._worker?.postMessage({\n            type: \"connectChannel\",\n            channel,\n            sender,\n            port,\n            options,\n            reqId: UUIDv4()\n        }, { transfer });\n    }\n\n    /**\n     * List all channels in the worker\n     */\n    listChannels(): Promise<string[]> {\n        return new Promise((resolve) => {\n            const reqId = UUIDv4();\n            const handler = (msg: ChannelMessage) => {\n                if (msg.type === \"channelList\" && (msg as any).reqId === reqId) {\n                    sub.unsubscribe();\n                    resolve((msg as any).channels ?? []);\n                }\n            };\n            const sub = this._inbound.subscribe(handler);\n            this._worker?.postMessage({ type: \"listChannels\", reqId });\n\n            // Timeout fallback\n            setTimeout(() => { sub.unsubscribe(); resolve([]); }, 5000);\n        });\n    }\n\n    private _handleIncoming(data: any): void {\n        // Detect channel creation/connection events\n        if (data?.type === \"channelCreated\" || data?.type === \"channelConnected\") {\n            this._emitIncomingConnection({\n                id: data.reqId ?? UUIDv4(),\n                channel: data.channel,\n                sender: data.sender ?? \"worker\",\n                transportType: \"worker\",\n                data,\n                timestamp: Date.now()\n            });\n        }\n\n        // Forward to inbound stream\n        this._inbound.next(data);\n    }\n\n    private _resolveWorker(): Worker {\n        if (this._workerSource instanceof Worker) return this._workerSource;\n        this._ownWorker = true;\n\n        if (typeof this._workerSource === \"function\") return this._workerSource();\n        if (this._workerSource instanceof URL) return new Worker(this._workerSource.href, { type: \"module\" });\n\n        if (typeof this._workerSource === \"string\") {\n            if (this._workerSource.startsWith(\"/\"))\n                return new Worker(new URL(this._workerSource.replace(/^\\//, \"./\"), import.meta.url).href, { type: \"module\" });\n            if (URL.canParse(this._workerSource) || this._workerSource.startsWith(\"./\"))\n                return new Worker(new URL(this._workerSource, import.meta.url).href, { type: \"module\" });\n            return new Worker(URL.createObjectURL(new Blob([this._workerSource], { type: \"application/javascript\" })), { type: \"module\" });\n        }\n        throw new Error(\"Invalid worker source\");\n    }\n\n    get worker(): Worker | null { return this._worker; }\n}\n\n// ============================================================================\n// MESSAGE PORT TRANSPORT\n// ============================================================================\n\nexport class MessagePortTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, private _port: MessagePort, options: ConnectionOptions = {}) {\n        super(channelName, \"message-port\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        const send = createTransportSender(this._port);\n        this._cleanup = createTransportListener(this._port, (data) => this._inbound.next(data));\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg, msg.transferable)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); this._port.close(); super.detach(); }\n    get port(): MessagePort { return this._port; }\n}\n\n// ============================================================================\n// BROADCAST CHANNEL TRANSPORT\n// ============================================================================\n\nexport class BroadcastChannelTransport extends TransportAdapter {\n    private _channel: BroadcastChannel | null = null;\n    private _cleanup: (() => void) | null = null;\n    private _connectedPeers = new Set<string>();\n\n    constructor(channelName: string, private _bcName?: string, options: ConnectionOptions = {}) {\n        super(channelName, \"broadcast\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        this._channel = new BroadcastChannel(this._bcName ?? this._channelName);\n        const send = createTransportSender(this._channel);\n        this._cleanup = createTransportListener(this._channel, (data) => {\n            if (data?.sender !== this._channelName) {\n                this._handleIncoming(data);\n            }\n        });\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n\n        // Announce presence\n        this._announcePresence();\n    }\n\n    private _handleIncoming(data: any): void {\n        // Detect connection announcements\n        if (data?.type === \"announce\" || data?.type === \"connect\") {\n            const sender = data.sender ?? \"unknown\";\n            const isNew = !this._connectedPeers.has(sender);\n            this._connectedPeers.add(sender);\n\n            if (isNew) {\n                this._emitIncomingConnection({\n                    id: data.reqId ?? UUIDv4(),\n                    channel: data.channel ?? this._channelName,\n                    sender,\n                    transportType: \"broadcast\",\n                    data,\n                    timestamp: Date.now()\n                });\n\n                // Respond to announcement\n                if (data.type === \"announce\") {\n                    this._channel?.postMessage({\n                        type: \"announce-ack\",\n                        channel: this._channelName,\n                        sender: this._channelName\n                    });\n                }\n            }\n        }\n\n        this._inbound.next(data);\n    }\n\n    private _announcePresence(): void {\n        this._channel?.postMessage({\n            type: \"announce\",\n            channel: this._channelName,\n            sender: this._channelName,\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Get connected peers\n     */\n    get connectedPeers(): string[] {\n        return [...this._connectedPeers];\n    }\n\n    detach(): void {\n        this._cleanup?.();\n        this._channel?.close();\n        this._channel = null;\n        this._connectedPeers.clear();\n        super.detach();\n    }\n}\n\n// ============================================================================\n// WEBSOCKET TRANSPORT\n// ============================================================================\n\nexport class WebSocketTransport extends TransportAdapter {\n    private _ws: WebSocket | null = null;\n    private _cleanup: (() => void) | null = null;\n    private _pending: ChannelMessage[] = [];\n    private _state = new ChannelSubject<\"connecting\" | \"open\" | \"closing\" | \"closed\">();\n    private _connectedChannels = new Set<string>();\n\n    constructor(channelName: string, private _url: string | URL, private _protocols?: string | string[], options: ConnectionOptions = {}) {\n        super(channelName, \"websocket\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        const url = typeof this._url === \"string\" ? this._url : this._url.href;\n        this._ws = new WebSocket(url, this._protocols);\n        this._state.next(\"connecting\");\n\n        const send: SendFn<ChannelMessage> = (msg) => {\n            if (this._ws?.readyState === WebSocket.OPEN) {\n                const { transferable: _, ...data } = msg as any;\n                this._ws.send(JSON.stringify(data));\n            } else {\n                this._pending.push(msg);\n            }\n        };\n\n        this._ws.addEventListener(\"open\", () => {\n            this._state.next(\"open\");\n            this._pending.forEach((m) => send(m));\n            this._pending = [];\n\n            // Emit self as connected\n            this._emitIncomingConnection({\n                id: UUIDv4(),\n                channel: this._channelName,\n                sender: \"server\",\n                transportType: \"websocket\",\n                timestamp: Date.now()\n            });\n        });\n\n        this._cleanup = createTransportListener(\n            this._ws,\n            (data) => this._handleIncoming(data),\n            (err) => this._inbound.error(err),\n            () => { this._state.next(\"closed\"); this._inbound.complete(); }\n        );\n\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n    }\n\n    private _handleIncoming(data: any): void {\n        // Detect channel connection events from server\n        if (data?.type === \"channel-connect\" || data?.type === \"peer-connect\" || data?.type === \"join\") {\n            const channel = data.channel ?? data.room ?? this._channelName;\n            const isNew = !this._connectedChannels.has(channel);\n\n            if (isNew) {\n                this._connectedChannels.add(channel);\n                this._emitIncomingConnection({\n                    id: data.id ?? UUIDv4(),\n                    channel,\n                    sender: data.sender ?? data.peerId ?? \"remote\",\n                    transportType: \"websocket\",\n                    data,\n                    timestamp: Date.now()\n                });\n            }\n        }\n\n        this._inbound.next(data);\n    }\n\n    /**\n     * Join/subscribe to a channel on the server\n     */\n    joinChannel(channel: string): void {\n        this.send({\n            id: UUIDv4(),\n            type: \"join\",\n            channel,\n            sender: this._channelName,\n            timestamp: Date.now()\n        } as ChannelMessage);\n    }\n\n    /**\n     * Leave/unsubscribe from a channel\n     */\n    leaveChannel(channel: string): void {\n        this._connectedChannels.delete(channel);\n        this.send({\n            id: UUIDv4(),\n            type: \"leave\",\n            channel,\n            sender: this._channelName,\n            timestamp: Date.now()\n        } as ChannelMessage);\n    }\n\n    /**\n     * Get connected channels\n     */\n    get connectedChannels(): string[] {\n        return [...this._connectedChannels];\n    }\n\n    detach(): void {\n        this._cleanup?.();\n        this._ws?.close();\n        this._ws = null;\n        this._connectedChannels.clear();\n        super.detach();\n    }\n\n    get ws(): WebSocket | null { return this._ws; }\n    get state(): Subscribable<string> { return this._state; }\n}\n\n// ============================================================================\n// CHROME RUNTIME TRANSPORT\n// ============================================================================\n\nexport class ChromeRuntimeTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, options: ConnectionOptions = {}) {\n        super(channelName, \"chrome-runtime\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n\n        const send = createTransportSender(\"chrome-runtime\");\n        this._cleanup = createTransportListener(\n            \"chrome-tabs\",\n            (data) => this._inbound.next(data),\n            undefined,\n            undefined,\n            { tabId: this._tabId }\n        );\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n}\n\n// ============================================================================\n// CHROME TABS TRANSPORT\n// ============================================================================\n\nexport class ChromeTabsTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, private _tabId?: number, options: ConnectionOptions = {}) {\n        super(channelName, \"chrome-tabs\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n        if (typeof chrome === \"undefined\" || !chrome.tabs) return;\n\n        const send: SendFn<ChannelMessage> = (msg) => {\n            if (this._tabId != null) {\n                const { transferable: _, ...data } = msg as any;\n                chrome.tabs.sendMessage(this._tabId, data);\n            }\n        };\n\n        this._cleanup = createTransportListener(\"chrome-runtime\", (data) => this._inbound.next(data));\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n    setTabId(tabId: number): void { this._tabId = tabId; }\n}\n\n// ============================================================================\n// CHROME PORT TRANSPORT\n// ============================================================================\n\nexport class ChromePortTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n    private _port: chrome.runtime.Port | null = null;\n\n    constructor(\n        channelName: string,\n        private _portName: string,\n        private _tabId?: number,\n        options: ConnectionOptions = {}\n    ) {\n        super(channelName, \"chrome-port\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n\n        this._port = this._tabId != null && chrome.tabs?.connect\n            ? chrome.tabs.connect(this._tabId, { name: this._portName })\n            : chrome.runtime.connect({ name: this._portName });\n\n        const send = (msg: ChannelMessage) => this._port?.postMessage(msg);\n        const onMessage = (msg: any) => this._inbound.next(msg);\n\n        this._port.onMessage.addListener(onMessage);\n        this._cleanup = () => {\n            try { this._port?.onMessage.removeListener(onMessage); } catch {}\n            try { this._port?.disconnect(); } catch {}\n            this._port = null;\n        };\n\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n}\n\n// ============================================================================\n// CHROME EXTERNAL TRANSPORT\n// ============================================================================\n\nexport class ChromeExternalTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, private _externalId: string, options: ConnectionOptions = {}) {\n        super(channelName, \"chrome-external\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n\n        const send = (msg: ChannelMessage) => chrome.runtime.sendMessage(this._externalId, msg);\n        const listener = (msg: any) => {\n            this._inbound.next(msg);\n            return false;\n        };\n\n        chrome.runtime.onMessageExternal?.addListener?.(listener);\n        this._cleanup = () => chrome.runtime.onMessageExternal?.removeListener?.(listener);\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n}\n\n// ============================================================================\n// SERVICE WORKER TRANSPORT\n// ============================================================================\n\nexport class ServiceWorkerTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, private _isHost = false, options: ConnectionOptions = {}) {\n        super(channelName, \"service-worker\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        const target = this._isHost ? \"service-worker-host\" : \"service-worker-client\";\n        const send = createTransportSender(target as TransportTarget);\n        this._cleanup = createTransportListener(target as TransportTarget, (data) => this._inbound.next(data));\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg, msg.transferable)));\n        this._isAttached = true;\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n}\n\n// ============================================================================\n// SELF TRANSPORT (inside worker)\n// ============================================================================\n\nexport class SelfTransport extends TransportAdapter {\n    private _cleanup: (() => void) | null = null;\n\n    constructor(channelName: string, options: ConnectionOptions = {}) {\n        super(channelName, \"self\", options);\n    }\n\n    attach(): void {\n        if (this._isAttached) return;\n\n        const send = createTransportSender(\"self\");\n        this._cleanup = createTransportListener(\"self\", (data) => this._handleIncoming(data));\n        this._subscriptions.push(this._outbound.subscribe((msg) => send(msg, msg.transferable)));\n        this._isAttached = true;\n    }\n\n    private _handleIncoming(data: any): void {\n        // Detect channel creation/connection requests\n        if (data?.type === \"createChannel\" || data?.type === \"connectChannel\") {\n            this._emitIncomingConnection({\n                id: data.reqId ?? UUIDv4(),\n                channel: data.channel,\n                sender: data.sender ?? \"unknown\",\n                transportType: \"self\",\n                port: data.messagePort ?? data.port,\n                data,\n                timestamp: Date.now()\n            });\n        }\n\n        this._inbound.next(data);\n    }\n\n    /**\n     * Notify sender that channel was created\n     */\n    notifyChannelCreated(channel: string, sender: string, reqId?: string): void {\n        postMessage({\n            type: \"channelCreated\",\n            channel,\n            sender,\n            reqId,\n            timestamp: Date.now()\n        });\n    }\n\n    detach(): void { this._cleanup?.(); super.detach(); }\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const TransportFactory = {\n    worker: (name: string, source: Worker | URL | string | (() => Worker), opts?: ConnectionOptions) =>\n        new WorkerTransport(name, source, opts),\n\n    messagePort: (name: string, port: MessagePort, opts?: ConnectionOptions) =>\n        new MessagePortTransport(name, port, opts),\n\n    broadcast: (name: string, bcName?: string, opts?: ConnectionOptions) =>\n        new BroadcastChannelTransport(name, bcName, opts),\n\n    websocket: (name: string, url: string | URL, protocols?: string | string[], opts?: ConnectionOptions) =>\n        new WebSocketTransport(name, url, protocols, opts),\n\n    chromeRuntime: (name: string, opts?: ConnectionOptions) =>\n        new ChromeRuntimeTransport(name, opts),\n\n    chromeTabs: (name: string, tabId?: number, opts?: ConnectionOptions) =>\n        new ChromeTabsTransport(name, tabId, opts),\n\n    chromePort: (name: string, portName: string, tabId?: number, opts?: ConnectionOptions) =>\n        new ChromePortTransport(name, portName, tabId, opts),\n\n    chromeExternal: (name: string, externalId: string, opts?: ConnectionOptions) =>\n        new ChromeExternalTransport(name, externalId, opts),\n\n    serviceWorker: (name: string, isHost?: boolean, opts?: ConnectionOptions) =>\n        new ServiceWorkerTransport(name, isHost, opts),\n\n    self: (name: string, opts?: ConnectionOptions) =>\n        new SelfTransport(name, opts)\n};\n\n// ============================================================================\n// CONNECTION OBSERVER UTILITIES\n// ============================================================================\n\n/**\n * Create a connection observer that aggregates incoming connections\n * from multiple transports\n */\nexport function createConnectionObserver(\n    transports: TransportAdapter[]\n): {\n    subscribe: (handler: (conn: TransportIncomingConnection) => void) => Subscription;\n    getConnections: () => TransportIncomingConnection[];\n} {\n    const connections: TransportIncomingConnection[] = [];\n    const subject = new ChannelSubject<TransportIncomingConnection>({ bufferSize: 100 });\n\n    for (const transport of transports) {\n        transport.subscribeIncoming((conn) => {\n            connections.push(conn);\n            subject.next(conn);\n        });\n    }\n\n    return {\n        subscribe: (handler) => subject.subscribe(handler),\n        getConnections: () => [...connections]\n    };\n}\n\n// Re-export types\nexport type { TransportType, ConnectionOptions, TransportTarget, TransportIncomingConnection, AcceptConnectionCallback };\n","/**\n * IndexedDB Integration for Channel System\n *\n * Provides persistent storage capabilities for channel communication:\n * - Defer: Queue messages for later delivery\n * - Pending: Track pending operations\n * - Mailbox/Inbox: Store messages per channel\n * - Transactions: Batch operations with rollback\n * - Exchange: Coordinate data between contexts\n */\n\nimport { UUIDv4, Promised } from \"fest/core\";\nimport { type ChannelMessage, ChannelSubject, type Subscription } from \"../observable/Observable\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Message status in storage */\nexport type MessageStatus = \"pending\" | \"processing\" | \"delivered\" | \"failed\" | \"expired\";\n\n/** Stored message envelope */\nexport interface StoredMessage<T = any> {\n    id: string;\n    channel: string;\n    sender: string;\n    recipient: string;\n    type: ChannelMessage[\"type\"];\n    payload: T;\n    status: MessageStatus;\n    priority: number;\n    createdAt: number;\n    updatedAt: number;\n    expiresAt: number | null;\n    retryCount: number;\n    maxRetries: number;\n    metadata?: Record<string, any>;\n}\n\n/** Transaction operation */\nexport interface TransactionOp<T = any> {\n    id: string;\n    type: \"put\" | \"delete\" | \"update\";\n    store: string;\n    key?: IDBValidKey;\n    value?: T;\n    timestamp: number;\n}\n\n/** Exchange record */\nexport interface ExchangeRecord<T = any> {\n    id: string;\n    key: string;\n    value: T;\n    owner: string;\n    sharedWith: string[];\n    version: number;\n    createdAt: number;\n    updatedAt: number;\n    lock?: { holder: string; acquiredAt: number; expiresAt: number };\n}\n\n/** Mailbox statistics */\nexport interface MailboxStats {\n    total: number;\n    pending: number;\n    processing: number;\n    delivered: number;\n    failed: number;\n    expired: number;\n}\n\n// ============================================================================\n// INDEXED DB MANAGER\n// ============================================================================\n\nconst DB_NAME = \"uniform_channels\";\nconst DB_VERSION = 1;\n\nconst STORES = {\n    MESSAGES: \"messages\",\n    MAILBOX: \"mailbox\",\n    PENDING: \"pending\",\n    EXCHANGE: \"exchange\",\n    TRANSACTIONS: \"transactions\"\n} as const;\n\n/**\n * IndexedDB manager for channel storage\n */\nexport class ChannelStorage {\n    private _db: IDBDatabase | null = null;\n    private _isOpen = false;\n    private _openPromise: Promise<IDBDatabase> | null = null;\n    private _channelName: string;\n\n    // Observables for real-time updates\n    private _messageUpdates = new ChannelSubject<StoredMessage>();\n    private _exchangeUpdates = new ChannelSubject<ExchangeRecord>();\n\n    constructor(channelName: string) {\n        this._channelName = channelName;\n    }\n\n    // ========================================================================\n    // DATABASE LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Open database connection\n     */\n    async open(): Promise<IDBDatabase> {\n        if (this._db && this._isOpen) return this._db;\n        if (this._openPromise) return this._openPromise;\n\n        this._openPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onerror = () => {\n                this._openPromise = null;\n                reject(new Error(\"Failed to open IndexedDB\"));\n            };\n\n            request.onsuccess = () => {\n                this._db = request.result;\n                this._isOpen = true;\n                this._openPromise = null;\n                resolve(this._db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                this._createStores(db);\n            };\n        });\n\n        return this._openPromise;\n    }\n\n    /**\n     * Close database connection\n     */\n    close(): void {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n            this._isOpen = false;\n        }\n    }\n\n    private _createStores(db: IDBDatabase): void {\n        // Messages store\n        if (!db.objectStoreNames.contains(STORES.MESSAGES)) {\n            const messagesStore = db.createObjectStore(STORES.MESSAGES, { keyPath: \"id\" });\n            messagesStore.createIndex(\"channel\", \"channel\", { unique: false });\n            messagesStore.createIndex(\"status\", \"status\", { unique: false });\n            messagesStore.createIndex(\"recipient\", \"recipient\", { unique: false });\n            messagesStore.createIndex(\"createdAt\", \"createdAt\", { unique: false });\n            messagesStore.createIndex(\"channel_status\", [\"channel\", \"status\"], { unique: false });\n        }\n\n        // Mailbox store (per-channel inbox)\n        if (!db.objectStoreNames.contains(STORES.MAILBOX)) {\n            const mailboxStore = db.createObjectStore(STORES.MAILBOX, { keyPath: \"id\" });\n            mailboxStore.createIndex(\"channel\", \"channel\", { unique: false });\n            mailboxStore.createIndex(\"priority\", \"priority\", { unique: false });\n            mailboxStore.createIndex(\"expiresAt\", \"expiresAt\", { unique: false });\n        }\n\n        // Pending operations store\n        if (!db.objectStoreNames.contains(STORES.PENDING)) {\n            const pendingStore = db.createObjectStore(STORES.PENDING, { keyPath: \"id\" });\n            pendingStore.createIndex(\"channel\", \"channel\", { unique: false });\n            pendingStore.createIndex(\"createdAt\", \"createdAt\", { unique: false });\n        }\n\n        // Exchange store (shared data)\n        if (!db.objectStoreNames.contains(STORES.EXCHANGE)) {\n            const exchangeStore = db.createObjectStore(STORES.EXCHANGE, { keyPath: \"id\" });\n            exchangeStore.createIndex(\"key\", \"key\", { unique: true });\n            exchangeStore.createIndex(\"owner\", \"owner\", { unique: false });\n        }\n\n        // Transactions store (for rollback support)\n        if (!db.objectStoreNames.contains(STORES.TRANSACTIONS)) {\n            const txStore = db.createObjectStore(STORES.TRANSACTIONS, { keyPath: \"id\" });\n            txStore.createIndex(\"createdAt\", \"createdAt\", { unique: false });\n        }\n    }\n\n    // ========================================================================\n    // DEFER: Queue messages for later delivery\n    // ========================================================================\n\n    /**\n     * Defer a message for later delivery\n     */\n    async defer(\n        message: Omit<ChannelMessage, \"id\" | \"timestamp\">,\n        options: {\n            priority?: number;\n            expiresIn?: number;\n            maxRetries?: number;\n            metadata?: Record<string, any>;\n        } = {}\n    ): Promise<string> {\n        const db = await this.open();\n\n        const storedMessage: StoredMessage = {\n            id: UUIDv4(),\n            channel: message.channel,\n            sender: message.sender ?? this._channelName,\n            recipient: message.channel,\n            type: message.type,\n            payload: message.payload,\n            status: \"pending\",\n            priority: options.priority ?? 0,\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            expiresAt: options.expiresIn ? Date.now() + options.expiresIn : null,\n            retryCount: 0,\n            maxRetries: options.maxRetries ?? 3,\n            metadata: options.metadata\n        };\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([STORES.MESSAGES, STORES.MAILBOX], \"readwrite\");\n            const messagesStore = tx.objectStore(STORES.MESSAGES);\n            const mailboxStore = tx.objectStore(STORES.MAILBOX);\n\n            messagesStore.add(storedMessage);\n            mailboxStore.add(storedMessage);\n\n            tx.oncomplete = () => {\n                this._messageUpdates.next(storedMessage);\n                resolve(storedMessage.id);\n            };\n\n            tx.onerror = () => reject(new Error(\"Failed to defer message\"));\n        });\n    }\n\n    /**\n     * Get deferred messages for a channel\n     */\n    async getDeferredMessages(\n        channel: string,\n        options: { status?: MessageStatus; limit?: number; offset?: number } = {}\n    ): Promise<StoredMessage[]> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MESSAGES, \"readonly\");\n            const store = tx.objectStore(STORES.MESSAGES);\n\n            const index = options.status\n                ? store.index(\"channel_status\")\n                : store.index(\"channel\");\n\n            const query = options.status\n                ? IDBKeyRange.only([channel, options.status])\n                : IDBKeyRange.only(channel);\n\n            const request = index.getAll(query, options.limit);\n\n            request.onsuccess = () => {\n                let results = request.result;\n                if (options.offset) {\n                    results = results.slice(options.offset);\n                }\n                resolve(results);\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to get deferred messages\"));\n        });\n    }\n\n    /**\n     * Process next pending message\n     */\n    async processNextPending(channel: string): Promise<StoredMessage | null> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MESSAGES, \"readwrite\");\n            const store = tx.objectStore(STORES.MESSAGES);\n            const index = store.index(\"channel_status\");\n\n            const request = index.openCursor(IDBKeyRange.only([channel, \"pending\"]));\n\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    const message = cursor.value as StoredMessage;\n                    message.status = \"processing\";\n                    message.updatedAt = Date.now();\n                    cursor.update(message);\n                    this._messageUpdates.next(message);\n                    resolve(message);\n                } else {\n                    resolve(null);\n                }\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to process pending message\"));\n        });\n    }\n\n    /**\n     * Mark message as delivered\n     */\n    async markDelivered(messageId: string): Promise<void> {\n        await this._updateMessageStatus(messageId, \"delivered\");\n    }\n\n    /**\n     * Mark message as failed and retry if possible\n     */\n    async markFailed(messageId: string): Promise<boolean> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MESSAGES, \"readwrite\");\n            const store = tx.objectStore(STORES.MESSAGES);\n            const request = store.get(messageId);\n\n            request.onsuccess = () => {\n                const message = request.result as StoredMessage;\n                if (!message) {\n                    resolve(false);\n                    return;\n                }\n\n                message.retryCount++;\n                message.updatedAt = Date.now();\n\n                if (message.retryCount < message.maxRetries) {\n                    message.status = \"pending\"; // Retry\n                } else {\n                    message.status = \"failed\";\n                }\n\n                store.put(message);\n                this._messageUpdates.next(message);\n                resolve(message.status === \"pending\");\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to mark message as failed\"));\n        });\n    }\n\n    private async _updateMessageStatus(messageId: string, status: MessageStatus): Promise<void> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MESSAGES, \"readwrite\");\n            const store = tx.objectStore(STORES.MESSAGES);\n            const request = store.get(messageId);\n\n            request.onsuccess = () => {\n                const message = request.result as StoredMessage;\n                if (message) {\n                    message.status = status;\n                    message.updatedAt = Date.now();\n                    store.put(message);\n                    this._messageUpdates.next(message);\n                }\n                resolve();\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to update message status\"));\n        });\n    }\n\n    // ========================================================================\n    // MAILBOX / INBOX: Per-channel message storage\n    // ========================================================================\n\n    /**\n     * Get mailbox for a channel\n     */\n    async getMailbox(\n        channel: string,\n        options: { limit?: number; sortBy?: \"priority\" | \"createdAt\" } = {}\n    ): Promise<StoredMessage[]> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MAILBOX, \"readonly\");\n            const store = tx.objectStore(STORES.MAILBOX);\n            const index = store.index(\"channel\");\n\n            const request = index.getAll(IDBKeyRange.only(channel), options.limit);\n\n            request.onsuccess = () => {\n                let results = request.result as StoredMessage[];\n\n                // Sort\n                if (options.sortBy === \"priority\") {\n                    results.sort((a, b) => b.priority - a.priority);\n                } else {\n                    results.sort((a, b) => b.createdAt - a.createdAt);\n                }\n\n                resolve(results);\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to get mailbox\"));\n        });\n    }\n\n    /**\n     * Get mailbox statistics\n     */\n    async getMailboxStats(channel: string): Promise<MailboxStats> {\n        const messages = await this.getDeferredMessages(channel);\n\n        const stats: MailboxStats = {\n            total: messages.length,\n            pending: 0,\n            processing: 0,\n            delivered: 0,\n            failed: 0,\n            expired: 0\n        };\n\n        const now = Date.now();\n        for (const msg of messages) {\n            if (msg.expiresAt && msg.expiresAt < now) {\n                stats.expired++;\n            } else {\n                stats[msg.status as keyof Omit<MailboxStats, \"total\" | \"expired\">]++;\n            }\n        }\n\n        return stats;\n    }\n\n    /**\n     * Clear mailbox for a channel\n     */\n    async clearMailbox(channel: string): Promise<number> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.MAILBOX, \"readwrite\");\n            const store = tx.objectStore(STORES.MAILBOX);\n            const index = store.index(\"channel\");\n\n            let deletedCount = 0;\n            const request = index.openCursor(IDBKeyRange.only(channel));\n\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    cursor.delete();\n                    deletedCount++;\n                    cursor.continue();\n                }\n            };\n\n            tx.oncomplete = () => resolve(deletedCount);\n            tx.onerror = () => reject(new Error(\"Failed to clear mailbox\"));\n        });\n    }\n\n    // ========================================================================\n    // PENDING: Track pending operations\n    // ========================================================================\n\n    /**\n     * Register a pending operation\n     */\n    async registerPending<T = any>(\n        operation: { type: string; data: T; metadata?: Record<string, any> }\n    ): Promise<string> {\n        const db = await this.open();\n\n        const pending = {\n            id: UUIDv4(),\n            channel: this._channelName,\n            type: operation.type,\n            data: operation.data,\n            metadata: operation.metadata,\n            createdAt: Date.now(),\n            status: \"pending\"\n        };\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.PENDING, \"readwrite\");\n            const store = tx.objectStore(STORES.PENDING);\n            store.add(pending);\n\n            tx.oncomplete = () => resolve(pending.id);\n            tx.onerror = () => reject(new Error(\"Failed to register pending operation\"));\n        });\n    }\n\n    /**\n     * Get all pending operations for channel\n     */\n    async getPendingOperations(): Promise<any[]> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.PENDING, \"readonly\");\n            const store = tx.objectStore(STORES.PENDING);\n            const index = store.index(\"channel\");\n\n            const request = index.getAll(IDBKeyRange.only(this._channelName));\n\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(new Error(\"Failed to get pending operations\"));\n        });\n    }\n\n    /**\n     * Complete a pending operation\n     */\n    async completePending(operationId: string): Promise<void> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.PENDING, \"readwrite\");\n            const store = tx.objectStore(STORES.PENDING);\n            store.delete(operationId);\n\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(new Error(\"Failed to complete pending operation\"));\n        });\n    }\n\n    /**\n     * Await a pending operation (poll until complete or timeout)\n     */\n    async awaitPending<T = any>(\n        operationId: string,\n        options: { timeout?: number; pollInterval?: number } = {}\n    ): Promise<T | null> {\n        const timeout = options.timeout ?? 30000;\n        const pollInterval = options.pollInterval ?? 100;\n        const startTime = Date.now();\n\n        while (Date.now() - startTime < timeout) {\n            const pending = await this._getPendingById(operationId);\n\n            if (!pending) {\n                // Operation completed (deleted)\n                return null;\n            }\n\n            if (pending.status === \"completed\") {\n                await this.completePending(operationId);\n                return pending.result as T;\n            }\n\n            await new Promise((r) => setTimeout(r, pollInterval));\n        }\n\n        throw new Error(`Pending operation ${operationId} timed out`);\n    }\n\n    private async _getPendingById(id: string): Promise<any | null> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.PENDING, \"readonly\");\n            const store = tx.objectStore(STORES.PENDING);\n            const request = store.get(id);\n\n            request.onsuccess = () => resolve(request.result ?? null);\n            request.onerror = () => reject(new Error(\"Failed to get pending operation\"));\n        });\n    }\n\n    // ========================================================================\n    // EXCHANGE: Shared data between contexts\n    // ========================================================================\n\n    /**\n     * Put data in exchange (shared storage)\n     */\n    async exchangePut<T = any>(\n        key: string,\n        value: T,\n        options: { sharedWith?: string[]; ttl?: number } = {}\n    ): Promise<string> {\n        const db = await this.open();\n\n        const record: ExchangeRecord<T> = {\n            id: UUIDv4(),\n            key,\n            value,\n            owner: this._channelName,\n            sharedWith: options.sharedWith ?? [\"*\"],\n            version: 1,\n            createdAt: Date.now(),\n            updatedAt: Date.now()\n        };\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.EXCHANGE, \"readwrite\");\n            const store = tx.objectStore(STORES.EXCHANGE);\n            const index = store.index(\"key\");\n\n            // Check if key exists\n            const getRequest = index.get(key);\n\n            getRequest.onsuccess = () => {\n                const existing = getRequest.result as ExchangeRecord<T> | undefined;\n\n                if (existing) {\n                    // Update existing\n                    record.id = existing.id;\n                    record.version = existing.version + 1;\n                    record.createdAt = existing.createdAt;\n                }\n\n                store.put(record);\n            };\n\n            tx.oncomplete = () => {\n                this._exchangeUpdates.next(record);\n                resolve(record.id);\n            };\n\n            tx.onerror = () => reject(new Error(\"Failed to put exchange data\"));\n        });\n    }\n\n    /**\n     * Get data from exchange\n     */\n    async exchangeGet<T = any>(key: string): Promise<T | null> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.EXCHANGE, \"readonly\");\n            const store = tx.objectStore(STORES.EXCHANGE);\n            const index = store.index(\"key\");\n\n            const request = index.get(key);\n\n            request.onsuccess = () => {\n                const record = request.result as ExchangeRecord<T> | undefined;\n\n                if (!record) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check access\n                if (!this._canAccessExchange(record)) {\n                    resolve(null);\n                    return;\n                }\n\n                resolve(record.value);\n            };\n\n            request.onerror = () => reject(new Error(\"Failed to get exchange data\"));\n        });\n    }\n\n    /**\n     * Delete data from exchange\n     */\n    async exchangeDelete(key: string): Promise<boolean> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.EXCHANGE, \"readwrite\");\n            const store = tx.objectStore(STORES.EXCHANGE);\n            const index = store.index(\"key\");\n\n            const getRequest = index.get(key);\n\n            getRequest.onsuccess = () => {\n                const record = getRequest.result as ExchangeRecord | undefined;\n\n                if (!record) {\n                    resolve(false);\n                    return;\n                }\n\n                // Only owner can delete\n                if (record.owner !== this._channelName) {\n                    resolve(false);\n                    return;\n                }\n\n                store.delete(record.id);\n            };\n\n            tx.oncomplete = () => resolve(true);\n            tx.onerror = () => reject(new Error(\"Failed to delete exchange data\"));\n        });\n    }\n\n    /**\n     * Acquire lock on exchange key\n     */\n    async exchangeLock(\n        key: string,\n        options: { timeout?: number } = {}\n    ): Promise<boolean> {\n        const db = await this.open();\n        const timeout = options.timeout ?? 30000;\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.EXCHANGE, \"readwrite\");\n            const store = tx.objectStore(STORES.EXCHANGE);\n            const index = store.index(\"key\");\n\n            const request = index.get(key);\n\n            request.onsuccess = () => {\n                const record = request.result as ExchangeRecord | undefined;\n\n                if (!record) {\n                    resolve(false);\n                    return;\n                }\n\n                // Check if locked by someone else\n                if (record.lock && record.lock.holder !== this._channelName) {\n                    if (record.lock.expiresAt > Date.now()) {\n                        resolve(false); // Still locked\n                        return;\n                    }\n                }\n\n                // Acquire lock\n                record.lock = {\n                    holder: this._channelName,\n                    acquiredAt: Date.now(),\n                    expiresAt: Date.now() + timeout\n                };\n                record.updatedAt = Date.now();\n\n                store.put(record);\n            };\n\n            tx.oncomplete = () => resolve(true);\n            tx.onerror = () => reject(new Error(\"Failed to acquire lock\"));\n        });\n    }\n\n    /**\n     * Release lock on exchange key\n     */\n    async exchangeUnlock(key: string): Promise<void> {\n        const db = await this.open();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(STORES.EXCHANGE, \"readwrite\");\n            const store = tx.objectStore(STORES.EXCHANGE);\n            const index = store.index(\"key\");\n\n            const request = index.get(key);\n\n            request.onsuccess = () => {\n                const record = request.result as ExchangeRecord | undefined;\n\n                if (record && record.lock?.holder === this._channelName) {\n                    delete record.lock;\n                    record.updatedAt = Date.now();\n                    store.put(record);\n                }\n            };\n\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(new Error(\"Failed to release lock\"));\n        });\n    }\n\n    private _canAccessExchange(record: ExchangeRecord): boolean {\n        if (record.owner === this._channelName) return true;\n        if (record.sharedWith.includes(\"*\")) return true;\n        return record.sharedWith.includes(this._channelName);\n    }\n\n    // ========================================================================\n    // TRANSACTIONS: Batch operations with rollback\n    // ========================================================================\n\n    /**\n     * Begin a transaction for batch operations\n     */\n    async beginTransaction(): Promise<ChannelTransaction> {\n        return new ChannelTransaction(this);\n    }\n\n    /**\n     * Execute operations in transaction\n     */\n    async executeTransaction(\n        operations: TransactionOp[]\n    ): Promise<void> {\n        const db = await this.open();\n\n        // Collect affected stores\n        const storeNames = new Set(operations.map((op) => op.store));\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction(Array.from(storeNames), \"readwrite\");\n\n            for (const op of operations) {\n                const store = tx.objectStore(op.store);\n\n                switch (op.type) {\n                    case \"put\":\n                        if (op.value !== undefined) {\n                            store.put(op.value);\n                        }\n                        break;\n                    case \"delete\":\n                        if (op.key !== undefined) {\n                            store.delete(op.key);\n                        }\n                        break;\n                    case \"update\":\n                        // Get and update\n                        if (op.key !== undefined) {\n                            const getReq = store.get(op.key);\n                            getReq.onsuccess = () => {\n                                if (getReq.result && op.value) {\n                                    store.put({ ...getReq.result, ...op.value });\n                                }\n                            };\n                        }\n                        break;\n                }\n            }\n\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(new Error(\"Transaction failed\"));\n        });\n    }\n\n    // ========================================================================\n    // SUBSCRIPTIONS\n    // ========================================================================\n\n    /**\n     * Subscribe to message updates\n     */\n    onMessageUpdate(handler: (msg: StoredMessage) => void): Subscription {\n        return this._messageUpdates.subscribe({ next: handler });\n    }\n\n    /**\n     * Subscribe to exchange updates\n     */\n    onExchangeUpdate(handler: (record: ExchangeRecord) => void): Subscription {\n        return this._exchangeUpdates.subscribe({ next: handler });\n    }\n\n    // ========================================================================\n    // CLEANUP\n    // ========================================================================\n\n    /**\n     * Clean up expired messages\n     */\n    async cleanupExpired(): Promise<number> {\n        const db = await this.open();\n        const now = Date.now();\n\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction([STORES.MESSAGES, STORES.MAILBOX], \"readwrite\");\n            const messagesStore = tx.objectStore(STORES.MESSAGES);\n            const mailboxStore = tx.objectStore(STORES.MAILBOX);\n\n            let deletedCount = 0;\n\n            // Clean messages\n            const msgRequest = messagesStore.openCursor();\n            msgRequest.onsuccess = () => {\n                const cursor = msgRequest.result;\n                if (cursor) {\n                    const msg = cursor.value as StoredMessage;\n                    if (msg.expiresAt && msg.expiresAt < now) {\n                        cursor.delete();\n                        deletedCount++;\n                    }\n                    cursor.continue();\n                }\n            };\n\n            // Clean mailbox\n            const mailRequest = mailboxStore.openCursor();\n            mailRequest.onsuccess = () => {\n                const cursor = mailRequest.result;\n                if (cursor) {\n                    const msg = cursor.value as StoredMessage;\n                    if (msg.expiresAt && msg.expiresAt < now) {\n                        cursor.delete();\n                        deletedCount++;\n                    }\n                    cursor.continue();\n                }\n            };\n\n            tx.oncomplete = () => resolve(deletedCount);\n            tx.onerror = () => reject(new Error(\"Failed to cleanup expired\"));\n        });\n    }\n}\n\n// ============================================================================\n// TRANSACTION HELPER\n// ============================================================================\n\n/**\n * Helper class for batch operations with rollback support\n */\nexport class ChannelTransaction {\n    private _operations: TransactionOp[] = [];\n    private _isCommitted = false;\n    private _isRolledBack = false;\n\n    constructor(private _storage: ChannelStorage) {}\n\n    /**\n     * Add put operation\n     */\n    put<T>(store: string, value: T): this {\n        this._checkState();\n        this._operations.push({\n            id: UUIDv4(),\n            type: \"put\",\n            store,\n            value,\n            timestamp: Date.now()\n        });\n        return this;\n    }\n\n    /**\n     * Add delete operation\n     */\n    delete(store: string, key: IDBValidKey): this {\n        this._checkState();\n        this._operations.push({\n            id: UUIDv4(),\n            type: \"delete\",\n            store,\n            key,\n            timestamp: Date.now()\n        });\n        return this;\n    }\n\n    /**\n     * Add update operation\n     */\n    update<T>(store: string, key: IDBValidKey, updates: Partial<T>): this {\n        this._checkState();\n        this._operations.push({\n            id: UUIDv4(),\n            type: \"update\",\n            store,\n            key,\n            value: updates,\n            timestamp: Date.now()\n        });\n        return this;\n    }\n\n    /**\n     * Commit transaction\n     */\n    async commit(): Promise<void> {\n        this._checkState();\n\n        if (this._operations.length === 0) {\n            this._isCommitted = true;\n            return;\n        }\n\n        await this._storage.executeTransaction(this._operations);\n        this._isCommitted = true;\n    }\n\n    /**\n     * Rollback transaction (just clear operations, don't execute)\n     */\n    rollback(): void {\n        this._operations = [];\n        this._isRolledBack = true;\n    }\n\n    /**\n     * Get operation count\n     */\n    get operationCount(): number {\n        return this._operations.length;\n    }\n\n    private _checkState(): void {\n        if (this._isCommitted) {\n            throw new Error(\"Transaction already committed\");\n        }\n        if (this._isRolledBack) {\n            throw new Error(\"Transaction already rolled back\");\n        }\n    }\n}\n\n// ============================================================================\n// SINGLETON STORAGE INSTANCES\n// ============================================================================\n\nconst _storageInstances = new Map<string, ChannelStorage>();\n\n/**\n * Get storage instance for channel\n */\nexport function getChannelStorage(channelName: string): ChannelStorage {\n    if (!_storageInstances.has(channelName)) {\n        _storageInstances.set(channelName, new ChannelStorage(channelName));\n    }\n    return _storageInstances.get(channelName)!;\n}\n\n/**\n * Close all storage instances\n */\nexport function closeAllStorage(): void {\n    for (const storage of _storageInstances.values()) {\n        storage.close();\n    }\n    _storageInstances.clear();\n}\n","/**\n * Channel Context - Multi-Channel Support\n *\n * Provides a way to create multiple independent channel endpoints/ports\n * in the same context. Suitable for:\n * - Lazy-loaded components\n * - Multiple DOM components with isolated communication\n * - Micro-frontend architectures\n * - Component-level channel isolation\n *\n * vNext architecture note:\n * - ChannelContext composes UnifiedChannel instances per endpoint.\n * - UnifiedChannel is the canonical transport/invocation runtime engine.\n */\n\nimport { UUIDv4, Promised } from \"fest/core\";\nimport {\n    ChannelConnection,\n    type ConnectionOptions,\n    type TransportType,\n    getConnectionPool,\n    getConnection\n} from \"./Connection\";\nimport {\n    type ChannelMessage,\n    type Subscription,\n    ChannelSubject,\n    filter\n} from \"../observable/Observable\";\nimport {\n    TransportAdapter,\n    WorkerTransport,\n    MessagePortTransport,\n    BroadcastChannelTransport,\n    SelfTransport,\n    TransportFactory\n} from \"../transport/Transport\";\nimport { getChannelStorage, type ChannelStorage } from \"../storage/Storage\";\nimport { WReflectAction, type WReflectDescriptor, type WReq, type WResp } from \"../types/Interface\";\nimport { makeRequestProxy } from \"../proxy/RequestProxy\";\nimport { readByPath, registeredInPath } from \"../storage/DataBase\";\nimport { handleRequest as coreHandleRequest } from \"../../core/RequestHandler\";\nimport { UnifiedChannel, type TransportBinding } from \"./UnifiedChannel\";\nimport {\n    ConnectionRegistry,\n    type ConnectionDirection,\n    type ConnectionStatus,\n    type ConnectionInfo,\n    type ConnectionEvent as BaseConnectionEvent,\n    type QueryConnectionsOptions as BaseQueryConnectionsOptions\n} from \"./internal/ConnectionModel\";\n\n// Worker code - use direct URL (works in both Vite and non-Vite)\nconst workerCode: string | URL = new URL(\"../transport/Worker.ts\", import.meta.url);\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Supported transport types for dynamic channel creation */\nexport type DynamicTransportType =\n    | \"worker\"\n    | \"shared-worker\"\n    | \"service-worker\"\n    | \"message-port\"\n    | \"broadcast\"\n    | \"chrome-runtime\"\n    | \"chrome-tabs\"\n    | \"chrome-port\"\n    | \"chrome-external\"\n    | \"websocket\"\n    | \"rtc\"\n    | \"self\";\n\n/** Configuration for dynamic transport creation */\nexport interface DynamicTransportConfig {\n    /** Transport type */\n    type: DynamicTransportType;\n    /** Worker URL or instance */\n    worker?: Worker | SharedWorker | URL | string;\n    /** MessagePort instance */\n    port?: MessagePort;\n    /** BroadcastChannel name or instance */\n    broadcast?: BroadcastChannel | string;\n    /** WebSocket URL or instance */\n    socket?: WebSocket | string;\n    /** Additional options */\n    options?: ConnectionOptions;\n}\n\nexport interface ChannelContextOptions {\n    /** Context name for identification */\n    name?: string;\n    /** Auto-connect channels on creation */\n    autoConnect?: boolean;\n    /** Default connection options for channels */\n    defaultOptions?: ConnectionOptions;\n    /** Enable isolated storage per context */\n    isolatedStorage?: boolean;\n    /** Use globalThis/self as default broadcast target */\n    useGlobalSelf?: boolean;\n}\n\nexport interface ChannelEndpoint {\n    /** Channel name */\n    name: string;\n    /** Channel handler instance */\n    handler: ChannelHandler;\n    /** Channel connection */\n    connection: ChannelConnection;\n    /** Subscriptions for cleanup */\n    subscriptions: Subscription[];\n    /** Associated transport if any */\n    transport?: TransportAdapter;\n    /** Transport type */\n    transportType?: DynamicTransportType;\n    /** Ready promise */\n    ready: Promise<RemoteChannelHelper | null>;\n    /** Deferred initialization function */\n    deferredInit?: () => Promise<RemoteChannelHelper | null>;\n    /** Backing unified channel engine (vNext core) */\n    unified?: UnifiedChannel;\n}\n\nexport interface RemoteChannelInfo {\n    channel: string;\n    context: ChannelContext;\n    messageChannel?: MessageChannel;\n    remote: Promise<RemoteChannelHelper>;\n    transport?: Worker | BroadcastChannel | MessagePort | WebSocket;\n    transportType?: DynamicTransportType;\n}\n\nexport type ContextConnectionDirection = ConnectionDirection;\nexport type ContextConnectionStatus = ConnectionStatus;\nexport type ContextConnectionInfo = ConnectionInfo<DynamicTransportType | TransportType | \"internal\"> & { contextId: string };\n\nexport interface ConnectionEvent extends Omit<BaseConnectionEvent<DynamicTransportType | TransportType | \"internal\">, \"connection\"> {\n    type: \"connected\" | \"notified\" | \"disconnected\";\n    connection: ContextConnectionInfo;\n    timestamp: number;\n    payload?: any;\n}\n\nexport type QueryConnectionsOptions = BaseQueryConnectionsOptions<DynamicTransportType | TransportType | \"internal\">;\n\nexport type NativeChannelTransport = Worker | BroadcastChannel | MessagePort | WebSocket;\n\n\n// ============================================================================\n// REMOTE CHANNEL HELPER\n// ============================================================================\n\nexport class RemoteChannelHelper {\n    private _connection: ChannelConnection;\n    private _storage: ChannelStorage;\n\n    constructor(\n        private _channel: string,\n        private _context: ChannelContext,\n        private _options: ConnectionOptions = {}\n    ) {\n        this._connection = getConnection(_channel);\n        this._storage = getChannelStorage(_channel);\n    }\n\n    async request(\n        path: string[] | WReflectDescriptor,\n        action: WReflectAction | any[],\n        args: any[] | any,\n        options: any = {}\n    ): Promise<any> {\n        let normalizedPath = typeof path === \"string\" ? [path] : path;\n        let normalizedAction = action;\n        let normalizedArgs = args;\n\n        if (Array.isArray(action) && isReflectAction(path)) {\n            options = args;\n            normalizedArgs = action;\n            normalizedAction = path as unknown as WReflectAction;\n            normalizedPath = [];\n        }\n\n        const handler = this._context.getHost();\n        return handler?.request(\n            normalizedPath as string[],\n            normalizedAction as WReflectAction,\n            normalizedArgs,\n            options,\n            this._channel\n        );\n    }\n\n    async doImportModule(url: string, options: any = {}): Promise<any> {\n        return this.request([], WReflectAction.IMPORT, [url], options);\n    }\n\n    async deferMessage(payload: any, options: { priority?: number; expiresIn?: number } = {}): Promise<string> {\n        return this._storage.defer({\n            channel: this._channel,\n            sender: this._context.hostName,\n            type: \"request\",\n            payload\n        }, options);\n    }\n\n    async getPendingMessages(): Promise<any[]> {\n        return this._storage.getDeferredMessages(this._channel, { status: \"pending\" });\n    }\n\n    get connection(): ChannelConnection { return this._connection; }\n    get channelName(): string { return this._channel; }\n    get context(): ChannelContext { return this._context; }\n}\n\n// ============================================================================\n// CHANNEL HANDLER (Per-endpoint)\n// ============================================================================\n\nexport class ChannelHandler {\n    // @ts-ignore\n    //private _forResolves = new Map<string, PromiseWithResolvers<any>>();\n    //private _broadcasts: Record<string, TransportBinding<NativeChannelTransport>> = {};\n    //private _subscriptions: Subscription[] = [];\n    private _connection: ChannelConnection;\n    private _unified: UnifiedChannel;\n\n    private get _forResolves(): Map<string, PromiseWithResolvers<any>> {\n        return this._unified.__getPrivate(\"_pending\");\n    }\n\n    private get _subscriptions(): Subscription[] {\n        return this._unified.__getPrivate(\"_subscriptions\");\n    }\n\n    private get _broadcasts(): Map<string, TransportBinding> {\n        return this._unified.__getPrivate(\"_transports\");\n    }\n    \n\n    constructor(\n        private _channel: string,\n        private _context: ChannelContext,\n        private _options: ConnectionOptions = {}\n    ) {\n        this._connection = getConnectionPool().getOrCreate(_channel, \"internal\", _options);\n        this._unified = new UnifiedChannel({\n            name: _channel,\n            autoListen: false,\n            timeout: _options?.timeout\n        });\n    }\n\n    createRemoteChannel(\n        channel: string,\n        options: ConnectionOptions = {},\n        broadcast?: TransportBinding<NativeChannelTransport> | NativeChannelTransport | null\n    ): RemoteChannelHelper {\n        const transport = normalizeTransportBinding((broadcast as any) ?? (this._context.$createOrUseExistingRemote(channel, options, broadcast ?? null))?.messageChannel?.port1);\n        const transportType = getDynamicTransportType(transport?.target ?? transport);\n\n        //\n        this._unified.listen(transport?.target, { targetChannel: channel });\n\n        /*\n        transport?.addEventListener?.('message', ((event: MessageEvent) => {\n            if (event.data.type === \"request\" && event.data.channel === this._channel) {\n                this.handleAndResponse(event.data.payload, event.data.reqId);\n            } else if (event.data.type === \"response\") {\n                this.resolveResponse(event.data.reqId, {\n                    result: event.data.payload.result,\n                    descriptor: event.data.payload.descriptor,\n                    type: event.data.payload.type\n                });\n            } else if (event.data.type === \"signal\") {\n                this._context.$observeSignal({\n                    localChannel: this._channel,\n                    remoteChannel: event.data.payload?.from ?? event.data.sender ?? channel,\n                    sender: event.data.sender ?? event.data.payload?.from ?? \"unknown\",\n                    transportType: event.data.transportType ?? transportType,\n                    payload: event.data.payload\n                });\n            }\n        }) as EventListener);\n        \n        transport?.addEventListener?.('error', (event) => {\n            console.error(event);\n            transport?.close?.();\n        });*/\n\n        if (transport) {\n            this._broadcasts?.set?.(channel, transport);\n            const canAttachUnified = !(transportType === \"self\" && typeof postMessage === \"undefined\");\n            if (canAttachUnified) {\n                this._unified.connect(transport, { targetChannel: channel });\n            }\n\n            this._context.$registerConnection({\n                localChannel: this._channel,\n                remoteChannel: channel,\n                sender: this._channel,\n                direction: \"outgoing\",\n                transportType\n            });\n            \n            this.notifyChannel(channel, {\n                contextId: this._context.id,\n                contextName: this._context.hostName\n            }, \"connect\");\n        }\n\n        //\n        return new RemoteChannelHelper(channel, this._context, options);\n    }\n\n    getChannel(): string { return this._channel; }\n    get connection(): ChannelConnection { return this._connection; }\n\n    request(\n        path: string[] | WReflectAction,\n        action: WReflectAction | any[],\n        args: any[] | any,\n        options: any | string = {},\n        toChannel: string = \"worker\"\n    ): Promise<any> | null {\n        let normalizedPath = typeof path === \"string\" ? [path] : path;\n        let normalizedArgs = args;\n\n        if (Array.isArray(action) && isReflectAction(path)) {\n            toChannel = options as string;\n            options = args;\n            normalizedArgs = action;\n            action = path as unknown as WReflectAction;\n            normalizedPath = [];\n        }\n        return this._unified.invoke(\n            toChannel,\n            action as WReflectAction,\n            (normalizedPath as string[]) ?? [],\n            Array.isArray(normalizedArgs) ? normalizedArgs : [normalizedArgs]\n        ) as Promise<any>;\n    }\n\n    private resolveResponse(reqId: string, result: any): Promise<any> | undefined {\n        this._forResolves.get(reqId)?.resolve?.(result);\n        const promise = this._forResolves.get(reqId)?.promise;\n        this._forResolves.delete(reqId);\n        return promise;\n    }\n\n    private async handleAndResponse(\n        request: WReq,\n        reqId: string,\n        responseFn?: (result: any, transfer: any[]) => void\n    ): Promise<void> {\n        // Use unified core handleRequest\n        /*const result = await coreHandleRequest(request, reqId, this._channel);\n        if (!result) return;\n\n        const { response, transfer } = result;\n        const send = responseFn ?? this._broadcasts?.get(request.sender)?.postMessage?.bind(this._broadcasts?.get(request.sender));\n        send?.(response, transfer);*/\n    }\n\n    notifyChannel(\n        targetChannel: string,\n        payload: any = {},\n        type: \"notify\" | \"connect\" = \"notify\"\n    ): boolean {\n        // Delegate notify/connect signaling to unified runtime.\n        return this._unified.notify(targetChannel, {\n            ...payload,\n            from: this._channel,\n            to: targetChannel\n        }, type);\n    }\n\n    getConnectedChannels(): string[] {\n        return this._unified.connectedChannels;\n    }\n\n    close(): void {\n        this._subscriptions.forEach(s => s.unsubscribe());\n        this._forResolves.clear();\n        this._broadcasts?.values?.()?.forEach((transport) => transport.close?.());\n        this._broadcasts?.clear?.();\n        this._unified.close();\n    }\n\n    get unified(): UnifiedChannel {\n        return this._unified;\n    }\n}\n\n// ============================================================================\n// CHANNEL CONTEXT\n// ============================================================================\n\n/**\n * Channel Context - Manages multiple channels in a single context\n *\n * Use this when you need multiple independent channels in the same\n * JavaScript context (same window, iframe, worker, etc.)\n *\n * Supports:\n * - Creating multiple channels at once or deferred\n * - Dynamic transport addition (workers, ports, sockets, etc.)\n * - Global self/globalThis as default target\n */\nexport class ChannelContext {\n    private _id = UUIDv4();\n    private _hostName: string;\n    private _host: ChannelHandler | null = null;\n    private _endpoints = new Map<string, ChannelEndpoint>();\n    private _unifiedByChannel = new Map<string, UnifiedChannel>();\n    private _unifiedConnectionSubs = new Map<string, Subscription>();\n    private _remoteChannels = new Map<string, RemoteChannelInfo>();\n    private _deferredChannels = new Map<string, () => Promise<ChannelEndpoint>>();\n    private _connectionEvents = new ChannelSubject<ConnectionEvent>({ bufferSize: 200 });\n    private _connectionRegistry = new ConnectionRegistry<DynamicTransportType | TransportType | \"internal\">(\n        () => UUIDv4(),\n        (event) => this._emitConnectionEvent(event)\n    );\n    private _closed = false;\n    private _globalSelf: typeof globalThis | null = null;\n\n    constructor(private _options: ChannelContextOptions = {}) {\n        this._hostName = _options.name ?? `ctx-${this._id.slice(0, 8)}`;\n\n        // Initialize with globalThis/self if requested\n        if (_options.useGlobalSelf !== false) {\n            this._globalSelf = typeof globalThis !== \"undefined\" ? globalThis\n                : typeof self !== \"undefined\" ? self\n                : null;\n        }\n    }\n\n    // ========================================================================\n    // HOST MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Initialize/get the host channel for this context\n     */\n    initHost(name?: string): ChannelHandler {\n        if (this._host && !name) return this._host;\n\n        const hostName = name ?? this._hostName;\n        this._hostName = hostName;\n\n        if (this._endpoints.has(hostName)) {\n            this._host = this._endpoints.get(hostName)!.handler;\n            return this._host;\n        }\n\n        this._host = new ChannelHandler(hostName, this, this._options.defaultOptions);\n        const endpoint: ChannelEndpoint = {\n            name: hostName,\n            handler: this._host,\n            connection: this._host.connection,\n            subscriptions: [],\n            ready: Promise.resolve(null),\n            unified: this._host.unified\n        };\n        this._endpoints.set(hostName, endpoint);\n        this._registerUnifiedChannel(hostName, this._host.unified);\n\n        return this._host;\n    }\n\n    /**\n     * Get the host channel\n     */\n    getHost(): ChannelHandler | null {\n        return this._host ?? this.initHost();\n    }\n\n    /**\n     * Get host name\n     */\n    get hostName(): string {\n        return this._hostName;\n    }\n\n    /**\n     * Get context ID\n     */\n    get id(): string {\n        return this._id;\n    }\n\n    /**\n     * Observable: connection events in this context\n     */\n    get onConnection() {\n        return this._connectionEvents;\n    }\n\n    /**\n     * Subscribe to connection events\n     */\n    subscribeConnections(handler: (event: ConnectionEvent) => void): Subscription {\n        return this._connectionEvents.subscribe(handler);\n    }\n\n    /**\n     * Notify all currently known active connections.\n     * Useful for service worker / cross-tab handshakes.\n     */\n    notifyConnections(payload: any = {}, query: QueryConnectionsOptions = {}): number {\n        let sent = 0;\n\n        for (const endpoint of this._endpoints.values()) {\n            const connectedTargets = endpoint.handler.getConnectedChannels();\n            for (const remoteChannel of connectedTargets) {\n                if (query.localChannel && query.localChannel !== endpoint.name) continue;\n                if (query.remoteChannel && query.remoteChannel !== remoteChannel) continue;\n\n                const existing = this.queryConnections({\n                    localChannel: endpoint.name,\n                    remoteChannel,\n                    status: \"active\"\n                })[0];\n\n                if (query.sender && existing?.sender !== query.sender) continue;\n                if (query.transportType && existing?.transportType !== query.transportType) continue;\n                if (query.channel && query.channel !== endpoint.name && query.channel !== remoteChannel) continue;\n\n                if (endpoint.handler.notifyChannel(remoteChannel, payload, \"notify\")) {\n                    sent++;\n                }\n            }\n        }\n\n        return sent;\n    }\n\n    /**\n     * Query tracked connections with filters\n     */\n    queryConnections(query: QueryConnectionsOptions = {}): ContextConnectionInfo[] {\n        return this._connectionRegistry\n            .query(query)\n            .map((connection) => ({\n                ...connection,\n                contextId: this._id\n            }));\n    }\n\n    // ========================================================================\n    // MULTI-CHANNEL CREATION\n    // ========================================================================\n\n    /**\n     * Create a new channel endpoint in this context\n     *\n     * @param name - Channel name\n     * @param options - Connection options\n     * @returns ChannelEndpoint with handler and connection\n     */\n    createChannel(name: string, options: ConnectionOptions = {}): ChannelEndpoint {\n        if (this._endpoints.has(name)) {\n            return this._endpoints.get(name)!;\n        }\n\n        const handler = new ChannelHandler(name, this, { ...this._options.defaultOptions, ...options });\n        const endpoint: ChannelEndpoint = {\n            name,\n            handler,\n            connection: handler.connection,\n            subscriptions: [],\n            ready: Promise.resolve(null),\n            unified: handler.unified\n        };\n\n        this._endpoints.set(name, endpoint);\n        this._registerUnifiedChannel(name, handler.unified);\n        return endpoint;\n    }\n\n    /**\n     * Create multiple channel endpoints at once\n     *\n     * @param names - Array of channel names\n     * @param options - Shared connection options\n     * @returns Map of channel names to endpoints\n     */\n    createChannels(names: string[], options: ConnectionOptions = {}): Map<string, ChannelEndpoint> {\n        const result = new Map<string, ChannelEndpoint>();\n        for (const name of names) {\n            result.set(name, this.createChannel(name, options));\n        }\n        return result;\n    }\n\n    /**\n     * Get an existing channel endpoint\n     */\n    getChannel(name: string): ChannelEndpoint | undefined {\n        return this._endpoints.get(name);\n    }\n\n    /**\n     * Get or create a channel endpoint\n     */\n    getOrCreateChannel(name: string, options: ConnectionOptions = {}): ChannelEndpoint {\n        return this._endpoints.get(name) ?? this.createChannel(name, options);\n    }\n\n    /**\n     * Check if channel exists in this context\n     */\n    hasChannel(name: string): boolean {\n        return this._endpoints.has(name);\n    }\n\n    /**\n     * Get all channel names in this context\n     */\n    getChannelNames(): string[] {\n        return [...this._endpoints.keys()];\n    }\n\n    /**\n     * Get total number of channels\n     */\n    get size(): number {\n        return this._endpoints.size;\n    }\n\n    // ========================================================================\n    // DYNAMIC / DEFERRED CHANNEL CREATION\n    // ========================================================================\n\n    /**\n     * Register a deferred channel that will be initialized on first use\n     *\n     * @param name - Channel name\n     * @param initFn - Function to initialize the channel\n     */\n    defer(name: string, initFn: () => Promise<ChannelEndpoint>): void {\n        this._deferredChannels.set(name, initFn);\n    }\n\n    /**\n     * Initialize a previously deferred channel\n     */\n    async initDeferred(name: string): Promise<ChannelEndpoint | null> {\n        const initFn = this._deferredChannels.get(name);\n        if (!initFn) return null;\n\n        const endpoint = await initFn();\n        this._endpoints.set(name, endpoint);\n        this._deferredChannels.delete(name);\n        return endpoint;\n    }\n\n    /**\n     * Check if channel is deferred (not yet initialized)\n     */\n    isDeferred(name: string): boolean {\n        return this._deferredChannels.has(name);\n    }\n\n    /**\n     * Get channel, initializing deferred if needed\n     */\n    async getChannelAsync(name: string): Promise<ChannelEndpoint | null> {\n        if (this._endpoints.has(name)) {\n            return this._endpoints.get(name)!;\n        }\n        if (this._deferredChannels.has(name)) {\n            return this.initDeferred(name);\n        }\n        return null;\n    }\n\n    /**\n     * Add a Worker channel dynamically\n     *\n     * @param name - Channel name\n     * @param worker - Worker instance, URL, or code string\n     * @param options - Connection options\n     */\n    async addWorker(\n        name: string,\n        worker: Worker | URL | string,\n        options: ConnectionOptions = {}\n    ): Promise<ChannelEndpoint> {\n        const workerInstance = loadWorker(worker);\n        if (!workerInstance) throw new Error(`Failed to create worker for channel: ${name}`);\n\n        const handler = new ChannelHandler(name, this, { ...this._options.defaultOptions, ...options });\n        const ready = handler.createRemoteChannel(name, options, workerInstance);\n\n        const endpoint: ChannelEndpoint = {\n            name,\n            handler,\n            connection: handler.connection,\n            subscriptions: [],\n            transportType: \"worker\",\n            ready: Promise.resolve(ready),\n            unified: handler.unified\n        };\n\n        this._endpoints.set(name, endpoint);\n        this._registerUnifiedChannel(name, handler.unified);\n\n        // Store in remote channels too\n        this._remoteChannels.set(name, {\n            channel: name,\n            context: this,\n            remote: Promise.resolve(ready),\n            transport: workerInstance,\n            transportType: \"worker\"\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * Add a MessagePort channel dynamically\n     *\n     * @param name - Channel name\n     * @param port - MessagePort instance\n     * @param options - Connection options\n     */\n    async addPort(\n        name: string,\n        port: MessagePort,\n        options: ConnectionOptions = {}\n    ): Promise<ChannelEndpoint> {\n        const handler = new ChannelHandler(name, this, { ...this._options.defaultOptions, ...options });\n        port.start?.();\n\n        const ready = handler.createRemoteChannel(name, options, port);\n\n        const endpoint: ChannelEndpoint = {\n            name,\n            handler,\n            connection: handler.connection,\n            subscriptions: [],\n            transportType: \"message-port\",\n            ready: Promise.resolve(ready),\n            unified: handler.unified\n        };\n\n        this._endpoints.set(name, endpoint);\n        this._registerUnifiedChannel(name, handler.unified);\n        this._remoteChannels.set(name, {\n            channel: name,\n            context: this,\n            remote: Promise.resolve(ready),\n            transport: port,\n            transportType: \"message-port\"\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * Add a BroadcastChannel dynamically\n     *\n     * @param name - Channel name (also used as BroadcastChannel name if not provided)\n     * @param broadcastName - Optional BroadcastChannel name (defaults to channel name)\n     * @param options - Connection options\n     */\n    async addBroadcast(\n        name: string,\n        broadcastName?: string,\n        options: ConnectionOptions = {}\n    ): Promise<ChannelEndpoint> {\n        const bc = new BroadcastChannel(broadcastName ?? name);\n        const handler = new ChannelHandler(name, this, { ...this._options.defaultOptions, ...options });\n\n        const ready = handler.createRemoteChannel(name, options, bc);\n\n        const endpoint: ChannelEndpoint = {\n            name,\n            handler,\n            connection: handler.connection,\n            subscriptions: [],\n            transportType: \"broadcast\",\n            ready: Promise.resolve(ready),\n            unified: handler.unified\n        };\n\n        this._endpoints.set(name, endpoint);\n        this._registerUnifiedChannel(name, handler.unified);\n        this._remoteChannels.set(name, {\n            channel: name,\n            context: this,\n            remote: Promise.resolve(ready),\n            transport: bc,\n            transportType: \"broadcast\"\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * Add a channel using self/globalThis (for same-context communication)\n     *\n     * @param name - Channel name\n     * @param options - Connection options\n     */\n    addSelfChannel(\n        name: string,\n        options: ConnectionOptions = {}\n    ): ChannelEndpoint {\n        const handler = new ChannelHandler(name, this, { ...this._options.defaultOptions, ...options });\n        const selfTarget = this._globalSelf ?? (typeof self !== \"undefined\" ? self : null);\n\n        const endpoint: ChannelEndpoint = {\n            name,\n            handler,\n            connection: handler.connection,\n            subscriptions: [],\n            transportType: \"self\",\n            ready: Promise.resolve(selfTarget ? handler.createRemoteChannel(name, options, selfTarget as any) : null),\n            unified: handler.unified\n        };\n\n        this._endpoints.set(name, endpoint);\n        this._registerUnifiedChannel(name, handler.unified);\n        return endpoint;\n    }\n\n    /**\n     * Add channel with dynamic transport configuration\n     *\n     * @param name - Channel name\n     * @param config - Transport configuration\n     */\n    async addTransport(\n        name: string,\n        config: DynamicTransportConfig\n    ): Promise<ChannelEndpoint> {\n        const options = config.options ?? {};\n\n        switch (config.type) {\n            case \"worker\":\n                if (!config.worker) throw new Error(\"Worker required for worker transport\");\n                return this.addWorker(name, config.worker as Worker | URL | string, options);\n\n            case \"message-port\":\n                if (!config.port) throw new Error(\"Port required for message-port transport\");\n                return this.addPort(name, config.port, options);\n\n            case \"broadcast\":\n                const bcName = typeof config.broadcast === \"string\" ? config.broadcast : undefined;\n                return this.addBroadcast(name, bcName, options);\n\n            case \"self\":\n                return this.addSelfChannel(name, options);\n\n            default:\n                // Fallback to basic channel\n                return this.createChannel(name, options);\n        }\n    }\n\n    /**\n     * Create a MessageChannel pair for bidirectional communication\n     *\n     * @param name1 - First channel name\n     * @param name2 - Second channel name\n     * @returns Both endpoints connected via MessageChannel\n     */\n    createChannelPair(\n        name1: string,\n        name2: string,\n        options: ConnectionOptions = {}\n    ): { channel1: ChannelEndpoint; channel2: ChannelEndpoint; messageChannel: MessageChannel } {\n        const mc = new MessageChannel();\n\n        const handler1 = new ChannelHandler(name1, this, { ...this._options.defaultOptions, ...options });\n        const handler2 = new ChannelHandler(name2, this, { ...this._options.defaultOptions, ...options });\n\n        mc.port1.start();\n        mc.port2.start();\n\n        const ready1 = handler1.createRemoteChannel(name2, options, mc.port1);\n        const ready2 = handler2.createRemoteChannel(name1, options, mc.port2);\n\n        const channel1: ChannelEndpoint = {\n            name: name1,\n            handler: handler1,\n            connection: handler1.connection,\n            subscriptions: [],\n            transportType: \"message-port\",\n            ready: ready1,\n            unified: handler1.unified\n        };\n\n        const channel2: ChannelEndpoint = {\n            name: name2,\n            handler: handler2,\n            connection: handler2.connection,\n            subscriptions: [],\n            transportType: \"message-port\",\n            ready: ready2,\n            unified: handler2.unified\n        };\n\n        this._endpoints.set(name1, channel1);\n        this._endpoints.set(name2, channel2);\n        this._registerUnifiedChannel(name1, handler1.unified);\n        this._registerUnifiedChannel(name2, handler2.unified);\n\n        return { channel1, channel2, messageChannel: mc };\n    }\n\n    /**\n     * Get the global self reference\n     */\n    get globalSelf(): typeof globalThis | null {\n        return this._globalSelf;\n    }\n\n    // ========================================================================\n    // REMOTE CHANNEL MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Connect to a remote channel (e.g., in a Worker)\n     */\n    async connectRemote(\n        channelName: string,\n        options: ConnectionOptions = {},\n        broadcast?: TransportBinding<NativeChannelTransport> | NativeChannelTransport | null\n    ): Promise<RemoteChannelHelper> {\n        this.initHost();\n        return this._host!.createRemoteChannel(channelName, options, broadcast);\n    }\n\n    /**\n     * Import a module in a remote channel\n     */\n    async importModuleInChannel(\n        channelName: string,\n        url: string,\n        options: { channelOptions?: ConnectionOptions; importOptions?: any } = {},\n        broadcast?: TransportBinding<NativeChannelTransport> | NativeChannelTransport | null\n    ): Promise<any> {\n        const remote = await this.connectRemote(channelName, options.channelOptions, broadcast);\n        return remote?.doImportModule?.(url, options.importOptions);\n    }\n\n    /**\n     * Internal: Create or use existing remote channel\n     */\n    $createOrUseExistingRemote(\n        channel: string,\n        options: ConnectionOptions = {},\n        broadcast: TransportBinding<NativeChannelTransport> | NativeChannelTransport | null\n    ): RemoteChannelInfo | null {\n        if (channel == null || broadcast) return null;\n        if (this._remoteChannels.has(channel)) return this._remoteChannels.get(channel)!;\n\n        const msgChannel = new MessageChannel();\n        const promise = Promised(new Promise<RemoteChannelHelper>((resolve) => {\n            const worker = loadWorker(workerCode);\n\n            worker?.addEventListener?.('message', (event: MessageEvent) => {\n                if (event.data.type === \"channelCreated\") {\n                    msgChannel.port1?.start?.();\n                    resolve(new RemoteChannelHelper(event.data.channel, this, options));\n                }\n            });\n\n            worker?.postMessage?.({\n                type: \"createChannel\",\n                channel,\n                sender: this._hostName,\n                options,\n                messagePort: msgChannel.port2\n            }, { transfer: [msgChannel.port2] });\n        }));\n\n        const info: RemoteChannelInfo = {\n            channel,\n            context: this,\n            messageChannel: msgChannel,\n            remote: promise\n        };\n\n        this._remoteChannels.set(channel, info);\n        return info;\n    }\n\n    $registerConnection(params: {\n        localChannel: string;\n        remoteChannel: string;\n        sender: string;\n        direction: ContextConnectionDirection;\n        transportType: DynamicTransportType | TransportType | \"internal\";\n        metadata?: Record<string, any>;\n    }): ContextConnectionInfo {\n        return {\n            ...this._connectionRegistry.register(params),\n            contextId: this._id\n        };\n    }\n\n    $markNotified(params: {\n        localChannel: string;\n        remoteChannel: string;\n        sender: string;\n        direction: ContextConnectionDirection;\n        transportType: DynamicTransportType | TransportType | \"internal\";\n        payload?: any;\n    }): void {\n        const connection = this._connectionRegistry.register({\n            localChannel: params.localChannel,\n            remoteChannel: params.remoteChannel,\n            sender: params.sender,\n            direction: params.direction,\n            transportType: params.transportType\n        });\n        this._connectionRegistry.markNotified(connection, params.payload);\n    }\n\n    $observeSignal(params: {\n        localChannel: string;\n        remoteChannel: string;\n        sender: string;\n        transportType: DynamicTransportType | TransportType | \"internal\";\n        payload?: any;\n    }): void {\n        const signalType = params.payload?.type ?? \"notify\";\n        const direction: ContextConnectionDirection = signalType === \"connect\" ? \"incoming\" : \"incoming\";\n        this.$markNotified({\n            localChannel: params.localChannel,\n            remoteChannel: params.remoteChannel,\n            sender: params.sender,\n            direction,\n            transportType: params.transportType,\n            payload: params.payload\n        });\n    }\n\n    $forwardUnifiedConnectionEvent(channel: string, event: import(\"./UnifiedChannel\").UnifiedConnectionEvent): void {\n        const mappedTransportType = (event.connection.transportType ?? \"internal\") as DynamicTransportType | TransportType | \"internal\";\n        const connection = this._connectionRegistry.register({\n            localChannel: event.connection.localChannel || channel,\n            remoteChannel: event.connection.remoteChannel,\n            sender: event.connection.sender,\n            direction: event.connection.direction as ContextConnectionDirection,\n            transportType: mappedTransportType,\n            metadata: event.connection.metadata\n        });\n        if (event.type === \"notified\") {\n            this._connectionRegistry.markNotified(connection, event.payload);\n        } else if (event.type === \"disconnected\") {\n            this._connectionRegistry.closeByChannel(event.connection.localChannel);\n        }\n    }\n\n    // ========================================================================\n    // LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Close a specific channel\n     */\n    closeChannel(name: string): boolean {\n        const endpoint = this._endpoints.get(name);\n        if (!endpoint) return false;\n\n        endpoint.subscriptions.forEach(s => s.unsubscribe());\n        endpoint.handler.close();\n        endpoint.transport?.detach();\n        this._unifiedConnectionSubs.get(name)?.unsubscribe();\n        this._unifiedConnectionSubs.delete(name);\n        this._unifiedByChannel.delete(name);\n\n        this._endpoints.delete(name);\n\n        if (name === this._hostName) {\n            this._host = null;\n        }\n\n        this._connectionRegistry.closeByChannel(name);\n\n        return true;\n    }\n\n    /**\n     * Close all channels and cleanup\n     */\n    close(): void {\n        if (this._closed) return;\n        this._closed = true;\n\n        for (const [name] of this._endpoints) {\n            this.closeChannel(name);\n        }\n\n        this._remoteChannels.clear();\n        this._host = null;\n        this._unifiedConnectionSubs.forEach((sub) => sub.unsubscribe());\n        this._unifiedConnectionSubs.clear();\n        this._unifiedByChannel.clear();\n        this._connectionRegistry.clear();\n        this._connectionEvents.complete();\n    }\n\n    /**\n     * Check if context is closed\n     */\n    get closed(): boolean {\n        return this._closed;\n    }\n\n    private _registerUnifiedChannel(name: string, unified: UnifiedChannel): void {\n        this._unifiedByChannel.set(name, unified);\n        this._unifiedConnectionSubs.get(name)?.unsubscribe();\n        const subscription = unified.subscribeConnections((event) => {\n            this.$forwardUnifiedConnectionEvent(name, event);\n        });\n        this._unifiedConnectionSubs.set(name, subscription);\n    }\n\n    private _emitConnectionEvent(event: BaseConnectionEvent<DynamicTransportType | TransportType | \"internal\">): void {\n        this._connectionEvents.next({\n            ...event,\n            connection: {\n                ...event.connection,\n                contextId: this._id\n            }\n        });\n    }\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction isReflectAction(action: any): action is WReflectAction {\n    return [...Object.values(WReflectAction)].includes(action);\n}\n\nfunction normalizeTransportBinding(\n    target: TransportBinding<NativeChannelTransport> | NativeChannelTransport | null | undefined\n): TransportBinding<NativeChannelTransport> | null {\n    if (!target) return null;\n    if (isTransportBinding(target)) return target;\n\n    const nativeTarget = target as NativeChannelTransport;\n    return {\n        target: nativeTarget,\n        postMessage: (message: any, options?: any) => {\n            nativeTarget.postMessage?.(message, options);\n        },\n        addEventListener: nativeTarget.addEventListener?.bind(nativeTarget),\n        removeEventListener: nativeTarget.removeEventListener?.bind(nativeTarget),\n        start: (nativeTarget as any).start?.bind(nativeTarget),\n        close: (nativeTarget as any).close?.bind(nativeTarget)\n    };\n}\n\nfunction isTransportBinding(value: any): value is TransportBinding<NativeChannelTransport> {\n    return !!value && typeof value === \"object\" && \"target\" in value && typeof value.postMessage === \"function\";\n}\n\nfunction getDynamicTransportType(\n    target: TransportBinding<NativeChannelTransport> | Worker | BroadcastChannel | MessagePort | WebSocket | typeof globalThis | string | null | undefined\n): DynamicTransportType | TransportType | \"internal\" {\n    const effectiveTarget = isTransportBinding(target) ? target.target : target;\n    if (!effectiveTarget) return \"internal\";\n    if (effectiveTarget === \"chrome-runtime\") return \"chrome-runtime\";\n    if (effectiveTarget === \"chrome-tabs\") return \"chrome-tabs\";\n    if (effectiveTarget === \"chrome-port\") return \"chrome-port\";\n    if (effectiveTarget === \"chrome-external\") return \"chrome-external\";\n    if (typeof MessagePort !== \"undefined\" && effectiveTarget instanceof MessagePort) return \"message-port\";\n    if (typeof BroadcastChannel !== \"undefined\" && effectiveTarget instanceof BroadcastChannel) return \"broadcast\";\n    if (typeof Worker !== \"undefined\" && effectiveTarget instanceof Worker) return \"worker\";\n    if (typeof WebSocket !== \"undefined\" && effectiveTarget instanceof WebSocket) return \"websocket\";\n    if (\n        typeof chrome !== \"undefined\" &&\n        typeof effectiveTarget === \"object\" &&\n        effectiveTarget &&\n        typeof (effectiveTarget as any).postMessage === \"function\" &&\n        (effectiveTarget as any).onMessage?.addListener\n    ) return \"chrome-port\";\n    if (typeof self !== \"undefined\" && effectiveTarget === self) return \"self\";\n    return \"internal\";\n}\n\nfunction loadWorker(WX: any): Worker | null {\n    if (WX instanceof Worker) return WX;\n    if (WX instanceof URL) return new Worker(WX.href, { type: \"module\" });\n    if (typeof WX === \"function\") {\n        try { return new WX({ type: \"module\" }); }\n        catch { return WX({ type: \"module\" }); }\n    }\n    if (typeof WX === \"string\") {\n        if (WX.startsWith(\"/\")) return new Worker(new URL(WX.replace(/^\\//, \"./\"), import.meta.url).href, { type: \"module\" });\n        if (URL.canParse(WX) || WX.startsWith(\"./\")) return new Worker(new URL(WX, import.meta.url).href, { type: \"module\" });\n        return new Worker(URL.createObjectURL(new Blob([WX], { type: \"application/javascript\" })), { type: \"module\" });\n    }\n    if (WX instanceof Blob || WX instanceof File) return new Worker(URL.createObjectURL(WX), { type: \"module\" });\n    return WX ?? (typeof self !== \"undefined\" ? self : null) as unknown as Worker;\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS & GLOBAL CONTEXT\n// ============================================================================\n\n/** Global context registry for shared contexts */\nconst CONTEXT_REGISTRY = new Map<string, ChannelContext>();\n\n/** Default global context (uses globalThis/self) */\nlet DEFAULT_CONTEXT: ChannelContext | null = null;\n\n/**\n * Get the default global context\n *\n * This context is shared across the entire JavaScript context\n * and uses globalThis/self for communication by default.\n */\nexport function getDefaultContext(): ChannelContext {\n    if (!DEFAULT_CONTEXT) {\n        DEFAULT_CONTEXT = new ChannelContext({\n            name: \"$default$\",\n            useGlobalSelf: true\n        });\n        CONTEXT_REGISTRY.set(\"$default$\", DEFAULT_CONTEXT);\n    }\n    return DEFAULT_CONTEXT;\n}\n\n/**\n * Create a new channel context\n *\n * Use this for isolated channel management in components\n */\nexport function createChannelContext(options: ChannelContextOptions = {}): ChannelContext {\n    const ctx = new ChannelContext(options);\n    if (options.name) {\n        CONTEXT_REGISTRY.set(options.name, ctx);\n    }\n    return ctx;\n}\n\n/**\n * Get or create a named context (shared across components)\n */\nexport function getOrCreateContext(name: string, options: ChannelContextOptions = {}): ChannelContext {\n    if (CONTEXT_REGISTRY.has(name)) {\n        return CONTEXT_REGISTRY.get(name)!;\n    }\n    return createChannelContext({ ...options, name });\n}\n\n/**\n * Get an existing context by name\n */\nexport function getContext(name: string): ChannelContext | undefined {\n    return CONTEXT_REGISTRY.get(name);\n}\n\n/**\n * Delete a context from the registry\n */\nexport function deleteContext(name: string): boolean {\n    const ctx = CONTEXT_REGISTRY.get(name);\n    if (ctx) {\n        ctx.close();\n        return CONTEXT_REGISTRY.delete(name);\n    }\n    return false;\n}\n\n/**\n * Get all registered context names\n */\nexport function getContextNames(): string[] {\n    return [...CONTEXT_REGISTRY.keys()];\n}\n\n/**\n * Quick helper: Create channels in a new context\n *\n * @example\n * const { context, channels } = createChannelsInContext([\"ui\", \"data\", \"api\"]);\n */\nexport function createChannelsInContext(\n    channelNames: string[],\n    contextOptions: ChannelContextOptions = {}\n): { context: ChannelContext; channels: Map<string, ChannelEndpoint> } {\n    const context = createChannelContext(contextOptions);\n    const channels = context.createChannels(channelNames);\n    return { context, channels };\n}\n\n/**\n * Quick helper: Import module in a new context's channel\n *\n * @example\n * const { context, module } = await importModuleInContext(\"myChannel\", \"./worker-module.ts\");\n */\nexport async function importModuleInContext(\n    channelName: string,\n    url: string,\n    options: {\n        contextOptions?: ChannelContextOptions;\n        channelOptions?: ConnectionOptions;\n        importOptions?: any;\n    } = {}\n): Promise<{ context: ChannelContext; module: any }> {\n    const context = createChannelContext(options.contextOptions);\n    const module = await context.importModuleInChannel(channelName, url, {\n        channelOptions: options.channelOptions,\n        importOptions: options.importOptions\n    });\n    return { context, module };\n}\n\n// ============================================================================\n// DEFAULT CONTEXT SHORTCUTS\n// ============================================================================\n\n/**\n * Add a worker channel to the default global context\n *\n * @example\n * const endpoint = await addWorkerChannel(\"compute\", new Worker(\"./worker.js\"));\n */\nexport async function addWorkerChannel(\n    name: string,\n    worker: Worker | URL | string,\n    options: ConnectionOptions = {}\n): Promise<ChannelEndpoint> {\n    return getDefaultContext().addWorker(name, worker, options);\n}\n\n/**\n * Add a MessagePort channel to the default global context\n *\n * @example\n * const endpoint = await addPortChannel(\"iframe-comm\", port);\n */\nexport async function addPortChannel(\n    name: string,\n    port: MessagePort,\n    options: ConnectionOptions = {}\n): Promise<ChannelEndpoint> {\n    return getDefaultContext().addPort(name, port, options);\n}\n\n/**\n * Add a BroadcastChannel to the default global context\n *\n * @example\n * const endpoint = await addBroadcastChannel(\"cross-tab\");\n */\nexport async function addBroadcastChannel(\n    name: string,\n    broadcastName?: string,\n    options: ConnectionOptions = {}\n): Promise<ChannelEndpoint> {\n    return getDefaultContext().addBroadcast(name, broadcastName, options);\n}\n\n/**\n * Add a self channel to the default global context\n *\n * @example\n * const endpoint = addSelfChannelToDefault(\"local\");\n */\nexport function addSelfChannelToDefault(\n    name: string,\n    options: ConnectionOptions = {}\n): ChannelEndpoint {\n    return getDefaultContext().addSelfChannel(name, options);\n}\n\n/**\n * Register a deferred channel in the default context\n *\n * @example\n * deferChannel(\"heavy-worker\", async () => {\n *     const worker = new Worker(\"./heavy.js\");\n *     return getDefaultContext().addWorker(\"heavy-worker\", worker);\n * });\n *\n * // Later, when needed:\n * const endpoint = await initDeferredChannel(\"heavy-worker\");\n */\nexport function deferChannel(\n    name: string,\n    initFn: () => Promise<ChannelEndpoint>\n): void {\n    getDefaultContext().defer(name, initFn);\n}\n\n/**\n * Initialize a deferred channel in the default context\n */\nexport async function initDeferredChannel(name: string): Promise<ChannelEndpoint | null> {\n    return getDefaultContext().initDeferred(name);\n}\n\n/**\n * Get channel from default context (initializing deferred if needed)\n */\nexport async function getChannelFromDefault(name: string): Promise<ChannelEndpoint | null> {\n    return getDefaultContext().getChannelAsync(name);\n}\n\n/**\n * Create a MessageChannel pair in the default context\n *\n * @example\n * const { channel1, channel2 } = createDefaultChannelPair(\"ui\", \"worker-proxy\");\n */\nexport function createDefaultChannelPair(\n    name1: string,\n    name2: string,\n    options: ConnectionOptions = {}\n) {\n    return getDefaultContext().createChannelPair(name1, name2, options);\n}\n","/**\n * Transport Observable - Observable wrappers for transports\n *\n * Direct Observable wrapper:\n * - next()  postMessage/send\n * - subscribe()  addEventListener\n */\n\nimport {\n    createTransportSender,\n    createTransportListener,\n    type TransportTarget\n} from \"../../core/TransportCore\";\nimport type { ChannelMessage, Observer, Subscription, Subscribable } from \"../types/Interface\";\nimport { ChannelSubject } from \"../observable/Observable\";\n\n// ============================================================================\n// BASE TRANSPORT OBSERVABLE\n// ============================================================================\n\nexport abstract class TransportObservable<T = ChannelMessage> implements Subscribable<T> {\n    protected _subs = new Set<Observer<T>>();\n    protected _listening = false;\n    protected _cleanup: (() => void) | null = null;\n\n    abstract next(value: T, transfer?: Transferable[]): void;\n\n    subscribe(observerOrNext: Observer<T> | ((v: T) => void)): Subscription {\n        const obs: Observer<T> = typeof observerOrNext === \"function\" ? { next: observerOrNext } : observerOrNext;\n        const first = this._subs.size === 0;\n        this._subs.add(obs);\n\n        if (first && !this._listening) this._activate();\n\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0 && this._listening) this._deactivate();\n            }\n        };\n    }\n\n    protected abstract _activate(): void;\n\n    protected _deactivate(): void {\n        this._cleanup?.();\n        this._cleanup = null;\n        this._listening = false;\n    }\n\n    protected _dispatch(value: T): void {\n        for (const s of this._subs) {\n            try { s.next?.(value); }\n            catch (e) { s.error?.(e as Error); }\n        }\n    }\n\n    protected _error(err: Error): void {\n        for (const s of this._subs) s.error?.(err);\n    }\n\n    protected _complete(): void {\n        for (const s of this._subs) s.complete?.();\n        this._subs.clear();\n        this._deactivate();\n    }\n\n    close(): void { this._complete(); }\n    get subscriberCount(): number { return this._subs.size; }\n    get isListening(): boolean { return this._listening; }\n}\n\n// ============================================================================\n// CONCRETE IMPLEMENTATIONS\n// ============================================================================\n\n/** Worker Observable */\nexport class WorkerObservable extends TransportObservable<ChannelMessage> {\n    private _send: ReturnType<typeof createTransportSender>;\n\n    constructor(private _worker: Worker) {\n        super();\n        this._send = createTransportSender(this._worker);\n    }\n\n    next(value: ChannelMessage, transfer?: Transferable[]): void { this._send(value, transfer); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(this._worker, (d) => this._dispatch(d), (e) => this._error(e));\n        this._listening = true;\n    }\n\n    terminate(): void { this._worker.terminate(); this._complete(); }\n    get worker(): Worker { return this._worker; }\n}\n\n/** MessagePort Observable */\nexport class MessagePortObservable extends TransportObservable<ChannelMessage> {\n    private _send: ReturnType<typeof createTransportSender>;\n\n    constructor(private _port: MessagePort) {\n        super();\n        this._send = createTransportSender(this._port);\n    }\n\n    next(value: ChannelMessage, transfer?: Transferable[]): void { this._send(value, transfer); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(this._port, (d) => this._dispatch(d));\n        this._listening = true;\n    }\n\n    get port(): MessagePort { return this._port; }\n}\n\n/** BroadcastChannel Observable */\nexport class BroadcastChannelObservable extends TransportObservable<ChannelMessage> {\n    private _channel: BroadcastChannel;\n    private _send: ReturnType<typeof createTransportSender>;\n\n    constructor(private _name: string) {\n        super();\n        this._channel = new BroadcastChannel(_name);\n        this._send = createTransportSender(this._channel);\n    }\n\n    next(value: ChannelMessage): void { this._send(value); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(this._channel, (d) => {\n            if (d?.sender !== this._name) this._dispatch(d);\n        });\n        this._listening = true;\n    }\n\n    close(): void { this._channel.close(); super.close(); }\n}\n\n/** WebSocket Observable */\nexport class WebSocketObservable extends TransportObservable<ChannelMessage> {\n    private _ws: WebSocket | null = null;\n    private _pending: ChannelMessage[] = [];\n    private _state = new ChannelSubject<\"connecting\" | \"open\" | \"closing\" | \"closed\">();\n\n    constructor(private _url: string | URL, private _protocols?: string | string[]) { super(); }\n\n    connect(): void {\n        if (this._ws) return;\n        const url = typeof this._url === \"string\" ? this._url : this._url.href;\n        this._ws = new WebSocket(url, this._protocols);\n        this._state.next(\"connecting\");\n\n        this._ws.addEventListener(\"open\", () => {\n            this._state.next(\"open\");\n            this._pending.forEach((m) => this.next(m));\n            this._pending = [];\n        });\n\n        this._cleanup = createTransportListener(\n            this._ws,\n            (d) => this._dispatch(d),\n            (e) => this._error(e),\n            () => { this._state.next(\"closed\"); this._complete(); }\n        );\n        this._listening = true;\n    }\n\n    next(value: ChannelMessage): void {\n        if (!this._ws || this._ws.readyState !== WebSocket.OPEN) {\n            this._pending.push(value);\n            return;\n        }\n        const { transferable: _, ...data } = value as any;\n        this._ws.send(JSON.stringify(data));\n    }\n\n    protected _activate(): void { if (!this._ws) this.connect(); }\n\n    close(code?: number, reason?: string): void {\n        this._state.next(\"closing\");\n        this._ws?.close(code, reason);\n        this._ws = null;\n        super.close();\n    }\n\n    get state(): Subscribable<string> { return this._state; }\n    get isOpen(): boolean { return this._ws?.readyState === WebSocket.OPEN; }\n}\n\n/** Chrome Runtime Observable */\nexport class ChromeRuntimeObservable extends TransportObservable<ChannelMessage> {\n    private _send = createTransportSender(\"chrome-runtime\");\n\n    next(value: ChannelMessage): void { this._send(value); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\"chrome-runtime\", (d) => this._dispatch(d));\n        this._listening = true;\n    }\n}\n\n/** Chrome Tabs Observable */\nexport class ChromeTabsObservable extends TransportObservable<ChannelMessage> {\n    constructor(private _tabId?: number) { super(); }\n\n    setTabId(id: number): void { this._tabId = id; }\n\n    next(value: ChannelMessage): void {\n        if (this._tabId == null || typeof chrome === \"undefined\" || !chrome.tabs) return;\n        const { transferable: _, ...data } = value as any;\n        chrome.tabs.sendMessage(this._tabId, data);\n    }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\n            \"chrome-tabs\",\n            (d) => this._dispatch(d),\n            undefined,\n            undefined,\n            { tabId: this._tabId }\n        );\n        this._listening = true;\n    }\n}\n\n/** Chrome Port Observable */\nexport class ChromePortObservable extends TransportObservable<ChannelMessage> {\n    private _send: ReturnType<typeof createTransportSender>;\n\n    constructor(private _portName: string, private _tabId?: number) {\n        super();\n        this._send = createTransportSender(\"chrome-port\", { portName: _portName, tabId: _tabId });\n    }\n\n    next(value: ChannelMessage): void {\n        this._send(value);\n    }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\n            \"chrome-port\",\n            (d) => this._dispatch(d),\n            undefined,\n            undefined,\n            { portName: this._portName, tabId: this._tabId }\n        );\n        this._listening = true;\n    }\n}\n\n/** ServiceWorker Client Observable */\nexport class ServiceWorkerClientObservable extends TransportObservable<ChannelMessage> {\n    private _send = createTransportSender(\"service-worker-client\");\n\n    next(value: ChannelMessage, transfer?: Transferable[]): void { this._send(value, transfer); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\"service-worker-client\", (d) => this._dispatch(d));\n        this._listening = true;\n    }\n}\n\n/** ServiceWorker Host Observable */\nexport class ServiceWorkerHostObservable extends TransportObservable<ChannelMessage & { _clientId?: string }> {\n    private _send = createTransportSender(\"service-worker-host\");\n\n    next(value: ChannelMessage & { _clientId?: string }, transfer?: Transferable[]): void {\n        this._send(value, transfer);\n    }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\"service-worker-host\", (d) => this._dispatch(d));\n        this._listening = true;\n    }\n}\n\n/** Self Observable (inside worker) */\nexport class SelfObservable extends TransportObservable<ChannelMessage> {\n    private _send = createTransportSender(\"self\");\n\n    next(value: ChannelMessage, transfer?: Transferable[]): void { this._send(value, transfer); }\n\n    protected _activate(): void {\n        if (this._listening) return;\n        this._cleanup = createTransportListener(\"self\", (d) => this._dispatch(d));\n        this._listening = true;\n    }\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const TransportObservableFactory = {\n    worker: (w: Worker) => new WorkerObservable(w),\n    workerFromUrl: (url: string | URL, opts?: WorkerOptions) =>\n        new WorkerObservable(new Worker(typeof url === \"string\" ? url : url.href, { type: \"module\", ...opts })),\n    messagePort: (p: MessagePort) => new MessagePortObservable(p),\n    messageChannel: () => {\n        const ch = new MessageChannel();\n        return { port1: new MessagePortObservable(ch.port1), port2: new MessagePortObservable(ch.port2) };\n    },\n    broadcast: (name: string) => new BroadcastChannelObservable(name),\n    websocket: (url: string | URL, protocols?: string | string[]) => new WebSocketObservable(url, protocols),\n    chromeRuntime: () => new ChromeRuntimeObservable(),\n    chromeTabs: (tabId?: number) => new ChromeTabsObservable(tabId),\n    chromePort: (portName: string, tabId?: number) => new ChromePortObservable(portName, tabId),\n    serviceWorkerClient: () => new ServiceWorkerClientObservable(),\n    serviceWorkerHost: () => new ServiceWorkerHostObservable(),\n    self: () => new SelfObservable()\n};\n\n// ============================================================================\n// BIDIRECTIONAL CHANNEL\n// ============================================================================\n\nexport function createBidirectionalChannel<T = ChannelMessage>(\n    outbound: TransportObservable<T>,\n    inbound: TransportObservable<T>\n): { send: (v: T, t?: Transferable[]) => void; subscribe: (h: (v: T) => void) => Subscription; close: () => void } {\n    return {\n        send: (v, t) => outbound.next(v, t),\n        subscribe: (h) => inbound.subscribe({ next: h }),\n        close: () => { outbound.close(); inbound.close(); }\n    };\n}\n","/**\n * Worker Entry Point - Multi-Channel Support\n *\n * This worker context supports:\n * - Multiple channel creation/initialization\n * - Observing new incoming channel connections\n * - Dynamic channel addition after initialization\n * - Connection from remote/host contexts\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport {\n    ChannelContext,\n    createChannelContext,\n    type ChannelEndpoint,\n    type ChannelContextOptions,\n    type QueryConnectionsOptions,\n    type ContextConnectionInfo\n} from \"../channel/ChannelContext\";\nimport { ChannelSubject, type Subscription } from \"../observable/Observable\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Incoming connection event */\nexport interface IncomingConnection {\n    /** Connection ID */\n    id: string;\n    /** Channel name */\n    channel: string;\n    /** Sender context name */\n    sender: string;\n    /** Connection type */\n    type: \"channel\" | \"port\" | \"broadcast\" | \"socket\";\n    /** MessagePort if provided */\n    port?: MessagePort;\n    /** Timestamp */\n    timestamp: number;\n    /** Connection options */\n    options?: any;\n}\n\n/** Channel created event */\nexport interface ChannelCreatedEvent {\n    /** Channel name */\n    channel: string;\n    /** Endpoint reference */\n    endpoint: ChannelEndpoint;\n    /** Remote sender */\n    sender: string;\n    /** Timestamp */\n    timestamp: number;\n}\n\n/** Worker context configuration */\nexport interface WorkerContextConfig extends ChannelContextOptions {\n    /** Worker name/identifier */\n    workerName?: string;\n    /** Auto-accept incoming channels */\n    autoAcceptChannels?: boolean;\n    /** Channel whitelist (if set, only these channels are accepted) */\n    allowedChannels?: string[];\n    /** Maximum concurrent channels */\n    maxChannels?: number;\n}\n\n// ============================================================================\n// WORKER CONTEXT\n// ============================================================================\n\n/**\n * WorkerContext - Manages channels within a Worker\n *\n * Supports observing new incoming connections from host/remote contexts.\n */\nexport class WorkerContext {\n    private _context: ChannelContext;\n    private _config: Required<WorkerContextConfig>;\n    private _subscriptions: Subscription[] = [];\n\n    // Observable streams for incoming connections\n    private _incomingConnections = new ChannelSubject<IncomingConnection>({ bufferSize: 100 });\n    private _channelCreated = new ChannelSubject<ChannelCreatedEvent>({ bufferSize: 100 });\n    private _channelClosed = new ChannelSubject<{ channel: string; timestamp: number }>();\n\n    constructor(config: WorkerContextConfig = {}) {\n        this._config = {\n            name: config.name ?? \"worker\",\n            workerName: config.workerName ?? `worker-${UUIDv4().slice(0, 8)}`,\n            autoAcceptChannels: config.autoAcceptChannels ?? true,\n            allowedChannels: config.allowedChannels ?? [],\n            maxChannels: config.maxChannels ?? 100,\n            autoConnect: config.autoConnect ?? true,\n            useGlobalSelf: true,\n            defaultOptions: config.defaultOptions ?? {},\n            isolatedStorage: config.isolatedStorage ?? false,\n            ...config\n        };\n\n        this._context = createChannelContext({\n            name: this._config.name,\n            useGlobalSelf: true,\n            defaultOptions: config.defaultOptions\n        });\n\n        this._setupMessageListener();\n    }\n\n    // ========================================================================\n    // INCOMING CONNECTION OBSERVABLES\n    // ========================================================================\n\n    /**\n     * Observable: New incoming connection requests\n     */\n    get onConnection() {\n        return this._incomingConnections;\n    }\n\n    /**\n     * Observable: Channel created events\n     */\n    get onChannelCreated() {\n        return this._channelCreated;\n    }\n\n    /**\n     * Observable: Channel closed events\n     */\n    get onChannelClosed() {\n        return this._channelClosed;\n    }\n\n    /**\n     * Subscribe to incoming connections\n     */\n    subscribeConnections(\n        handler: (conn: IncomingConnection) => void\n    ): Subscription {\n        return this._incomingConnections.subscribe(handler);\n    }\n\n    /**\n     * Subscribe to channel creation\n     */\n    subscribeChannelCreated(\n        handler: (event: ChannelCreatedEvent) => void\n    ): Subscription {\n        return this._channelCreated.subscribe(handler);\n    }\n\n    // ========================================================================\n    // CHANNEL MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Accept an incoming connection and create the channel\n     */\n    acceptConnection(connection: IncomingConnection): ChannelEndpoint | null {\n        if (!this._canAcceptChannel(connection.channel)) {\n            return null;\n        }\n\n        const endpoint = this._context.createChannel(connection.channel, connection.options);\n\n        // Setup remote connection\n        if (connection.port) {\n            connection.port.start?.();\n            endpoint.handler.createRemoteChannel(\n                connection.sender,\n                connection.options,\n                connection.port\n            );\n        }\n\n        this._channelCreated.next({\n            channel: connection.channel,\n            endpoint,\n            sender: connection.sender,\n            timestamp: Date.now()\n        });\n\n        // Notify sender\n        this._postChannelCreated(connection.channel, connection.sender, connection.id);\n\n        return endpoint;\n    }\n\n    /**\n     * Create a new channel in this worker context\n     */\n    createChannel(name: string, options?: any): ChannelEndpoint {\n        return this._context.createChannel(name, options);\n    }\n\n    /**\n     * Get an existing channel\n     */\n    getChannel(name: string): ChannelEndpoint | undefined {\n        return this._context.getChannel(name);\n    }\n\n    /**\n     * Check if channel exists\n     */\n    hasChannel(name: string): boolean {\n        return this._context.hasChannel(name);\n    }\n\n    /**\n     * Get all channel names\n     */\n    getChannelNames(): string[] {\n        return this._context.getChannelNames();\n    }\n\n    /**\n     * Query currently tracked channel connections in this worker.\n     */\n    queryConnections(query: QueryConnectionsOptions = {}): ContextConnectionInfo[] {\n        return this._context.queryConnections(query);\n    }\n\n    /**\n     * Notify active connections (useful for worker<->host sync).\n     */\n    notifyConnections(payload: any = {}, query: QueryConnectionsOptions = {}): number {\n        return this._context.notifyConnections(payload, query);\n    }\n\n    /**\n     * Close a specific channel\n     */\n    closeChannel(name: string): boolean {\n        const closed = this._context.closeChannel(name);\n        if (closed) {\n            this._channelClosed.next({ channel: name, timestamp: Date.now() });\n        }\n        return closed;\n    }\n\n    /**\n     * Get the underlying context\n     */\n    get context(): ChannelContext {\n        return this._context;\n    }\n\n    /**\n     * Get worker configuration\n     */\n    get config(): Readonly<Required<WorkerContextConfig>> {\n        return this._config;\n    }\n\n    // ========================================================================\n    // PRIVATE METHODS\n    // ========================================================================\n\n    private _setupMessageListener(): void {\n        addEventListener(\"message\", ((event: MessageEvent) => {\n            this._handleIncomingMessage(event);\n        }) as EventListener);\n    }\n\n    private _handleIncomingMessage(event: MessageEvent): void {\n        const data = event.data;\n        if (!data || typeof data !== \"object\") return;\n\n        switch (data.type) {\n            case \"createChannel\":\n                this._handleCreateChannel(data);\n                break;\n\n            case \"connectChannel\":\n                this._handleConnectChannel(data);\n                break;\n\n            case \"addPort\":\n                this._handleAddPort(data);\n                break;\n\n            case \"listChannels\":\n                this._handleListChannels(data);\n                break;\n\n            case \"closeChannel\":\n                this._handleCloseChannel(data);\n                break;\n\n            case \"ping\":\n                postMessage({ type: \"pong\", id: data.id, timestamp: Date.now() });\n                break;\n\n            default:\n                // Pass to existing handler or log\n                if (data.channel && this._context.hasChannel(data.channel)) {\n                    // Route to specific channel\n                    const endpoint = this._context.getChannel(data.channel);\n                    endpoint?.handler?.handleAndResponse?.(data.payload, data.reqId);\n                }\n        }\n    }\n\n    private _handleCreateChannel(data: any): void {\n        const connection: IncomingConnection = {\n            id: data.reqId ?? UUIDv4(),\n            channel: data.channel,\n            sender: data.sender ?? \"unknown\",\n            type: \"channel\",\n            port: data.messagePort,\n            timestamp: Date.now(),\n            options: data.options\n        };\n\n        // Emit to observers\n        this._incomingConnections.next(connection);\n\n        // Auto-accept if configured\n        if (this._config.autoAcceptChannels) {\n            this.acceptConnection(connection);\n        }\n    }\n\n    private _handleConnectChannel(data: any): void {\n        const connection: IncomingConnection = {\n            id: data.reqId ?? UUIDv4(),\n            channel: data.channel,\n            sender: data.sender ?? \"unknown\",\n            type: data.portType ?? \"channel\",\n            port: data.port,\n            timestamp: Date.now(),\n            options: data.options\n        };\n\n        this._incomingConnections.next(connection);\n\n        if (this._config.autoAcceptChannels && this._canAcceptChannel(data.channel)) {\n            // Connect to existing channel or create new\n            const endpoint = this._context.getOrCreateChannel(data.channel, data.options);\n\n            if (data.port) {\n                data.port.start?.();\n                endpoint.handler.createRemoteChannel(data.sender, data.options, data.port);\n            }\n\n            postMessage({\n                type: \"channelConnected\",\n                channel: data.channel,\n                reqId: data.reqId\n            });\n        }\n    }\n\n    private _handleAddPort(data: any): void {\n        if (!data.port || !data.channel) return;\n\n        const connection: IncomingConnection = {\n            id: data.reqId ?? UUIDv4(),\n            channel: data.channel,\n            sender: data.sender ?? \"unknown\",\n            type: \"port\",\n            port: data.port,\n            timestamp: Date.now(),\n            options: data.options\n        };\n\n        this._incomingConnections.next(connection);\n\n        if (this._config.autoAcceptChannels) {\n            this.acceptConnection(connection);\n        }\n    }\n\n    private _handleListChannels(data: any): void {\n        postMessage({\n            type: \"channelList\",\n            channels: this.getChannelNames(),\n            reqId: data.reqId\n        });\n    }\n\n    private _handleCloseChannel(data: any): void {\n        if (data.channel) {\n            this.closeChannel(data.channel);\n            postMessage({\n                type: \"channelClosed\",\n                channel: data.channel,\n                reqId: data.reqId\n            });\n        }\n    }\n\n    private _canAcceptChannel(channel: string): boolean {\n        // Check max channels\n        if (this._context.size >= this._config.maxChannels) {\n            return false;\n        }\n\n        // Check whitelist\n        if (this._config.allowedChannels.length > 0) {\n            return this._config.allowedChannels.includes(channel);\n        }\n\n        return true;\n    }\n\n    private _postChannelCreated(channel: string, sender: string, reqId?: string): void {\n        postMessage({\n            type: \"channelCreated\",\n            channel,\n            sender,\n            reqId,\n            timestamp: Date.now()\n        });\n    }\n\n    // ========================================================================\n    // LIFECYCLE\n    // ========================================================================\n\n    close(): void {\n        this._subscriptions.forEach(s => s.unsubscribe());\n        this._subscriptions = [];\n        this._incomingConnections.complete();\n        this._channelCreated.complete();\n        this._channelClosed.complete();\n        this._context.close();\n    }\n}\n\n// ============================================================================\n// GLOBAL WORKER CONTEXT (Singleton)\n// ============================================================================\n\nlet WORKER_CONTEXT: WorkerContext | null = null;\n\n/**\n * Get or create the worker context singleton\n */\nexport function getWorkerContext(config?: WorkerContextConfig): WorkerContext {\n    if (!WORKER_CONTEXT) {\n        WORKER_CONTEXT = new WorkerContext(config);\n    }\n    return WORKER_CONTEXT;\n}\n\n/**\n * Initialize worker context with config\n */\nexport function initWorkerContext(config?: WorkerContextConfig): WorkerContext {\n    WORKER_CONTEXT?.close();\n    WORKER_CONTEXT = new WorkerContext(config);\n    return WORKER_CONTEXT;\n}\n\n/**\n * Subscribe to incoming connections in the global worker context\n */\nexport function onWorkerConnection(\n    handler: (conn: IncomingConnection) => void\n): Subscription {\n    return getWorkerContext().subscribeConnections(handler);\n}\n\n/**\n * Subscribe to channel creation in the global worker context\n */\nexport function onWorkerChannelCreated(\n    handler: (event: ChannelCreatedEvent) => void\n): Subscription {\n    return getWorkerContext().subscribeChannelCreated(handler);\n}\n\n// ============================================================================\n// INVOKER INTEGRATION\n// ============================================================================\n\nimport {\n    Responder,\n    BidirectionalInvoker,\n    createResponder,\n    createInvoker,\n    detectContextType,\n    detectTransportType,\n    type ContextType,\n    type IncomingInvocation\n} from \"../proxy/Invoker\";\n\nlet WORKER_RESPONDER: Responder | null = null;\nlet WORKER_INVOKER: BidirectionalInvoker | null = null;\n\n/**\n * Get the worker's Responder (for handling incoming invocations)\n */\nexport function getWorkerResponder(channel?: string): Responder {\n    if (!WORKER_RESPONDER) {\n        WORKER_RESPONDER = createResponder(channel ?? \"worker\");\n        WORKER_RESPONDER.listen(self);\n    }\n    return WORKER_RESPONDER;\n}\n\n/**\n * Get the worker's bidirectional Invoker\n */\nexport function getWorkerInvoker(channel?: string): BidirectionalInvoker {\n    if (!WORKER_INVOKER) {\n        WORKER_INVOKER = createInvoker(channel ?? \"worker\");\n        WORKER_INVOKER.connect(self);\n    }\n    return WORKER_INVOKER;\n}\n\n/**\n * Expose an object for remote invocation from the worker\n */\nexport function exposeFromWorker(name: string, obj: any): void {\n    getWorkerResponder().expose(name, obj);\n}\n\n/**\n * Subscribe to incoming invocations in the worker\n */\nexport function onWorkerInvocation(\n    handler: (inv: IncomingInvocation) => void\n): Subscription {\n    return getWorkerResponder().subscribeInvocations(handler);\n}\n\n/**\n * Create a proxy to invoke methods on the host from the worker\n */\nexport function createHostProxy<T = any>(hostChannel: string = \"host\", basePath: string[] = []): T {\n    return getWorkerInvoker().createProxy<T>(hostChannel, basePath);\n}\n\n/**\n * Import a module in the host context from the worker\n */\nexport function importInHost<T = any>(url: string, hostChannel: string = \"host\"): Promise<T> {\n    return getWorkerInvoker().importModule<T>(hostChannel, url);\n}\n\n// Re-export detection utilities\nexport { detectContextType, detectTransportType };\nexport type { ContextType, IncomingInvocation };\n\n// ============================================================================\n// AUTO-INITIALIZE (Compatible with legacy usage)\n// ============================================================================\n\n// Initialize the worker context\nconst ctx = getWorkerContext({ name: \"worker\" });\n\n// Export for direct access\nexport { ctx as workerContext };\n","/**\n * Chrome Extension Observable API\n *\n * Observable wrappers for Chrome Extension messaging.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"./Observable\";\nimport type { ChannelMessage, InvokerHandler, ResponderFn, Subscriber, PendingRequest } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ChromeMessage<T = any> extends ChannelMessage {\n    _sender?: chrome.runtime.MessageSender;\n    _tabId?: number;\n    _frameId?: number;\n}\n\nexport interface PortInfo {\n    name: string;\n    tabId?: number;\n    frameId?: number;\n    url?: string;\n}\n\nexport interface ChromeObservableOptions {\n    filterSender?: (sender: chrome.runtime.MessageSender) => boolean;\n    filterMessage?: (message: any) => boolean;\n    asyncResponse?: boolean;\n}\n\n// ============================================================================\n// BASE CHROME OBSERVABLE\n// ============================================================================\n\nabstract class BaseChromeObservable<T = ChromeMessage> {\n    protected _subs = new Set<Observer<T>>();\n    protected _listening = false;\n    protected _cleanup: (() => void) | null = null;\n\n    abstract send(msg: T): void;\n\n    subscribe(observer: Observer<T> | ((v: T) => void)): Subscription {\n        const obs: Observer<T> = typeof observer === \"function\" ? { next: observer } : observer;\n        const first = this._subs.size === 0;\n        this._subs.add(obs);\n        if (first && !this._listening) this._activate();\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0 && this._listening) this._deactivate();\n            }\n        };\n    }\n\n    protected abstract _activate(): void;\n    protected _deactivate(): void { this._cleanup?.(); this._cleanup = null; this._listening = false; }\n\n    protected _dispatch(value: T): void {\n        for (const s of this._subs) { try { s.next?.(value); } catch (e) { s.error?.(e as Error); } }\n    }\n\n    close(): void { this._subs.forEach((s) => s.complete?.()); this._subs.clear(); this._deactivate(); }\n}\n\n// ============================================================================\n// CHROME RUNTIME OBSERVABLE\n// ============================================================================\n\nexport class ChromeRuntimeObservable extends BaseChromeObservable<ChromeMessage> {\n    private _pending = new Map<string, PendingRequest>();\n\n    constructor(\n        private _handler?: InvokerHandler<ChromeMessage>,\n        private _options: ChromeObservableOptions = {}\n    ) { super(); }\n\n    send(msg: ChromeMessage): void {\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n        const { _sender, _tabId, _frameId, transferable, ...data } = msg as any;\n        chrome.runtime.sendMessage(data);\n    }\n\n    request(msg: ChromeMessage): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            this._pending.set(reqId, { resolve, reject, timestamp: Date.now() });\n            const { _sender, _tabId, _frameId, transferable, ...data } = { ...msg, reqId } as any;\n            chrome.runtime.sendMessage(data, (response) => {\n                if (chrome.runtime.lastError) reject(new Error(chrome.runtime.lastError.message));\n                else resolve(response);\n                this._pending.delete(reqId);\n            });\n        });\n    }\n\n    protected _activate(): void {\n        if (this._listening || typeof chrome === \"undefined\" || !chrome.runtime) return;\n\n        const listener = (message: any, sender: chrome.runtime.MessageSender, sendResponse: (r?: any) => void): boolean | void => {\n            if (this._options.filterSender && !this._options.filterSender(sender)) return false;\n            if (this._options.filterMessage && !this._options.filterMessage(message)) return false;\n\n            const data: ChromeMessage = {\n                ...message, id: message.id ?? UUIDv4(),\n                _sender: sender, _tabId: sender.tab?.id, _frameId: sender.frameId\n            };\n\n            // Handle response\n            if (data.type === \"response\" && data.reqId) {\n                const p = this._pending.get(data.reqId);\n                if (p) { p.resolve(data.payload); this._pending.delete(data.reqId); }\n            }\n\n            if (this._handler) {\n                const respond: ResponderFn<ChromeMessage> = (result) => sendResponse(result);\n                const subscriber: Subscriber<ChromeMessage> = {\n                    next: (v) => this._dispatch(v), error: () => {}, complete: () => {},\n                    signal: new AbortController().signal, active: true\n                };\n                const result = this._handler(data, respond, subscriber);\n                return result instanceof Promise ? true : this._options.asyncResponse;\n            }\n\n            this._dispatch(data);\n            return false;\n        };\n\n        chrome.runtime.onMessage.addListener(listener);\n        this._cleanup = () => chrome.runtime.onMessage.removeListener(listener);\n        this._listening = true;\n    }\n}\n\n// ============================================================================\n// CHROME TABS OBSERVABLE\n// ============================================================================\n\nexport class ChromeTabsObservable extends BaseChromeObservable<ChromeMessage> {\n    constructor(private _tabId?: number, private _options: ChromeObservableOptions = {}) { super(); }\n\n    setTabId(id: number): void { this._tabId = id; }\n\n    send(msg: ChromeMessage): void {\n        if (typeof chrome === \"undefined\" || !chrome.tabs || this._tabId == null) return;\n        const { _sender, _tabId, _frameId, transferable, ...data } = msg as any;\n        chrome.tabs.sendMessage(this._tabId, data);\n    }\n\n    protected _activate(): void {\n        if (this._listening || typeof chrome === \"undefined\" || !chrome.runtime) return;\n\n        const listener = (message: any, sender: chrome.runtime.MessageSender): void => {\n            if (this._tabId != null && sender.tab?.id !== this._tabId) return;\n            if (this._options.filterSender && !this._options.filterSender(sender)) return;\n\n            const data: ChromeMessage = {\n                ...message, id: message.id ?? UUIDv4(),\n                _sender: sender, _tabId: sender.tab?.id, _frameId: sender.frameId\n            };\n            this._dispatch(data);\n        };\n\n        chrome.runtime.onMessage.addListener(listener);\n        this._cleanup = () => chrome.runtime.onMessage.removeListener(listener);\n        this._listening = true;\n    }\n}\n\n// ============================================================================\n// CHROME PORT OBSERVABLE\n// ============================================================================\n\nexport class ChromePortObservable extends BaseChromeObservable<ChromeMessage> {\n    private _port: chrome.runtime.Port | null = null;\n    private _info: PortInfo | null = null;\n\n    constructor(private _portName: string, private _tabId?: number) { super(); }\n\n    connect(): void {\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n        this._port = this._tabId != null\n            ? chrome.tabs.connect(this._tabId, { name: this._portName })\n            : chrome.runtime.connect({ name: this._portName });\n\n        this._info = { name: this._portName, tabId: this._tabId };\n        this._setupListeners();\n    }\n\n    send(msg: ChromeMessage): void {\n        if (!this._port) return;\n        const { _sender, _tabId, _frameId, transferable, ...data } = msg as any;\n        this._port.postMessage(data);\n    }\n\n    private _setupListeners(): void {\n        if (!this._port) return;\n        this._port.onMessage.addListener((msg) => this._dispatch({ ...msg, id: msg.id ?? UUIDv4() }));\n        this._port.onDisconnect.addListener(() => { this._subs.forEach((s) => s.complete?.()); this._port = null; });\n    }\n\n    protected _activate(): void { if (!this._port) this.connect(); this._listening = true; }\n    protected _deactivate(): void { this._port?.disconnect(); this._port = null; super._deactivate(); }\n\n    get portInfo(): PortInfo | null { return this._info; }\n    get isConnected(): boolean { return this._port != null; }\n}\n\n// ============================================================================\n// CHROME EXTERNAL OBSERVABLE\n// ============================================================================\n\nexport class ChromeExternalObservable extends BaseChromeObservable<ChromeMessage> {\n    constructor(private _extensionId?: string) { super(); }\n\n    send(msg: ChromeMessage): void {\n        if (typeof chrome === \"undefined\" || !chrome.runtime) return;\n        const { _sender, _tabId, _frameId, transferable, ...data } = msg as any;\n        if (this._extensionId) chrome.runtime.sendMessage(this._extensionId, data);\n        else chrome.runtime.sendMessage(data);\n    }\n\n    protected _activate(): void {\n        if (this._listening || typeof chrome === \"undefined\" || !chrome.runtime?.onMessageExternal) return;\n\n        const listener = (message: any, sender: chrome.runtime.MessageSender): void => {\n            this._dispatch({ ...message, id: message.id ?? UUIDv4(), _sender: sender });\n        };\n\n        chrome.runtime.onMessageExternal.addListener(listener);\n        this._cleanup = () => chrome.runtime.onMessageExternal.removeListener(listener);\n        this._listening = true;\n    }\n}\n\n// ============================================================================\n// REQUEST HANDLER\n// ============================================================================\n\nexport function createChromeRequestHandler(\n    channelName: string,\n    handlers: Record<string, (args: any[], data: ChromeMessage) => any | Promise<any>>\n): InvokerHandler<ChromeMessage> {\n    return async (data, respond, subscriber) => {\n        if (data.type !== \"request\") { subscriber.next(data); return; }\n        const action = data.payload?.action;\n        if (action && handlers[action]) {\n            try {\n                const result = await handlers[action](data.payload?.args ?? [], data);\n                respond({ id: UUIDv4(), channel: data.sender, sender: channelName, reqId: data.reqId, type: \"response\", payload: { result }, timestamp: Date.now() } as ChromeMessage);\n            } catch (error) {\n                respond({ id: UUIDv4(), channel: data.sender, sender: channelName, reqId: data.reqId, type: \"response\", payload: { error: error instanceof Error ? error.message : String(error) }, timestamp: Date.now() } as ChromeMessage);\n            }\n        } else {\n            subscriber.next(data);\n        }\n    };\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const ChromeObservableFactory = {\n    runtime: (handler?: InvokerHandler<ChromeMessage>, options?: ChromeObservableOptions) => new ChromeRuntimeObservable(handler, options),\n    tabs: (tabId?: number, options?: ChromeObservableOptions) => new ChromeTabsObservable(tabId, options),\n    port: (name: string, tabId?: number) => new ChromePortObservable(name, tabId),\n    external: (extensionId?: string) => new ChromeExternalObservable(extensionId)\n};\n","/**\n * Socket.IO Observable API\n *\n * Observable wrapper for Socket.IO client.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"./Observable\";\nimport type { ChannelMessage, InvokerHandler, ResponderFn, Subscriber, PendingRequest } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface SocketIOLike {\n    on(event: string, listener: (...args: any[]) => void): void;\n    off(event: string, listener: (...args: any[]) => void): void;\n    emit(event: string, ...args: any[]): void;\n    connect?(): void;\n    disconnect?(): void;\n    connected?: boolean;\n}\n\nexport interface SocketMessage<T = any> extends ChannelMessage {\n    event?: string;\n    room?: string;\n    ack?: (response: any) => void;\n}\n\nexport interface SocketObservableOptions {\n    events?: string[];\n    defaultEvent?: string;\n    autoConnect?: boolean;\n}\n\n// ============================================================================\n// SOCKET.IO OBSERVABLE\n// ============================================================================\n\nexport class SocketIOObservable {\n    private _subs = new Set<Observer<SocketMessage>>();\n    private _pending = new Map<string, PendingRequest>();\n    private _listening = false;\n    private _cleanups: (() => void)[] = [];\n    private _events: string[];\n    private _defaultEvent: string;\n    private _state = new ChannelSubject<\"connecting\" | \"connected\" | \"disconnected\" | \"error\">();\n\n    constructor(\n        private _socket: SocketIOLike,\n        private _channelName: string,\n        private _options: SocketObservableOptions = {}\n    ) {\n        this._events = _options.events ?? [\"message\", \"channel\"];\n        this._defaultEvent = _options.defaultEvent ?? \"message\";\n        if (_options.autoConnect !== false) this._socket.connect?.();\n    }\n\n    send(msg: SocketMessage, event?: string): void {\n        const { transferable, ack, ...data } = msg as any;\n        this._socket.emit(event ?? msg.event ?? this._defaultEvent, data);\n    }\n\n    emit(event: string, data: any): void {\n        this._socket.emit(event, data);\n    }\n\n    request(msg: SocketMessage, event?: string): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            this._pending.set(reqId, { resolve, reject, timestamp: Date.now() });\n            const timeout = setTimeout(() => {\n                if (this._pending.has(reqId)) {\n                    this._pending.delete(reqId);\n                    reject(new Error(\"Request timeout\"));\n                }\n            }, 30000);\n            const { transferable, ack, ...data } = { ...msg, reqId } as any;\n            this._socket.emit(event ?? this._defaultEvent, data, (response: any) => {\n                clearTimeout(timeout);\n                this._pending.delete(reqId);\n                resolve(response);\n            });\n        });\n    }\n\n    subscribe(observer: Observer<SocketMessage> | ((v: SocketMessage) => void)): Subscription {\n        const obs: Observer<SocketMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        const first = this._subs.size === 0;\n        this._subs.add(obs);\n        if (first && !this._listening) this._activate();\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0 && this._listening) this._deactivate();\n            }\n        };\n    }\n\n    private _activate(): void {\n        if (this._listening) return;\n\n        for (const event of this._events) {\n            const handler = (data: any, ack?: (r: any) => void) => {\n                const msg: SocketMessage = {\n                    ...(typeof data === \"object\" ? data : { payload: data }),\n                    id: data?.id ?? UUIDv4(),\n                    event,\n                    ack\n                };\n\n                // Handle response\n                if (msg.type === \"response\" && msg.reqId) {\n                    const p = this._pending.get(msg.reqId);\n                    if (p) { p.resolve(msg.payload); this._pending.delete(msg.reqId); }\n                }\n\n                for (const s of this._subs) { try { s.next?.(msg); } catch (e) { s.error?.(e as Error); } }\n            };\n            this._socket.on(event, handler);\n            this._cleanups.push(() => this._socket.off(event, handler));\n        }\n\n        // Connection events\n        const onConnect = () => this._state.next(\"connected\");\n        const onDisconnect = () => this._state.next(\"disconnected\");\n        const onError = (err: any) => {\n            this._state.next(\"error\");\n            for (const s of this._subs) s.error?.(err instanceof Error ? err : new Error(String(err)));\n        };\n\n        this._socket.on(\"connect\", onConnect);\n        this._socket.on(\"disconnect\", onDisconnect);\n        this._socket.on(\"error\", onError);\n        this._cleanups.push(\n            () => this._socket.off(\"connect\", onConnect),\n            () => this._socket.off(\"disconnect\", onDisconnect),\n            () => this._socket.off(\"error\", onError)\n        );\n\n        this._listening = true;\n    }\n\n    private _deactivate(): void {\n        this._cleanups.forEach((fn) => fn());\n        this._cleanups = [];\n        this._listening = false;\n    }\n\n    close(): void {\n        this._subs.forEach((s) => s.complete?.());\n        this._subs.clear();\n        this._deactivate();\n        this._socket.disconnect?.();\n    }\n\n    get socket(): SocketIOLike { return this._socket; }\n    get channelName(): string { return this._channelName; }\n    get isConnected(): boolean { return this._socket.connected ?? false; }\n    get state() { return this._state; }\n}\n\n// ============================================================================\n// ROOM OBSERVABLE\n// ============================================================================\n\nexport class SocketIORoomObservable {\n    private _subs = new Set<Observer<SocketMessage>>();\n    private _parentSub: Subscription | null = null;\n\n    constructor(\n        private _parent: SocketIOObservable,\n        private _roomName: string\n    ) {}\n\n    send(msg: SocketMessage): void {\n        this._parent.send({ ...msg, room: this._roomName });\n    }\n\n    subscribe(observer: Observer<SocketMessage> | ((v: SocketMessage) => void)): Subscription {\n        const obs: Observer<SocketMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        const first = this._subs.size === 0;\n        this._subs.add(obs);\n\n        if (first && !this._parentSub) {\n            this._parentSub = this._parent.subscribe({\n                next: (msg) => {\n                    if (msg.room === this._roomName || msg.channel === this._roomName) {\n                        for (const s of this._subs) { try { s.next?.(msg); } catch (e) { s.error?.(e as Error); } }\n                    }\n                },\n                error: (e) => { for (const s of this._subs) s.error?.(e); },\n                complete: () => { for (const s of this._subs) s.complete?.(); }\n            });\n        }\n\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0) {\n                    this._parentSub?.unsubscribe();\n                    this._parentSub = null;\n                }\n            }\n        };\n    }\n\n    get roomName(): string { return this._roomName; }\n}\n\n// ============================================================================\n// REQUEST HANDLER\n// ============================================================================\n\nexport function createSocketRequestHandler(\n    channelName: string,\n    handlers: Record<string, (args: any[], data: SocketMessage) => any | Promise<any>>\n): (data: SocketMessage) => void {\n    return async (data) => {\n        if (data.type !== \"request\" || !data.ack) return;\n        const action = data.payload?.action;\n        if (action && handlers[action]) {\n            try {\n                const result = await handlers[action](data.payload?.args ?? [], data);\n                data.ack({ id: UUIDv4(), channel: data.sender, sender: channelName, reqId: data.reqId, type: \"response\", payload: { result }, timestamp: Date.now() });\n            } catch (error) {\n                data.ack({ id: UUIDv4(), channel: data.sender, sender: channelName, reqId: data.reqId, type: \"response\", payload: { error: error instanceof Error ? error.message : String(error) }, timestamp: Date.now() });\n            }\n        }\n    };\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const SocketIOObservableFactory = {\n    create: (socket: SocketIOLike, channelName: string, options?: SocketObservableOptions) =>\n        new SocketIOObservable(socket, channelName, options),\n    room: (parent: SocketIOObservable, roomName: string) =>\n        new SocketIORoomObservable(parent, roomName)\n};\n\nexport function createSocketObservable(\n    socket: SocketIOLike,\n    channelName: string,\n    options?: SocketObservableOptions\n): SocketIOObservable {\n    return new SocketIOObservable(socket, channelName, options);\n}\n","/**\n * SharedWorker Transport\n *\n * Enables shared worker communication across multiple tabs/windows.\n * SharedWorker provides a shared context that persists across all\n * connected browsing contexts.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\nimport type { ChannelMessage, PendingRequest, Subscriber } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface SharedWorkerMessage<T = any> extends ChannelMessage {\n    portId?: string;\n    broadcast?: boolean;\n}\n\nexport interface SharedWorkerOptions {\n    name?: string;\n    credentials?: RequestCredentials;\n    type?: WorkerType;\n    autoConnect?: boolean;\n}\n\nexport interface SharedWorkerPortInfo {\n    id: string;\n    connectedAt: number;\n    lastSeen: number;\n    metadata?: Record<string, any>;\n}\n\n// ============================================================================\n// SHARED WORKER CLIENT (Page/Tab Side)\n// ============================================================================\n\n/**\n * SharedWorker client - connects to a shared worker from page/tab\n */\nexport class SharedWorkerClient {\n    private _worker: SharedWorker | null = null;\n    private _port: MessagePort | null = null;\n    private _subs = new Set<Observer<SharedWorkerMessage>>();\n    private _pending = new Map<string, PendingRequest>();\n    private _listening = false;\n    private _cleanup: (() => void) | null = null;\n    private _portId: string = UUIDv4();\n    private _state = new ChannelSubject<\"connecting\" | \"connected\" | \"disconnected\" | \"error\">();\n\n    constructor(\n        private _scriptUrl: string | URL,\n        private _channelName: string,\n        private _options: SharedWorkerOptions = {}\n    ) {\n        if (_options.autoConnect !== false) this.connect();\n    }\n\n    connect(): void {\n        if (this._worker) return;\n\n        try {\n            this._worker = new SharedWorker(this._scriptUrl, {\n                name: this._options.name,\n                credentials: this._options.credentials,\n                type: this._options.type\n            });\n            this._port = this._worker.port;\n            this._setupListeners();\n            this._port.start();\n            this._state.next(\"connecting\");\n\n            // Send handshake\n            this.send({\n                id: UUIDv4(),\n                channel: this._channelName,\n                sender: this._portId,\n                type: \"signal\",\n                payload: { action: \"connect\", portId: this._portId }\n            });\n        } catch (e) {\n            this._state.next(\"error\");\n            throw e;\n        }\n    }\n\n    send(msg: SharedWorkerMessage, transfer?: Transferable[]): void {\n        if (!this._port) return;\n        const { transferable, ...data } = msg as any;\n        this._port.postMessage({ ...data, portId: this._portId }, transfer ?? []);\n    }\n\n    request(msg: Omit<SharedWorkerMessage, \"reqId\"> & { reqId?: string }): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                if (this._pending.has(reqId)) {\n                    this._pending.delete(reqId);\n                    reject(new Error(\"Request timeout\"));\n                }\n            }, 30000);\n\n            this._pending.set(reqId, {\n                resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                reject: (e) => { clearTimeout(timeout); reject(e); },\n                timestamp: Date.now()\n            });\n\n            this.send({ ...msg, reqId, type: \"request\" } as SharedWorkerMessage);\n        });\n    }\n\n    broadcast(msg: SharedWorkerMessage, transfer?: Transferable[]): void {\n        this.send({ ...msg, broadcast: true }, transfer);\n    }\n\n    subscribe(observer: Observer<SharedWorkerMessage> | ((v: SharedWorkerMessage) => void)): Subscription {\n        const obs: Observer<SharedWorkerMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        if (!this._listening) this._activate();\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0) this._deactivate();\n            }\n        };\n    }\n\n    private _setupListeners(): void {\n        if (!this._port) return;\n\n        const msgHandler = (e: MessageEvent) => {\n            const data = e.data as SharedWorkerMessage;\n\n            // Handle connection acknowledgment\n            if (data.type === \"signal\" && data.payload?.action === \"connected\") {\n                this._state.next(\"connected\");\n            }\n\n            // Handle response\n            if (data.type === \"response\" && data.reqId) {\n                const p = this._pending.get(data.reqId);\n                if (p) {\n                    this._pending.delete(data.reqId);\n                    if (data.payload?.error) p.reject(new Error(data.payload.error));\n                    else p.resolve(data.payload?.result ?? data.payload);\n                }\n            }\n\n            for (const s of this._subs) {\n                try { s.next?.(data); } catch (e) { s.error?.(e as Error); }\n            }\n        };\n\n        const errHandler = (e: MessageEvent) => {\n            this._state.next(\"error\");\n            const err = new Error(\"SharedWorker error\");\n            for (const s of this._subs) s.error?.(err);\n        };\n\n        this._port.addEventListener(\"message\", msgHandler);\n        this._port.addEventListener(\"messageerror\", errHandler);\n        this._cleanup = () => {\n            this._port?.removeEventListener(\"message\", msgHandler);\n            this._port?.removeEventListener(\"messageerror\", errHandler);\n        };\n    }\n\n    private _activate(): void { this._listening = true; }\n    private _deactivate(): void {\n        this._cleanup?.();\n        this._cleanup = null;\n        this._listening = false;\n    }\n\n    disconnect(): void {\n        this.send({\n            id: UUIDv4(),\n            channel: this._channelName,\n            sender: this._portId,\n            type: \"signal\",\n            payload: { action: \"disconnect\", portId: this._portId }\n        });\n        this._deactivate();\n        this._port?.close();\n        this._port = null;\n        this._worker = null;\n        this._state.next(\"disconnected\");\n    }\n\n    close(): void {\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        this.disconnect();\n    }\n\n    get port(): MessagePort | null { return this._port; }\n    get portId(): string { return this._portId; }\n    get isConnected(): boolean { return this._state.getValue() === \"connected\"; }\n    get state() { return this._state; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// SHARED WORKER HOST (Inside SharedWorker)\n// ============================================================================\n\n/**\n * SharedWorker host - runs inside the shared worker context\n */\nexport class SharedWorkerHost {\n    private _ports = new Map<string, { port: MessagePort; info: SharedWorkerPortInfo }>();\n    private _subs = new Set<Observer<SharedWorkerMessage>>();\n    private _state = new ChannelSubject<\"ready\" | \"error\">();\n\n    constructor(private _channelName: string) {\n        this._setupGlobalHandler();\n    }\n\n    private _setupGlobalHandler(): void {\n        // In SharedWorker context, `self` has `onconnect`\n        if (typeof self !== \"undefined\" && \"onconnect\" in self) {\n            (self as any).onconnect = (e: MessageEvent) => {\n                const port = e.ports[0];\n                const portId = UUIDv4();\n                this._registerPort(portId, port);\n            };\n            this._state.next(\"ready\");\n        }\n    }\n\n    private _registerPort(portId: string, port: MessagePort): void {\n        const info: SharedWorkerPortInfo = {\n            id: portId,\n            connectedAt: Date.now(),\n            lastSeen: Date.now()\n        };\n\n        port.onmessage = (e: MessageEvent) => {\n            const data = e.data as SharedWorkerMessage;\n            info.lastSeen = Date.now();\n\n            // Handle connection message\n            if (data.type === \"signal\") {\n                if (data.payload?.action === \"connect\") {\n                    const realPortId = data.payload.portId || portId;\n                    // Update mapping with real portId\n                    this._ports.delete(portId);\n                    info.id = realPortId;\n                    this._ports.set(realPortId, { port, info });\n\n                    // Send acknowledgment\n                    port.postMessage({\n                        id: UUIDv4(),\n                        channel: this._channelName,\n                        sender: \"host\",\n                        type: \"signal\",\n                        payload: { action: \"connected\", portId: realPortId }\n                    });\n                    return;\n                }\n\n                if (data.payload?.action === \"disconnect\") {\n                    this._unregisterPort(data.portId ?? portId);\n                    return;\n                }\n            }\n\n            // Handle broadcast\n            if (data.broadcast) {\n                this.broadcast(data, data.portId ?? portId);\n            }\n\n            // Notify subscribers\n            for (const s of this._subs) {\n                try { s.next?.({ ...data, portId: data.portId ?? portId }); }\n                catch (e) { s.error?.(e as Error); }\n            }\n        };\n\n        port.onmessageerror = (e: MessageEvent) => {\n            const err = new Error(\"Port message error\");\n            for (const s of this._subs) s.error?.(err);\n        };\n\n        port.start();\n        this._ports.set(portId, { port, info });\n    }\n\n    private _unregisterPort(portId: string): void {\n        const entry = this._ports.get(portId);\n        if (entry) {\n            entry.port.close();\n            this._ports.delete(portId);\n        }\n    }\n\n    send(portId: string, msg: SharedWorkerMessage, transfer?: Transferable[]): void {\n        const entry = this._ports.get(portId);\n        if (!entry) return;\n        const { transferable, ...data } = msg as any;\n        entry.port.postMessage(data, transfer ?? []);\n    }\n\n    broadcast(msg: SharedWorkerMessage, excludePortId?: string): void {\n        const { transferable, ...data } = msg as any;\n        for (const [id, entry] of this._ports) {\n            if (id !== excludePortId) {\n                entry.port.postMessage({ ...data, broadcast: true });\n            }\n        }\n    }\n\n    respond(msg: SharedWorkerMessage, result: any, transfer?: Transferable[]): void {\n        if (!msg.portId || !msg.reqId) return;\n        this.send(msg.portId, {\n            id: UUIDv4(),\n            channel: msg.sender,\n            sender: this._channelName,\n            type: \"response\",\n            reqId: msg.reqId,\n            payload: { result }\n        }, transfer);\n    }\n\n    subscribe(observer: Observer<SharedWorkerMessage> | ((v: SharedWorkerMessage) => void)): Subscription {\n        const obs: Observer<SharedWorkerMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    getPorts(): Map<string, SharedWorkerPortInfo> {\n        const result = new Map<string, SharedWorkerPortInfo>();\n        for (const [id, entry] of this._ports) {\n            result.set(id, { ...entry.info });\n        }\n        return result;\n    }\n\n    get portCount(): number { return this._ports.size; }\n    get state() { return this._state; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// OBSERVABLE WRAPPER\n// ============================================================================\n\nexport function createSharedWorkerObservable(\n    scriptUrl: string | URL,\n    channelName: string,\n    options?: SharedWorkerOptions\n): SharedWorkerClient {\n    return new SharedWorkerClient(scriptUrl, channelName, options);\n}\n\nexport function createSharedWorkerHostObservable(channelName: string): SharedWorkerHost {\n    return new SharedWorkerHost(channelName);\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const SharedWorkerObservableFactory = {\n    client: (url: string | URL, name: string, opts?: SharedWorkerOptions) =>\n        new SharedWorkerClient(url, name, opts),\n    host: (name: string) => new SharedWorkerHost(name)\n};\n","/**\n * SharedArrayBuffer + Atomics Transport\n *\n * High-performance inter-worker communication using shared memory.\n * Uses CBOR-X for efficient binary serialization.\n *\n * Features:\n * - Zero-copy message passing between workers\n * - Lock-free synchronization with Atomics\n * - CBOR-X encoding for compact binary format\n * - Supports ArrayBuffer.transfer() for ownership transfer\n *\n * References:\n * - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\n * - https://tc39.es/ecma262/multipage/memory-model.html\n * - https://github.com/kriszyp/cbor-x\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\nimport type { ChannelMessage, PendingRequest, Subscriber } from \"../types/Interface\";\n\n// ============================================================================\n// CBOR-X INTERFACE (Dynamic Import)\n// ============================================================================\n\ninterface CBOREncoder {\n    encode(value: any): Uint8Array;\n    decode(data: Uint8Array): any;\n}\n\nlet cborEncoder: CBOREncoder | null = null;\n\nasync function getCBOREncoder(): Promise<CBOREncoder> {\n    if (cborEncoder) return cborEncoder;\n\n    try {\n        // @ts-ignore - Dynamic import of cbor-x\n        const cborx = await import(\"cbor-x\");\n        cborEncoder = {\n            encode: (v) => cborx.encode(v),\n            decode: (d) => cborx.decode(d)\n        };\n    } catch {\n        // Fallback to JSON with typed array support\n        cborEncoder = {\n            encode: (v) => new TextEncoder().encode(JSON.stringify(v, replacer)),\n            decode: (d) => JSON.parse(new TextDecoder().decode(d), reviver)\n        };\n    }\n\n    return cborEncoder;\n}\n\n// JSON serialization with TypedArray support\nfunction replacer(_key: string, value: any): any {\n    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {\n        return {\n            __typedArray: true,\n            type: value.constructor.name,\n            data: Array.from(value as any)\n        };\n    }\n    if (value instanceof ArrayBuffer) {\n        return {\n            __arrayBuffer: true,\n            data: Array.from(new Uint8Array(value))\n        };\n    }\n    return value;\n}\n\nfunction reviver(_key: string, value: any): any {\n    if (value?.__typedArray) {\n        const TypedArrayCtor = (globalThis as any)[value.type];\n        return TypedArrayCtor ? new TypedArrayCtor(value.data) : value.data;\n    }\n    if (value?.__arrayBuffer) {\n        return new Uint8Array(value.data).buffer;\n    }\n    return value;\n}\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface AtomicsMessage<T = any> extends ChannelMessage {\n    /** Message sequence number */\n    seq?: number;\n    /** Worker ID that sent the message */\n    workerId?: string;\n}\n\nexport interface AtomicsTransportConfig {\n    /** Size of shared buffer in bytes (default: 64KB) */\n    bufferSize?: number;\n    /** Maximum message size (default: 60KB) */\n    maxMessageSize?: number;\n    /** Enable message compression (requires CBOR-X) */\n    compression?: boolean;\n    /** Timeout for atomic wait operations (ms) */\n    waitTimeout?: number;\n    /** Use Atomics.waitAsync when available (non-blocking) */\n    useAsyncWait?: boolean;\n}\n\n/** Shared memory layout constants */\nconst HEADER_SIZE = 32;  // Control header size\nconst LOCK_OFFSET = 0;   // Lock flag (Int32)\nconst SEQ_OFFSET = 4;    // Sequence number (Int32)\nconst SIZE_OFFSET = 8;   // Message size (Int32)\nconst FLAGS_OFFSET = 12; // Flags (Int32)\nconst READY_OFFSET = 16; // Ready signal (Int32)\nconst ACK_OFFSET = 20;   // Acknowledgment (Int32)\nconst DATA_OFFSET = HEADER_SIZE;\n\n// Flag bits\nconst FLAG_HAS_TRANSFER = 1 << 0;\nconst FLAG_COMPRESSED = 1 << 1;\nconst FLAG_RESPONSE = 1 << 2;\n\n// ============================================================================\n// ATOMICS BUFFER MANAGER\n// ============================================================================\n\nexport class AtomicsBuffer {\n    private _sharedBuffer: SharedArrayBuffer;\n    private _int32View: Int32Array;\n    private _uint8View: Uint8Array;\n    private _maxDataSize: number;\n\n    constructor(\n        bufferOrSize: SharedArrayBuffer | number = 65536,\n        private _config: AtomicsTransportConfig = {}\n    ) {\n        if (typeof bufferOrSize === \"number\") {\n            this._sharedBuffer = new SharedArrayBuffer(bufferOrSize);\n        } else {\n            this._sharedBuffer = bufferOrSize;\n        }\n\n        this._int32View = new Int32Array(this._sharedBuffer);\n        this._uint8View = new Uint8Array(this._sharedBuffer);\n        this._maxDataSize = this._config.maxMessageSize ?? (this._sharedBuffer.byteLength - HEADER_SIZE);\n    }\n\n    /**\n     * Write message to shared buffer with lock\n     */\n    async write(data: Uint8Array, flags: number = 0): Promise<boolean> {\n        if (data.byteLength > this._maxDataSize) {\n            throw new Error(`Message too large: ${data.byteLength} > ${this._maxDataSize}`);\n        }\n\n        // Acquire lock using compare-and-swap\n        while (Atomics.compareExchange(this._int32View, LOCK_OFFSET / 4, 0, 1) !== 0) {\n            // Spin-wait with backoff\n            const result = this._config.useAsyncWait && \"waitAsync\" in Atomics\n                // @ts-ignore - waitAsync is newer API\n                ? await Atomics.waitAsync(this._int32View, LOCK_OFFSET / 4, 1, this._config.waitTimeout ?? 100).value\n                : Atomics.wait(this._int32View, LOCK_OFFSET / 4, 1, this._config.waitTimeout ?? 100);\n\n            if (result === \"timed-out\") continue;\n        }\n\n        try {\n            // Write message size\n            Atomics.store(this._int32View, SIZE_OFFSET / 4, data.byteLength);\n\n            // Write flags\n            Atomics.store(this._int32View, FLAGS_OFFSET / 4, flags);\n\n            // Copy data\n            this._uint8View.set(data, DATA_OFFSET);\n\n            // Increment sequence\n            Atomics.add(this._int32View, SEQ_OFFSET / 4, 1);\n\n            // Signal ready\n            Atomics.store(this._int32View, READY_OFFSET / 4, 1);\n            Atomics.notify(this._int32View, READY_OFFSET / 4);\n\n            return true;\n        } finally {\n            // Release lock\n            Atomics.store(this._int32View, LOCK_OFFSET / 4, 0);\n            Atomics.notify(this._int32View, LOCK_OFFSET / 4);\n        }\n    }\n\n    /**\n     * Read message from shared buffer\n     */\n    async read(): Promise<{ data: Uint8Array; flags: number; seq: number } | null> {\n        // Wait for ready signal\n        const readyValue = Atomics.load(this._int32View, READY_OFFSET / 4);\n        if (readyValue === 0) {\n            const result = this._config.useAsyncWait && \"waitAsync\" in Atomics\n                // @ts-ignore - waitAsync is newer API\n                ? await Atomics.waitAsync(this._int32View, READY_OFFSET / 4, 0, this._config.waitTimeout ?? 1000).value\n                : Atomics.wait(this._int32View, READY_OFFSET / 4, 0, this._config.waitTimeout ?? 1000);\n\n            if (result === \"timed-out\") return null;\n        }\n\n        // Read message\n        const size = Atomics.load(this._int32View, SIZE_OFFSET / 4);\n        const flags = Atomics.load(this._int32View, FLAGS_OFFSET / 4);\n        const seq = Atomics.load(this._int32View, SEQ_OFFSET / 4);\n\n        if (size <= 0 || size > this._maxDataSize) return null;\n\n        // Copy data out\n        const data = new Uint8Array(size);\n        data.set(this._uint8View.subarray(DATA_OFFSET, DATA_OFFSET + size));\n\n        // Clear ready signal\n        Atomics.store(this._int32View, READY_OFFSET / 4, 0);\n\n        // Send acknowledgment\n        Atomics.add(this._int32View, ACK_OFFSET / 4, 1);\n        Atomics.notify(this._int32View, ACK_OFFSET / 4);\n\n        return { data, flags, seq };\n    }\n\n    /**\n     * Wait for acknowledgment\n     */\n    async waitAck(expectedSeq: number): Promise<boolean> {\n        const timeout = this._config.waitTimeout ?? 5000;\n        const start = Date.now();\n\n        while (Date.now() - start < timeout) {\n            const ack = Atomics.load(this._int32View, ACK_OFFSET / 4);\n            if (ack >= expectedSeq) return true;\n\n            if (this._config.useAsyncWait && \"waitAsync\" in Atomics) {\n                // @ts-ignore\n                await Atomics.waitAsync(this._int32View, ACK_OFFSET / 4, ack, 100).value;\n            } else {\n                await new Promise(r => setTimeout(r, 10));\n            }\n        }\n\n        return false;\n    }\n\n    get buffer(): SharedArrayBuffer { return this._sharedBuffer; }\n    get currentSeq(): number { return Atomics.load(this._int32View, SEQ_OFFSET / 4); }\n}\n\n// ============================================================================\n// ATOMICS TRANSPORT\n// ============================================================================\n\nexport class AtomicsTransport {\n    private _sendBuffer: AtomicsBuffer;\n    private _recvBuffer: AtomicsBuffer;\n    private _encoder: CBOREncoder | null = null;\n    private _subs = new Set<Observer<AtomicsMessage>>();\n    private _pending = new Map<string, PendingRequest>();\n    private _polling = false;\n    private _pollAbort: AbortController | null = null;\n    private _workerId: string = UUIDv4();\n    private _lastSeq = 0;\n    private _state = new ChannelSubject<\"ready\" | \"polling\" | \"stopped\" | \"error\">();\n\n    constructor(\n        private _channelName: string,\n        sendBuffer: SharedArrayBuffer | AtomicsBuffer,\n        recvBuffer: SharedArrayBuffer | AtomicsBuffer,\n        private _config: AtomicsTransportConfig = {}\n    ) {\n        this._sendBuffer = sendBuffer instanceof AtomicsBuffer\n            ? sendBuffer : new AtomicsBuffer(sendBuffer, _config);\n        this._recvBuffer = recvBuffer instanceof AtomicsBuffer\n            ? recvBuffer : new AtomicsBuffer(recvBuffer, _config);\n\n        this._init();\n    }\n\n    private async _init(): Promise<void> {\n        this._encoder = await getCBOREncoder();\n        this._state.next(\"ready\");\n    }\n\n    async send(msg: AtomicsMessage, transfer?: Transferable[]): Promise<void> {\n        if (!this._encoder) await this._init();\n\n        const { transferable, ...data } = msg as any;\n        let flags = 0;\n\n        // Handle transferables - encode references\n        if (transfer?.length) {\n            flags |= FLAG_HAS_TRANSFER;\n            data._transferMeta = transfer.map((t, i) => ({\n                index: i,\n                type: t.constructor.name,\n                // Use ArrayBuffer.transfer() if available (ES2024+)\n                // @ts-ignore - Modern API\n                transferred: t instanceof ArrayBuffer && \"transfer\" in t\n            }));\n        }\n\n        const encoded = this._encoder!.encode(data);\n\n        if (this._config.compression && encoded.length > 1024) {\n            // Could add compression here\n            flags |= FLAG_COMPRESSED;\n        }\n\n        await this._sendBuffer.write(encoded, flags);\n    }\n\n    async request(msg: Omit<AtomicsMessage, \"reqId\"> & { reqId?: string }): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this._pending.delete(reqId);\n                reject(new Error(\"Request timeout\"));\n            }, this._config.waitTimeout ?? 30000);\n\n            this._pending.set(reqId, {\n                resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                reject: (e) => { clearTimeout(timeout); reject(e); },\n                timestamp: Date.now()\n            });\n\n            this.send({ ...msg, reqId, type: \"request\" } as AtomicsMessage);\n        });\n    }\n\n    subscribe(observer: Observer<AtomicsMessage> | ((v: AtomicsMessage) => void)): Subscription {\n        const obs: Observer<AtomicsMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        if (!this._polling) this._startPolling();\n        return {\n            closed: false,\n            unsubscribe: () => {\n                this._subs.delete(obs);\n                if (this._subs.size === 0) this._stopPolling();\n            }\n        };\n    }\n\n    private async _startPolling(): Promise<void> {\n        if (this._polling) return;\n        this._polling = true;\n        this._pollAbort = new AbortController();\n        this._state.next(\"polling\");\n\n        while (this._polling && !this._pollAbort.signal.aborted) {\n            try {\n                const result = await this._recvBuffer.read();\n                if (!result) continue;\n\n                // Skip already processed messages\n                if (result.seq <= this._lastSeq) continue;\n                this._lastSeq = result.seq;\n\n                const data = this._encoder!.decode(result.data) as AtomicsMessage;\n                data.seq = result.seq;\n                data.workerId = data.workerId ?? this._workerId;\n\n                // Handle response\n                if ((result.flags & FLAG_RESPONSE) || data.type === \"response\") {\n                    if (data.reqId) {\n                        const p = this._pending.get(data.reqId);\n                        if (p) {\n                            this._pending.delete(data.reqId);\n                            if (data.payload?.error) p.reject(new Error(data.payload.error));\n                            else p.resolve(data.payload?.result ?? data.payload);\n                            continue;\n                        }\n                    }\n                }\n\n                for (const s of this._subs) {\n                    try { s.next?.(data); } catch (e) { s.error?.(e as Error); }\n                }\n            } catch (e) {\n                for (const s of this._subs) s.error?.(e as Error);\n            }\n        }\n    }\n\n    private _stopPolling(): void {\n        this._polling = false;\n        this._pollAbort?.abort();\n        this._pollAbort = null;\n        this._state.next(\"stopped\");\n    }\n\n    close(): void {\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        this._stopPolling();\n    }\n\n    get sendBuffer(): SharedArrayBuffer { return this._sendBuffer.buffer; }\n    get recvBuffer(): SharedArrayBuffer { return this._recvBuffer.buffer; }\n    get workerId(): string { return this._workerId; }\n    get state() { return this._state; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// BIDIRECTIONAL ATOMICS CHANNEL\n// ============================================================================\n\nexport interface AtomicsChannelPair {\n    main: AtomicsTransport;\n    worker: { sendBuffer: SharedArrayBuffer; recvBuffer: SharedArrayBuffer };\n}\n\n/**\n * Create a bidirectional atomics channel for main<->worker communication\n */\nexport function createAtomicsChannelPair(\n    channelName: string,\n    config: AtomicsTransportConfig = {}\n): AtomicsChannelPair {\n    const bufferSize = config.bufferSize ?? 65536;\n    const bufferA = new SharedArrayBuffer(bufferSize);\n    const bufferB = new SharedArrayBuffer(bufferSize);\n\n    // Main thread: sends to A, receives from B\n    const main = new AtomicsTransport(channelName, bufferA, bufferB, config);\n\n    // Worker: sends to B, receives from A (swapped)\n    return {\n        main,\n        worker: { sendBuffer: bufferB, recvBuffer: bufferA }\n    };\n}\n\n/**\n * Create worker-side atomics transport from buffers\n */\nexport function createWorkerAtomicsTransport(\n    channelName: string,\n    sendBuffer: SharedArrayBuffer,\n    recvBuffer: SharedArrayBuffer,\n    config: AtomicsTransportConfig = {}\n): AtomicsTransport {\n    return new AtomicsTransport(channelName, sendBuffer, recvBuffer, config);\n}\n\n// ============================================================================\n// RING BUFFER (Advanced multi-message queue)\n// ============================================================================\n\nexport interface RingBufferConfig {\n    /** Total buffer size (must be power of 2) */\n    bufferSize?: number;\n    /** Individual slot size */\n    slotSize?: number;\n    /** Number of slots */\n    slotCount?: number;\n}\n\n/**\n * Lock-free ring buffer for high-throughput message passing\n */\nexport class AtomicsRingBuffer {\n    private _buffer: SharedArrayBuffer;\n    private _meta: Int32Array;\n    private _data: Uint8Array;\n    private _slotSize: number;\n    private _slotCount: number;\n    private _mask: number;\n\n    // Meta layout: [writeIndex, readIndex, overflow]\n    private static META_SIZE = 16;\n    private static WRITE_IDX = 0;\n    private static READ_IDX = 4;\n    private static OVERFLOW = 8;\n\n    constructor(bufferOrConfig: SharedArrayBuffer | RingBufferConfig = {}) {\n        if (bufferOrConfig instanceof SharedArrayBuffer) {\n            this._buffer = bufferOrConfig;\n            // Extract config from buffer size\n            this._slotCount = 64;\n            this._slotSize = (this._buffer.byteLength - AtomicsRingBuffer.META_SIZE) / this._slotCount;\n        } else {\n            this._slotSize = bufferOrConfig.slotSize ?? 1024;\n            this._slotCount = bufferOrConfig.slotCount ?? 64;\n            // Round up to power of 2\n            this._slotCount = 1 << Math.ceil(Math.log2(this._slotCount));\n            const totalSize = AtomicsRingBuffer.META_SIZE + (this._slotSize * this._slotCount);\n            this._buffer = new SharedArrayBuffer(totalSize);\n        }\n\n        this._meta = new Int32Array(this._buffer, 0, AtomicsRingBuffer.META_SIZE / 4);\n        this._data = new Uint8Array(this._buffer, AtomicsRingBuffer.META_SIZE);\n        this._mask = this._slotCount - 1;\n    }\n\n    /**\n     * Write message to ring buffer (non-blocking)\n     */\n    write(data: Uint8Array): boolean {\n        if (data.byteLength > this._slotSize - 4) return false;\n\n        const writeIdx = Atomics.load(this._meta, AtomicsRingBuffer.WRITE_IDX);\n        const readIdx = Atomics.load(this._meta, AtomicsRingBuffer.READ_IDX);\n\n        // Check if buffer is full\n        if (((writeIdx + 1) & this._mask) === (readIdx & this._mask)) {\n            Atomics.add(this._meta, AtomicsRingBuffer.OVERFLOW, 1);\n            return false;\n        }\n\n        const slot = (writeIdx & this._mask) * this._slotSize;\n\n        // Write size first (4 bytes)\n        new DataView(this._buffer, AtomicsRingBuffer.META_SIZE + slot).setUint32(0, data.byteLength, true);\n\n        // Write data\n        this._data.set(data, slot + 4);\n\n        // Update write index\n        Atomics.store(this._meta, AtomicsRingBuffer.WRITE_IDX, writeIdx + 1);\n        Atomics.notify(this._meta, AtomicsRingBuffer.WRITE_IDX);\n\n        return true;\n    }\n\n    /**\n     * Read message from ring buffer (non-blocking)\n     */\n    read(): Uint8Array | null {\n        const writeIdx = Atomics.load(this._meta, AtomicsRingBuffer.WRITE_IDX);\n        const readIdx = Atomics.load(this._meta, AtomicsRingBuffer.READ_IDX);\n\n        // Check if buffer is empty\n        if (readIdx === writeIdx) return null;\n\n        const slot = (readIdx & this._mask) * this._slotSize;\n\n        // Read size\n        const size = new DataView(this._buffer, AtomicsRingBuffer.META_SIZE + slot).getUint32(0, true);\n        if (size === 0 || size > this._slotSize - 4) return null;\n\n        // Copy data\n        const data = new Uint8Array(size);\n        data.set(this._data.subarray(slot + 4, slot + 4 + size));\n\n        // Update read index\n        Atomics.store(this._meta, AtomicsRingBuffer.READ_IDX, readIdx + 1);\n\n        return data;\n    }\n\n    /**\n     * Wait for data to be available\n     */\n    async waitRead(timeout?: number): Promise<Uint8Array | null> {\n        const writeIdx = Atomics.load(this._meta, AtomicsRingBuffer.WRITE_IDX);\n        const readIdx = Atomics.load(this._meta, AtomicsRingBuffer.READ_IDX);\n\n        if (readIdx < writeIdx) return this.read();\n\n        // @ts-ignore\n        if (\"waitAsync\" in Atomics) {\n            // @ts-ignore\n            const result = await Atomics.waitAsync(this._meta, AtomicsRingBuffer.WRITE_IDX, writeIdx, timeout ?? 1000).value;\n            if (result === \"ok\") return this.read();\n        } else {\n            await new Promise(r => setTimeout(r, Math.min(timeout ?? 1000, 100)));\n            return this.read();\n        }\n\n        return null;\n    }\n\n    get buffer(): SharedArrayBuffer { return this._buffer; }\n    get available(): number {\n        const w = Atomics.load(this._meta, AtomicsRingBuffer.WRITE_IDX);\n        const r = Atomics.load(this._meta, AtomicsRingBuffer.READ_IDX);\n        return (w - r) & this._mask;\n    }\n    get overflow(): number { return Atomics.load(this._meta, AtomicsRingBuffer.OVERFLOW); }\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const AtomicsTransportFactory = {\n    create: (name: string, send: SharedArrayBuffer, recv: SharedArrayBuffer, config?: AtomicsTransportConfig) =>\n        new AtomicsTransport(name, send, recv, config),\n    createPair: (name: string, config?: AtomicsTransportConfig) =>\n        createAtomicsChannelPair(name, config),\n    createBuffer: (sizeOrBuffer?: SharedArrayBuffer | number, config?: AtomicsTransportConfig) =>\n        new AtomicsBuffer(sizeOrBuffer, config),\n    createRingBuffer: (config?: RingBufferConfig) =>\n        new AtomicsRingBuffer(config),\n    getCBOR: getCBOREncoder\n};\n","/**\n * WebRTC DataChannel Transport\n *\n * P2P communication using WebRTC DataChannels.\n * Enables direct browser-to-browser communication without a server relay.\n *\n * Features:\n * - Peer-to-peer messaging\n * - Binary data support\n * - Ordered/unordered delivery\n * - Reliable/unreliable modes\n * - SCTP-based flow control\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\nimport type { ChannelMessage, PendingRequest, Subscriber } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface RTCMessage<T = any> extends ChannelMessage {\n    peerId?: string;\n    dataChannelLabel?: string;\n    binary?: boolean;\n}\n\nexport interface RTCTransportConfig {\n    /** ICE servers for STUN/TURN */\n    iceServers?: RTCIceServer[];\n    /** Data channel options */\n    dataChannelOptions?: RTCDataChannelInit;\n    /** Signaling method */\n    signaling?: RTCSignaling;\n    /** Auto-negotiate on connect */\n    autoNegotiate?: boolean;\n    /** Binary serialization format */\n    binaryFormat?: \"json\" | \"cbor\" | \"msgpack\";\n    /** Connection timeout (ms) */\n    connectionTimeout?: number;\n}\n\nexport interface RTCSignaling {\n    /** Send signaling message to peer */\n    send(peerId: string, message: RTCSignalMessage): void | Promise<void>;\n    /** Subscribe to signaling messages */\n    onMessage(handler: (message: RTCSignalMessage) => void): Subscription | (() => void);\n}\n\nexport interface RTCSignalMessage {\n    type: \"offer\" | \"answer\" | \"ice-candidate\" | \"disconnect\";\n    fromPeerId: string;\n    toPeerId: string;\n    sdp?: string;\n    candidate?: RTCIceCandidateInit;\n}\n\nexport interface RTCPeerInfo {\n    id: string;\n    connectionState: RTCPeerConnectionState;\n    iceConnectionState: RTCIceConnectionState;\n    dataChannelState: RTCDataChannelState;\n    connectedAt?: number;\n    lastSeen?: number;\n}\n\n// ============================================================================\n// DEFAULT ICE SERVERS\n// ============================================================================\n\nconst DEFAULT_ICE_SERVERS: RTCIceServer[] = [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    { urls: \"stun:stun1.l.google.com:19302\" },\n    { urls: \"stun:stun2.l.google.com:19302\" }\n];\n\n// ============================================================================\n// RTC PEER CONNECTION WRAPPER\n// ============================================================================\n\nexport class RTCPeerTransport {\n    private _pc: RTCPeerConnection;\n    private _channel: RTCDataChannel | null = null;\n    private _subs = new Set<Observer<RTCMessage>>();\n    private _pending = new Map<string, PendingRequest>();\n    private _localId: string = UUIDv4();\n    private _remoteId: string | null = null;\n    private _state = new ChannelSubject<RTCPeerConnectionState>();\n    private _channelState = new ChannelSubject<RTCDataChannelState>();\n    private _iceCandidates: RTCIceCandidateInit[] = [];\n    private _iceGatheringComplete = false;\n\n    constructor(\n        private _channelName: string,\n        private _config: RTCTransportConfig = {}\n    ) {\n        this._pc = new RTCPeerConnection({\n            iceServers: _config.iceServers ?? DEFAULT_ICE_SERVERS\n        });\n        this._setupPeerConnection();\n    }\n\n    private _setupPeerConnection(): void {\n        this._pc.onicecandidate = (e) => {\n            if (e.candidate) {\n                this._iceCandidates.push(e.candidate.toJSON());\n                if (this._remoteId && this._config.signaling) {\n                    this._config.signaling.send(this._remoteId, {\n                        type: \"ice-candidate\",\n                        fromPeerId: this._localId,\n                        toPeerId: this._remoteId,\n                        candidate: e.candidate.toJSON()\n                    });\n                }\n            }\n        };\n\n        this._pc.onicegatheringstatechange = () => {\n            if (this._pc.iceGatheringState === \"complete\") {\n                this._iceGatheringComplete = true;\n            }\n        };\n\n        this._pc.onconnectionstatechange = () => {\n            this._state.next(this._pc.connectionState);\n            if (this._pc.connectionState === \"failed\" || this._pc.connectionState === \"disconnected\") {\n                for (const s of this._subs) s.error?.(new Error(`Connection ${this._pc.connectionState}`));\n            }\n        };\n\n        this._pc.ondatachannel = (e) => {\n            this._setupDataChannel(e.channel);\n        };\n    }\n\n    private _setupDataChannel(channel: RTCDataChannel): void {\n        this._channel = channel;\n        channel.binaryType = \"arraybuffer\";\n\n        channel.onopen = () => {\n            this._channelState.next(\"open\");\n        };\n\n        channel.onclose = () => {\n            this._channelState.next(\"closed\");\n            for (const s of this._subs) s.complete?.();\n        };\n\n        channel.onerror = (e) => {\n            const err = new Error(\"DataChannel error\");\n            for (const s of this._subs) s.error?.(err);\n        };\n\n        channel.onmessage = (e) => {\n            let data: RTCMessage;\n\n            if (typeof e.data === \"string\") {\n                data = JSON.parse(e.data);\n            } else {\n                // Binary data - decode based on format\n                data = this._decodeBinary(e.data);\n            }\n\n            data.peerId = this._remoteId ?? undefined;\n            data.dataChannelLabel = channel.label;\n\n            // Handle response\n            if (data.type === \"response\" && data.reqId) {\n                const p = this._pending.get(data.reqId);\n                if (p) {\n                    this._pending.delete(data.reqId);\n                    if (data.payload?.error) p.reject(new Error(data.payload.error));\n                    else p.resolve(data.payload?.result ?? data.payload);\n                    return;\n                }\n            }\n\n            for (const s of this._subs) {\n                try { s.next?.(data); } catch (e) { s.error?.(e as Error); }\n            }\n        };\n    }\n\n    /**\n     * Create offer to initiate connection\n     */\n    async createOffer(remoteId: string): Promise<RTCSignalMessage> {\n        this._remoteId = remoteId;\n\n        // Create data channel\n        const channel = this._pc.createDataChannel(this._channelName, this._config.dataChannelOptions);\n        this._setupDataChannel(channel);\n\n        // Create offer\n        const offer = await this._pc.createOffer();\n        await this._pc.setLocalDescription(offer);\n\n        return {\n            type: \"offer\",\n            fromPeerId: this._localId,\n            toPeerId: remoteId,\n            sdp: offer.sdp\n        };\n    }\n\n    /**\n     * Handle incoming offer\n     */\n    async handleOffer(signal: RTCSignalMessage): Promise<RTCSignalMessage> {\n        this._remoteId = signal.fromPeerId;\n\n        await this._pc.setRemoteDescription({\n            type: \"offer\",\n            sdp: signal.sdp\n        });\n\n        const answer = await this._pc.createAnswer();\n        await this._pc.setLocalDescription(answer);\n\n        return {\n            type: \"answer\",\n            fromPeerId: this._localId,\n            toPeerId: signal.fromPeerId,\n            sdp: answer.sdp\n        };\n    }\n\n    /**\n     * Handle incoming answer\n     */\n    async handleAnswer(signal: RTCSignalMessage): Promise<void> {\n        await this._pc.setRemoteDescription({\n            type: \"answer\",\n            sdp: signal.sdp\n        });\n    }\n\n    /**\n     * Handle incoming ICE candidate\n     */\n    async addIceCandidate(signal: RTCSignalMessage): Promise<void> {\n        if (signal.candidate) {\n            await this._pc.addIceCandidate(signal.candidate);\n        }\n    }\n\n    /**\n     * Send message to peer\n     */\n    send(msg: RTCMessage, binary?: boolean): void {\n        if (!this._channel || this._channel.readyState !== \"open\") return;\n\n        const { transferable, peerId, dataChannelLabel, ...data } = msg as any;\n\n        if (binary || msg.binary) {\n            this._channel.send(this._encodeBinary(data));\n        } else {\n            this._channel.send(JSON.stringify(data));\n        }\n    }\n\n    /**\n     * Send request and wait for response\n     */\n    request(msg: RTCMessage): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this._pending.delete(reqId);\n                reject(new Error(\"Request timeout\"));\n            }, this._config.connectionTimeout ?? 30000);\n\n            this._pending.set(reqId, {\n                resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                reject: (e) => { clearTimeout(timeout); reject(e); },\n                timestamp: Date.now()\n            });\n\n            this.send({ ...msg, reqId, type: \"request\" } as RTCMessage);\n        });\n    }\n\n    subscribe(observer: Observer<RTCMessage> | ((v: RTCMessage) => void)): Subscription {\n        const obs: Observer<RTCMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    private _encodeBinary(data: any): ArrayBuffer {\n        const json = JSON.stringify(data);\n        return new TextEncoder().encode(json).buffer;\n    }\n\n    private _decodeBinary(buffer: ArrayBuffer): RTCMessage {\n        const json = new TextDecoder().decode(buffer);\n        return JSON.parse(json);\n    }\n\n    close(): void {\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n\n        if (this._remoteId && this._config.signaling) {\n            this._config.signaling.send(this._remoteId, {\n                type: \"disconnect\",\n                fromPeerId: this._localId,\n                toPeerId: this._remoteId\n            });\n        }\n\n        this._channel?.close();\n        this._pc.close();\n    }\n\n    get localId(): string { return this._localId; }\n    get remoteId(): string | null { return this._remoteId; }\n    get connectionState(): RTCPeerConnectionState { return this._pc.connectionState; }\n    get channelState(): RTCDataChannelState | null { return this._channel?.readyState ?? null; }\n    get state() { return this._state; }\n    get channelStateObservable() { return this._channelState; }\n    get iceCandidates(): RTCIceCandidateInit[] { return [...this._iceCandidates]; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// RTC PEER MANAGER (Multi-peer)\n// ============================================================================\n\nexport class RTCPeerManager {\n    private _peers = new Map<string, RTCPeerTransport>();\n    private _localId: string = UUIDv4();\n    private _subs = new Set<Observer<RTCMessage>>();\n    private _signalingCleanup: (() => void) | null = null;\n    private _peerEvents = new ChannelSubject<{\n        type: \"connected\" | \"disconnected\" | \"failed\";\n        peerId: string;\n        peer?: RTCPeerTransport;\n    }>();\n\n    constructor(\n        private _channelName: string,\n        private _config: RTCTransportConfig = {}\n    ) {\n        this._setupSignaling();\n    }\n\n    private _setupSignaling(): void {\n        if (!this._config.signaling) return;\n\n        const cleanup = this._config.signaling.onMessage(async (signal) => {\n            if (signal.toPeerId !== this._localId) return;\n\n            switch (signal.type) {\n                case \"offer\": {\n                    const peer = this._getOrCreatePeer(signal.fromPeerId);\n                    const answer = await peer.handleOffer(signal);\n                    this._config.signaling!.send(signal.fromPeerId, answer);\n                    break;\n                }\n                case \"answer\": {\n                    const peer = this._peers.get(signal.fromPeerId);\n                    if (peer) await peer.handleAnswer(signal);\n                    break;\n                }\n                case \"ice-candidate\": {\n                    const peer = this._peers.get(signal.fromPeerId);\n                    if (peer) await peer.addIceCandidate(signal);\n                    break;\n                }\n                case \"disconnect\": {\n                    this._removePeer(signal.fromPeerId);\n                    break;\n                }\n            }\n        });\n\n        if (typeof cleanup === \"function\") {\n            this._signalingCleanup = cleanup;\n        } else if (cleanup && \"unsubscribe\" in cleanup) {\n            this._signalingCleanup = () => cleanup.unsubscribe();\n        }\n    }\n\n    private _getOrCreatePeer(peerId: string): RTCPeerTransport {\n        let peer = this._peers.get(peerId);\n        if (!peer) {\n            peer = new RTCPeerTransport(this._channelName, this._config);\n            this._peers.set(peerId, peer);\n\n            // Subscribe to peer events\n            peer.state.subscribe({\n                next: (state) => {\n                    if (state === \"connected\") {\n                        this._peerEvents.next({ type: \"connected\", peerId, peer });\n                    } else if (state === \"disconnected\" || state === \"closed\") {\n                        this._peerEvents.next({ type: \"disconnected\", peerId });\n                    } else if (state === \"failed\") {\n                        this._peerEvents.next({ type: \"failed\", peerId });\n                        this._removePeer(peerId);\n                    }\n                }\n            });\n\n            // Forward messages\n            peer.subscribe({\n                next: (msg) => {\n                    for (const s of this._subs) {\n                        try { s.next?.(msg); } catch (e) { s.error?.(e as Error); }\n                    }\n                },\n                error: (e) => {\n                    for (const s of this._subs) s.error?.(e);\n                }\n            });\n        }\n        return peer;\n    }\n\n    private _removePeer(peerId: string): void {\n        const peer = this._peers.get(peerId);\n        if (peer) {\n            peer.close();\n            this._peers.delete(peerId);\n            this._peerEvents.next({ type: \"disconnected\", peerId });\n        }\n    }\n\n    /**\n     * Connect to a peer\n     */\n    async connect(peerId: string): Promise<RTCPeerTransport> {\n        const peer = this._getOrCreatePeer(peerId);\n        const offer = await peer.createOffer(peerId);\n\n        if (this._config.signaling) {\n            await this._config.signaling.send(peerId, offer);\n        }\n\n        return peer;\n    }\n\n    /**\n     * Send to specific peer\n     */\n    send(peerId: string, msg: RTCMessage): void {\n        this._peers.get(peerId)?.send(msg);\n    }\n\n    /**\n     * Broadcast to all peers\n     */\n    broadcast(msg: RTCMessage): void {\n        for (const peer of this._peers.values()) {\n            peer.send(msg);\n        }\n    }\n\n    /**\n     * Request from specific peer\n     */\n    request(peerId: string, msg: RTCMessage): Promise<any> {\n        const peer = this._peers.get(peerId);\n        if (!peer) return Promise.reject(new Error(\"Peer not found\"));\n        return peer.request(msg);\n    }\n\n    subscribe(observer: Observer<RTCMessage> | ((v: RTCMessage) => void)): Subscription {\n        const obs: Observer<RTCMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    onPeerEvent(handler: (e: { type: \"connected\" | \"disconnected\" | \"failed\"; peerId: string }) => void): Subscription {\n        return this._peerEvents.subscribe({ next: handler });\n    }\n\n    getPeers(): Map<string, RTCPeerInfo> {\n        const result = new Map<string, RTCPeerInfo>();\n        for (const [id, peer] of this._peers) {\n            result.set(id, {\n                id,\n                connectionState: peer.connectionState,\n                iceConnectionState: \"new\", // simplified\n                dataChannelState: peer.channelState ?? \"closed\"\n            });\n        }\n        return result;\n    }\n\n    close(): void {\n        this._signalingCleanup?.();\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        for (const peer of this._peers.values()) {\n            peer.close();\n        }\n        this._peers.clear();\n    }\n\n    get localId(): string { return this._localId; }\n    get peerCount(): number { return this._peers.size; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// SIMPLE BROADCAST CHANNEL SIGNALING\n// ============================================================================\n\n/**\n * Simple signaling using BroadcastChannel (for same-origin peers)\n */\nexport function createBroadcastSignaling(channelName: string): RTCSignaling & { close(): void } {\n    const bc = new BroadcastChannel(`rtc-signaling:${channelName}`);\n    const handlers = new Set<(msg: RTCSignalMessage) => void>();\n\n    bc.onmessage = (e) => {\n        for (const h of handlers) h(e.data);\n    };\n\n    return {\n        send(peerId: string, message: RTCSignalMessage) {\n            bc.postMessage(message);\n        },\n        onMessage(handler) {\n            handlers.add(handler);\n            return { unsubscribe: () => handlers.delete(handler), closed: false };\n        },\n        close() {\n            bc.close();\n            handlers.clear();\n        }\n    };\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const RTCTransportFactory = {\n    createPeer: (name: string, config?: RTCTransportConfig) =>\n        new RTCPeerTransport(name, config),\n    createManager: (name: string, config?: RTCTransportConfig) =>\n        new RTCPeerManager(name, config),\n    createSignaling: (name: string) =>\n        createBroadcastSignaling(name)\n};\n","/**\n * MessagePort/MessageChannel Enhanced Transport\n *\n * Advanced port-based communication with:\n * - MessageChannel pair creation\n * - Port pooling and management\n * - Cross-context transfer (iframe, worker, window)\n * - Automatic reconnection\n * - Request/response with timeout\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\nimport type { ChannelMessage, PendingRequest, Subscriber } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface PortMessage<T = any> extends ChannelMessage {\n    portId?: string;\n    sourceContext?: \"main\" | \"worker\" | \"iframe\" | \"window\";\n}\n\nexport interface PortTransportConfig {\n    autoStart?: boolean;\n    timeout?: number;\n    retryOnError?: boolean;\n    maxRetries?: number;\n    keepAlive?: boolean;\n    keepAliveInterval?: number;\n}\n\nexport interface PortPair {\n    local: MessagePort;\n    remote: MessagePort;\n}\n\n// ============================================================================\n// MESSAGE PORT TRANSPORT\n// ============================================================================\n\nexport class PortTransport {\n    private _port: MessagePort;\n    private _subs = new Set<Observer<PortMessage>>();\n    private _pending = new Map<string, PendingRequest>();\n    private _listening = false;\n    private _cleanup: (() => void) | null = null;\n    private _portId: string = UUIDv4();\n    private _state = new ChannelSubject<\"closed\" | \"ready\" | \"error\">();\n    private _keepAliveTimer: ReturnType<typeof setInterval> | null = null;\n\n    constructor(\n        port: MessagePort,\n        private _channelName: string,\n        private _config: PortTransportConfig = {}\n    ) {\n        this._port = port;\n        this._setupPort();\n        if (_config.autoStart !== false) this.start();\n    }\n\n    private _setupPort(): void {\n        const msgHandler = (e: MessageEvent) => {\n            const data = e.data as PortMessage;\n\n            // Handle response\n            if (data.type === \"response\" && data.reqId) {\n                const p = this._pending.get(data.reqId);\n                if (p) {\n                    this._pending.delete(data.reqId);\n                    if (data.payload?.error) p.reject(new Error(data.payload.error));\n                    else p.resolve(data.payload?.result ?? data.payload);\n                    return;\n                }\n            }\n\n            // Handle keep-alive ping\n            if (data.type === \"signal\" && data.payload?.action === \"ping\") {\n                this.send({\n                    id: UUIDv4(),\n                    channel: this._channelName,\n                    sender: this._portId,\n                    type: \"signal\",\n                    payload: { action: \"pong\" }\n                });\n                return;\n            }\n\n            data.portId = data.portId ?? this._portId;\n\n            for (const s of this._subs) {\n                try { s.next?.(data); } catch (e) { s.error?.(e as Error); }\n            }\n        };\n\n        const errHandler = () => {\n            this._state.next(\"error\");\n            const err = new Error(\"Port error\");\n            for (const s of this._subs) s.error?.(err);\n        };\n\n        this._port.addEventListener(\"message\", msgHandler);\n        this._port.addEventListener(\"messageerror\", errHandler);\n\n        this._cleanup = () => {\n            this._port.removeEventListener(\"message\", msgHandler);\n            this._port.removeEventListener(\"messageerror\", errHandler);\n        };\n    }\n\n    start(): void {\n        if (this._listening) return;\n        this._port.start();\n        this._listening = true;\n        this._state.next(\"ready\");\n\n        if (this._config.keepAlive) {\n            this._startKeepAlive();\n        }\n    }\n\n    send(msg: PortMessage, transfer?: Transferable[]): void {\n        const { transferable, ...data } = msg as any;\n        this._port.postMessage({ ...data, portId: this._portId }, transfer ?? []);\n    }\n\n    request(msg: Omit<PortMessage, \"reqId\"> & { reqId?: string }): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this._pending.delete(reqId);\n                reject(new Error(\"Request timeout\"));\n            }, this._config.timeout ?? 30000);\n\n            this._pending.set(reqId, {\n                resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                reject: (e) => { clearTimeout(timeout); reject(e); },\n                timestamp: Date.now()\n            });\n\n            this.send({ ...msg, reqId, type: \"request\" } as PortMessage);\n        });\n    }\n\n    subscribe(observer: Observer<PortMessage> | ((v: PortMessage) => void)): Subscription {\n        const obs: Observer<PortMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    private _startKeepAlive(): void {\n        this._keepAliveTimer = setInterval(() => {\n            this.send({\n                id: UUIDv4(),\n                channel: this._channelName,\n                sender: this._portId,\n                type: \"signal\",\n                payload: { action: \"ping\" }\n            });\n        }, this._config.keepAliveInterval ?? 30000);\n    }\n\n    close(): void {\n        if (this._keepAliveTimer) {\n            clearInterval(this._keepAliveTimer);\n            this._keepAliveTimer = null;\n        }\n        this._cleanup?.();\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        this._port.close();\n        this._state.next(\"closed\");\n    }\n\n    get port(): MessagePort { return this._port; }\n    get portId(): string { return this._portId; }\n    get isListening(): boolean { return this._listening; }\n    get state() { return this._state; }\n    get channelName(): string { return this._channelName; }\n}\n\n// ============================================================================\n// MESSAGE CHANNEL FACTORY\n// ============================================================================\n\nexport interface ChannelPairResult {\n    local: PortTransport;\n    remote: MessagePort;\n    transfer(): MessagePort;\n}\n\n/**\n * Create a MessageChannel pair with configured local transport\n */\nexport function createChannelPair(\n    channelName: string,\n    config?: PortTransportConfig\n): ChannelPairResult {\n    const channel = new MessageChannel();\n\n    const local = new PortTransport(channel.port1, channelName, config);\n\n    return {\n        local,\n        remote: channel.port2,\n        transfer: () => {\n            // Use ArrayBuffer.transfer-like semantics for port\n            const port = channel.port2;\n            return port;\n        }\n    };\n}\n\n/**\n * Create transport from remote port\n */\nexport function createFromPort(\n    port: MessagePort,\n    channelName: string,\n    config?: PortTransportConfig\n): PortTransport {\n    return new PortTransport(port, channelName, config);\n}\n\n// ============================================================================\n// PORT POOL (Multiplexed Channels)\n// ============================================================================\n\nexport class PortPool {\n    private _channels = new Map<string, PortTransport>();\n    private _mainPort: PortTransport | null = null;\n    private _subs = new Set<Observer<PortMessage>>();\n\n    constructor(\n        private _defaultConfig: PortTransportConfig = {}\n    ) {}\n\n    /**\n     * Create new channel in pool\n     */\n    create(channelName: string, config?: PortTransportConfig): ChannelPairResult {\n        const result = createChannelPair(channelName, { ...this._defaultConfig, ...config });\n\n        result.local.subscribe({\n            next: (msg) => {\n                for (const s of this._subs) {\n                    try { s.next?.(msg); } catch (e) { s.error?.(e as Error); }\n                }\n            }\n        });\n\n        this._channels.set(channelName, result.local);\n        return result;\n    }\n\n    /**\n     * Add existing port to pool\n     */\n    add(channelName: string, port: MessagePort, config?: PortTransportConfig): PortTransport {\n        const transport = new PortTransport(port, channelName, { ...this._defaultConfig, ...config });\n\n        transport.subscribe({\n            next: (msg) => {\n                for (const s of this._subs) {\n                    try { s.next?.(msg); } catch (e) { s.error?.(e as Error); }\n                }\n            }\n        });\n\n        this._channels.set(channelName, transport);\n        return transport;\n    }\n\n    /**\n     * Get channel by name\n     */\n    get(channelName: string): PortTransport | undefined {\n        return this._channels.get(channelName);\n    }\n\n    /**\n     * Send to specific channel\n     */\n    send(channelName: string, msg: PortMessage, transfer?: Transferable[]): void {\n        this._channels.get(channelName)?.send(msg, transfer);\n    }\n\n    /**\n     * Broadcast to all channels\n     */\n    broadcast(msg: PortMessage, transfer?: Transferable[]): void {\n        for (const transport of this._channels.values()) {\n            transport.send(msg, transfer);\n        }\n    }\n\n    /**\n     * Request on specific channel\n     */\n    request(channelName: string, msg: PortMessage): Promise<any> {\n        const channel = this._channels.get(channelName);\n        if (!channel) return Promise.reject(new Error(`Channel ${channelName} not found`));\n        return channel.request(msg);\n    }\n\n    /**\n     * Subscribe to all channels\n     */\n    subscribe(observer: Observer<PortMessage> | ((v: PortMessage) => void)): Subscription {\n        const obs: Observer<PortMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    /**\n     * Remove channel\n     */\n    remove(channelName: string): void {\n        const channel = this._channels.get(channelName);\n        if (channel) {\n            channel.close();\n            this._channels.delete(channelName);\n        }\n    }\n\n    /**\n     * Close all channels\n     */\n    close(): void {\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        for (const channel of this._channels.values()) {\n            channel.close();\n        }\n        this._channels.clear();\n    }\n\n    get channelNames(): string[] { return Array.from(this._channels.keys()); }\n    get size(): number { return this._channels.size; }\n}\n\n// ============================================================================\n// WINDOW/IFRAME PORT CONNECTOR\n// ============================================================================\n\nexport interface WindowPortConnectorConfig extends PortTransportConfig {\n    targetOrigin?: string;\n    handshakeTimeout?: number;\n}\n\n/**\n * Connect to window/iframe via MessageChannel\n */\nexport class WindowPortConnector {\n    private _transport: PortTransport | null = null;\n    private _state = new ChannelSubject<\"disconnected\" | \"connecting\" | \"connected\" | \"error\">();\n    private _handshakeComplete = false;\n\n    constructor(\n        private _target: Window,\n        private _channelName: string,\n        private _config: WindowPortConnectorConfig = {}\n    ) {}\n\n    /**\n     * Initiate connection to target window\n     */\n    async connect(): Promise<PortTransport> {\n        if (this._transport && this._handshakeComplete) {\n            return this._transport;\n        }\n\n        this._state.next(\"connecting\");\n\n        const { local, remote } = createChannelPair(this._channelName, this._config);\n\n        // Send port to target window\n        this._target.postMessage(\n            {\n                type: \"port-connect\",\n                channelName: this._channelName,\n                portId: local.portId\n            },\n            this._config.targetOrigin ?? \"*\",\n            [remote]\n        );\n\n        // Wait for handshake\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error(\"Handshake timeout\"));\n                this._state.next(\"error\");\n            }, this._config.handshakeTimeout ?? 10000);\n\n            const sub = local.subscribe({\n                next: (msg) => {\n                    if (msg.type === \"signal\" && msg.payload?.action === \"handshake-ack\") {\n                        clearTimeout(timeout);\n                        this._handshakeComplete = true;\n                        this._transport = local;\n                        this._state.next(\"connected\");\n                        sub.unsubscribe();\n                        resolve(local);\n                    }\n                }\n            });\n        });\n    }\n\n    /**\n     * Listen for incoming connections (target side)\n     */\n    static listen(\n        channelName: string,\n        handler: (transport: PortTransport) => void,\n        config?: WindowPortConnectorConfig\n    ): () => void {\n        const msgHandler = (e: MessageEvent) => {\n            if (e.data?.type !== \"port-connect\" || e.data?.channelName !== channelName) return;\n            if (!e.ports[0]) return;\n\n            const transport = new PortTransport(e.ports[0], channelName, config);\n\n            // Send handshake acknowledgment\n            transport.send({\n                id: UUIDv4(),\n                channel: channelName,\n                sender: transport.portId,\n                type: \"signal\",\n                payload: { action: \"handshake-ack\" }\n            });\n\n            handler(transport);\n        };\n\n        globalThis.addEventListener(\"message\", msgHandler);\n        return () => globalThis.removeEventListener(\"message\", msgHandler);\n    }\n\n    disconnect(): void {\n        this._transport?.close();\n        this._transport = null;\n        this._handshakeComplete = false;\n        this._state.next(\"disconnected\");\n    }\n\n    get isConnected(): boolean { return this._handshakeComplete; }\n    get state() { return this._state; }\n    get transport(): PortTransport | null { return this._transport; }\n}\n\n// ============================================================================\n// COMLINK-LIKE PROXY OVER PORT (using unified Proxy module)\n// ============================================================================\n\nimport {\n    createSenderProxy,\n    createExposeHandler,\n    type ProxyMethods\n} from \"../proxy/Proxy\";\n\n// Re-export for backward compatibility\nexport type { ProxyMethods };\n\n/**\n * Create proxy for remote object over PortTransport\n *\n * Uses unified Proxy module for consistent behavior.\n */\nexport function createPortProxy<T extends object>(\n    transport: PortTransport,\n    targetPath: string[] = []\n): ProxyMethods<T> {\n    return createSenderProxy<T>({\n        request: (msg) => transport.request(msg),\n        channelName: transport.channelName,\n        senderId: transport.portId\n    }, targetPath);\n}\n\n/**\n * Expose object methods over PortTransport\n *\n * Uses unified Proxy module's expose handler.\n */\nexport function exposeOverPort<T extends object>(\n    transport: PortTransport,\n    target: T\n): Subscription {\n    const handler = createExposeHandler(target);\n\n    return transport.subscribe({\n        next: async (msg) => {\n            if (msg.type !== \"request\" || !msg.payload?.path) return;\n\n            const { action, path, args } = msg.payload;\n            let result: any;\n            let error: string | undefined;\n\n            try {\n                result = await handler(action, path, args ?? []);\n            } catch (e) {\n                error = e instanceof Error ? e.message : String(e);\n            }\n\n            transport.send({\n                id: UUIDv4(),\n                channel: msg.sender,\n                sender: transport.portId,\n                type: \"response\",\n                reqId: msg.reqId,\n                payload: error ? { error } : { result }\n            });\n        }\n    });\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const PortTransportFactory = {\n    create: (port: MessagePort, name: string, config?: PortTransportConfig) =>\n        new PortTransport(port, name, config),\n    createPair: (name: string, config?: PortTransportConfig) =>\n        createChannelPair(name, config),\n    createPool: (config?: PortTransportConfig) =>\n        new PortPool(config),\n    createWindowConnector: (target: Window, name: string, config?: WindowPortConnectorConfig) =>\n        new WindowPortConnector(target, name, config),\n    listen: WindowPortConnector.listen,\n    createProxy: createPortProxy,\n    expose: exposeOverPort\n};\n","/**\n * Transferable Storage - IndexedDB with Transferable Support\n *\n * High-performance storage layer with support for:\n * - ArrayBuffer and TypedArray storage\n * - ArrayBuffer.transfer() for zero-copy operations\n * - Structured cloning for complex objects\n * - Transaction batching for bulk operations\n * - Observable change notifications\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface TransferableRecord<T = any> {\n    id: string;\n    data: T;\n    buffers?: ArrayBuffer[];\n    metadata?: Record<string, any>;\n    createdAt: number;\n    updatedAt: number;\n    expiresAt?: number;\n}\n\nexport interface TransferableQuery<T = any> {\n    index?: string;\n    range?: IDBKeyRange;\n    direction?: IDBCursorDirection;\n    limit?: number;\n    offset?: number;\n    filter?: (record: TransferableRecord<T>) => boolean;\n}\n\nexport interface TransferableStorageConfig {\n    dbName: string;\n    storeName?: string;\n    version?: number;\n    indexes?: Array<{ name: string; keyPath: string | string[]; unique?: boolean }>;\n    enableChangeTracking?: boolean;\n    autoCleanupExpired?: boolean;\n    cleanupInterval?: number;\n}\n\nexport type ChangeType = \"add\" | \"put\" | \"delete\" | \"clear\";\n\nexport interface StorageChange<T = any> {\n    type: ChangeType;\n    key: string;\n    record?: TransferableRecord<T>;\n    previousRecord?: TransferableRecord<T>;\n    timestamp: number;\n}\n\n// ============================================================================\n// TRANSFERABLE STORAGE\n// ============================================================================\n\nexport class TransferableStorage<T = any> {\n    private _db: IDBDatabase | null = null;\n    private _config: Required<TransferableStorageConfig>;\n    private _changes = new ChannelSubject<StorageChange<T>>();\n    private _state = new ChannelSubject<\"closed\" | \"opening\" | \"open\" | \"error\">();\n    private _cleanupTimer: ReturnType<typeof setInterval> | null = null;\n\n    constructor(config: TransferableStorageConfig) {\n        this._config = {\n            storeName: \"transferable\",\n            version: 1,\n            indexes: [],\n            enableChangeTracking: true,\n            autoCleanupExpired: true,\n            cleanupInterval: 60000,\n            ...config\n        };\n    }\n\n    /**\n     * Open database connection\n     */\n    async open(): Promise<void> {\n        if (this._db) return;\n        this._state.next(\"opening\");\n\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this._config.dbName, this._config.version);\n\n            request.onerror = () => {\n                this._state.next(\"error\");\n                reject(new Error(`Failed to open database: ${request.error?.message}`));\n            };\n\n            request.onsuccess = () => {\n                this._db = request.result;\n                this._state.next(\"open\");\n\n                if (this._config.autoCleanupExpired) {\n                    this._startCleanupTimer();\n                }\n\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n\n                // Create store if needed\n                if (!db.objectStoreNames.contains(this._config.storeName)) {\n                    const store = db.createObjectStore(this._config.storeName, { keyPath: \"id\" });\n\n                    // Create indexes\n                    store.createIndex(\"createdAt\", \"createdAt\");\n                    store.createIndex(\"updatedAt\", \"updatedAt\");\n                    store.createIndex(\"expiresAt\", \"expiresAt\");\n\n                    for (const idx of this._config.indexes) {\n                        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique ?? false });\n                    }\n                }\n            };\n        });\n    }\n\n    /**\n     * Close database connection\n     */\n    close(): void {\n        if (this._cleanupTimer) {\n            clearInterval(this._cleanupTimer);\n            this._cleanupTimer = null;\n        }\n        this._db?.close();\n        this._db = null;\n        this._state.next(\"closed\");\n    }\n\n    /**\n     * Store data with optional ArrayBuffer transfer\n     */\n    async put(\n        id: string,\n        data: T,\n        options: {\n            buffers?: ArrayBuffer[];\n            transfer?: boolean;\n            metadata?: Record<string, any>;\n            expiresIn?: number;\n        } = {}\n    ): Promise<TransferableRecord<T>> {\n        await this._ensureOpen();\n\n        let buffers = options.buffers ?? [];\n\n        // Use ArrayBuffer.transfer() if available and requested (ES2024+)\n        if (options.transfer && buffers.length > 0) {\n            buffers = buffers.map(buf => {\n                // @ts-ignore - Modern API (ES2024)\n                if (\"transfer\" in buf && typeof buf.transfer === \"function\") {\n                    // @ts-ignore\n                    return buf.transfer();\n                }\n                return buf;\n            });\n        }\n\n        const now = Date.now();\n        const existing = await this.get(id);\n\n        const record: TransferableRecord<T> = {\n            id,\n            data,\n            buffers: buffers.length > 0 ? buffers : undefined,\n            metadata: options.metadata,\n            createdAt: existing?.createdAt ?? now,\n            updatedAt: now,\n            expiresAt: options.expiresIn ? now + options.expiresIn : undefined\n        };\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readwrite\");\n            const store = tx.objectStore(this._config.storeName);\n\n            const request = store.put(record);\n\n            request.onsuccess = () => {\n                if (this._config.enableChangeTracking) {\n                    this._changes.next({\n                        type: existing ? \"put\" : \"add\",\n                        key: id,\n                        record,\n                        previousRecord: existing ?? undefined,\n                        timestamp: now\n                    });\n                }\n                resolve(record);\n            };\n\n            request.onerror = () => reject(new Error(`Put failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Store ArrayBuffer directly with zero-copy semantics\n     */\n    async putBuffer(\n        id: string,\n        buffer: ArrayBuffer,\n        options: { transfer?: boolean; metadata?: Record<string, any>; expiresIn?: number } = {}\n    ): Promise<TransferableRecord<ArrayBuffer>> {\n        return this.put(id, buffer as any, { buffers: [buffer], ...options }) as Promise<TransferableRecord<ArrayBuffer>>;\n    }\n\n    /**\n     * Store TypedArray\n     */\n    async putTypedArray<A extends ArrayBufferView>(\n        id: string,\n        array: A,\n        options: { transfer?: boolean; metadata?: Record<string, any>; expiresIn?: number } = {}\n    ): Promise<TransferableRecord<{ type: string; data: number[] }>> {\n        const data = {\n            type: array.constructor.name,\n            data: Array.from(array as any)\n        };\n\n        return this.put(id, data as any, {\n            buffers: options.transfer ? [array.buffer] : undefined,\n            ...options\n        }) as Promise<TransferableRecord<{ type: string; data: number[] }>>;\n    }\n\n    /**\n     * Get record by ID\n     */\n    async get(id: string): Promise<TransferableRecord<T> | null> {\n        await this._ensureOpen();\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readonly\");\n            const store = tx.objectStore(this._config.storeName);\n            const request = store.get(id);\n\n            request.onsuccess = () => {\n                const record = request.result as TransferableRecord<T> | undefined;\n\n                // Check expiration\n                if (record?.expiresAt && record.expiresAt < Date.now()) {\n                    this.delete(id); // Async cleanup\n                    resolve(null);\n                } else {\n                    resolve(record ?? null);\n                }\n            };\n\n            request.onerror = () => reject(new Error(`Get failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Get ArrayBuffer and optionally transfer ownership\n     */\n    async getBuffer(id: string, transfer?: boolean): Promise<ArrayBuffer | null> {\n        const record = await this.get(id);\n        if (!record) return null;\n\n        let buffer = record.buffers?.[0] ?? (record.data instanceof ArrayBuffer ? record.data : null);\n\n        if (buffer && transfer) {\n            // @ts-ignore - Modern API\n            if (\"transfer\" in buffer && typeof buffer.transfer === \"function\") {\n                // @ts-ignore\n                buffer = buffer.transfer();\n            }\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Reconstruct TypedArray from stored data\n     */\n    async getTypedArray<A extends ArrayBufferView>(id: string): Promise<A | null> {\n        const record = await this.get(id);\n        if (!record || !record.data || typeof record.data !== \"object\") return null;\n\n        const { type, data } = record.data as { type: string; data: number[] };\n        const TypedArrayCtor = (globalThis as any)[type];\n\n        if (!TypedArrayCtor) return null;\n        return new TypedArrayCtor(data) as A;\n    }\n\n    /**\n     * Delete record\n     */\n    async delete(id: string): Promise<boolean> {\n        await this._ensureOpen();\n\n        const existing = this._config.enableChangeTracking ? await this.get(id) : null;\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readwrite\");\n            const store = tx.objectStore(this._config.storeName);\n            const request = store.delete(id);\n\n            request.onsuccess = () => {\n                if (this._config.enableChangeTracking && existing) {\n                    this._changes.next({\n                        type: \"delete\",\n                        key: id,\n                        previousRecord: existing,\n                        timestamp: Date.now()\n                    });\n                }\n                resolve(true);\n            };\n\n            request.onerror = () => reject(new Error(`Delete failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Query records with cursor\n     */\n    async query(query: TransferableQuery<T> = {}): Promise<TransferableRecord<T>[]> {\n        await this._ensureOpen();\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readonly\");\n            const store = tx.objectStore(this._config.storeName);\n            const source = query.index ? store.index(query.index) : store;\n\n            const results: TransferableRecord<T>[] = [];\n            let skipped = 0;\n            const offset = query.offset ?? 0;\n            const limit = query.limit ?? Infinity;\n\n            const request = source.openCursor(query.range, query.direction);\n\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (!cursor || results.length >= limit) {\n                    resolve(results);\n                    return;\n                }\n\n                const record = cursor.value as TransferableRecord<T>;\n\n                // Check expiration\n                if (record.expiresAt && record.expiresAt < Date.now()) {\n                    cursor.continue();\n                    return;\n                }\n\n                // Apply filter\n                if (query.filter && !query.filter(record)) {\n                    cursor.continue();\n                    return;\n                }\n\n                // Handle offset\n                if (skipped < offset) {\n                    skipped++;\n                    cursor.continue();\n                    return;\n                }\n\n                results.push(record);\n                cursor.continue();\n            };\n\n            request.onerror = () => reject(new Error(`Query failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Batch operations in single transaction\n     */\n    async batch(\n        operations: Array<\n            | { type: \"put\"; id: string; data: T; options?: any }\n            | { type: \"delete\"; id: string }\n        >\n    ): Promise<void> {\n        await this._ensureOpen();\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readwrite\");\n            const store = tx.objectStore(this._config.storeName);\n            const now = Date.now();\n\n            for (const op of operations) {\n                if (op.type === \"put\") {\n                    const record: TransferableRecord<T> = {\n                        id: op.id,\n                        data: op.data,\n                        metadata: op.options?.metadata,\n                        createdAt: now,\n                        updatedAt: now,\n                        expiresAt: op.options?.expiresIn ? now + op.options.expiresIn : undefined\n                    };\n                    store.put(record);\n                } else if (op.type === \"delete\") {\n                    store.delete(op.id);\n                }\n            }\n\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(new Error(`Batch failed: ${tx.error?.message}`));\n        });\n    }\n\n    /**\n     * Clear all records\n     */\n    async clear(): Promise<void> {\n        await this._ensureOpen();\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readwrite\");\n            const store = tx.objectStore(this._config.storeName);\n            const request = store.clear();\n\n            request.onsuccess = () => {\n                if (this._config.enableChangeTracking) {\n                    this._changes.next({\n                        type: \"clear\",\n                        key: \"*\",\n                        timestamp: Date.now()\n                    });\n                }\n                resolve();\n            };\n\n            request.onerror = () => reject(new Error(`Clear failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Count records\n     */\n    async count(query?: { index?: string; range?: IDBKeyRange }): Promise<number> {\n        await this._ensureOpen();\n\n        return new Promise((resolve, reject) => {\n            const tx = this._db!.transaction(this._config.storeName, \"readonly\");\n            const store = tx.objectStore(this._config.storeName);\n            const source = query?.index ? store.index(query.index) : store;\n            const request = source.count(query?.range);\n\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(new Error(`Count failed: ${request.error?.message}`));\n        });\n    }\n\n    /**\n     * Subscribe to changes\n     */\n    onChanges(handler: (change: StorageChange<T>) => void): Subscription {\n        return this._changes.subscribe({ next: handler });\n    }\n\n    /**\n     * Subscribe to state changes\n     */\n    onState(handler: (state: \"closed\" | \"opening\" | \"open\" | \"error\") => void): Subscription {\n        return this._state.subscribe({ next: handler });\n    }\n\n    /**\n     * Cleanup expired records\n     */\n    async cleanupExpired(): Promise<number> {\n        await this._ensureOpen();\n\n        const now = Date.now();\n        const expired = await this.query({\n            index: \"expiresAt\",\n            range: IDBKeyRange.upperBound(now)\n        });\n\n        for (const record of expired) {\n            await this.delete(record.id);\n        }\n\n        return expired.length;\n    }\n\n    // ========================================================================\n    // PRIVATE\n    // ========================================================================\n\n    private async _ensureOpen(): Promise<void> {\n        if (!this._db) await this.open();\n    }\n\n    private _startCleanupTimer(): void {\n        this._cleanupTimer = setInterval(() => {\n            this.cleanupExpired().catch(console.error);\n        }, this._config.cleanupInterval);\n    }\n\n    get isOpen(): boolean { return this._db !== null; }\n    get state() { return this._state; }\n    get changes() { return this._changes; }\n}\n\n// ============================================================================\n// MESSAGE QUEUE STORAGE\n// ============================================================================\n\nexport interface QueuedMessage<T = any> {\n    id: string;\n    channel: string;\n    sender: string;\n    type: string;\n    payload: T;\n    priority: number;\n    attempts: number;\n    maxAttempts: number;\n    status: \"pending\" | \"processing\" | \"completed\" | \"failed\" | \"expired\";\n    createdAt: number;\n    scheduledFor: number;\n    expiresAt?: number;\n    lastAttemptAt?: number;\n    error?: string;\n}\n\nexport class MessageQueueStorage extends TransferableStorage<QueuedMessage> {\n    constructor(dbName: string = \"uniform-message-queue\") {\n        super({\n            dbName,\n            storeName: \"messages\",\n            indexes: [\n                { name: \"channel\", keyPath: \"channel\" },\n                { name: \"status\", keyPath: \"status\" },\n                { name: \"priority\", keyPath: \"priority\" },\n                { name: \"scheduledFor\", keyPath: \"scheduledFor\" },\n                { name: \"channel-status\", keyPath: [\"channel\", \"status\"] }\n            ]\n        });\n    }\n\n    /**\n     * Enqueue a message\n     */\n    async enqueue(message: {\n        channel: string;\n        sender: string;\n        type: string;\n        payload: any;\n        priority?: number;\n        delay?: number;\n        expiresIn?: number;\n        maxAttempts?: number;\n    }): Promise<QueuedMessage> {\n        const now = Date.now();\n        const id = UUIDv4();\n\n        const queuedMessage: QueuedMessage = {\n            id,\n            channel: message.channel,\n            sender: message.sender,\n            type: message.type,\n            payload: message.payload,\n            priority: message.priority ?? 0,\n            attempts: 0,\n            maxAttempts: message.maxAttempts ?? 3,\n            status: \"pending\",\n            createdAt: now,\n            scheduledFor: now + (message.delay ?? 0),\n            expiresAt: message.expiresIn ? now + message.expiresIn : undefined\n        };\n\n        await this.put(id, queuedMessage);\n        return queuedMessage;\n    }\n\n    /**\n     * Dequeue next message for channel\n     */\n    async dequeue(channel: string): Promise<QueuedMessage | null> {\n        const now = Date.now();\n\n        const messages = await this.query({\n            filter: (r) =>\n                r.data.channel === channel &&\n                r.data.status === \"pending\" &&\n                r.data.scheduledFor <= now &&\n                (!r.data.expiresAt || r.data.expiresAt > now),\n            limit: 1\n        });\n\n        if (messages.length === 0) return null;\n\n        const message = messages[0].data;\n        message.status = \"processing\";\n        message.attempts++;\n        message.lastAttemptAt = now;\n\n        await this.put(message.id, message);\n        return message;\n    }\n\n    /**\n     * Mark message as completed\n     */\n    async complete(id: string): Promise<void> {\n        const record = await this.get(id);\n        if (!record) return;\n\n        record.data.status = \"completed\";\n        await this.put(id, record.data);\n    }\n\n    /**\n     * Mark message as failed\n     */\n    async fail(id: string, error: string): Promise<void> {\n        const record = await this.get(id);\n        if (!record) return;\n\n        if (record.data.attempts >= record.data.maxAttempts) {\n            record.data.status = \"failed\";\n        } else {\n            record.data.status = \"pending\";\n        }\n        record.data.error = error;\n\n        await this.put(id, record.data);\n    }\n\n    /**\n     * Get pending count for channel\n     */\n    async getPendingCount(channel: string): Promise<number> {\n        const messages = await this.query({\n            filter: (r) => r.data.channel === channel && r.data.status === \"pending\"\n        });\n        return messages.length;\n    }\n}\n\n// ============================================================================\n// FACTORY\n// ============================================================================\n\nexport const TransferableStorageFactory = {\n    create: <T>(config: TransferableStorageConfig) =>\n        new TransferableStorage<T>(config),\n    createMessageQueue: (dbName?: string) =>\n        new MessageQueueStorage(dbName)\n};\n","/**\n * Service Worker Host Channel\n *\n * In PWA context, the Service Worker acts as a HOST that\n * components/views/modules connect TO.\n *\n * This is a REVERSE of the normal worker pattern:\n * - Normal: Main thread is host, Worker connects to it\n * - PWA SW: Service Worker is host, Clients connect to it\n *\n * The Service Worker hosts the channel and:\n * - Receives connections from clients (pages/components)\n * - Manages client registry\n * - Routes messages between clients\n * - Handles offline queueing via IndexedDB storage\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport {\n    ChannelConnection,\n    getConnectionPool,\n    type ConnectionOptions\n} from \"../channel/Connection\";\nimport {\n    ChannelSubject,\n    type ChannelMessage,\n    type Subscription,\n    filter\n} from \"../observable/Observable\";\nimport { getChannelStorage, type ChannelStorage, type StoredMessage } from \"../storage/Storage\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/** Client info tracked by SW host */\nexport interface SWClientInfo {\n    id: string;\n    type: \"window\" | \"worker\" | \"sharedworker\" | \"all\";\n    url: string;\n    visibilityState: \"visible\" | \"hidden\";\n    focused: boolean;\n    connectedAt: number;\n    lastSeen: number;\n    channels: Set<string>;\n}\n\n/** Message types for SW host protocol */\nexport type SWHostMessageType =\n    | \"connect\"      // Client connects to SW host\n    | \"disconnect\"   // Client disconnects\n    | \"subscribe\"    // Client subscribes to a channel\n    | \"unsubscribe\"  // Client unsubscribes from channel\n    | \"request\"      // Standard request\n    | \"response\"     // Standard response\n    | \"event\"        // Broadcast event\n    | \"sync\"         // Background sync\n    | \"push\";        // Push notification data\n\n/** SW host configuration */\nexport interface SWHostConfig {\n    /** Channel name for this host */\n    channelName: string;\n    /** Enable message buffering for offline clients */\n    enableOfflineQueue?: boolean;\n    /** Maximum messages per client in offline queue */\n    maxOfflineQueueSize?: number;\n    /** Message TTL in milliseconds */\n    messageTTL?: number;\n    /** Enable automatic cleanup of stale clients */\n    autoCleanup?: boolean;\n    /** Cleanup interval in milliseconds */\n    cleanupInterval?: number;\n}\n\n// ============================================================================\n// SERVICE WORKER HOST\n// ============================================================================\n\n/**\n * ServiceWorkerHost - The host channel that runs inside Service Worker.\n *\n * Clients (pages, components) connect TO this host.\n * This is the reverse of normal worker pattern.\n */\nexport class ServiceWorkerHost {\n    private _connection: ChannelConnection;\n    private _storage: ChannelStorage;\n    private _clients = new Map<string, SWClientInfo>();\n    private _channelSubscribers = new Map<string, Set<string>>(); // channel -> client IDs\n    private _subscriptions: Subscription[] = [];\n    private _cleanupInterval: ReturnType<typeof setInterval> | null = null;\n\n    // Observable streams for events\n    private _clientEvents = new ChannelSubject<{\n        type: \"connected\" | \"disconnected\" | \"updated\";\n        client: SWClientInfo;\n    }>();\n\n    private _config: Required<SWHostConfig>;\n\n    constructor(config: SWHostConfig) {\n        this._config = {\n            enableOfflineQueue: true,\n            maxOfflineQueueSize: 100,\n            messageTTL: 24 * 60 * 60 * 1000, // 24 hours\n            autoCleanup: true,\n            cleanupInterval: 60 * 1000, // 1 minute\n            ...config\n        };\n\n        // Initialize connection as host\n        this._connection = getConnectionPool().getOrCreate(\n            this._config.channelName,\n            \"service-worker\",\n            { metadata: { isHost: true } }\n        );\n\n        // Initialize storage\n        this._storage = getChannelStorage(this._config.channelName);\n\n        this._setupMessageHandlers();\n\n        if (this._config.autoCleanup) {\n            this._startCleanupInterval();\n        }\n    }\n\n    // ========================================================================\n    // CLIENT MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Register a client connection\n     */\n    async registerClient(clientId: string, clientInfo: Partial<SWClientInfo> = {}): Promise<void> {\n        const info: SWClientInfo = {\n            id: clientId,\n            type: clientInfo.type ?? \"window\",\n            url: clientInfo.url ?? \"\",\n            visibilityState: clientInfo.visibilityState ?? \"visible\",\n            focused: clientInfo.focused ?? false,\n            connectedAt: Date.now(),\n            lastSeen: Date.now(),\n            channels: new Set(clientInfo.channels ?? [])\n        };\n\n        this._clients.set(clientId, info);\n        this._clientEvents.next({ type: \"connected\", client: info });\n\n        // Deliver any queued messages\n        await this._deliverQueuedMessages(clientId);\n    }\n\n    /**\n     * Unregister a client\n     */\n    unregisterClient(clientId: string): void {\n        const client = this._clients.get(clientId);\n        if (client) {\n            // Remove from all channel subscriptions\n            for (const subscribers of this._channelSubscribers.values()) {\n                subscribers.delete(clientId);\n            }\n\n            this._clients.delete(clientId);\n            this._clientEvents.next({ type: \"disconnected\", client });\n        }\n    }\n\n    /**\n     * Update client info\n     */\n    updateClient(clientId: string, updates: Partial<SWClientInfo>): void {\n        const client = this._clients.get(clientId);\n        if (client) {\n            Object.assign(client, updates, { lastSeen: Date.now() });\n            this._clientEvents.next({ type: \"updated\", client });\n        }\n    }\n\n    /**\n     * Subscribe client to a channel\n     */\n    subscribeClientToChannel(clientId: string, channel: string): void {\n        // Track in client info\n        const client = this._clients.get(clientId);\n        if (client) {\n            client.channels.add(channel);\n        }\n\n        // Track in channel subscribers\n        if (!this._channelSubscribers.has(channel)) {\n            this._channelSubscribers.set(channel, new Set());\n        }\n        this._channelSubscribers.get(channel)!.add(clientId);\n    }\n\n    /**\n     * Unsubscribe client from a channel\n     */\n    unsubscribeClientFromChannel(clientId: string, channel: string): void {\n        const client = this._clients.get(clientId);\n        if (client) {\n            client.channels.delete(channel);\n        }\n\n        this._channelSubscribers.get(channel)?.delete(clientId);\n    }\n\n    /**\n     * Get all connected clients\n     */\n    getClients(): Map<string, SWClientInfo> {\n        return new Map(this._clients);\n    }\n\n    /**\n     * Get clients subscribed to a channel\n     */\n    getChannelSubscribers(channel: string): Set<string> {\n        return new Set(this._channelSubscribers.get(channel) ?? []);\n    }\n\n    // ========================================================================\n    // MESSAGING\n    // ========================================================================\n\n    /**\n     * Send message to specific client\n     */\n    async sendToClient(clientId: string, message: ChannelMessage): Promise<boolean> {\n        const client = this._clients.get(clientId);\n\n        if (!client) {\n            // Client not connected, queue if enabled\n            if (this._config.enableOfflineQueue) {\n                await this._queueMessage(clientId, message);\n            }\n            return false;\n        }\n\n        return this._postToClient(clientId, message);\n    }\n\n    /**\n     * Broadcast message to all clients subscribed to a channel\n     */\n    async broadcastToChannel(channel: string, message: ChannelMessage): Promise<number> {\n        const subscribers = this._channelSubscribers.get(channel);\n        if (!subscribers || subscribers.size === 0) {\n            return 0;\n        }\n\n        let deliveredCount = 0;\n        for (const clientId of subscribers) {\n            const delivered = await this.sendToClient(clientId, message);\n            if (delivered) deliveredCount++;\n        }\n\n        return deliveredCount;\n    }\n\n    /**\n     * Broadcast to all connected clients\n     */\n    async broadcastToAll(message: ChannelMessage): Promise<number> {\n        let deliveredCount = 0;\n\n        for (const clientId of this._clients.keys()) {\n            const delivered = await this.sendToClient(clientId, message);\n            if (delivered) deliveredCount++;\n        }\n\n        return deliveredCount;\n    }\n\n    /**\n     * Handle incoming message from client\n     */\n    async handleClientMessage(\n        clientId: string,\n        data: any\n    ): Promise<void> {\n        // Update last seen\n        this.updateClient(clientId, { lastSeen: Date.now() });\n\n        if (!data || typeof data !== \"object\") return;\n\n        const messageType = data.type as SWHostMessageType;\n\n        switch (messageType) {\n            case \"connect\":\n                await this.registerClient(clientId, data.payload);\n                break;\n\n            case \"disconnect\":\n                this.unregisterClient(clientId);\n                break;\n\n            case \"subscribe\":\n                this.subscribeClientToChannel(clientId, data.payload?.channel);\n                break;\n\n            case \"unsubscribe\":\n                this.unsubscribeClientFromChannel(clientId, data.payload?.channel);\n                break;\n\n            case \"request\":\n                // Handle request and send response\n                const response = await this._handleRequest(data);\n                if (response) {\n                    await this.sendToClient(clientId, response);\n                }\n                break;\n\n            case \"event\":\n                // Forward event to appropriate channel\n                if (data.channel) {\n                    await this.broadcastToChannel(data.channel, data);\n                }\n                break;\n\n            default:\n                // Push to connection for other handlers\n                this._connection.pushInbound({\n                    ...data,\n                    _clientId: clientId\n                });\n        }\n    }\n\n    // ========================================================================\n    // SUBSCRIPTIONS\n    // ========================================================================\n\n    /**\n     * Subscribe to client events\n     */\n    onClientEvent(\n        handler: (event: { type: \"connected\" | \"disconnected\" | \"updated\"; client: SWClientInfo }) => void\n    ): Subscription {\n        return this._clientEvents.subscribe({ next: handler });\n    }\n\n    /**\n     * Subscribe to messages from clients\n     */\n    onMessage(handler: (msg: ChannelMessage) => void): Subscription {\n        return this._connection.subscribe(handler);\n    }\n\n    /**\n     * Subscribe to messages of specific type\n     */\n    onMessageType(\n        type: ChannelMessage[\"type\"],\n        handler: (msg: ChannelMessage) => void\n    ): Subscription {\n        return this._connection.onMessageType(type, handler);\n    }\n\n    // ========================================================================\n    // OFFLINE QUEUE\n    // ========================================================================\n\n    /**\n     * Queue message for offline client\n     */\n    private async _queueMessage(clientId: string, message: ChannelMessage): Promise<void> {\n        await this._storage.defer(\n            {\n                channel: message.channel,\n                sender: message.sender,\n                type: message.type,\n                payload: { ...message.payload, _targetClient: clientId }\n            },\n            {\n                expiresIn: this._config.messageTTL,\n                priority: 0,\n                metadata: { targetClient: clientId }\n            }\n        );\n    }\n\n    /**\n     * Deliver queued messages when client reconnects\n     */\n    private async _deliverQueuedMessages(clientId: string): Promise<void> {\n        if (!this._config.enableOfflineQueue) return;\n\n        const messages = await this._storage.getDeferredMessages(clientId, { status: \"pending\" });\n\n        for (const stored of messages) {\n            const message: ChannelMessage = {\n                id: stored.id,\n                channel: stored.channel,\n                sender: stored.sender,\n                type: stored.type as ChannelMessage[\"type\"],\n                payload: stored.payload,\n                timestamp: stored.createdAt\n            };\n\n            const delivered = await this._postToClient(clientId, message);\n            if (delivered) {\n                await this._storage.markDelivered(stored.id);\n            }\n        }\n    }\n\n    // ========================================================================\n    // LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Start the host (call in SW activate)\n     */\n    async start(): Promise<void> {\n        await this._storage.open();\n        this._connection.markConnected();\n\n        // Cleanup expired messages\n        await this._storage.cleanupExpired();\n    }\n\n    /**\n     * Stop the host\n     */\n    stop(): void {\n        if (this._cleanupInterval) {\n            clearInterval(this._cleanupInterval);\n            this._cleanupInterval = null;\n        }\n\n        for (const sub of this._subscriptions) {\n            sub.unsubscribe();\n        }\n        this._subscriptions = [];\n\n        this._connection.close();\n        this._storage.close();\n    }\n\n    // ========================================================================\n    // PRIVATE METHODS\n    // ========================================================================\n\n    private _setupMessageHandlers(): void {\n        // Listen to incoming messages on connection\n        const messageSub = this._connection.subscribe({\n            next: (msg) => {\n                // Route based on message type\n                if (msg.type === \"request\") {\n                    this._handleRequest(msg);\n                }\n            }\n        });\n\n        this._subscriptions.push(messageSub);\n    }\n\n    private async _handleRequest(msg: ChannelMessage): Promise<ChannelMessage | null> {\n        // Generate response\n        const response: ChannelMessage = {\n            id: UUIDv4(),\n            channel: msg.sender,\n            sender: this._config.channelName,\n            type: \"response\",\n            reqId: msg.reqId,\n            payload: {\n                result: null,\n                error: null\n            },\n            timestamp: Date.now()\n        };\n\n        try {\n            // Handle based on payload action\n            const action = msg.payload?.action;\n\n            switch (action) {\n                case \"getClients\":\n                    response.payload.result = Array.from(this._clients.values()).map((c) => ({\n                        ...c,\n                        channels: Array.from(c.channels)\n                    }));\n                    break;\n\n                case \"getChannelInfo\":\n                    const channel = msg.payload?.channel;\n                    response.payload.result = {\n                        channel,\n                        subscriberCount: this._channelSubscribers.get(channel)?.size ?? 0\n                    };\n                    break;\n\n                case \"ping\":\n                    response.payload.result = \"pong\";\n                    break;\n\n                default:\n                    // Emit for custom handlers\n                    this._connection.pushInbound(msg);\n                    return null;\n            }\n        } catch (error) {\n            response.payload.error = error instanceof Error ? error.message : String(error);\n        }\n\n        return response;\n    }\n\n    private async _postToClient(clientId: string, message: ChannelMessage): Promise<boolean> {\n        // Service Worker specific: use clients API\n        if (typeof clients === \"undefined\") return false;\n\n        try {\n            const client = await clients.get(clientId);\n            if (client) {\n                client.postMessage(message);\n                return true;\n            }\n        } catch (e) {\n            console.error(\"[SWHost] Failed to post to client:\", e);\n        }\n\n        return false;\n    }\n\n    private _startCleanupInterval(): void {\n        this._cleanupInterval = setInterval(() => {\n            this._cleanupStaleClients();\n            this._storage.cleanupExpired();\n        }, this._config.cleanupInterval);\n    }\n\n    private async _cleanupStaleClients(): Promise<void> {\n        if (typeof clients === \"undefined\") return;\n\n        const allClients = await clients.matchAll({ includeUncontrolled: true });\n        const activeIds = new Set(allClients.map((c) => c.id));\n\n        // Remove clients that are no longer active\n        for (const clientId of this._clients.keys()) {\n            if (!activeIds.has(clientId)) {\n                this.unregisterClient(clientId);\n            }\n        }\n    }\n}\n\n// ============================================================================\n// CLIENT CONNECTOR (for pages/components)\n// ============================================================================\n\n/**\n * ServiceWorkerClient - Connects a page/component TO the SW host.\n *\n * This is what runs in the main thread to connect to the SW host.\n */\nexport class ServiceWorkerClient {\n    private _registration: ServiceWorkerRegistration | null = null;\n    private _messageHandler: ((event: MessageEvent) => void) | null = null;\n    private _subject = new ChannelSubject<ChannelMessage>();\n    // @ts-ignore\n    private _pendingRequests = new Map<string, PromiseWithResolvers<any>>();\n    private _isConnected = false;\n\n    constructor(private _channelName: string) {}\n\n    /**\n     * Connect to SW host\n     */\n    async connect(): Promise<void> {\n        if (!(\"serviceWorker\" in navigator)) {\n            throw new Error(\"Service Worker not supported\");\n        }\n\n        this._registration = await navigator.serviceWorker.ready;\n\n        // Setup message listener\n        this._messageHandler = (event: MessageEvent) => {\n            const data = event.data;\n            if (!data || typeof data !== \"object\") return;\n\n            // Handle responses\n            if (data.type === \"response\" && data.reqId) {\n                const resolvers = this._pendingRequests.get(data.reqId);\n                if (resolvers) {\n                    this._pendingRequests.delete(data.reqId);\n                    if (data.payload?.error) {\n                        resolvers.reject(new Error(data.payload.error));\n                    } else {\n                        resolvers.resolve(data.payload?.result);\n                    }\n                    return;\n                }\n            }\n\n            // Push to subject for subscribers\n            this._subject.next(data as ChannelMessage);\n        };\n\n        navigator.serviceWorker.addEventListener(\"message\", this._messageHandler);\n\n        // Send connect message\n        this._sendToSW({\n            type: \"connect\",\n            channel: this._channelName,\n            payload: {\n                url: location.href,\n                visibilityState: document.visibilityState,\n                focused: document.hasFocus()\n            }\n        });\n\n        this._isConnected = true;\n\n        // Track visibility changes\n        document.addEventListener(\"visibilitychange\", this._onVisibilityChange);\n    }\n\n    /**\n     * Disconnect from SW host\n     */\n    disconnect(): void {\n        if (this._messageHandler) {\n            navigator.serviceWorker.removeEventListener(\"message\", this._messageHandler);\n            this._messageHandler = null;\n        }\n\n        this._sendToSW({\n            type: \"disconnect\",\n            channel: this._channelName\n        });\n\n        document.removeEventListener(\"visibilitychange\", this._onVisibilityChange);\n        this._isConnected = false;\n    }\n\n    /**\n     * Subscribe to a channel\n     */\n    subscribeToChannel(channel: string): void {\n        this._sendToSW({\n            type: \"subscribe\",\n            channel: this._channelName,\n            payload: { channel }\n        });\n    }\n\n    /**\n     * Unsubscribe from a channel\n     */\n    unsubscribeFromChannel(channel: string): void {\n        this._sendToSW({\n            type: \"unsubscribe\",\n            channel: this._channelName,\n            payload: { channel }\n        });\n    }\n\n    /**\n     * Send request to SW host\n     */\n    async request<T = any>(action: string, payload: any = {}): Promise<T> {\n        const reqId = UUIDv4();\n\n        // @ts-ignore\n        const resolvers = Promise.withResolvers<T>();\n        this._pendingRequests.set(reqId, resolvers);\n\n        this._sendToSW({\n            id: UUIDv4(),\n            type: \"request\",\n            channel: this._channelName,\n            sender: \"client\",\n            reqId,\n            payload: { action, ...payload },\n            timestamp: Date.now()\n        });\n\n        // Timeout\n        setTimeout(() => {\n            if (this._pendingRequests.has(reqId)) {\n                this._pendingRequests.delete(reqId);\n                resolvers.reject(new Error(\"Request timeout\"));\n            }\n        }, 30000);\n\n        return resolvers.promise;\n    }\n\n    /**\n     * Send event to SW host\n     */\n    emit(eventType: string, data: any, targetChannel?: string): void {\n        this._sendToSW({\n            id: UUIDv4(),\n            type: \"event\",\n            channel: targetChannel ?? this._channelName,\n            sender: \"client\",\n            payload: { type: eventType, data },\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Subscribe to messages from SW host\n     */\n    subscribe(handler: (msg: ChannelMessage) => void): Subscription {\n        return this._subject.subscribe({ next: handler });\n    }\n\n    /**\n     * Subscribe to specific event type\n     */\n    on(eventType: string, handler: (data: any) => void): Subscription {\n        return filter(\n            this._subject,\n            (m) => m.type === \"event\" && m.payload?.type === eventType\n        ).subscribe({\n            next: (msg) => handler(msg.payload?.data)\n        });\n    }\n\n    /**\n     * Check if connected\n     */\n    get isConnected(): boolean {\n        return this._isConnected;\n    }\n\n    // ========================================================================\n    // PRIVATE\n    // ========================================================================\n\n    private _sendToSW(message: any): void {\n        if (!this._registration?.active) return;\n        this._registration.active.postMessage(message);\n    }\n\n    private _onVisibilityChange = (): void => {\n        if (!this._isConnected) return;\n\n        this._sendToSW({\n            type: \"event\",\n            channel: this._channelName,\n            payload: {\n                type: \"visibilityChange\",\n                data: {\n                    visibilityState: document.visibilityState,\n                    focused: document.hasFocus()\n                }\n            }\n        });\n    };\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create SW host (call in service worker)\n */\nexport function createServiceWorkerHost(config: SWHostConfig): ServiceWorkerHost {\n    return new ServiceWorkerHost(config);\n}\n\n/**\n * Create SW client (call in page/component)\n */\nexport function createServiceWorkerClient(channelName: string): ServiceWorkerClient {\n    return new ServiceWorkerClient(channelName);\n}\n","/**\n * Unified Transport - Single entry point for all transport types\n *\n * Factory and abstraction layer that provides consistent API\n * across all supported message transports.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport { Observable, ChannelSubject, type Subscription, type Observer } from \"../observable/Observable\";\nimport type { ChannelMessage, PendingRequest } from \"../types/Interface\";\nimport {\n    createTransportSender,\n    createTransportListener,\n    detectTransportType,\n    getTransportMeta,\n    createWebSocketTransport,\n    createBroadcastTransport,\n    type TransportTarget,\n    type TransportType,\n    type TransportMeta,\n    type SendFn\n} from \"../../core/TransportCore\";\n\n// Import specialized transports\nimport { SharedWorkerClient, SharedWorkerHost, type SharedWorkerOptions } from \"./SharedWorkerTransport\";\nimport { AtomicsTransport, AtomicsBuffer, AtomicsRingBuffer, createAtomicsChannelPair, type AtomicsTransportConfig } from \"./AtomicsTransport\";\nimport { RTCPeerTransport, RTCPeerManager, createBroadcastSignaling, type RTCTransportConfig } from \"./RTCDataChannelTransport\";\nimport { PortTransport, PortPool, WindowPortConnector, createChannelPair, type PortTransportConfig } from \"./PortTransport\";\nimport { TransferableStorage, MessageQueueStorage, type TransferableStorageConfig } from \"../storage/TransferableStorage\";\nimport { SocketIOObservable, type SocketIOLike, type SocketObservableOptions } from \"../observable/SocketIOObservable\";\nimport {\n    ChromeRuntimeObservable,\n    ChromeTabsObservable,\n    ChromePortObservable,\n    ChromeExternalObservable,\n    type ChromeObservableOptions\n} from \"../observable/ChromeObservable\";\nimport { ServiceWorkerHost, ServiceWorkerClient, type SWHostConfig } from \"./ServiceWorkerHost\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface UnifiedTransportConfig {\n    channelName: string;\n    type?: TransportType;\n    timeout?: number;\n    autoConnect?: boolean;\n    metadata?: Record<string, any>;\n}\n\nexport interface TransportInstance {\n    send(msg: ChannelMessage, transfer?: Transferable[]): void;\n    request(msg: ChannelMessage): Promise<any>;\n    subscribe(observer: Observer<ChannelMessage> | ((v: ChannelMessage) => void)): Subscription;\n    close(): void;\n    readonly type: TransportType;\n    readonly channelName: string;\n    readonly isReady: boolean;\n}\n\n// ============================================================================\n// ABSTRACT TRANSPORT\n// ============================================================================\n\nexport abstract class AbstractTransport implements TransportInstance {\n    protected _subs = new Set<Observer<ChannelMessage>>();\n    protected _pending = new Map<string, PendingRequest>();\n    protected _state = new ChannelSubject<\"disconnected\" | \"connecting\" | \"connected\" | \"error\">();\n    protected _ready = false;\n\n    constructor(\n        protected _type: TransportType,\n        protected _channelName: string,\n        protected _config: UnifiedTransportConfig\n    ) {}\n\n    abstract send(msg: ChannelMessage, transfer?: Transferable[]): void;\n\n    request(msg: ChannelMessage): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this._pending.delete(reqId);\n                reject(new Error(\"Request timeout\"));\n            }, this._config.timeout ?? 30000);\n\n            this._pending.set(reqId, {\n                resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                reject: (e) => { clearTimeout(timeout); reject(e); },\n                timestamp: Date.now()\n            });\n\n            this.send({ ...msg, reqId, type: \"request\" } as ChannelMessage);\n        });\n    }\n\n    subscribe(observer: Observer<ChannelMessage> | ((v: ChannelMessage) => void)): Subscription {\n        const obs: Observer<ChannelMessage> = typeof observer === \"function\" ? { next: observer } : observer;\n        this._subs.add(obs);\n        return {\n            closed: false,\n            unsubscribe: () => { this._subs.delete(obs); }\n        };\n    }\n\n    protected _handleMessage(data: ChannelMessage): void {\n        // Handle response\n        if (data.type === \"response\" && data.reqId) {\n            const p = this._pending.get(data.reqId);\n            if (p) {\n                this._pending.delete(data.reqId);\n                if (data.payload?.error) p.reject(new Error(data.payload.error));\n                else p.resolve(data.payload?.result ?? data.payload);\n                return;\n            }\n        }\n\n        for (const s of this._subs) {\n            try { s.next?.(data); } catch (e) { s.error?.(e as Error); }\n        }\n    }\n\n    close(): void {\n        this._subs.forEach(s => s.complete?.());\n        this._subs.clear();\n        this._ready = false;\n        this._state.next(\"disconnected\");\n    }\n\n    get type(): TransportType { return this._type; }\n    get channelName(): string { return this._channelName; }\n    get isReady(): boolean { return this._ready; }\n    get state() { return this._state; }\n}\n\n// ============================================================================\n// NATIVE TRANSPORT WRAPPER\n// ============================================================================\n\nclass NativeTransport extends AbstractTransport {\n    private _sendFn: SendFn<ChannelMessage>;\n    private _cleanup: (() => void) | null = null;\n\n    constructor(\n        private _target: TransportTarget,\n        config: UnifiedTransportConfig\n    ) {\n        super(detectTransportType(_target), config.channelName, config);\n        this._sendFn = createTransportSender(_target);\n        this._setupListener();\n    }\n\n    private _setupListener(): void {\n        this._cleanup = createTransportListener(\n            this._target,\n            (data) => this._handleMessage(data),\n            (err) => this._subs.forEach(s => s.error?.(err)),\n            () => this._subs.forEach(s => s.complete?.())\n        );\n        this._ready = true;\n        this._state.next(\"connected\");\n    }\n\n    send(msg: ChannelMessage, transfer?: Transferable[]): void {\n        this._sendFn(msg, transfer);\n    }\n\n    close(): void {\n        this._cleanup?.();\n        super.close();\n    }\n}\n\n// ============================================================================\n// UNIFIED FACTORY\n// ============================================================================\n\nexport interface TransportFactoryOptions {\n    // Worker\n    worker?: {\n        scriptUrl?: string | URL;\n        options?: WorkerOptions;\n        existing?: Worker;\n    };\n\n    // SharedWorker\n    sharedWorker?: {\n        scriptUrl?: string | URL;\n        options?: SharedWorkerOptions;\n    };\n\n    // WebSocket\n    websocket?: {\n        url: string;\n        protocols?: string | string[];\n        reconnect?: boolean;\n    };\n\n    // BroadcastChannel\n    broadcast?: {\n        name?: string;\n    };\n\n    // MessagePort\n    port?: {\n        port?: MessagePort;\n        config?: PortTransportConfig;\n    };\n\n    // Chrome Extension\n    chrome?: {\n        mode: \"runtime\" | \"tabs\" | \"port\" | \"external\";\n        tabId?: number;\n        portName?: string;\n        options?: ChromeObservableOptions;\n    };\n\n    // Socket.IO\n    socketio?: {\n        socket: SocketIOLike;\n        options?: SocketObservableOptions;\n    };\n\n    // Service Worker\n    serviceWorker?: {\n        mode: \"host\" | \"client\";\n        config?: SWHostConfig;\n    };\n\n    // Atomics\n    atomics?: {\n        sendBuffer: SharedArrayBuffer;\n        recvBuffer: SharedArrayBuffer;\n        config?: AtomicsTransportConfig;\n    };\n\n    // WebRTC\n    rtc?: {\n        mode: \"peer\" | \"manager\";\n        config?: RTCTransportConfig;\n    };\n}\n\n/**\n * Create transport instance based on options\n */\nexport function createTransport(\n    channelName: string,\n    options: TransportFactoryOptions = {},\n    config: Partial<UnifiedTransportConfig> = {}\n): TransportInstance {\n    const baseConfig: UnifiedTransportConfig = {\n        channelName,\n        timeout: 30000,\n        autoConnect: true,\n        ...config\n    };\n\n    // Worker\n    if (options.worker) {\n        const worker = options.worker.existing ??\n            new Worker(options.worker.scriptUrl!, options.worker.options);\n        return new NativeTransport(worker, baseConfig);\n    }\n\n    // SharedWorker\n    if (options.sharedWorker) {\n        const client = new SharedWorkerClient(\n            options.sharedWorker.scriptUrl!,\n            channelName,\n            options.sharedWorker.options\n        );\n        return {\n            send: (msg, transfer) => client.send(msg, transfer),\n            request: (msg) => client.request(msg),\n            subscribe: (obs) => client.subscribe(obs as any),\n            close: () => client.close(),\n            type: \"shared-worker\",\n            channelName,\n            isReady: true\n        };\n    }\n\n    // WebSocket\n    if (options.websocket) {\n        const ws = createWebSocketTransport(options.websocket.url, {\n            protocols: options.websocket.protocols,\n            reconnect: options.websocket.reconnect\n        });\n        const subs = new Set<Observer<ChannelMessage>>();\n        const pending = new Map<string, PendingRequest>();\n\n        ws.listen((data) => {\n            if (data.type === \"response\" && data.reqId) {\n                const p = pending.get(data.reqId);\n                if (p) {\n                    pending.delete(data.reqId);\n                    if (data.payload?.error) p.reject(new Error(data.payload.error));\n                    else p.resolve(data.payload?.result ?? data.payload);\n                    return;\n                }\n            }\n            for (const s of subs) {\n                try { s.next?.(data); } catch {}\n            }\n        });\n\n        return {\n            send: (msg, transfer) => ws.send(msg, transfer),\n            request: (msg) => new Promise((resolve, reject) => {\n                const reqId = msg.reqId ?? UUIDv4();\n                const timeout = setTimeout(() => {\n                    pending.delete(reqId);\n                    reject(new Error(\"Request timeout\"));\n                }, baseConfig.timeout);\n                pending.set(reqId, {\n                    resolve: (v) => { clearTimeout(timeout); resolve(v); },\n                    reject: (e) => { clearTimeout(timeout); reject(e); },\n                    timestamp: Date.now()\n                });\n                ws.send({ ...msg, reqId, type: \"request\" });\n            }),\n            subscribe: (obs) => {\n                const o: Observer<ChannelMessage> = typeof obs === \"function\" ? { next: obs } : obs;\n                subs.add(o);\n                return { closed: false, unsubscribe: () => subs.delete(o) };\n            },\n            close: () => { subs.clear(); ws.close(); },\n            type: \"websocket\",\n            channelName,\n            isReady: ws.socket.readyState === WebSocket.OPEN\n        };\n    }\n\n    // BroadcastChannel\n    if (options.broadcast) {\n        const bc = createBroadcastTransport(options.broadcast.name ?? channelName);\n        return new NativeTransport(bc.channel, baseConfig);\n    }\n\n    // MessagePort\n    if (options.port?.port) {\n        const transport = new PortTransport(options.port.port, channelName, options.port.config);\n        return {\n            send: (msg, transfer) => transport.send(msg, transfer),\n            request: (msg) => transport.request(msg),\n            subscribe: (obs) => transport.subscribe(obs as any),\n            close: () => transport.close(),\n            type: \"message-port\",\n            channelName,\n            isReady: transport.isListening\n        };\n    }\n\n    // Chrome\n    if (options.chrome) {\n        if (options.chrome.mode === \"runtime\") {\n            const obs = new ChromeRuntimeObservable(undefined, options.chrome.options);\n            return {\n                send: (msg) => obs.send(msg),\n                request: (msg) => obs.request(msg),\n                subscribe: (o) => obs.subscribe(o as any),\n                close: () => obs.close(),\n                type: \"chrome-runtime\",\n                channelName,\n                isReady: true\n            };\n        }\n        if (options.chrome.mode === \"tabs\") {\n            const obs = new ChromeTabsObservable(options.chrome.tabId, options.chrome.options);\n            return {\n                send: (msg) => obs.send(msg),\n                request: () => Promise.reject(\"Not supported\"),\n                subscribe: (o) => obs.subscribe(o as any),\n                close: () => obs.close(),\n                type: \"chrome-tabs\",\n                channelName,\n                isReady: true\n            };\n        }\n        if (options.chrome.mode === \"port\") {\n            const obs = new ChromePortObservable(options.chrome.portName ?? channelName, options.chrome.tabId);\n            return {\n                send: (msg) => obs.send(msg),\n                request: () => Promise.reject(\"Not supported\"),\n                subscribe: (o) => obs.subscribe(o as any),\n                close: () => obs.close(),\n                type: \"chrome-port\",\n                channelName,\n                isReady: obs.isConnected\n            };\n        }\n        if (options.chrome.mode === \"external\") {\n            const obs = new ChromeExternalObservable(options.chrome.options);\n            return {\n                send: (msg) => obs.send(msg),\n                request: () => Promise.reject(\"Not supported\"),\n                subscribe: (o) => obs.subscribe(o as any),\n                close: () => obs.close(),\n                type: \"chrome-external\",\n                channelName,\n                isReady: true\n            };\n        }\n    }\n\n    // Socket.IO\n    if (options.socketio) {\n        const obs = new SocketIOObservable(options.socketio.socket, channelName, options.socketio.options);\n        return {\n            send: (msg) => obs.send(msg),\n            request: (msg) => obs.request(msg),\n            subscribe: (o) => obs.subscribe(o as any),\n            close: () => obs.close(),\n            type: \"socket-io\",\n            channelName,\n            isReady: obs.isConnected\n        };\n    }\n\n    // Service Worker\n    if (options.serviceWorker) {\n        if (options.serviceWorker.mode === \"client\") {\n            const client = new ServiceWorkerClient(channelName);\n            client.connect();\n            return {\n                send: (msg) => client.emit(msg.type, msg.payload, msg.channel),\n                request: (msg) => client.request(msg.payload?.action ?? \"unknown\", msg.payload),\n                subscribe: (o) => client.subscribe(typeof o === \"function\" ? o : (m) => o.next?.(m)),\n                close: () => client.disconnect(),\n                type: \"service-worker\",\n                channelName,\n                isReady: client.isConnected\n            };\n        }\n    }\n\n    // Atomics\n    if (options.atomics) {\n        const transport = new AtomicsTransport(\n            channelName,\n            options.atomics.sendBuffer,\n            options.atomics.recvBuffer,\n            options.atomics.config\n        );\n        return {\n            send: (msg, transfer) => transport.send(msg),\n            request: (msg) => transport.request(msg),\n            subscribe: (o) => transport.subscribe(o as any),\n            close: () => transport.close(),\n            type: \"atomics\",\n            channelName,\n            isReady: true\n        };\n    }\n\n    // RTC\n    if (options.rtc) {\n        if (options.rtc.mode === \"peer\") {\n            const peer = new RTCPeerTransport(channelName, options.rtc.config);\n            return {\n                send: (msg) => peer.send(msg),\n                request: (msg) => peer.request(msg),\n                subscribe: (o) => peer.subscribe(o as any),\n                close: () => peer.close(),\n                type: \"rtc-data\",\n                channelName,\n                isReady: peer.connectionState === \"connected\"\n            };\n        }\n        if (options.rtc.mode === \"manager\") {\n            const manager = new RTCPeerManager(channelName, options.rtc.config);\n            return {\n                send: (msg) => manager.broadcast(msg),\n                request: () => Promise.reject(\"Use manager.request(peerId, msg) directly\"),\n                subscribe: (o) => manager.subscribe(o as any),\n                close: () => manager.close(),\n                type: \"rtc-data\",\n                channelName,\n                isReady: true\n            };\n        }\n    }\n\n    // Default: internal observable\n    const subject = new ChannelSubject<ChannelMessage>();\n    return {\n        send: (msg) => subject.next(msg),\n        request: () => Promise.reject(\"Internal transport does not support request\"),\n        subscribe: (o) => subject.subscribe(o as any),\n        close: () => subject.complete(),\n        type: \"internal\",\n        channelName,\n        isReady: true\n    };\n}\n\n// ============================================================================\n// TRANSPORT REGISTRY\n// ============================================================================\n\nclass TransportRegistry {\n    private _transports = new Map<string, TransportInstance>();\n\n    register(name: string, transport: TransportInstance): void {\n        this._transports.set(name, transport);\n    }\n\n    get(name: string): TransportInstance | undefined {\n        return this._transports.get(name);\n    }\n\n    getOrCreate(\n        name: string,\n        options: TransportFactoryOptions = {},\n        config: Partial<UnifiedTransportConfig> = {}\n    ): TransportInstance {\n        let transport = this._transports.get(name);\n        if (!transport) {\n            transport = createTransport(name, options, config);\n            this._transports.set(name, transport);\n        }\n        return transport;\n    }\n\n    remove(name: string): void {\n        const transport = this._transports.get(name);\n        if (transport) {\n            transport.close();\n            this._transports.delete(name);\n        }\n    }\n\n    closeAll(): void {\n        for (const transport of this._transports.values()) {\n            transport.close();\n        }\n        this._transports.clear();\n    }\n\n    list(): string[] {\n        return Array.from(this._transports.keys());\n    }\n\n    get size(): number {\n        return this._transports.size;\n    }\n}\n\nlet _registry: TransportRegistry | null = null;\n\nexport function getTransportRegistry(): TransportRegistry {\n    if (!_registry) _registry = new TransportRegistry();\n    return _registry;\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport const UnifiedTransportFactory = {\n    // Main factory\n    create: createTransport,\n    registry: getTransportRegistry,\n\n    // Native wrappers\n    fromWorker: (worker: Worker, name: string, config?: Partial<UnifiedTransportConfig>) =>\n        createTransport(name, { worker: { existing: worker } }, config),\n    fromPort: (port: MessagePort, name: string, config?: Partial<UnifiedTransportConfig>) =>\n        createTransport(name, { port: { port } }, config),\n    fromWebSocket: (url: string, name: string, config?: Partial<UnifiedTransportConfig>) =>\n        createTransport(name, { websocket: { url } }, config),\n    fromBroadcast: (name: string, config?: Partial<UnifiedTransportConfig>) =>\n        createTransport(name, { broadcast: {} }, config),\n\n    // Specialized transports\n    sharedWorker: {\n        client: (url: string | URL, name: string, opts?: SharedWorkerOptions) =>\n            new SharedWorkerClient(url, name, opts),\n        host: (name: string) => new SharedWorkerHost(name)\n    },\n\n    atomics: {\n        create: (name: string, send: SharedArrayBuffer, recv: SharedArrayBuffer, config?: AtomicsTransportConfig) =>\n            new AtomicsTransport(name, send, recv, config),\n        createPair: createAtomicsChannelPair,\n        buffer: (size?: number) => new AtomicsBuffer(size),\n        ringBuffer: () => new AtomicsRingBuffer()\n    },\n\n    rtc: {\n        peer: (name: string, config?: RTCTransportConfig) => new RTCPeerTransport(name, config),\n        manager: (name: string, config?: RTCTransportConfig) => new RTCPeerManager(name, config),\n        signaling: createBroadcastSignaling\n    },\n\n    port: {\n        create: (port: MessagePort, name: string, config?: PortTransportConfig) =>\n            new PortTransport(port, name, config),\n        createPair: createChannelPair,\n        pool: (config?: PortTransportConfig) => new PortPool(config),\n        windowConnector: (target: Window, name: string) => new WindowPortConnector(target, name)\n    },\n\n    storage: {\n        create: <T>(config: TransferableStorageConfig) => new TransferableStorage<T>(config),\n        messageQueue: (dbName?: string) => new MessageQueueStorage(dbName)\n    },\n\n    serviceWorker: {\n        host: (config: SWHostConfig) => new ServiceWorkerHost(config),\n        client: (name: string) => new ServiceWorkerClient(name)\n    },\n\n    socketio: (socket: SocketIOLike, name: string, opts?: SocketObservableOptions) =>\n        new SocketIOObservable(socket, name, opts),\n\n    chrome: {\n        runtime: (opts?: ChromeObservableOptions) => new ChromeRuntimeObservable(undefined, opts),\n        tabs: (tabId?: number, opts?: ChromeObservableOptions) => new ChromeTabsObservable(tabId, opts),\n        port: (name: string, tabId?: number) => new ChromePortObservable(name, tabId)\n    },\n\n    // Utilities\n    detect: detectTransportType,\n    meta: getTransportMeta\n};\n\n// Default export\nexport default UnifiedTransportFactory;\n","import { UUIDv4 } from \"fest/core\";\nimport { initChannelHandler } from \"../channel/Channels\";\n\n/**\n * Type definitions for fest/uniform\n * Centralized to avoid circular import issues\n */\n\nexport interface WorkerChannel {\n    request(method: string, args?: any[]): Promise<any>;\n    close(): void;\n}\n\nexport interface WorkerConfig {\n    name: string;\n    script: string | (() => Worker) | Worker;\n    options?: WorkerOptions;\n    context?: 'main' | 'service-worker' | 'chrome-extension';\n    tabsChannel?: boolean;\n    tabsOptions?: { tabFilter?: (tab: chrome.tabs.Tab) => boolean };\n    currentTabChannel?: boolean;\n    currentTabOptions?: {\n        tabIdGetter?: () => Promise<number> | number;\n        useVisibleTab?: boolean;\n    };\n}\n\nexport interface QueuedRequest {\n    id: string;\n    method: string;\n    args: any[];\n    resolve: (value: any) => void;\n    reject: (error: any) => void;\n    timestamp: number;\n}\n\nexport interface MessageEnvelope {\n    id: string;\n    type: string;\n    payload: any;\n    timestamp: number;\n    replyTo?: string;\n}\n\nexport interface ProtocolOptions {\n    timeout?: number;\n    retries?: number;\n    compression?: boolean;\n    batching?: boolean;\n}\n\n\n/**\n * Queued worker channel that buffers requests until the channel is available\n */\nexport class QueuedWorkerChannel implements WorkerChannel {\n    private underlyingChannel: WorkerChannel | null = null;\n    private isConnected = false;\n    private requestQueue: QueuedRequest[] = [];\n    private connectionPromise: Promise<void> | null = null;\n    private connectionResolver: (() => void) | null = null;\n    private context: 'main' | 'service-worker' | 'chrome-extension' | 'unknown';\n\n    constructor(\n        private config: WorkerConfig,\n        private onChannelReady?: (channel: WorkerChannel) => void\n    ) {\n        this.context = config.context ?? 'unknown';\n    }\n\n    /**\n     * Initialize the underlying channel\n     */\n    async connect(underlyingChannel: WorkerChannel | null = null): Promise<void> {\n        this.underlyingChannel = underlyingChannel;\n    }\n\n    /**\n     * Queue a request if channel isn't ready, otherwise send immediately\n     */\n    async request(method: string, args: any[] = []): Promise<any> {\n        if (this.isConnected && this.underlyingChannel) {\n            return this.underlyingChannel.request(method, args);\n        }\n\n        // Queue the request\n        return new Promise((resolve, reject) => {\n            const queuedRequest: QueuedRequest = {\n                id: UUIDv4(),\n                method,\n                args,\n                resolve,\n                reject,\n                timestamp: Date.now()\n            };\n\n            this.requestQueue.push(queuedRequest);\n\n            // Auto-connect if not already connecting\n            if (!this.connectionPromise) {\n                this.connect().catch((error) => {\n                    this.rejectAllQueued(error);\n                });\n            }\n        });\n    }\n\n    /**\n     * Process all queued requests\n     */\n    private async flushQueue(): Promise<void> {\n        if (!this.underlyingChannel) return;\n\n        const queueCopy = [...this.requestQueue];\n        this.requestQueue = [];\n\n        for (const queuedRequest of queueCopy) {\n            try {\n                const result = await this.underlyingChannel.request(queuedRequest.method, queuedRequest.args);\n                queuedRequest.resolve(result);\n            } catch (error) {\n                queuedRequest.reject(error);\n            }\n        }\n    }\n\n    /**\n     * Reject all queued requests with an error\n     */\n    private rejectAllQueued(error: Error): void {\n        const queueCopy = [...this.requestQueue];\n        this.requestQueue = [];\n\n        for (const queuedRequest of queueCopy) {\n            queuedRequest.reject(error);\n        }\n    }\n\n    /**\n     * Get queue status\n     */\n    getQueueStatus() {\n        return {\n            isConnected: this.isConnected,\n            queuedRequests: this.requestQueue.length,\n            isConnecting: !!this.connectionPromise && !this.isConnected\n        };\n    }\n\n    close(): void {\n        this.rejectAllQueued(new Error('Channel closed'));\n        this.underlyingChannel?.close();\n        this.underlyingChannel = null;\n        this.isConnected = false;\n        this.connectionPromise = null;\n    }\n}\n\n\n\n/**\n * Default tab ID getter - gets current active tab\n */\nexport const getCurrentTabId = async (): Promise<number> => {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length === 0) {\n        throw new Error('No active tab found');\n    }\n    if (!tabs[0].id) {\n        throw new Error('Active tab has no ID');\n    }\n    return tabs[0].id;\n};\n\n/**\n * Tab ID getter for visible tab (may be different from active)\n */\nexport const getVisibleTabId = async (): Promise<number> => {\n    // First try active tab\n    try {\n        return await getCurrentTabId();\n    } catch {\n        // Fallback to any visible tab\n        const tabs = await chrome.tabs.query({ currentWindow: true });\n        const visibleTab = tabs.find(tab => tab.active);\n        if (!visibleTab?.id) {\n            throw new Error('No visible tab found');\n        }\n        return visibleTab.id;\n    }\n};\n\n/**\n * Chrome Extension Runtime Module Interface\n */\nexport interface CrxRuntimeModule {\n    // Capture screenshot + AI processing in one call\n    capture(rect?: { x: number; y: number; width: number; height: number }, mode?: string): Promise<any>;\n\n    // Just capture screenshot, return image data\n    captureScreenshot(rect?: { x: number; y: number; width: number; height: number }): Promise<any>;\n\n    // Process captured image data with AI\n    processImage(imageData: string | Blob, mode?: string): Promise<any>;\n\n    processText(text: string, options?: { type?: string }): Promise<any>;\n    doCopy(data: { text?: string; data?: any }, options?: { showToast?: boolean }): Promise<any>;\n    loadMarkdown(src: string): Promise<any>;\n    captureWithRect(mode?: string): Promise<any>;\n    getCurrentTab(): Promise<chrome.tabs.Tab | null>;\n    sendMessage(type: string, data?: any): Promise<any>;\n    close(): void;\n}\n\n/**\n * Simplified worker registration for common patterns\n */\nexport const registerWorkerAPI = (api: Record<string, Function>, channelName: string = \"worker\") => {\n    // This will be called in worker context to register functions\n    const channelHandler = initChannelHandler(channelName ?? \"worker\");\n\n    // Register functions in the uniform data store\n    Object.keys(api).forEach(methodName => {\n        const method = api[methodName];\n        if (typeof method === 'function') {\n            // Functions are automatically available through the uniform reflection system\n            // The channel handler will proxy calls to these functions\n        }\n    });\n\n    return channelHandler;\n};\n\n/**\n * Optimized communication protocol for fest/uniform\n * Provides efficient message passing and state synchronization\n */\n\nexport interface ProtocolOptions {\n    timeout?: number;\n    retries?: number;\n    compression?: boolean;\n    batching?: boolean;\n}\n\nexport class OptimizedWorkerChannel {\n    private channel: WorkerChannel | null = null;\n    private isChannelReady = false;\n    private pendingRequests = new Map<string, {\n        resolve: Function;\n        reject: Function;\n        timeout: number;\n    }>();\n    private messageQueue: MessageEnvelope[] = [];\n    private queuedRequests: QueuedRequest[] = [];\n    private batchTimer?: number;\n    private options: Required<ProtocolOptions>;\n    private onChannelReady?: (channel: WorkerChannel) => void;\n\n    constructor(\n        channel: WorkerChannel | null = null,\n        options: ProtocolOptions = {},\n        onChannelReady?: (channel: WorkerChannel) => void\n    ) {\n        this.channel = channel;\n        this.isChannelReady = !!channel;\n        this.onChannelReady = onChannelReady;\n        this.options = {\n            timeout: 30000,\n            retries: 3,\n            compression: false,\n            batching: true,\n            ...options\n        };\n    }\n\n    /**\n     * Set the underlying channel when it becomes available\n     */\n    setChannel(channel: WorkerChannel): void {\n        this.channel = channel;\n        this.isChannelReady = true;\n        this.onChannelReady?.(channel);\n        this.flushQueuedRequests();\n    }\n\n    /**\n     * Send a request and wait for response\n     */\n    async request(type: string, payload: any, options?: Partial<ProtocolOptions>): Promise<any> {\n        // If channel is not ready, queue the request\n        if (!this.isChannelReady || !this.channel) {\n            return new Promise((resolve, reject) => {\n                const queuedRequest: QueuedRequest = {\n                    id: UUIDv4(),\n                    method: type,\n                    args: [payload],\n                    resolve,\n                    reject,\n                    timestamp: Date.now()\n                };\n                this.queuedRequests.push(queuedRequest);\n            });\n        }\n\n        const opts = { ...this.options, ...options };\n        const messageId = UUIDv4();\n\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this.pendingRequests.delete(messageId);\n                reject(new Error(`Request timeout: ${type}`));\n            }, opts.timeout);\n\n            this.pendingRequests.set(messageId, { resolve, reject, timeout });\n\n            const envelope: MessageEnvelope = {\n                id: messageId,\n                type,\n                payload,\n                timestamp: Date.now()\n            };\n\n            if (opts.batching) {\n                this.queueMessage(envelope);\n            } else {\n                this.sendMessage(envelope);\n            }\n        });\n    }\n\n    /**\n     * Process queued requests when channel becomes available\n     */\n    private async flushQueuedRequests(): Promise<void> {\n        if (!this.channel || this.queuedRequests.length === 0) return;\n\n        const queueCopy = [...this.queuedRequests];\n        this.queuedRequests = [];\n\n        for (const queuedRequest of queueCopy) {\n            try { // @ts-ignore\n                const result = await this.request(queuedRequest.method, ...((queuedRequest?.args ?? []) as any));\n                queuedRequest.resolve(result);\n            } catch (error) {\n                queuedRequest.reject(error);\n            }\n        }\n    }\n\n    /**\n     * Send a one-way message (fire and forget)\n     */\n    notify(type: string, payload: any): void {\n        const envelope: MessageEnvelope = {\n            id: UUIDv4(),\n            type,\n            payload,\n            timestamp: Date.now()\n        };\n\n        if (this.options.batching) {\n            this.queueMessage(envelope);\n        } else {\n            this.sendMessage(envelope);\n        }\n    }\n\n    /**\n     * Stream data with backpressure handling\n     */\n    async *stream(type: string, data: any[]): AsyncGenerator<any> {\n        for (const chunk of data) {\n            const result = await this.request(`${type}:chunk`, chunk);\n            yield result;\n        }\n    }\n\n    /**\n     * Queue message for batching\n     */\n    private queueMessage(envelope: MessageEnvelope): void {\n        this.messageQueue.push(envelope);\n\n        if (!this.batchTimer) {\n            this.batchTimer = setTimeout(() => {\n                this.flushBatch();\n            }, 16); // ~60fps\n        }\n    }\n\n    /**\n     * Send batched messages\n     */\n    private flushBatch(): void {\n        if (this.messageQueue.length === 0) return;\n\n        const batchEnvelope: MessageEnvelope = {\n            id: UUIDv4(),\n            type: \"batch\",\n            payload: this.messageQueue,\n            timestamp: Date.now()\n        };\n\n        this.sendMessage(batchEnvelope);\n        this.messageQueue = [];\n        this.batchTimer = undefined;\n    }\n\n    /**\n     * Send single message through channel\n     */\n    private async sendMessage(envelope: MessageEnvelope): Promise<void> {\n        try {\n            const result = await this.channel?.request?.(\"processMessage\", [envelope]);\n\n            // Handle response if it's a reply\n            if (envelope.replyTo && this.pendingRequests.has(envelope.replyTo)) {\n                const { resolve, timeout } = this.pendingRequests.get(envelope.replyTo)!;\n                clearTimeout(timeout);\n                this.pendingRequests.delete(envelope.replyTo);\n                resolve(result);\n            }\n        } catch (error) {\n            // Handle failed message\n            if (this.pendingRequests.has(envelope.id)) {\n                const { reject, timeout } = this.pendingRequests.get(envelope.id)!;\n                clearTimeout(timeout);\n                this.pendingRequests.delete(envelope.id);\n                reject(error);\n            }\n        }\n    }\n\n    /**\n     * Close the channel\n     */\n    close(): void {\n        if (this.batchTimer) {\n            clearTimeout(this.batchTimer);\n        }\n\n        // Reject all pending requests\n        for (const [id, { reject, timeout }] of this.pendingRequests) {\n            clearTimeout(timeout);\n            reject(new Error(\"Channel closed\"));\n        }\n\n        //\n        this.pendingRequests.clear();\n        this.channel?.close?.();\n    }\n}\n","/**\n * Generic Message Queue Utility\n * Provides persistent queuing for cross-context communications using IndexedDB\n * Part of fest/uniform - no app-specific dependencies\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface QueuedMessage<T = unknown> {\n    id: string;\n    type: string;\n    data: T;\n    timestamp: number;\n    priority: MessagePriority;\n    retryCount: number;\n    maxRetries: number;\n    expiresAt?: number;\n    destination?: string;\n    metadata?: Record<string, unknown>;\n}\n\nexport type MessagePriority = 'low' | 'normal' | 'high';\n\nexport interface MessageQueueOptions {\n    dbName?: string;\n    storeName?: string;\n    maxRetries?: number;\n    defaultExpirationMs?: number;\n    fallbackStorageKey?: string;\n}\n\nexport interface QueueMessageOptions {\n    priority?: MessagePriority;\n    maxRetries?: number;\n    expiresAt?: number;\n    destination?: string;\n    metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// MESSAGE QUEUE CLASS\n// ============================================================================\n\nexport class MessageQueue {\n    private db: IDBDatabase | null = null;\n    private dbPromise: Promise<IDBDatabase> | null = null;\n    private options: Required<MessageQueueOptions>;\n\n    constructor(options: MessageQueueOptions = {}) {\n        this.options = {\n            dbName: options.dbName ?? 'UniformMessageQueue',\n            storeName: options.storeName ?? 'messages',\n            maxRetries: options.maxRetries ?? 3,\n            defaultExpirationMs: options.defaultExpirationMs ?? 24 * 60 * 60 * 1000, // 24 hours\n            fallbackStorageKey: options.fallbackStorageKey ?? 'uniform_message_queue'\n        };\n    }\n\n    // ========================================================================\n    // DATABASE INITIALIZATION\n    // ========================================================================\n\n    /**\n     * Initialize IndexedDB database\n     */\n    private async initDB(): Promise<IDBDatabase | null> {\n        if (this.db) return this.db;\n        if (this.dbPromise) return this.dbPromise;\n\n        // Check if IndexedDB is available\n        if (!MessageQueue.isIndexedDBAvailable()) {\n            console.warn('[MessageQueue] IndexedDB not available, using sessionStorage fallback');\n            return null;\n        }\n\n        this.dbPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.options.dbName, 1);\n\n            request.onerror = () => {\n                console.warn('[MessageQueue] IndexedDB open failed, falling back to sessionStorage');\n                reject(new Error('IndexedDB not available'));\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(this.options.storeName)) {\n                    const store = db.createObjectStore(this.options.storeName, { keyPath: 'id' });\n                    store.createIndex('timestamp', 'timestamp', { unique: false });\n                    store.createIndex('type', 'type', { unique: false });\n                    store.createIndex('priority', 'priority', { unique: false });\n                    store.createIndex('destination', 'destination', { unique: false });\n                }\n            };\n        });\n\n        try {\n            this.db = await this.dbPromise;\n            return this.db;\n        } catch {\n            // Fallback to sessionStorage if IndexedDB fails\n            return null;\n        }\n    }\n\n    // ========================================================================\n    // QUEUE OPERATIONS\n    // ========================================================================\n\n    /**\n     * Generate unique message ID\n     */\n    private generateId(): string {\n        return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n    }\n\n    /**\n     * Queue a message for later processing\n     */\n    async queueMessage<T>(\n        type: string,\n        data: T,\n        options: QueueMessageOptions = {}\n    ): Promise<string> {\n        const message: QueuedMessage<T> = {\n            id: this.generateId(),\n            type,\n            data,\n            timestamp: Date.now(),\n            priority: options.priority ?? 'normal',\n            retryCount: 0,\n            maxRetries: options.maxRetries ?? this.options.maxRetries,\n            expiresAt: options.expiresAt ?? (Date.now() + this.options.defaultExpirationMs),\n            destination: options.destination,\n            metadata: options.metadata\n        };\n\n        try {\n            const db = await this.initDB();\n            if (db) {\n                await this.addToIndexedDB(db, message);\n            } else {\n                this.addToSessionStorage(message);\n            }\n\n            console.log(`[MessageQueue] Queued message: ${type}`, message.id);\n            return message.id;\n        } catch (error) {\n            console.error('[MessageQueue] Failed to queue message:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get all queued messages\n     */\n    async getQueuedMessages<T = unknown>(destination?: string): Promise<QueuedMessage<T>[]> {\n        try {\n            const db = await this.initDB();\n            let messages: QueuedMessage<T>[];\n            \n            if (db) {\n                messages = await this.getAllFromIndexedDB<T>(db);\n            } else {\n                messages = this.getAllFromSessionStorage<T>();\n            }\n\n            // Filter by destination if specified\n            if (destination) {\n                messages = messages.filter(msg => msg.destination === destination);\n            }\n\n            // Filter out expired messages\n            const now = Date.now();\n            return messages.filter(msg => !msg.expiresAt || msg.expiresAt > now);\n        } catch (error) {\n            console.error('[MessageQueue] Failed to get queued messages:', error);\n            return this.getAllFromSessionStorage<T>();\n        }\n    }\n\n    /**\n     * Remove a message from the queue\n     */\n    async removeMessage(messageId: string): Promise<void> {\n        try {\n            const db = await this.initDB();\n            if (db) {\n                await this.deleteFromIndexedDB(db, messageId);\n            } else {\n                this.deleteFromSessionStorage(messageId);\n            }\n        } catch (error) {\n            console.error('[MessageQueue] Failed to remove message:', error);\n        }\n    }\n\n    /**\n     * Update message retry count\n     */\n    async updateMessageRetry(messageId: string, retryCount: number): Promise<void> {\n        try {\n            const db = await this.initDB();\n            if (db) {\n                await this.updateInIndexedDB(db, messageId, { retryCount });\n            } else {\n                this.updateInSessionStorage(messageId, { retryCount });\n            }\n        } catch (error) {\n            console.error('[MessageQueue] Failed to update message retry:', error);\n        }\n    }\n\n    /**\n     * Clear all expired messages\n     */\n    async clearExpiredMessages(): Promise<number> {\n        try {\n            const messages = await this.getQueuedMessages();\n            const now = Date.now();\n            const expiredIds = messages\n                .filter(msg => msg.expiresAt && msg.expiresAt <= now)\n                .map(msg => msg.id);\n\n            for (const id of expiredIds) {\n                await this.removeMessage(id);\n            }\n\n            if (expiredIds.length > 0) {\n                console.log(`[MessageQueue] Cleared ${expiredIds.length} expired messages`);\n            }\n            \n            return expiredIds.length;\n        } catch (error) {\n            console.error('[MessageQueue] Failed to clear expired messages:', error);\n            return 0;\n        }\n    }\n\n    /**\n     * Clear all messages\n     */\n    async clearAll(): Promise<void> {\n        try {\n            const db = await this.initDB();\n            if (db) {\n                await this.clearIndexedDB(db);\n            } else {\n                sessionStorage.removeItem(this.options.fallbackStorageKey);\n            }\n            console.log('[MessageQueue] Cleared all messages');\n        } catch (error) {\n            console.error('[MessageQueue] Failed to clear all messages:', error);\n        }\n    }\n\n    /**\n     * Get queue statistics\n     */\n    async getStats(): Promise<{\n        total: number;\n        byPriority: Record<MessagePriority, number>;\n        byDestination: Record<string, number>;\n        expired: number;\n    }> {\n        const messages = await this.getQueuedMessages();\n        const now = Date.now();\n        \n        const byPriority: Record<MessagePriority, number> = { low: 0, normal: 0, high: 0 };\n        const byDestination: Record<string, number> = {};\n        let expired = 0;\n\n        for (const msg of messages) {\n            byPriority[msg.priority]++;\n            if (msg.destination) {\n                byDestination[msg.destination] = (byDestination[msg.destination] || 0) + 1;\n            }\n            if (msg.expiresAt && msg.expiresAt <= now) {\n                expired++;\n            }\n        }\n\n        return {\n            total: messages.length,\n            byPriority,\n            byDestination,\n            expired\n        };\n    }\n\n    // ========================================================================\n    // INDEXEDDB OPERATIONS\n    // ========================================================================\n\n    private async addToIndexedDB<T>(db: IDBDatabase, message: QueuedMessage<T>): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.options.storeName], 'readwrite');\n            const store = transaction.objectStore(this.options.storeName);\n            const request = store.add(message);\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    private async getAllFromIndexedDB<T>(db: IDBDatabase): Promise<QueuedMessage<T>[]> {\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.options.storeName], 'readonly');\n            const store = transaction.objectStore(this.options.storeName);\n            const request = store.getAll();\n            request.onsuccess = () => resolve(request.result as QueuedMessage<T>[]);\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    private async deleteFromIndexedDB(db: IDBDatabase, id: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.options.storeName], 'readwrite');\n            const store = transaction.objectStore(this.options.storeName);\n            const request = store.delete(id);\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    private async updateInIndexedDB(\n        db: IDBDatabase, \n        id: string, \n        updates: Partial<QueuedMessage>\n    ): Promise<void> {\n        const transaction = db.transaction([this.options.storeName], 'readwrite');\n        const store = transaction.objectStore(this.options.storeName);\n        \n        const message = await new Promise<QueuedMessage | undefined>((resolve, reject) => {\n            const request = store.get(id);\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n\n        if (message) {\n            Object.assign(message, updates);\n            await new Promise<void>((resolve, reject) => {\n                const request = store.put(message);\n                request.onsuccess = () => resolve();\n                request.onerror = () => reject(request.error);\n            });\n        }\n    }\n\n    private async clearIndexedDB(db: IDBDatabase): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([this.options.storeName], 'readwrite');\n            const store = transaction.objectStore(this.options.storeName);\n            const request = store.clear();\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    // ========================================================================\n    // SESSION STORAGE FALLBACK\n    // ========================================================================\n\n    private getAllFromSessionStorage<T>(): QueuedMessage<T>[] {\n        try {\n            const stored = sessionStorage.getItem(this.options.fallbackStorageKey);\n            return stored ? JSON.parse(stored) : [];\n        } catch {\n            return [];\n        }\n    }\n\n    private addToSessionStorage<T>(message: QueuedMessage<T>): void {\n        const existing = this.getAllFromSessionStorage();\n        existing.push(message);\n        sessionStorage.setItem(this.options.fallbackStorageKey, JSON.stringify(existing));\n    }\n\n    private deleteFromSessionStorage(id: string): void {\n        const existing = this.getAllFromSessionStorage();\n        const filtered = existing.filter(msg => msg.id !== id);\n        sessionStorage.setItem(this.options.fallbackStorageKey, JSON.stringify(filtered));\n    }\n\n    private updateInSessionStorage(id: string, updates: Partial<QueuedMessage>): void {\n        const existing = this.getAllFromSessionStorage();\n        const message = existing.find(msg => msg.id === id);\n        if (message) {\n            Object.assign(message, updates);\n            sessionStorage.setItem(this.options.fallbackStorageKey, JSON.stringify(existing));\n        }\n    }\n\n    // ========================================================================\n    // STATIC UTILITIES\n    // ========================================================================\n\n    /**\n     * Check if IndexedDB is available\n     */\n    static isIndexedDBAvailable(): boolean {\n        try {\n            return typeof indexedDB !== 'undefined' &&\n                   typeof IDBTransaction !== 'undefined' &&\n                   typeof IDBKeyRange !== 'undefined';\n        } catch {\n            return false;\n        }\n    }\n}\n\n// ============================================================================\n// SINGLETON FACTORY\n// ============================================================================\n\nconst instances = new Map<string, MessageQueue>();\n\n/**\n * Get or create a MessageQueue instance\n */\nexport function getMessageQueue(options?: MessageQueueOptions): MessageQueue {\n    const key = options?.dbName ?? 'default';\n    if (!instances.has(key)) {\n        instances.set(key, new MessageQueue(options));\n    }\n    return instances.get(key)!;\n}\n\n/**\n * Create a new MessageQueue instance (not cached)\n */\nexport function createMessageQueue(options?: MessageQueueOptions): MessageQueue {\n    return new MessageQueue(options);\n}\n","export type ExecutionContext =\n    | \"main\"\n    | \"service-worker\"\n    | \"chrome-extension\"\n    | \"unknown\";\n\nexport const isServiceWorkerContext = (): boolean => {\n    try {\n        const SWGS = (globalThis as any)?.ServiceWorkerGlobalScope;\n        return typeof SWGS !== \"undefined\" && (globalThis as any) instanceof SWGS;\n    } catch {\n        return false;\n    }\n};\n\nexport const isChromeExtensionContext = (): boolean => {\n    try {\n        // eslint-disable-next-line no-undef\n        return typeof chrome !== \"undefined\" && !!chrome?.runtime?.id;\n    } catch {\n        return false;\n    }\n};\n\n/**\n * Detect the current runtime context.\n *\n * NOTE: In MV3, the background is a Service Worker but still part of the\n * extension runtime. We treat it as \"chrome-extension\" for API compatibility.\n */\nexport const detectExecutionContext = (): ExecutionContext => {\n    if (isChromeExtensionContext()) return \"chrome-extension\";\n    if (isServiceWorkerContext()) return \"service-worker\";\n\n    // best-effort heuristic: if we have DOM, call it \"main\"\n    try {\n        if (typeof document !== \"undefined\") return \"main\";\n    } catch {\n        // ignore\n    }\n\n    return \"unknown\";\n};\n\nexport const supportsDedicatedWorkers = (): boolean => {\n    if (isServiceWorkerContext()) return false;\n    try {\n        return typeof Worker !== \"undefined\";\n    } catch {\n        return false;\n    }\n};\n\n","type CrxSender = chrome.runtime.MessageSender;\ntype CrxSendResponse = (response: any) => void;\ntype CrxListener = (event: any, sender: CrxSender, sendResponse: CrxSendResponse) => void | Promise<void>;\n\nconst runtimeListenerRegistry = new Map<string, Set<CrxListener>>();\nlet runtimeListenerInstalled = false;\n\nconst ensureRuntimeListener = () => {\n    if (runtimeListenerInstalled) return;\n    runtimeListenerInstalled = true;\n\n    chrome?.runtime?.onMessage?.addListener?.((message: any, sender: CrxSender, sendResponse: CrxSendResponse) => {\n        const channelName = (message?.channelName ?? message?.target) as string | undefined;\n        if (!channelName) return;\n\n        const listeners = runtimeListenerRegistry.get(channelName);\n        if (!listeners || listeners.size === 0) return;\n\n        const event = {\n            data: message,\n            origin: sender?.url || \"chrome-extension\",\n            source: sender\n        };\n\n        // Dispatch (sync or async). Returning true keeps sendResponse alive.\n        for (const listener of listeners) {\n            try {\n                const out = listener(event, sender, sendResponse);\n                // avoid unhandled rejections on async listeners\n                if (out && typeof (out as any)?.catch === \"function\") {\n                    (out as Promise<void>).catch((error) => console.error(\"[ChromeExtensionBroadcastChannel] Listener error:\", error));\n                }\n            } catch (error) {\n                console.error(\"[ChromeExtensionBroadcastChannel] Listener error:\", error);\n            }\n        }\n\n        return true;\n    });\n};\n\n/**\n * Chrome Extension Broadcast-like Channel\n * Acts like a BroadcastChannel but uses chrome.runtime messaging\n */\nexport class ChromeExtensionBroadcastChannel {\n    private listeners: Set<CrxListener> = new Set();\n\n    constructor(private channelName: string) {\n        ensureRuntimeListener();\n    }\n\n    addEventListener(type: \"message\", listener: (event: any, sender: CrxSender, sendResponse: CrxSendResponse) => void | Promise<void>) {\n        if (type !== \"message\") return;\n        this.listeners.add(listener);\n        let set = runtimeListenerRegistry.get(this.channelName);\n        if (!set) {\n            set = new Set();\n            runtimeListenerRegistry.set(this.channelName, set);\n        }\n        set.add(listener);\n    }\n\n    removeEventListener(type: \"message\", listener: (event: any, sender: CrxSender, sendResponse: CrxSendResponse) => void | Promise<void>) {\n        if (type !== \"message\") return;\n        this.listeners.delete(listener);\n        runtimeListenerRegistry.get(this.channelName)?.delete(listener);\n    }\n\n    postMessage(message: any) {\n        const messageWithChannel = {\n            ...message,\n            channelName: this.channelName,\n            source: \"broadcast-channel\"\n        };\n\n        // Send via chrome runtime messaging (ignore response)\n        chrome?.runtime?.sendMessage?.(messageWithChannel, () => void 0);\n    }\n\n    close() {\n        for (const listener of this.listeners) {\n            runtimeListenerRegistry.get(this.channelName)?.delete(listener);\n        }\n        this.listeners.clear();\n    }\n}\n\n/**\n * Unified Chrome Extension Tabs Channel\n * Acts like a BroadcastChannel but uses chrome.tabs messaging to communicate with content scripts\n * Supports both broadcast-to-multiple-tabs and current-tab-only targeting\n */\nexport class ChromeExtensionTabsChannel {\n    private wrappedByOriginal = new Map<CrxListener, CrxListener>();\n    private wrappedListeners: Set<CrxListener> = new Set();\n    private channelName: string;\n    private mode: 'broadcast' | 'current-tab' = 'broadcast';\n    private tabFilter?: (tab: chrome.tabs.Tab) => boolean;\n    private tabIdGetter?: () => Promise<number> | number;\n\n    constructor(channelName: string, options?: {\n        mode?: 'broadcast' | 'current-tab';\n        tabFilter?: (tab: chrome.tabs.Tab) => boolean;\n        tabIdGetter?: () => Promise<number> | number;\n    }) {\n        this.channelName = channelName;\n        this.mode = options?.mode || 'broadcast';\n        this.tabFilter = options?.tabFilter;\n        this.tabIdGetter = options?.tabIdGetter || this.getCurrentTabId;\n        this.startListening();\n    }\n\n    private startListening() {\n        ensureRuntimeListener();\n\n        // No per-instance chrome.runtime.onMessage listener here; we reuse the global runtime listener.\n        // Filtering by tab is handled in our instance-level handler below.\n    }\n\n    addEventListener(type: \"message\", listener: CrxListener) {\n        if (type !== \"message\") return;\n\n        const existing = this.wrappedByOriginal.get(listener);\n        if (existing) return;\n\n        const wrapped: CrxListener = async (event, sender, sendResponse) => {\n            const message = event?.data;\n            if (!sender?.tab) return;\n\n            // For current-tab mode, verify this is from our target tab\n            if (this.mode === \"current-tab\") {\n                const targetTabId = await this.tabIdGetter?.();\n                if (typeof targetTabId === \"number\" && sender.tab.id !== targetTabId) return;\n            }\n\n            // For broadcast mode, apply tab filter if specified\n            if (this.mode === \"broadcast\" && this.tabFilter && !this.tabFilter(sender.tab)) return;\n\n            const enhancedEvent = {\n                ...event,\n                origin: sender.url || \"chrome-extension-tab\",\n                tab: sender.tab\n            };\n\n            return listener(enhancedEvent, sender, sendResponse);\n        };\n\n        this.wrappedByOriginal.set(listener, wrapped);\n        this.wrappedListeners.add(wrapped);\n        let set = runtimeListenerRegistry.get(this.channelName);\n        if (!set) {\n            set = new Set();\n            runtimeListenerRegistry.set(this.channelName, set);\n        }\n        set.add(wrapped);\n    }\n\n    removeEventListener(type: \"message\", listener: CrxListener) {\n        if (type !== \"message\") return;\n        const wrapped = this.wrappedByOriginal.get(listener);\n        if (!wrapped) return;\n        this.wrappedByOriginal.delete(listener);\n        this.wrappedListeners.delete(wrapped);\n        runtimeListenerRegistry.get(this.channelName)?.delete(wrapped);\n    }\n\n    /**\n     * Send message to specific tab\n     */\n    sendToTab(tabId: number, message: any): Promise<any> {\n        const messageWithChannel = {\n            channelName: this.channelName,\n            source: 'tabs-channel',\n            ...message\n        };\n\n        return new Promise((resolve, reject) => {\n            chrome?.tabs?.sendMessage?.(tabId, messageWithChannel, (response) => {\n                if (chrome?.runtime?.lastError) {\n                    reject(new Error(chrome.runtime.lastError.message));\n                } else {\n                    resolve(response);\n                }\n            });\n        });\n    }\n\n    /**\n     * Send message to active/current tab\n     */\n    async sendToActiveTab(message: any): Promise<any> {\n        if (this.mode === 'current-tab' && this.tabIdGetter) {\n            // Use the configured tab ID getter\n            const tabId = await this.tabIdGetter();\n            return this.sendToTab(tabId, message);\n        } else {\n            // Fallback to querying active tab\n            const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n            if (tabs.length === 0) {\n                throw new Error('No active tab found');\n            }\n            return this.sendToTab(tabs[0].id!, message);\n        }\n    }\n\n    /**\n     * Broadcast message to all matching tabs (only works in broadcast mode)\n     */\n    async broadcastToTabs(message: any, options?: { allWindows?: boolean; tabFilter?: (tab: chrome.tabs.Tab) => boolean }): Promise<any[]> {\n        if (this.mode === 'current-tab') {\n            // In current-tab mode, broadcast is just sending to the current tab\n            try {\n                const response = await this.sendToActiveTab(message);\n                return [{ tabId: await this.tabIdGetter!(), response }];\n            } catch (error) {\n                return [{ error }];\n            }\n        }\n\n        // Broadcast mode - send to multiple tabs\n        const query: chrome.tabs.QueryInfo = {\n            status: 'complete'\n        };\n\n        if (!options?.allWindows) {\n            query.currentWindow = true;\n        }\n\n        const tabs = await chrome.tabs.query(query);\n        const targetTabs = tabs.filter(tab => {\n            // Apply custom filter if provided\n            if (options?.tabFilter && !options.tabFilter(tab)) return false;\n            // Apply instance filter\n            if (this.tabFilter && !this.tabFilter(tab)) return false;\n            return true;\n        });\n\n        const messageWithChannel = {\n            channelName: this.channelName,\n            source: 'tabs-channel',\n            ...message\n        };\n\n        const promises = targetTabs.map(tab =>\n            new Promise<any>((resolve, reject) => {\n                chrome?.tabs?.sendMessage?.(tab.id!, messageWithChannel, (response) => {\n                    if (chrome?.runtime?.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                    } else {\n                        resolve({ tabId: tab.id, response });\n                    }\n                });\n            })\n        );\n\n        return Promise.allSettled(promises);\n    }\n\n    /**\n     * Send message via chrome runtime (for service worker communication)\n     */\n    async postMessage(message: any) {\n        const tabId = await this.tabIdGetter!();\n\n        const messageWithChannel = {\n            channelName: this.channelName,\n            source: 'tabs-channel',\n            ...message\n        };\n\n        // Send via chrome.tabs messaging (ignore response)\n        return chrome?.tabs?.sendMessage?.(tabId, messageWithChannel, () => void 0);\n    }\n\n    /**\n     * Get current tab ID (convenience method)\n     */\n    async getCurrentTabId(): Promise<number> {\n        if (this.tabIdGetter) {\n            return await this.tabIdGetter();\n        }\n        return 0;\n    }\n\n    close() {\n        for (const wrapped of this.wrappedListeners) {\n            runtimeListenerRegistry.get(this.channelName)?.delete(wrapped);\n        }\n        this.wrappedListeners.clear();\n        this.wrappedByOriginal.clear();\n    }\n}\n\n/**\n * Chrome Extension Port Channel\n * Adapts chrome.runtime.Port into a BroadcastChannel-like interface.\n */\nexport class ChromeExtensionPortChannel {\n    private listeners = new Set<(event: any) => void>();\n\n    constructor(private port: chrome.runtime.Port, private channelName: string) {\n        this.port?.onMessage?.addListener?.((message: any) => {\n            if ((message?.channelName ?? message?.target) !== this.channelName) return;\n            const event = { data: message, origin: \"chrome-extension-port\", source: this.port };\n            for (const listener of this.listeners) {\n                try {\n                    listener(event);\n                } catch (error) {\n                    console.error(\"[ChromeExtensionPortChannel] Listener error:\", error);\n                }\n            }\n        });\n    }\n\n    addEventListener(type: \"message\", listener: (event: any) => void) {\n        if (type !== \"message\") return;\n        this.listeners.add(listener);\n    }\n\n    removeEventListener(type: \"message\", listener: (event: any) => void) {\n        if (type !== \"message\") return;\n        this.listeners.delete(listener);\n    }\n\n    postMessage(message: any) {\n        this.port?.postMessage?.({\n            ...message,\n            channelName: this.channelName,\n            source: \"port-channel\"\n        });\n    }\n\n    close() {\n        this.listeners.clear();\n        this.port?.disconnect?.();\n    }\n}\n","import { OptimizedWorkerChannel, QueuedWorkerChannel, type ProtocolOptions, type WorkerChannel, type WorkerConfig } from \"../storage/Queued\";\nimport { createOrUseExistingChannel } from \"../channel/Channels\";\nimport { UUIDv4 } from \"fest/core\";\nimport { ChromeExtensionBroadcastChannel } from \"./Wrappers\";\nimport { ChromeExtensionTabsChannel } from \"./Wrappers\";\nimport { initChannelHandler } from \"../channel/Channels\";\n\n/**\n * Create a chrome extension worker channel\n */\nexport const createChromeExtensionChannel = async (config: WorkerConfig): Promise<WorkerChannel> => {\n    // Chrome extensions can use dedicated workers, but might need special handling\n    let worker: Worker;\n    try {\n        // Try to use chrome.runtime.getURL for extension resources\n        if (typeof config.script !== \"string\") {\n            throw new Error(\"Chrome extension worker channel requires config.script to be a string path\");\n        }\n        worker = new Worker(chrome.runtime.getURL(config.script), config.options);\n    } catch (error) {\n        // Fallback for non-extension workers in extension context\n        if (typeof config.script === \"string\") {\n            worker = new Worker(new URL(config.script, import.meta.url), config.options);\n        } else if (typeof config.script === \"function\") {\n            worker = config.script();\n        } else {\n            worker = config.script;\n        }\n    }\n\n    const channel = await createOrUseExistingChannel(config.name, {}, worker);\n    return channel?.remote ?? channel;\n};\n\n/**\n * Create a chrome extension broadcast channel\n * Acts like BroadcastChannel but uses chrome.runtime messaging\n */\nexport const createChromeExtensionBroadcast = (channelName: string): BroadcastChannel => {\n    const worker = new ChromeExtensionBroadcastChannel(channelName) as any;\n    return worker as BroadcastChannel;\n};\n\n/**\n * Create a chrome extension broadcast-like channel\n * Acts like BroadcastChannel but uses chrome.runtime messaging\n */\nexport const createChromeExtensionBroadcastChannel = (channelName: string): WorkerChannel => {\n    const worker = new ChromeExtensionBroadcastChannel(channelName) as any;\n    const channel = createOrUseExistingChannel(channelName, {}, worker);\n    return channel?.remote ?? channel;\n};\n\n/**\n * Create a chrome extension tabs channel\n * Acts like BroadcastChannel but uses chrome.tabs messaging to communicate with content scripts\n */\n\n/**\n * Create a chrome extension tabs channel (unified)\n * Acts like BroadcastChannel but uses chrome.tabs messaging to communicate with content scripts\n * Supports both broadcast and current-tab modes\n */\nexport const createChromeExtensionTabsChannel = (\n    channelName: string,\n    options?: {\n        mode?: 'broadcast' | 'current-tab';\n        tabFilter?: (tab: chrome.tabs.Tab) => boolean;\n        tabIdGetter?: () => Promise<number> | number;\n    }\n): WorkerChannel => {\n    const worker = new ChromeExtensionTabsChannel(channelName, options) as any;\n    const channel = createOrUseExistingChannel(channelName, {}, worker);\n    return channel?.remote ?? channel;\n};\n\n/**\n * Create a chrome extension tabs messaging channel (unified)\n * Uses chrome.tabs.sendMessage for tab-to-content-script communication\n * Supports both broadcast and current-tab modes\n */\nexport const createChromeExtensionTabsMessagingChannel = (\n    channelName: string,\n    options?: {\n        mode?: 'broadcast' | 'current-tab';\n        tabFilter?: (tab: chrome.tabs.Tab) => boolean;\n        tabIdGetter?: () => Promise<number> | number;\n    }\n): WorkerChannel => {\n    // Create a tabs channel for chrome extension messaging\n    return createChromeExtensionTabsChannel(channelName, options);\n};\n\n/**\n * Initialize the main thread channel handler\n */\nexport const initMainChannel = (name: string = \"$host$\") => {\n    return initChannelHandler(name ?? \"$host$\");\n};\n\n/**\n * Create a queued worker channel that waits for connection\n */\nexport const createQueuedWorkerChannel = (\n    config: WorkerConfig,\n    onChannelReady?: (channel: WorkerChannel) => void\n): QueuedWorkerChannel => {\n    return new QueuedWorkerChannel(config, onChannelReady);\n};\n\n/**\n * Create a service worker channel (for when running in service worker context)\n */\nexport const createServiceWorkerChannel = async (config: WorkerConfig): Promise<WorkerChannel> => {\n    // In service worker context, we can't create dedicated workers\n    // Instead, we create a channel that communicates through alternative means\n    // This could be through BroadcastChannel, MessageChannel, or direct function calls\n\n    return {\n        async request(method: string, args: any[] = []) {\n            // For service worker context, we might need to handle operations differently\n            // This could involve:\n            // 1. Direct function calls if the API is available in SW context\n            // 2. Communication through BroadcastChannel to main thread\n            // 3. Using clients.matchAll() to communicate with controlled pages\n\n            // For now, we'll use a BroadcastChannel approach\n            return new Promise((resolve, reject) => {\n                const channel = new BroadcastChannel(`${config.name}-sw-channel`);\n                const messageId = UUIDv4();\n\n                const timeout = setTimeout(() => {\n                    channel.close();\n                    reject(new Error(`Service worker request timeout: ${method}`));\n                }, 10000); // 10 second timeout\n\n                channel.onmessage = (event) => {\n                    const { id, result, error } = event.data;\n                    if (id === messageId) {\n                        clearTimeout(timeout);\n                        channel.close();\n                        if (error) {\n                            reject(new Error(error));\n                        } else {\n                            resolve(result);\n                        }\n                    }\n                };\n\n                channel.postMessage({\n                    id: messageId,\n                    type: 'request',\n                    method,\n                    args\n                });\n            });\n        },\n\n        close() {\n            // Service worker channels don't need explicit closing\n            // as they use BroadcastChannel which auto-manages\n        }\n    };\n};\n\n/**\n * Create a worker channel with simplified API\n */\nexport const createWorkerChannel = async (config: WorkerConfig): Promise<WorkerChannel> => {\n    const context = config.context;\n\n    if (context === 'service-worker') {\n        // Service workers cannot create dedicated workers directly\n        // Instead, we create a channel that will use alternative communication\n        return createServiceWorkerChannel(config);\n    }\n\n    // Handle different script types\n    let worker: Worker;\n    if (typeof config.script === 'function') {\n        // Script is a constructor function\n        worker = config.script();\n    } else if (config.script instanceof Worker) {\n        // Script is already a Worker instance\n        worker = config.script;\n    } else {\n        // Script is a string path - handle context-specific loading\n        if (context === 'chrome-extension') {\n            // Chrome extensions might need special handling for worker scripts\n            try {\n                worker = new Worker(chrome.runtime.getURL(config.script), config.options);\n            } catch (error) {\n                // Fallback to regular worker creation\n                worker = new Worker(new URL(config.script, import.meta.url), config.options);\n            }\n        } else {\n            worker = new Worker(new URL(config.script, import.meta.url), config.options);\n        }\n    }\n\n    const channel = await createOrUseExistingChannel(config.name, {}, worker);\n    return channel as WorkerChannel;\n};\n\n/**\n * Create an optimized worker channel\n */\nexport const createOptimizedWorkerChannel = async (\n    config: WorkerConfig,\n    options?: ProtocolOptions\n): Promise<OptimizedWorkerChannel> => {\n    const baseChannel = await createWorkerChannel(config);\n    return new OptimizedWorkerChannel(baseChannel, options);\n};\n\n/**\n * Create an optimized worker channel with queuing support\n */\nexport const createQueuedOptimizedWorkerChannel = (\n    config: WorkerConfig,\n    options?: ProtocolOptions,\n    onChannelReady?: (channel: WorkerChannel) => void\n): OptimizedWorkerChannel => {\n    // Create the optimized channel first (without underlying channel)\n    const optimizedChannel = new OptimizedWorkerChannel(null, options, onChannelReady);\n\n    // Then create the underlying channel asynchronously\n    createWorkerChannel(config).then((baseChannel) => {\n        optimizedChannel.setChannel(baseChannel);\n    }).catch((error) => {\n        console.error('[createQueuedOptimizedWorkerChannel] Failed to create base channel:', error);\n        // Reject all queued requests\n        optimizedChannel.close();\n    });\n\n    return optimizedChannel;\n};\n","/**\n * Unified Messaging System\n * Consolidates all messaging, broadcasting, queuing, and pipeline functionality\n * Part of fest/uniform - configurable without app-specific dependencies\n */\n\nimport {\n    OptimizedWorkerChannel,\n} from '../next/storage/Queued';\nimport { detectExecutionContext, supportsDedicatedWorkers } from '../next/utils/Env';\nimport { createQueuedOptimizedWorkerChannel } from '../next/utils/Utils';\n\nimport {\n    MessageQueue,\n    getMessageQueue,\n    type QueuedMessage,\n    type MessagePriority\n} from './MessageQueue';\n\n// ============================================================================\n// TYPES AND INTERFACES\n// ============================================================================\n\nexport interface UnifiedMessage<T = unknown> {\n    id: string;\n    type: string;\n    source: string;\n    destination?: string;\n    contentType?: string;\n    data: T;\n    metadata?: MessageMetadata;\n}\n\nexport interface MessageMetadata {\n    timestamp?: number;\n    correlationId?: string;\n    priority?: MessagePriority;\n    expiresAt?: number;\n    retryCount?: number;\n    maxRetries?: number;\n    [key: string]: unknown;\n}\n\nexport interface MessageHandler<T = unknown> {\n    canHandle: (message: UnifiedMessage<T>) => boolean;\n    handle: (message: UnifiedMessage<T>) => Promise<void> | void;\n}\n\nexport interface WorkerChannelConfig {\n    name: string;\n    script: string | (() => Worker) | Worker;\n    options?: WorkerOptions;\n    protocolOptions?: {\n        timeout?: number;\n        retries?: number;\n        batching?: boolean;\n        compression?: boolean;\n    };\n}\n\nexport interface PipelineConfig {\n    name: string;\n    stages: PipelineStage[];\n    errorHandler?: (error: unknown, stage: PipelineStage, message: UnifiedMessage) => void;\n    timeout?: number;\n}\n\nexport interface PipelineStage {\n    name: string;\n    handler: (message: UnifiedMessage) => Promise<UnifiedMessage> | UnifiedMessage;\n    timeout?: number;\n    retries?: number;\n}\n\nexport interface ChannelMapping {\n    destination: string;\n    channel: string;\n}\n\nexport interface UnifiedMessagingConfig {\n    /** Custom channel mappings (destination -> channel name) */\n    channelMappings?: Record<string, string>;\n    /** Message queue options */\n    queueOptions?: {\n        dbName?: string;\n        storeName?: string;\n        maxRetries?: number;\n        defaultExpirationMs?: number;\n    };\n    /** Pending message store options */\n    pendingStoreOptions?: {\n        storageKey?: string;\n        maxMessages?: number;\n        defaultTTLMs?: number;\n    };\n}\n\n// ============================================================================\n// PENDING MESSAGE STORE (SYNC CATCH-UP)\n// ============================================================================\n\ninterface PendingStoreEntry {\n    destination: string;\n    message: UnifiedMessage;\n    storedAt: number;\n}\n\nexport class PendingMessageStore {\n    private readonly storageKey: string;\n    private readonly maxMessages: number;\n    private readonly defaultTTLMs: number;\n\n    constructor(options?: { storageKey?: string; maxMessages?: number; defaultTTLMs?: number }) {\n        this.storageKey = options?.storageKey ?? 'uniform-messaging-pending';\n        this.maxMessages = options?.maxMessages ?? 200;\n        this.defaultTTLMs = options?.defaultTTLMs ?? 24 * 60 * 60 * 1000; // 24h\n    }\n\n    private read(): PendingStoreEntry[] {\n        if (typeof window === 'undefined' || typeof localStorage === 'undefined') return [];\n        try {\n            const raw = localStorage.getItem(this.storageKey);\n            if (!raw) return [];\n            const parsed = JSON.parse(raw);\n            return Array.isArray(parsed) ? parsed : [];\n        } catch {\n            return [];\n        }\n    }\n\n    private write(entries: PendingStoreEntry[]): void {\n        if (typeof window === 'undefined' || typeof localStorage === 'undefined') return;\n        try {\n            localStorage.setItem(this.storageKey, JSON.stringify(entries));\n        } catch {\n            // Storage might be full or unavailable\n        }\n    }\n\n    enqueue(destination: string, message: UnifiedMessage): void {\n        if (!destination) return;\n        const now = Date.now();\n        const ttl = Number(message?.metadata?.expiresAt)\n            ? Math.max(0, Number(message.metadata!.expiresAt) - now)\n            : this.defaultTTLMs;\n\n        // Skip immediately-expired\n        if (ttl <= 0) return;\n\n        const entries = this.read()\n            .filter(e => e && typeof e === 'object')\n            .filter(e => {\n                const expiresAt = Number(e?.message?.metadata?.expiresAt) ||\n                    (Number(e?.storedAt) + this.defaultTTLMs);\n                return expiresAt > now;\n            });\n\n        entries.push({ destination, message, storedAt: now });\n        if (entries.length > this.maxMessages) {\n            entries.splice(0, entries.length - this.maxMessages);\n        }\n        this.write(entries);\n    }\n\n    drain(destination: string): UnifiedMessage[] {\n        if (!destination) return [];\n        const now = Date.now();\n        const entries = this.read();\n\n        const keep: PendingStoreEntry[] = [];\n        const out: UnifiedMessage[] = [];\n\n        for (const e of entries) {\n            const expiresAt = Number(e?.message?.metadata?.expiresAt) ||\n                (Number(e?.storedAt) + this.defaultTTLMs);\n            if (expiresAt <= now) continue;\n            if (e?.destination === destination && e?.message) {\n                out.push(e.message);\n            } else {\n                keep.push(e);\n            }\n        }\n\n        this.write(keep);\n        return out;\n    }\n\n    has(destination: string): boolean {\n        if (!destination) return false;\n        const now = Date.now();\n        return this.read().some((e) => {\n            if (!e || typeof e !== 'object') return false;\n            const expiresAt = Number(e?.message?.metadata?.expiresAt) ||\n                (Number(e?.storedAt) + this.defaultTTLMs);\n            return expiresAt > now && e?.destination === destination;\n        });\n    }\n\n    clear(): void {\n        this.write([]);\n    }\n}\n\n// ============================================================================\n// UNIFIED MESSAGING MANAGER\n// ============================================================================\n\nexport class UnifiedMessagingManager {\n    private handlers = new Map<string, MessageHandler[]>();\n    private channels = new Map<string, BroadcastChannel | OptimizedWorkerChannel>();\n    private workerChannels = new Map<string, OptimizedWorkerChannel>();\n    private viewChannels = new Map<string, Set<string>>();\n    private pipelines = new Map<string, PipelineConfig>();\n    private messageQueue: MessageQueue;\n    private pendingStore: PendingMessageStore;\n    private initializedViews = new Set<string>();\n    private viewReadyPromises = new Map<string, { resolve: () => void; reject: (e: unknown) => void; promise: Promise<void> }>();\n    private executionContext: ReturnType<typeof detectExecutionContext>;\n    private channelMappings: Record<string, string>;\n    private componentRegistry = new Map<string, string>();\n\n    constructor(config: UnifiedMessagingConfig = {}) {\n        this.executionContext = detectExecutionContext();\n        this.channelMappings = config.channelMappings ?? {};\n        this.messageQueue = getMessageQueue(config.queueOptions);\n        this.pendingStore = new PendingMessageStore(config.pendingStoreOptions);\n        this.setupGlobalListeners();\n    }\n\n    // ========================================================================\n    // MESSAGE HANDLING\n    // ========================================================================\n\n    /**\n     * Register a message handler for a specific destination\n     */\n    registerHandler(destination: string, handler: MessageHandler): void {\n        if (!this.handlers.has(destination)) {\n            this.handlers.set(destination, []);\n        }\n        this.handlers.get(destination)!.push(handler);\n    }\n\n    /**\n     * Unregister a message handler\n     */\n    unregisterHandler(destination: string, handler: MessageHandler): void {\n        const handlers = this.handlers.get(destination);\n        if (handlers) {\n            const index = handlers.indexOf(handler);\n            if (index > -1) {\n                handlers.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * Send a message to a destination\n     */\n    async sendMessage(message: Partial<UnifiedMessage> & { type: string; data: unknown }): Promise<boolean> {\n        // Ensure message has required fields\n        const fullMessage: UnifiedMessage = {\n            id: message.id ?? crypto.randomUUID(),\n            type: message.type,\n            source: message.source ?? 'unified-messaging',\n            destination: message.destination,\n            contentType: message.contentType,\n            data: message.data,\n            metadata: { timestamp: Date.now(), ...message.metadata }\n        };\n\n        // Try to deliver immediately\n        if (await this.tryDeliverMessage(fullMessage)) {\n            return true;\n        }\n\n        // Queue for later delivery if destination not available\n        if (fullMessage.destination) {\n            // Store in sync pending store for view/component catch-up\n            this.pendingStore.enqueue(fullMessage.destination, fullMessage);\n\n            await this.messageQueue.queueMessage(fullMessage.type, fullMessage, {\n                priority: fullMessage.metadata?.priority ?? 'normal',\n                maxRetries: fullMessage.metadata?.maxRetries ?? 3,\n                destination: fullMessage.destination\n            });\n        }\n\n        return false;\n    }\n\n    /**\n     * Process a message through registered handlers\n     */\n    async processMessage(message: UnifiedMessage): Promise<void> {\n        const destination = message.destination ?? 'general';\n        const handlers = this.handlers.get(destination) ?? [];\n\n        for (const handler of handlers) {\n            if (handler.canHandle(message)) {\n                try {\n                    await handler.handle(message);\n                } catch (error) {\n                    console.error(`[UnifiedMessaging] Handler error for ${destination}:`, error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to deliver message immediately\n     */\n    private async tryDeliverMessage(message: UnifiedMessage): Promise<boolean> {\n        // Check if destination has handlers\n        if (message.destination && this.handlers.has(message.destination)) {\n            await this.processMessage(message);\n            return true;\n        }\n\n        // Check if we have a broadcast channel for the destination\n        const channelName = this.getChannelForDestination(message.destination);\n        if (channelName && this.channels.has(channelName)) {\n            const channel = this.channels.get(channelName);\n            if (channel instanceof BroadcastChannel) {\n                try {\n                    channel.postMessage(message);\n                    return true;\n                } catch (error) {\n                    console.warn(`[UnifiedMessaging] Failed to post to broadcast channel ${channelName}:`, error);\n                }\n            } else if (channel && 'request' in channel) {\n                try {\n                    await (channel as OptimizedWorkerChannel).request(message.type, [message]);\n                    return true;\n                } catch (error) {\n                    console.warn(`[UnifiedMessaging] Failed to post to worker channel ${channelName}:`, error);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // ========================================================================\n    // WORKER CHANNEL MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Register worker channels for a specific view\n     */\n    registerViewChannels(viewHash: string, configs: WorkerChannelConfig[]): void {\n        const channelNames = new Set<string>();\n\n        for (const config of configs) {\n            if (!this.isWorkerSupported(config)) {\n                console.log(`[UnifiedMessaging] Skipping worker '${config.name}' in ${this.executionContext} context`);\n                continue;\n            }\n\n            const channel = createQueuedOptimizedWorkerChannel({\n                name: config.name,\n                script: config.script,\n                options: config.options,\n                context: this.executionContext\n            }, config.protocolOptions, () => {\n                console.log(`[UnifiedMessaging] Channel '${config.name}' ready for view '${viewHash}'`);\n            });\n\n            const channelKey = `${viewHash}:${config.name}`;\n            this.workerChannels.set(channelKey, channel);\n            this.channels.set(channelKey, channel);\n            channelNames.add(config.name);\n        }\n\n        this.viewChannels.set(viewHash, channelNames);\n    }\n\n    /**\n     * Initialize channels when a view becomes active\n     */\n    async initializeViewChannels(viewHash: string): Promise<void> {\n        if (this.initializedViews.has(viewHash)) return;\n\n        const deferred = this.createDeferred<void>();\n        this.viewReadyPromises.set(viewHash, deferred);\n\n        console.log(`[UnifiedMessaging] Initializing channels for view: ${viewHash}`);\n\n        const channelNames = this.viewChannels.get(viewHash);\n        if (!channelNames) {\n            deferred.resolve();\n            return;\n        }\n\n        const initPromises: Promise<void>[] = [];\n        for (const channelName of channelNames) {\n            const channelKey = `${viewHash}:${channelName}`;\n            const channel = this.workerChannels.get(channelKey);\n\n            if (channel) {\n                initPromises.push(\n                    channel.request('ping', {}).catch(() => {\n                        console.log(`[UnifiedMessaging] Channel '${channelName}' queued for view '${viewHash}'`);\n                    })\n                );\n            }\n        }\n\n        await Promise.allSettled(initPromises);\n        this.initializedViews.add(viewHash);\n        deferred.resolve();\n    }\n\n    /**\n     * Get a worker channel for a specific view and worker\n     */\n    getWorkerChannel(viewHash: string, workerName: string): OptimizedWorkerChannel | null {\n        return this.workerChannels.get(`${viewHash}:${workerName}`) ?? null;\n    }\n\n    // ========================================================================\n    // BROADCAST CHANNEL MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Create or get a broadcast channel\n     */\n    getBroadcastChannel(channelName: string): BroadcastChannel {\n        if (!this.channels.has(channelName)) {\n            try {\n                const channel = new BroadcastChannel(channelName);\n                channel.addEventListener('message', (event) => {\n                    this.handleBroadcastMessage(event.data, channelName);\n                });\n                this.channels.set(channelName, channel);\n            } catch (error) {\n                console.warn(`[UnifiedMessaging] BroadcastChannel not available: ${channelName}`, error);\n                // Return a mock channel that does nothing\n                const mockChannel = {\n                    postMessage: () => {},\n                    close: () => {},\n                    addEventListener: () => {},\n                    removeEventListener: () => {}\n                } as unknown as BroadcastChannel;\n                this.channels.set(channelName, mockChannel);\n            }\n        }\n        return this.channels.get(channelName) as BroadcastChannel;\n    }\n\n    /**\n     * Handle incoming broadcast messages\n     */\n    private async handleBroadcastMessage(message: unknown, channelName: string): Promise<void> {\n        try {\n            const msgObj = message as Record<string, unknown>;\n            const unifiedMessage: UnifiedMessage = msgObj?.id ? (message as UnifiedMessage) : {\n                id: crypto.randomUUID(),\n                type: String(msgObj?.type ?? 'unknown'),\n                source: channelName,\n                data: message,\n                metadata: { timestamp: Date.now() }\n            };\n\n            await this.processMessage(unifiedMessage);\n        } catch (error) {\n            console.error(`[UnifiedMessaging] Error handling broadcast message on ${channelName}:`, error);\n        }\n    }\n\n    // ========================================================================\n    // PIPELINE MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Register a message processing pipeline\n     */\n    registerPipeline(config: PipelineConfig): void {\n        this.pipelines.set(config.name, config);\n    }\n\n    /**\n     * Process a message through a pipeline\n     */\n    async processThroughPipeline(pipelineName: string, message: UnifiedMessage): Promise<UnifiedMessage> {\n        const pipeline = this.pipelines.get(pipelineName);\n        if (!pipeline) {\n            throw new Error(`Pipeline '${pipelineName}' not found`);\n        }\n\n        let currentMessage = { ...message };\n        const timeout = pipeline.timeout ?? 30000;\n\n        for (const stage of pipeline.stages) {\n            const stageTimeout = stage.timeout ?? timeout;\n            const retries = stage.retries ?? 0;\n\n            for (let attempt = 0; attempt <= retries; attempt++) {\n                try {\n                    const result = await Promise.race([\n                        stage.handler(currentMessage),\n                        new Promise<never>((_, reject) =>\n                            setTimeout(() => reject(new Error(`Stage '${stage.name}' timeout`)), stageTimeout)\n                        )\n                    ]);\n\n                    currentMessage = result;\n                    break; // Success, move to next stage\n                } catch (error) {\n                    if (attempt === retries) {\n                        if (pipeline.errorHandler) {\n                            pipeline.errorHandler(error, stage, currentMessage);\n                        }\n                        throw error;\n                    }\n                    console.warn(`[UnifiedMessaging] Pipeline '${pipelineName}' stage '${stage.name}' attempt ${attempt + 1} failed:`, error);\n                }\n            }\n        }\n\n        return currentMessage;\n    }\n\n    // ========================================================================\n    // QUEUE MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Process queued messages for a destination\n     */\n    async processQueuedMessages(destination?: string): Promise<void> {\n        const queuedMessages = await this.messageQueue.getQueuedMessages(destination);\n\n        for (const queuedMessage of queuedMessages) {\n            const dataAsMessage = queuedMessage.data as Record<string, unknown>;\n            const message: UnifiedMessage = (\n                dataAsMessage &&\n                typeof dataAsMessage === 'object' &&\n                typeof dataAsMessage.type === 'string' &&\n                typeof dataAsMessage.id === 'string'\n            )\n                ? (dataAsMessage as unknown as UnifiedMessage)\n                : {\n                    id: queuedMessage.id,\n                    type: queuedMessage.type,\n                    source: 'queue',\n                    destination: queuedMessage.destination,\n                    data: queuedMessage.data,\n                    metadata: {\n                        timestamp: queuedMessage.timestamp,\n                        retryCount: queuedMessage.retryCount,\n                        maxRetries: queuedMessage.maxRetries,\n                        ...queuedMessage.metadata\n                    }\n                };\n\n            if (await this.tryDeliverMessage(message)) {\n                await this.messageQueue.removeMessage(queuedMessage.id);\n            }\n        }\n    }\n\n    // ========================================================================\n    // COMPONENT REGISTRATION\n    // ========================================================================\n\n    /**\n     * Register a component with a destination\n     */\n    registerComponent(componentId: string, destination: string): void {\n        this.componentRegistry.set(componentId, destination);\n    }\n\n    /**\n     * Initialize a component and return any pending messages\n     */\n    initializeComponent(componentId: string): UnifiedMessage[] {\n        const destination = this.componentRegistry.get(componentId);\n        if (!destination) return [];\n        return this.pendingStore.drain(destination);\n    }\n\n    /**\n     * Check if there are pending messages for a destination\n     */\n    hasPendingMessages(destination: string): boolean {\n        return this.pendingStore.has(destination);\n    }\n\n    /**\n     * Explicitly enqueue a pending message\n     */\n    enqueuePendingMessage(destination: string, message: UnifiedMessage): void {\n        const dest = String(destination ?? '').trim();\n        if (!dest || !message) return;\n        this.pendingStore.enqueue(dest, message);\n    }\n\n    // ========================================================================\n    // CHANNEL MAPPING\n    // ========================================================================\n\n    /**\n     * Set channel mappings\n     */\n    setChannelMappings(mappings: Record<string, string>): void {\n        this.channelMappings = { ...this.channelMappings, ...mappings };\n    }\n\n    /**\n     * Get channel name for a destination\n     */\n    private getChannelForDestination(destination?: string): string | null {\n        if (!destination) return null;\n        return this.channelMappings[destination] ?? null;\n    }\n\n    // ========================================================================\n    // UTILITY METHODS\n    // ========================================================================\n\n    /**\n     * Check if a worker configuration is supported\n     */\n    private isWorkerSupported(_config: WorkerChannelConfig): boolean {\n        if (this.executionContext === 'service-worker') {\n            return true;\n        }\n\n        if (this.executionContext === 'chrome-extension') {\n            return supportsDedicatedWorkers();\n        }\n\n        return true;\n    }\n\n    /**\n     * Set up global listeners for cross-component communication\n     */\n    private setupGlobalListeners(): void {\n        if (typeof window !== 'undefined') {\n            globalThis.addEventListener('message', (event) => {\n                if (event.data && typeof event.data === 'object' && event.data.type) {\n                    this.handleBroadcastMessage(event.data, 'window-message');\n                }\n            });\n        }\n    }\n\n    /**\n     * Create a deferred promise\n     */\n    private createDeferred<T>(): { resolve: (value: T) => void; reject: (e: unknown) => void; promise: Promise<T> } {\n        let resolve!: (value: T) => void;\n        let reject!: (e: unknown) => void;\n        const promise = new Promise<T>((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        return { resolve, reject, promise };\n    }\n\n    /**\n     * Get execution context\n     */\n    getExecutionContext(): string {\n        return this.executionContext;\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy(): void {\n        for (const channel of this.channels.values()) {\n            if (channel instanceof BroadcastChannel) {\n                channel.close();\n            } else if (channel && 'close' in channel) {\n                (channel as OptimizedWorkerChannel).close();\n            }\n        }\n\n        this.channels.clear();\n        this.workerChannels.clear();\n        this.handlers.clear();\n        this.pipelines.clear();\n    }\n}\n\n// ============================================================================\n// SINGLETON FACTORY\n// ============================================================================\n\nlet defaultInstance: UnifiedMessagingManager | null = null;\n\n/**\n * Get the default UnifiedMessagingManager instance\n */\nexport function getUnifiedMessaging(config?: UnifiedMessagingConfig): UnifiedMessagingManager {\n    if (!defaultInstance) {\n        defaultInstance = new UnifiedMessagingManager(config);\n    }\n    return defaultInstance;\n}\n\n/**\n * Create a new UnifiedMessagingManager instance (not cached)\n */\nexport function createUnifiedMessaging(config?: UnifiedMessagingConfig): UnifiedMessagingManager {\n    return new UnifiedMessagingManager(config);\n}\n\n/**\n * Reset the default instance (useful for testing)\n */\nexport function resetUnifiedMessaging(): void {\n    if (defaultInstance) {\n        defaultInstance.destroy();\n        defaultInstance = null;\n    }\n}\n\n// ============================================================================\n// CONVENIENCE FUNCTIONS\n// ============================================================================\n\n/**\n * Send a message using the default manager\n */\nexport function sendMessage(message: Partial<UnifiedMessage> & { type: string; data: unknown }): Promise<boolean> {\n    return getUnifiedMessaging().sendMessage(message);\n}\n\n/**\n * Register a handler using the default manager\n */\nexport function registerHandler(destination: string, handler: MessageHandler): void {\n    getUnifiedMessaging().registerHandler(destination, handler);\n}\n\n/**\n * Get a worker channel using the default manager\n */\nexport function getWorkerChannel(viewHash: string, workerName: string): OptimizedWorkerChannel | null {\n    return getUnifiedMessaging().getWorkerChannel(viewHash, workerName);\n}\n\n/**\n * Get a broadcast channel using the default manager\n */\nexport function getBroadcastChannel(channelName: string): BroadcastChannel {\n    return getUnifiedMessaging().getBroadcastChannel(channelName);\n}\n","/**\n * Service Channel Manager\n * Manages BroadcastChannel-based service channels for views and components\n * Part of fest/uniform - configurable without app-specific dependencies\n */\n\nimport { detectExecutionContext } from '../next/utils/Env';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Channel configuration\n */\nexport interface ServiceChannelConfig {\n    broadcastName: string;\n    routeHash?: string;\n    component?: string;\n    description?: string;\n}\n\n/**\n * Channel message format\n */\nexport interface ChannelMessage<T = unknown> {\n    type: string;\n    source: string;\n    target: string;\n    data: T;\n    timestamp: number;\n    correlationId?: string;\n}\n\n/**\n * Channel state\n */\nexport interface ChannelState {\n    connected: boolean;\n    lastActivity: number;\n    pendingMessages: number;\n}\n\n/**\n * Service channel manager configuration\n */\nexport interface ServiceChannelManagerConfig {\n    /** Channel configurations by ID */\n    channels?: Record<string, ServiceChannelConfig>;\n    /** Log prefix for debugging */\n    logPrefix?: string;\n}\n\n// ============================================================================\n// SERVICE CHANNEL MANAGER\n// ============================================================================\n\nexport class ServiceChannelManager<TChannelId extends string = string> {\n    private channels = new Map<TChannelId, BroadcastChannel>();\n    private readyPromises = new Map<TChannelId, { promise: Promise<void>; resolve: () => void }>();\n    private messageHandlers = new Map<TChannelId, Set<(msg: ChannelMessage) => void>>();\n    private channelConfigs: Record<string, ServiceChannelConfig>;\n    private executionContext: string;\n    private logPrefix: string;\n\n    constructor(config: ServiceChannelManagerConfig = {}) {\n        this.channelConfigs = config.channels ?? {};\n        this.logPrefix = config.logPrefix ?? '[ServiceChannels]';\n        this.executionContext = detectExecutionContext();\n        console.log(`${this.logPrefix} Initialized in ${this.executionContext} context`);\n    }\n\n    // ========================================================================\n    // CONFIGURATION\n    // ========================================================================\n\n    /**\n     * Register channel configurations\n     */\n    registerConfigs(configs: Record<string, ServiceChannelConfig>): void {\n        this.channelConfigs = { ...this.channelConfigs, ...configs };\n    }\n\n    /**\n     * Get channel configuration\n     */\n    getConfig(channelId: TChannelId): ServiceChannelConfig | undefined {\n        return this.channelConfigs[channelId];\n    }\n\n    /**\n     * Get all channel configurations\n     */\n    getAllConfigs(): Record<string, ServiceChannelConfig> {\n        return { ...this.channelConfigs };\n    }\n\n    // ========================================================================\n    // CHANNEL LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Initialize a service channel\n     */\n    async initChannel(channelId: TChannelId): Promise<BroadcastChannel> {\n        // Return existing channel if already initialized\n        if (this.channels.has(channelId)) {\n            return this.channels.get(channelId)!;\n        }\n\n        const config = this.channelConfigs[channelId];\n        if (!config) {\n            throw new Error(`Unknown channel: ${channelId}. Register configuration first.`);\n        }\n\n        // Create deferred for ready state\n        let resolveReady!: () => void;\n        const readyPromise = new Promise<void>((resolve) => {\n            resolveReady = resolve;\n        });\n        this.readyPromises.set(channelId, { promise: readyPromise, resolve: resolveReady });\n\n        console.log(`${this.logPrefix} Initializing channel: ${channelId} -> ${config.broadcastName}`);\n\n        // Create broadcast channel\n        const channel = new BroadcastChannel(config.broadcastName);\n        \n        // Setup message handler\n        channel.onmessage = (event) => {\n            this.handleIncomingMessage(channelId, event.data);\n        };\n\n        channel.onmessageerror = (event) => {\n            console.error(`${this.logPrefix} Message error on ${channelId}:`, event);\n        };\n\n        this.channels.set(channelId, channel);\n        \n        // Mark as ready\n        resolveReady();\n        \n        console.log(`${this.logPrefix} Channel ready: ${channelId}`);\n        return channel;\n    }\n\n    /**\n     * Close a service channel\n     */\n    closeChannel(channelId: TChannelId): void {\n        const channel = this.channels.get(channelId);\n        if (channel) {\n            channel.close();\n            this.channels.delete(channelId);\n            this.readyPromises.delete(channelId);\n            this.messageHandlers.delete(channelId);\n            console.log(`${this.logPrefix} Channel closed: ${channelId}`);\n        }\n    }\n\n    /**\n     * Close all channels\n     */\n    closeAll(): void {\n        for (const channelId of this.channels.keys()) {\n            this.closeChannel(channelId);\n        }\n    }\n\n    /**\n     * Wait for a channel to be ready\n     */\n    async waitForChannel(channelId: TChannelId): Promise<void> {\n        const deferred = this.readyPromises.get(channelId);\n        if (deferred) {\n            await deferred.promise;\n        } else {\n            await this.initChannel(channelId);\n        }\n    }\n\n    // ========================================================================\n    // MESSAGING\n    // ========================================================================\n\n    /**\n     * Send a message to a channel\n     */\n    async send<T>(\n        target: TChannelId,\n        type: string,\n        data: T,\n        options: { correlationId?: string; source?: string } = {}\n    ): Promise<void> {\n        await this.waitForChannel(target);\n\n        const channel = this.channels.get(target);\n        if (!channel) {\n            throw new Error(`Channel not ready: ${target}`);\n        }\n\n        const message: ChannelMessage<T> = {\n            type,\n            source: options.source ?? this.executionContext,\n            target,\n            data,\n            timestamp: Date.now(),\n            correlationId: options.correlationId\n        };\n\n        channel.postMessage(message);\n        console.log(`${this.logPrefix} Sent message to ${target}:`, type);\n    }\n\n    /**\n     * Broadcast a message to all initialized channels\n     */\n    broadcast<T>(type: string, data: T, source?: string): void {\n        for (const [channelId, channel] of this.channels) {\n            const message: ChannelMessage<T> = {\n                type,\n                source: source ?? this.executionContext,\n                target: channelId,\n                data,\n                timestamp: Date.now()\n            };\n            channel.postMessage(message);\n        }\n        console.log(`${this.logPrefix} Broadcast message:`, type);\n    }\n\n    /**\n     * Subscribe to messages on a channel\n     */\n    subscribe(\n        channelId: TChannelId,\n        handler: (msg: ChannelMessage) => void\n    ): () => void {\n        if (!this.messageHandlers.has(channelId)) {\n            this.messageHandlers.set(channelId, new Set());\n        }\n\n        this.messageHandlers.get(channelId)!.add(handler);\n\n        // Initialize channel if not already\n        this.initChannel(channelId).catch(console.error);\n\n        // Return unsubscribe function\n        return () => {\n            this.messageHandlers.get(channelId)?.delete(handler);\n        };\n    }\n\n    /**\n     * Handle incoming message\n     */\n    private handleIncomingMessage(channelId: TChannelId, data: unknown): void {\n        const handlers = this.messageHandlers.get(channelId);\n        if (!handlers || handlers.size === 0) {\n            console.log(`${this.logPrefix} No handlers for ${channelId}, message queued`);\n            return;\n        }\n\n        const message = data as ChannelMessage;\n        for (const handler of handlers) {\n            try {\n                handler(message);\n            } catch (error) {\n                console.error(`${this.logPrefix} Handler error on ${channelId}:`, error);\n            }\n        }\n    }\n\n    // ========================================================================\n    // CHANNEL STATE\n    // ========================================================================\n\n    /**\n     * Check if channel is initialized\n     */\n    isInitialized(channelId: TChannelId): boolean {\n        return this.channels.has(channelId);\n    }\n\n    /**\n     * Get all initialized channel IDs\n     */\n    getInitializedChannels(): TChannelId[] {\n        return Array.from(this.channels.keys());\n    }\n\n    /**\n     * Get channel status\n     */\n    getStatus(): Record<string, ChannelState> {\n        const status: Record<string, ChannelState> = {};\n        \n        for (const channelId of Object.keys(this.channelConfigs)) {\n            status[channelId] = {\n                connected: this.channels.has(channelId as TChannelId),\n                lastActivity: Date.now(),\n                pendingMessages: 0\n            };\n        }\n\n        return status;\n    }\n\n    /**\n     * Get execution context\n     */\n    getExecutionContext(): string {\n        return this.executionContext;\n    }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create a new ServiceChannelManager instance\n */\nexport function createServiceChannelManager<TChannelId extends string = string>(\n    config?: ServiceChannelManagerConfig\n): ServiceChannelManager<TChannelId> {\n    return new ServiceChannelManager<TChannelId>(config);\n}\n\n// Default instance (optional singleton pattern)\nlet defaultManager: ServiceChannelManager | null = null;\n\n/**\n * Get or create the default ServiceChannelManager\n */\nexport function getServiceChannelManager(config?: ServiceChannelManagerConfig): ServiceChannelManager {\n    if (!defaultManager) {\n        defaultManager = new ServiceChannelManager(config);\n    } else if (config?.channels) {\n        defaultManager.registerConfigs(config.channels);\n    }\n    return defaultManager;\n}\n\n/**\n * Reset the default manager (useful for testing)\n */\nexport function resetServiceChannelManager(): void {\n    if (defaultManager) {\n        defaultManager.closeAll();\n        defaultManager = null;\n    }\n}\n","/**\n * Channel Message Handler - Unified message routing\n *\n * Delegates to core/TransportCore and core/RequestHandler.\n * Simplified wrapper providing Observable-style message handling.\n */\n\nimport { UUIDv4 } from \"fest/core\";\nimport {\n    createTransportSender,\n    createTransportListener,\n    type TransportTarget,\n    type SendFn\n} from \"../../core/TransportCore\";\nimport { handleRequest } from \"../../core/RequestHandler\";\nimport type { ChannelMessage, Subscriber, Subscription, Observer } from \"../observable/Observable\";\nimport type { WReq } from \"../types/Interface\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type MessageType = \"request\" | \"response\" | \"event\" | \"ping\" | \"pong\";\nexport type RespondFn<T = any> = (result: T, transfer?: Transferable[]) => void | Promise<void>;\nexport type MessageHandlerCallback<T = ChannelMessage> = (data: T, respond: RespondFn<T>) => void | Promise<void>;\n\nexport interface ChannelSubscriber<T = ChannelMessage> extends Subscriber<T> {\n    request?(msg: T): Promise<any>;\n}\n\ninterface PendingRequest {\n    resolve: (value: any) => void;\n    reject: (error: Error) => void;\n    timestamp: number;\n}\n\nexport type { TransportTarget };\n\n// ============================================================================\n// MESSAGE HANDLER FACTORY\n// ============================================================================\n\nexport function makeChannelMessageHandler(\n    transport: TransportTarget,\n    channelName: string,\n    handler?: MessageHandlerCallback<ChannelMessage>\n): (subscriber: ChannelSubscriber<ChannelMessage>) => () => void {\n    const pending = new Map<string, PendingRequest>();\n    const send = createTransportSender(transport);\n\n    return (subscriber) => {\n        const respond = (data: ChannelMessage): RespondFn<ChannelMessage> => {\n            if (data.type === \"response\" && data.reqId) {\n                return (result) => {\n                    const p = pending.get(data.reqId!);\n                    if (p) { p.resolve(result); pending.delete(data.reqId!); }\n                };\n            }\n            if (data.type === \"request\") {\n                return (result, transfer) => send({ ...result, channel: data.sender, sender: channelName, type: \"response\", reqId: data.reqId }, transfer);\n            }\n            return send;\n        };\n\n        const onMessage = (data: ChannelMessage): void => {\n            if (!subscriber.active) return;\n            if (data.type === \"response\" && data.reqId) {\n                const p = pending.get(data.reqId);\n                if (p) { p.resolve(data.payload); pending.delete(data.reqId); }\n            }\n            handler ? handler(data, respond(data)) : subscriber.next(data);\n        };\n\n        const cleanup = createTransportListener(transport, onMessage, (e) => subscriber.error(e), () => subscriber.complete());\n\n        // Add request capability\n        (subscriber as any).request = (msg: ChannelMessage) => {\n            const reqId = msg.reqId ?? UUIDv4();\n            msg.reqId = reqId;\n            return new Promise((resolve, reject) => {\n                pending.set(reqId, { resolve, reject, timestamp: Date.now() });\n                send(msg);\n            });\n        };\n\n        return cleanup;\n    };\n}\n\n// ============================================================================\n// MESSAGE OBSERVABLE\n// ============================================================================\n\nexport class ChannelMessageObservable {\n    private _pending = new Map<string, PendingRequest>();\n    private _subs = new Set<Observer<ChannelMessage>>();\n    private _cleanup: (() => void) | null = null;\n    private _send: SendFn<ChannelMessage>;\n    private _active = false;\n\n    constructor(private _transport: TransportTarget, private _channelName: string) {\n        this._send = createTransportSender(_transport);\n    }\n\n    subscribe(observer: { next?: (v: ChannelMessage) => void; error?: (e: Error) => void; complete?: () => void }): { unsubscribe: () => void } {\n        this._subs.add(observer);\n        if (!this._active) this._activate();\n        return {\n            unsubscribe: () => {\n                this._subs.delete(observer);\n                if (this._subs.size === 0) this._deactivate();\n            }\n        };\n    }\n\n    next(msg: ChannelMessage, transfer?: Transferable[]): void { this._send(msg, transfer); }\n\n    request(msg: Omit<ChannelMessage, \"reqId\"> & { reqId?: string }): Promise<any> {\n        const reqId = msg.reqId ?? UUIDv4();\n        return new Promise((resolve, reject) => {\n            this._pending.set(reqId, { resolve, reject, timestamp: Date.now() });\n            this.next({ ...msg, reqId } as ChannelMessage);\n        });\n    }\n\n    private _activate(): void {\n        if (this._active) return;\n        this._cleanup = createTransportListener(\n            this._transport,\n            (data) => {\n                if (data.type === \"response\" && data.reqId) {\n                    const p = this._pending.get(data.reqId);\n                    if (p) { p.resolve(data.payload); this._pending.delete(data.reqId); }\n                }\n                for (const s of this._subs) { try { s.next?.(data); } catch (e) { s.error?.(e as Error); } }\n            },\n            (e) => this._subs.forEach((s) => s.error?.(e)),\n            () => this._subs.forEach((s) => s.complete?.())\n        );\n        this._active = true;\n    }\n\n    private _deactivate(): void {\n        this._cleanup?.(); this._cleanup = null; this._active = false;\n    }\n}\n\n// ============================================================================\n// REQUEST HANDLER FACTORY\n// ============================================================================\n\nexport function createChannelRequestHandler(\n    channelName: string,\n    options: { onRequest?: (req: WReq) => void; onResponse?: (res: any) => void } = {}\n): MessageHandlerCallback<ChannelMessage> {\n    return async (data, respond) => {\n        if (data.type !== \"request\" || data.channel !== channelName) return;\n        options.onRequest?.(data.payload as WReq);\n        const result = await handleRequest(data.payload as WReq, data.reqId!, channelName);\n        if (result) {\n            options.onResponse?.(result.response);\n            respond({ ...result.response, id: UUIDv4(), timestamp: Date.now() } as ChannelMessage, result.transfer);\n        }\n    };\n}\n\n// ============================================================================\n// DISPATCHER (Simplified)\n// ============================================================================\n\nexport class ObservableRequestDispatcher {\n    private _pending = new Map<string, PendingRequest>();\n    private _subscriber: ChannelSubscriber<ChannelMessage> | null = null;\n\n    constructor(private _channelName: string, private _targetChannel: string) {}\n\n    connect(subscriber: ChannelSubscriber<ChannelMessage>): void { this._subscriber = subscriber; }\n\n    disconnect(): void {\n        for (const p of this._pending.values()) p.reject(new Error(\"Disconnected\"));\n        this._pending.clear();\n        this._subscriber = null;\n    }\n\n    handleMessage(data: ChannelMessage): void {\n        if (data.type === \"response\" && data.reqId) {\n            const p = this._pending.get(data.reqId);\n            if (p) { p.resolve(data.payload); this._pending.delete(data.reqId); }\n        }\n    }\n\n    dispatch(action: string, path: string[], args: any[]): Promise<any> {\n        if (!this._subscriber?.active) return Promise.reject(new Error(\"Not connected\"));\n        const reqId = UUIDv4();\n        const msg: ChannelMessage = {\n            id: UUIDv4(), channel: this._targetChannel, sender: this._channelName,\n            type: \"request\", reqId, payload: { channel: this._targetChannel, sender: this._channelName, path, action, args },\n            timestamp: Date.now()\n        };\n        const promise = new Promise((resolve, reject) => this._pending.set(reqId, { resolve, reject, timestamp: Date.now() }));\n        this._subscriber.next(msg);\n        return promise;\n    }\n}\n\nexport type { PendingRequest, MessageHandlerCallback as ChannelMessageCallback };\n","/**\n * Uniform.ts - Unified Channel Communication Library\n *\n * Provides a unified API for cross-context communication:\n * - Workers, SharedWorkers, ServiceWorkers\n * - BroadcastChannel, MessagePort, WebSocket\n * - Chrome Extension messaging\n * - SharedArrayBuffer + Atomics\n * - WebRTC DataChannel\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type {\n    WReflectDescriptor, WReq, WResp, WError, WSuccess,\n    Observer, Subscription, Subscribable, Subscriber, Producer,\n    ChannelMessage, ChannelState, ChannelMeta,\n    TransportType, TransportTarget, ConnectionOptions,\n    ResponderFn, InvokerHandler, MessageHandler, SendFn, PendingRequest,\n    AtomicsConfig, RTCConfig, SharedWorkerConfig, PortConfig,\n    TransferableConfig, TransportCapabilities\n} from \"./next/types/Interface\";\n\nexport { WStatus, WType, WReflectAction } from \"./next/types/Interface\";\n\n// ============================================================================\n// CORE (Transport & Request Handling)\n// ============================================================================\n\nexport {\n    createTransportSender,\n    createTransportListener,\n    createChromeListener,\n    createChromeTabsListener,\n    createWebSocketTransport,\n    createBroadcastTransport,\n    detectTransportType,\n    getTransportMeta,\n    TransportCoreFactory,\n    type TransportMeta\n} from \"./core/TransportCore\";\n\nexport { executeAction, buildResponse, handleRequest } from \"./core/RequestHandler\";\n\n// ============================================================================\n// OBSERVABLE (Core)\n// ============================================================================\n\nexport {\n    // Core classes\n    Observable,\n    ChannelSubject,\n    ReplayChannelSubject,\n    ChannelObservable,\n    MessageObservable,\n\n    // Invoker factories\n    makeWorkerInvoker,\n    makeMessagePortInvoker,\n    makeBroadcastInvoker,\n    makeWebSocketInvoker,\n    makeChromeRuntimeInvoker,\n    makeServiceWorkerClientInvoker,\n    makeServiceWorkerHostInvoker,\n    makeSelfInvoker,\n\n    // Handlers\n    createInvokerObservable,\n    createReflectHandler,\n    createBidirectionalChannel,\n\n    // Operators\n    filter, map, take, takeUntil, debounce, throttle,\n\n    // Utilities\n    fromEvent, fromPromise, delay, interval, merge, when, createMessageId,\n\n    // Factory\n    ObservableFactory,\n\n    // Types\n    type BidirectionalChannel\n} from \"./next/observable/Observable\";\n\n// ============================================================================\n// UNIFIED CHANNEL (Primary API)\n// ============================================================================\n\nexport {\n    UnifiedChannel,\n    createUnifiedChannel,\n    setupUnifiedChannel,\n    createUnifiedChannelPair,\n    getUnifiedChannel,\n    getUnifiedChannelNames,\n    closeUnifiedChannel,\n    getWorkerChannel,\n    exposeFromUnified,\n    remoteFromUnified,\n    type UnifiedChannelConfig,\n    type ConnectOptions,\n    type UnifiedConnectionDirection,\n    type UnifiedConnectionStatus,\n    type UnifiedConnectionInfo,\n    type UnifiedConnectionEvent,\n    type UnifiedQueryConnectionsOptions\n} from \"./next/channel/UnifiedChannel\";\n\n// ============================================================================\n// INVOKER (Requestor/Responder Pattern)\n// ============================================================================\n\nexport {\n    Requestor,\n    Responder,\n    BidirectionalInvoker,\n    DefaultReflect,\n    createRequestor,\n    createResponder,\n    createInvoker,\n    setupInvoker,\n    autoInvoker,\n    detectContextType,\n    detectTransportType as detectTransport,\n    detectIncomingContextType,\n    type InvokerConfig,\n    type ReflectLike,\n    type InvocationResponse,\n    type ContextType,\n    type IncomingInvocation\n} from \"./next/proxy/Invoker\";\n\n// ============================================================================\n// MULTI-CHANNEL CONTEXT\n// ============================================================================\n// vNext note:\n// - UnifiedChannel is the canonical runtime engine.\n// - ChannelContext remains as orchestration facade for multi-channel workflows\n//   and compatibility with legacy endpoint-style APIs.\n\nexport {\n    ChannelContext,\n    createChannelContext,\n    getOrCreateContext,\n    getContext,\n    deleteContext,\n    getContextNames,\n    createChannelsInContext,\n    importModuleInContext,\n    getDefaultContext,\n    addWorkerChannel,\n    addPortChannel,\n    addBroadcastChannel,\n    addSelfChannelToDefault,\n    deferChannel,\n    initDeferredChannel,\n    getChannelFromDefault,\n    createDefaultChannelPair,\n    type ChannelContextOptions,\n    type ChannelEndpoint,\n    type RemoteChannelInfo,\n    type ContextConnectionDirection,\n    type ContextConnectionStatus,\n    type ContextConnectionInfo,\n    type ConnectionEvent,\n    type QueryConnectionsOptions,\n    type DynamicTransportType,\n    type DynamicTransportConfig\n} from \"./next/channel/ChannelContext\";\n\n// ============================================================================\n// CONNECTION\n// ============================================================================\n\nexport {\n    ChannelConnection,\n    ConnectionPool,\n    getConnection,\n    getHostConnection,\n    getConnectionPool\n} from \"./next/channel/Connection\";\n\n// ============================================================================\n// TRANSPORT ADAPTERS\n// ============================================================================\n\nexport {\n    TransportAdapter,\n    WorkerTransport,\n    MessagePortTransport,\n    BroadcastChannelTransport,\n    WebSocketTransport,\n    ChromeRuntimeTransport,\n    ChromeTabsTransport,\n    ChromePortTransport,\n    ChromeExternalTransport,\n    ServiceWorkerTransport,\n    SelfTransport,\n    TransportFactory,\n    createConnectionObserver,\n    type TransportIncomingConnection,\n    type AcceptConnectionCallback\n} from \"./next/transport/Transport\";\n\nexport {\n    TransportObservable,\n    WorkerObservable,\n    MessagePortObservable,\n    BroadcastChannelObservable,\n    WebSocketObservable,\n    ChromeRuntimeObservable as TransportChromeRuntimeObservable,\n    ChromeTabsObservable as TransportChromeTabsObservable,\n    ChromePortObservable as TransportChromePortObservable,\n    ServiceWorkerClientObservable,\n    ServiceWorkerHostObservable,\n    SelfObservable,\n    TransportObservableFactory,\n    createBidirectionalChannel as createBidirectionalTransport\n} from \"./next/transport/TransportObservable\";\n\n// ============================================================================\n// WORKER CONTEXT\n// ============================================================================\n\nexport {\n    WorkerContext,\n    getWorkerContext,\n    initWorkerContext,\n    onWorkerConnection,\n    onWorkerChannelCreated,\n    workerContext,\n    getWorkerResponder,\n    getWorkerInvoker,\n    exposeFromWorker,\n    onWorkerInvocation,\n    createHostProxy,\n    importInHost,\n    type IncomingConnection,\n    type ChannelCreatedEvent,\n    type WorkerContextConfig\n} from \"./next/transport/Worker\";\n\n// ============================================================================\n// CHROME EXTENSION\n// ============================================================================\n\nexport {\n    ChromeRuntimeObservable,\n    ChromeTabsObservable,\n    ChromePortObservable,\n    ChromeExternalObservable,\n    ChromeObservableFactory,\n    createChromeRequestHandler,\n    type ChromeMessage,\n    type PortInfo,\n    type ChromeObservableOptions\n} from \"./next/observable/ChromeObservable\";\n\n// ============================================================================\n// SOCKET.IO\n// ============================================================================\n\nexport {\n    SocketIOObservable,\n    SocketIORoomObservable,\n    SocketIOObservableFactory,\n    createSocketRequestHandler,\n    createSocketObservable,\n    type SocketIOLike,\n    type SocketMessage,\n    type SocketObservableOptions\n} from \"./next/observable/SocketIOObservable\";\n\n// ============================================================================\n// ADVANCED TRANSPORTS\n// ============================================================================\n\n// SharedWorker\nexport {\n    SharedWorkerClient,\n    SharedWorkerHost,\n    createSharedWorkerObservable,\n    createSharedWorkerHostObservable,\n    SharedWorkerObservableFactory,\n    type SharedWorkerMessage,\n    type SharedWorkerOptions,\n    type SharedWorkerPortInfo\n} from \"./next/transport/SharedWorkerTransport\";\n\n// Atomics (SharedArrayBuffer)\nexport {\n    AtomicsTransport,\n    AtomicsBuffer,\n    AtomicsRingBuffer,\n    createAtomicsChannelPair,\n    createWorkerAtomicsTransport,\n    AtomicsTransportFactory,\n    type AtomicsMessage,\n    type AtomicsTransportConfig,\n    type AtomicsChannelPair,\n    type RingBufferConfig\n} from \"./next/transport/AtomicsTransport\";\n\n// WebRTC DataChannel\nexport {\n    RTCPeerTransport,\n    RTCPeerManager,\n    createBroadcastSignaling,\n    RTCTransportFactory,\n    type RTCMessage,\n    type RTCTransportConfig,\n    type RTCSignaling,\n    type RTCSignalMessage,\n    type RTCPeerInfo\n} from \"./next/transport/RTCDataChannelTransport\";\n\n// MessagePort Enhanced\nexport {\n    PortTransport,\n    PortPool,\n    WindowPortConnector,\n    createChannelPair,\n    createFromPort,\n    createPortProxy,\n    exposeOverPort,\n    PortTransportFactory,\n    type PortMessage,\n    type PortTransportConfig,\n    type PortPair,\n    type WindowPortConnectorConfig,\n    type ProxyMethods\n} from \"./next/transport/PortTransport\";\n\n// Unified Transport Factory\nexport {\n    createTransport,\n    getTransportRegistry,\n    AbstractTransport,\n    UnifiedTransportFactory,\n    type UnifiedTransportConfig,\n    type TransportInstance,\n    type TransportFactoryOptions\n} from \"./next/transport/UnifiedTransport\";\n\n// ============================================================================\n// STORAGE\n// ============================================================================\n\nexport * from \"./next/storage/Storage\";\nexport * from \"./next/storage/TransferableStorage\";\nexport * from \"./next/storage/Queued\";\nexport * from \"./next/storage/DataBase\";\nexport * from \"./next/transport/ServiceWorkerHost\";\n\n// ============================================================================\n// MESSAGING (Cross-context communication)\n// ============================================================================\n\nexport * from \"./messaging\";\n\n// ============================================================================\n// UTILITIES\n// ============================================================================\n\nexport * from \"./next/utils/Env\";\nexport * from \"./next/utils/Utils\";\nexport * from \"./next/utils/Wrappers\";\n\n// ============================================================================\n// PROXY (Unified Proxy Creation)\n// ============================================================================\n\nexport {\n    // Types\n    type ProxyInvoker,\n    type ProxyDescriptor,\n    type ProxyConfig,\n    type ProxyMethods as ProxyMethodsType,\n    type RemoteProxy,\n    type ExposeHandler,\n    type ProxySender,\n\n    // Symbols\n    PROXY_MARKER,\n    PROXY_INTERNALS,\n\n    // Classes\n    RemoteProxyHandler,\n    DispatchProxyHandler as DispatchHandler,\n    ProxyBuilder,\n\n    // Factory functions\n    createRemoteProxy,\n    wrapDescriptor,\n    isRemoteProxy,\n    getProxyDescriptor,\n    getProxyInternals,\n    createExposeHandler,\n    createSenderProxy,\n    proxyBuilder\n} from \"./next/proxy/Proxy\";\n\n// ============================================================================\n// LEGACY (Backward Compatibility)\n// ============================================================================\n\nexport {\n    ChannelHandler,\n    RemoteChannelHelper,\n    SELF_CHANNEL,\n    CHANNEL_MAP,\n    RemoteChannels,\n    initChannelHandler,\n    loadWorker,\n    $createOrUseExistingChannel,\n    createHostChannel,\n    createOrUseExistingChannel\n} from \"./next/channel/Channels\";\n\nexport {\n    makeRequestProxy,\n    makeObservableRequestProxy,\n    wrapChannel,\n    wrapObservableChannel,\n    createObservableChannel,\n    DispatchProxyHandler\n} from \"./next/proxy/RequestProxy\";\n\nexport {\n    makeChannelMessageHandler,\n    ObservableRequestDispatcher,\n    ChannelMessageObservable,\n    createChannelRequestHandler\n} from \"./next/channel/ChannelMessageHandler\";\n\n// Aliases for legacy support\nexport { ChannelHandler as ObservableChannelHandler } from \"./next/channel/Channels\";\nexport { Observable as ChannelNativeObservable } from \"./next/observable/Observable\";\n\n// ============================================================================\n// HIGH-LEVEL API\n// ============================================================================\n\nimport { createOrUseExistingChannel, createHostChannel, SELF_CHANNEL } from \"./next/channel/Channels\";\nimport { wrapChannel } from \"./next/proxy/RequestProxy\";\nimport { createChannelContext, getOrCreateContext, createChannelsInContext, importModuleInContext } from \"./next/channel/ChannelContext\";\nimport { detectExecutionContext } from \"./next/utils/Env\";\nimport type { WorkerChannel } from \"./next/storage/Queued\";\n\nexport interface BroadcastLike {\n    addEventListener: (type: \"message\" | \"error\", listener: (...args: any[]) => any) => void;\n    removeEventListener?: (type: \"message\" | \"error\", listener: (...args: any[]) => any) => void;\n    postMessage: (message: any, transfer?: any) => void;\n    close?: () => void;\n    start?: () => void;\n}\n\n/** Sync with a remote channel */\nexport const sync = async (channel: string, options: any = {}, broadcast: BroadcastLike | Worker | BroadcastChannel | MessagePort | null = null) =>\n    createOrUseExistingChannel(channel, options, (broadcast ?? (typeof self !== \"undefined\" ? (self as any) : null)) as any);\n\n/** Import a module in a remote channel */\nexport const importModuleInChannel = async (\n    channel: string, url: string, options: any = {},\n    broadcast: BroadcastLike | Worker | BroadcastChannel | MessagePort | null = (typeof self !== \"undefined\" ? (self as any) : null)\n) => {\n    const remote = await createOrUseExistingChannel(channel, options?.channelOptions, broadcast as any);\n    return remote?.doImportModule?.(url, options?.importOptions);\n};\n\n/** Create a new isolated channel context */\nexport const createContext = createChannelContext;\n\n/** Get or create a shared context by name */\nexport const getSharedContext = getOrCreateContext;\n\n/** Create multiple channels in a new context */\nexport const createMultiChannel = createChannelsInContext;\n\n/** Import a module with its own isolated context */\nexport const importIsolatedModule = importModuleInContext;\n\n/** Connect to a channel as a module */\nexport const connectToChannelAsModule = async (\n    channel: string, options: any = {},\n    broadcast: BroadcastLike | Worker | BroadcastChannel | MessagePort | null = (typeof self !== \"undefined\" ? (self as any) : null),\n    hostChannel: string | null = \"$host$\"\n) => {\n    const host = createHostChannel(hostChannel ?? \"$host$\");\n    await host?.createRemoteChannel(channel, options, broadcast as any);\n    return wrapChannel(channel, host ?? SELF_CHANNEL?.instance);\n};\n\n/** Create Chrome extension runtime channel */\nexport const createChromeExtensionRuntimeChannel = (channelName: string, options: any = {}): WorkerChannel => {\n    const context = detectExecutionContext();\n    if (context !== \"chrome-extension\") {\n        return { async request(method: string) { throw new Error(`Chrome extension messaging not available in ${context}`); }, close() {} };\n    }\n    return {\n        async request(method: string, args: any[] = []) {\n            return new Promise((resolve, reject) => {\n                try {\n                    chrome.runtime.sendMessage({\n                        id: `crx_${Date.now()}_${Math.random().toString(36).slice(2)}`,\n                        type: method, source: context, target: channelName,\n                        data: args?.length === 1 ? args[0] : args,\n                        metadata: { timestamp: Date.now(), ...(options?.metadata ?? {}) }\n                    }, (response) => {\n                        if (chrome.runtime.lastError) reject(new Error(chrome.runtime.lastError.message));\n                        else resolve(response);\n                    });\n                } catch (error) { reject(error); }\n            });\n        },\n        close() {}\n    };\n};\n"],"file":"index.js"}