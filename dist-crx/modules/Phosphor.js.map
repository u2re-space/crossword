{"version":3,"file":"Phosphor.js","sources":["../../../../modules/projects/icon.ts/src/loader/OPFSCache.ts","../../../../modules/projects/icon.ts/src/loader/CSSIconRegistry.ts","../../../../modules/projects/icon.ts/src/loader/Loader.ts","../../../../modules/projects/icon.ts/src/loader/Phosphor.ts"],"sourcesContent":["/**\n * OPFS (Origin Private File System) Icon Cache\n *\n * Provides persistent caching for:\n * - Vector SVG icon files (reduces network fetches)\n * - Rasterized mask images (reduces canvas operations)\n */\n\nconst CACHE_VERSION = 2; // Increment to invalidate old caches\nconst ROOT_DIR_NAME = \"icon-cache\";\nconst VECTOR_DIR = \"vector\";\nconst RASTER_DIR = \"raster\";\nconst META_FILE = \".cache-meta.json\";\nconst MAX_CACHE_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\nconst MAX_CACHE_SIZE_BYTES = 50 * 1024 * 1024; // 50MB\n\ntype CacheMeta = {\n    version: number;\n    created: number;\n    lastAccess: number;\n};\n\nlet rootHandle: FileSystemDirectoryHandle | null = null;\nlet vectorDirHandle: FileSystemDirectoryHandle | null = null;\nlet rasterDirHandle: FileSystemDirectoryHandle | null = null;\nlet isSupported: boolean | null = null;\nlet initPromise: Promise<boolean> | null = null;\n\n/**\n * Checks if OPFS is supported in current environment\n */\nexport const isOPFSSupported = (): boolean => {\n    if (isSupported !== null) return isSupported;\n\n    try {\n        isSupported = !!(\n            typeof navigator !== \"undefined\" &&\n            \"storage\" in navigator &&\n            typeof navigator.storage?.getDirectory === \"function\" &&\n            typeof FileSystemFileHandle !== \"undefined\" &&\n            typeof FileSystemDirectoryHandle !== \"undefined\"\n        );\n    } catch {\n        isSupported = false;\n    }\n\n    return isSupported;\n};\n\n/**\n * Sanitizes a cache key to be a valid filename\n */\nconst sanitizeKey = (key: string): string => {\n    if (!key || typeof key !== \"string\") return \"_empty_\";\n    return key\n        .replace(/[<>:\"/\\\\|?*\\x00-\\x1F]/g, \"_\")\n        .replace(/\\.{2,}/g, \"_\")\n        .replace(/^\\./, \"_\")\n        .slice(0, 200);\n};\n\n/**\n * Initializes the OPFS cache directories\n */\nexport const initOPFSCache = async (): Promise<boolean> => {\n    if (initPromise) return initPromise;\n\n    initPromise = (async (): Promise<boolean> => {\n        if (!isOPFSSupported()) return false;\n\n        try {\n            const storageRoot = await navigator.storage.getDirectory();\n            rootHandle = await storageRoot.getDirectoryHandle(ROOT_DIR_NAME, { create: true });\n\n            // Check cache version and clear if outdated\n            const meta = await readCacheMeta();\n            const now = Date.now();\n\n            if (meta && meta.version !== CACHE_VERSION) {\n                if (typeof console !== \"undefined\") {\n                    console.log?.(\"[icon-cache] Cache version mismatch, clearing cache\");\n                }\n                await clearAllCache();\n            } else if (meta && (now - meta.lastAccess) > MAX_CACHE_AGE_MS) {\n                if (typeof console !== \"undefined\") {\n                    console.log?.(\"[icon-cache] Cache expired, clearing cache\");\n                }\n                await clearAllCache();\n            } else {\n                // Check cache size and clean up if too large\n                const stats = await getCacheStats();\n                if (stats && stats.totalSize > MAX_CACHE_SIZE_BYTES) {\n                    if (typeof console !== \"undefined\") {\n                        console.log?.(\"[icon-cache] Cache size exceeded, clearing cache\");\n                    }\n                    await clearAllCache();\n                }\n            }\n\n            // Create/get subdirectories\n            vectorDirHandle = await rootHandle.getDirectoryHandle(VECTOR_DIR, { create: true });\n            rasterDirHandle = await rootHandle.getDirectoryHandle(RASTER_DIR, { create: true });\n\n            // Write/update metadata\n            await writeCacheMeta();\n\n            return true;\n        } catch (error) {\n            if (typeof console !== \"undefined\") {\n                console.warn?.(\"[icon-cache] OPFS init failed:\", error);\n            }\n            rootHandle = null;\n            vectorDirHandle = null;\n            rasterDirHandle = null;\n            return false;\n        }\n    })();\n\n    return initPromise;\n};\n\n/**\n * Reads cache metadata\n */\nconst readCacheMeta = async (): Promise<CacheMeta | null> => {\n    if (!rootHandle) return null;\n\n    try {\n        const fileHandle = await rootHandle.getFileHandle(META_FILE);\n        const file = await fileHandle.getFile();\n        const text = await file.text();\n        return JSON.parse(text) as CacheMeta;\n    } catch {\n        return null;\n    }\n};\n\n/**\n * Writes cache metadata\n */\nconst writeCacheMeta = async (): Promise<void> => {\n    if (!rootHandle) return;\n\n    try {\n        const fileHandle = await rootHandle.getFileHandle(META_FILE, { create: true });\n        const writable = await fileHandle.createWritable();\n        const meta: CacheMeta = {\n            version: CACHE_VERSION,\n            created: Date.now(),\n            lastAccess: Date.now(),\n        };\n        await writable.write(JSON.stringify(meta));\n        await writable.close();\n    } catch {\n        /* silently fail */\n    }\n};\n\n/**\n * Stores a vector (SVG) icon in cache\n */\nexport const cacheVectorIcon = async (key: string, svgContent: string | Blob): Promise<boolean> => {\n    if (!vectorDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !vectorDirHandle) return false;\n    }\n\n    try {\n        const filename = sanitizeKey(key) + \".svg\";\n        const fileHandle = await vectorDirHandle!.getFileHandle(filename, { create: true });\n        const writable = await fileHandle.createWritable();\n\n        if (svgContent instanceof Blob) {\n            await writable.write(svgContent);\n        } else {\n            await writable.write(new Blob([svgContent], { type: \"image/svg+xml\" }));\n        }\n\n        await writable.close();\n        return true;\n    } catch (error) {\n        if (typeof console !== \"undefined\") {\n            console.warn?.(\"[icon-cache] Failed to cache vector:\", key, error);\n        }\n        return false;\n    }\n};\n\n/**\n * Retrieves a vector (SVG) icon from cache\n * Returns blob URL if found, null otherwise\n */\nexport const getCachedVectorIcon = async (key: string): Promise<string | null> => {\n    if (!vectorDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !vectorDirHandle) return null;\n    }\n\n    try {\n        const filename = sanitizeKey(key) + \".svg\";\n        const fileHandle = await vectorDirHandle!.getFileHandle(filename);\n        const file = await fileHandle.getFile();\n        return URL.createObjectURL(file);\n    } catch {\n        return null;\n    }\n};\n\n/**\n * Checks if a vector icon exists in cache\n */\nexport const hasVectorIcon = async (key: string): Promise<boolean> => {\n    if (!vectorDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !vectorDirHandle) return false;\n    }\n\n    try {\n        const filename = sanitizeKey(key) + \".svg\";\n        await vectorDirHandle!.getFileHandle(filename);\n        return true;\n    } catch {\n        return false;\n    }\n};\n\n/**\n * Stores a rasterized icon (PNG blob) in cache\n */\nexport const cacheRasterIcon = async (key: string, bucket: number, blob: Blob): Promise<boolean> => {\n    if (!rasterDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !rasterDirHandle) return false;\n    }\n\n    try {\n        const filename = `${sanitizeKey(key)}@${bucket}.png`;\n        const fileHandle = await rasterDirHandle!.getFileHandle(filename, { create: true });\n        const writable = await fileHandle.createWritable();\n        await writable.write(blob);\n        await writable.close();\n        return true;\n    } catch (error) {\n        if (typeof console !== \"undefined\") {\n            console.warn?.(\"[icon-cache] Failed to cache raster:\", key, error);\n        }\n        return false;\n    }\n};\n\n/**\n * Retrieves a rasterized icon from cache\n * Returns blob URL if found, null otherwise\n */\nexport const getCachedRasterIcon = async (key: string, bucket: number): Promise<string | null> => {\n    if (!rasterDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !rasterDirHandle) return null;\n    }\n\n    try {\n        const filename = `${sanitizeKey(key)}@${bucket}.png`;\n        const fileHandle = await rasterDirHandle!.getFileHandle(filename);\n        const file = await fileHandle.getFile();\n        return URL.createObjectURL(file);\n    } catch {\n        return null;\n    }\n};\n\n/**\n * Checks if a raster icon exists in cache\n */\nexport const hasRasterIcon = async (key: string, bucket: number): Promise<boolean> => {\n    if (!rasterDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !rasterDirHandle) return false;\n    }\n\n    try {\n        const filename = `${sanitizeKey(key)}@${bucket}.png`;\n        await rasterDirHandle!.getFileHandle(filename);\n        return true;\n    } catch {\n        return false;\n    }\n};\n\n/**\n * Removes a specific vector icon from cache\n */\nexport const removeVectorIcon = async (key: string): Promise<boolean> => {\n    if (!vectorDirHandle) return false;\n\n    try {\n        const filename = sanitizeKey(key) + \".svg\";\n        await vectorDirHandle.removeEntry(filename);\n        return true;\n    } catch {\n        return false;\n    }\n};\n\n/**\n * Removes a specific raster icon from cache\n */\nexport const removeRasterIcon = async (key: string, bucket: number): Promise<boolean> => {\n    if (!rasterDirHandle) return false;\n\n    try {\n        const filename = `${sanitizeKey(key)}@${bucket}.png`;\n        await rasterDirHandle.removeEntry(filename);\n        return true;\n    } catch {\n        return false;\n    }\n};\n\n/**\n * Clears all cached icons\n */\nexport const clearAllCache = async (): Promise<void> => {\n    if (!rootHandle) {\n        const ready = await initOPFSCache();\n        if (!ready || !rootHandle) return;\n    }\n\n    try {\n        // Remove subdirectories recursively\n        for await (const [name] of (rootHandle as any).entries()) {\n            if (name !== META_FILE) {\n                await rootHandle!.removeEntry(name, { recursive: true });\n            }\n        }\n\n        // Reset handles\n        vectorDirHandle = null;\n        rasterDirHandle = null;\n\n        // Reinitialize\n        initPromise = null;\n        await initOPFSCache();\n    } catch (error) {\n        if (typeof console !== \"undefined\") {\n            console.warn?.(\"[icon-cache] Failed to clear cache:\", error);\n        }\n    }\n};\n\n/**\n * Gets cache statistics\n */\nexport const getCacheStats = async (): Promise<{\n    vectorCount: number;\n    rasterCount: number;\n    totalSize: number;\n} | null> => {\n    if (!vectorDirHandle || !rasterDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready) return null;\n    }\n\n    try {\n        let vectorCount = 0;\n        let rasterCount = 0;\n        let totalSize = 0;\n\n        for await (const [, handle] of (vectorDirHandle as any).entries()) {\n            if (handle.kind === \"file\") {\n                vectorCount++;\n                const file = await (handle as FileSystemFileHandle).getFile();\n                totalSize += file.size;\n            }\n        }\n\n        for await (const [, handle] of (rasterDirHandle as any).entries()) {\n            if (handle.kind === \"file\") {\n                rasterCount++;\n                const file = await (handle as FileSystemFileHandle).getFile();\n                totalSize += file.size;\n            }\n        }\n\n        return { vectorCount, rasterCount, totalSize };\n    } catch {\n        return null;\n    }\n};\n\n/**\n * Validates and cleans up corrupted cache entries\n */\nexport const validateAndCleanCache = async (): Promise<void> => {\n    if (!vectorDirHandle || !rasterDirHandle) {\n        const ready = await initOPFSCache();\n        if (!ready) return;\n    }\n\n    const corruptedKeys: string[] = [];\n\n    try {\n        // Check vector icons\n        for await (const [name, handle] of (vectorDirHandle as any).entries()) {\n            if (handle.kind === \"file\" && name.endsWith('.svg')) {\n                try {\n                    const file = await (handle as FileSystemFileHandle).getFile();\n                    // Basic validation - check if file has content and starts with SVG tag\n                    if (file.size === 0) {\n                        corruptedKeys.push(`vector:${name}`);\n                        continue;\n                    }\n\n                    const text = await file.text();\n                    if (!text.trim().startsWith('<svg')) {\n                        corruptedKeys.push(`vector:${name}`);\n                    }\n                } catch {\n                    corruptedKeys.push(`vector:${name}`);\n                }\n            }\n        }\n\n        // Check raster icons\n        for await (const [name, handle] of (rasterDirHandle as any).entries()) {\n            if (handle.kind === \"file\" && (name.endsWith('.png') || name.endsWith('.webp'))) {\n                try {\n                    const file = await (handle as FileSystemFileHandle).getFile();\n                    if (file.size === 0) {\n                        corruptedKeys.push(`raster:${name}`);\n                    }\n                } catch {\n                    corruptedKeys.push(`raster:${name}`);\n                }\n            }\n        }\n\n        // Remove corrupted entries\n        for (const key of corruptedKeys) {\n            try {\n                const [type, filename] = key.split(':');\n                if (type === 'vector' && vectorDirHandle) {\n                    await vectorDirHandle.removeEntry(filename);\n                } else if (type === 'raster' && rasterDirHandle) {\n                    await rasterDirHandle.removeEntry(filename);\n                }\n            } catch {\n                /* ignore removal errors */\n            }\n        }\n\n        if (corruptedKeys.length > 0 && typeof console !== \"undefined\") {\n            console.log?.(`[icon-cache] Cleaned up ${corruptedKeys.length} corrupted cache entries`);\n        }\n    } catch (error) {\n        if (typeof console !== \"undefined\") {\n            console.warn?.(\"[icon-cache] Cache validation failed:\", error);\n        }\n    }\n};\n\n/**\n * Pre-initializes cache on module load (non-blocking)\n */\nif (isOPFSSupported()) {\n    initOPFSCache().then(() => {\n        // Validate cache after initialization\n        validateAndCleanCache().catch(() => {\n            /* silent validation failure */\n        });\n    }).catch(() => {\n        /* silent init failure */\n    });\n}\n\n","/**\n * CSS-based Icon Registry\n *\n * Instead of caching URLs in JavaScript Maps and setting inline styles,\n * this registry manages a shared stylesheet with attribute-based selectors\n * and image-set() for resolution-aware icon loading.\n *\n * CSS rules are generated lazily when icons are first requested.\n * Multiple icon instances share the same CSS rule automatically.\n */\n\n// Constants inlined to avoid circular dependency with Loader.ts\nconst MAX_RASTER_SIZE = 512;\nconst MIN_RASTER_SIZE = 32;\n\n// Icon style element reference\nlet iconStyleSheet: CSSStyleSheet | null = null;\nlet styleElement: HTMLStyleElement | null = null;\n\n// Track which icon+style+bucket combinations have rules\nconst registeredRules = new Set<string>();\n\n// Store actual rule data for persistence across refreshes\nconst registeredRuleData = new Map<string, { selector: string; cssText: string }>();\n\n// Persistent registry storage - survives page refreshes via localStorage\nconst PERSISTENT_REGISTRY_KEY = 'ui-icon-registry-state.v2';\nconst LEGACY_PERSISTENT_KEYS = ['ui-icon-registry-state'];\n\nconst extractFirstCssUrl = (cssText: string): string | null => {\n    if (!cssText || typeof cssText !== \"string\") return null;\n    const match = cssText.match(/url\\(\\s*(['\"]?)([^'\")\\s]+)\\1\\s*\\)/i);\n    return match?.[2] ?? null;\n};\n\nconst isPersistableRuleCssText = (cssText: string): boolean => {\n    const url = extractFirstCssUrl(cssText);\n    if (!url) { return false; }\n\n    // blob: URLs are not stable across refreshes\n    if (/^blob:/i.test(url)) { return false; }\n\n    // data: URLs are safe to persist\n    if (/^data:/i.test(url)) { return true; }\n\n    // For http(s), only persist if same-origin (cross-origin will trigger CORS issues in CSS fetch)\n    if (/^https?:/i.test(url)) {\n        try {\n            if (typeof location !== \"undefined\" && typeof URL === \"function\") {\n                return new URL(url).origin === location.origin;\n            }\n        } catch {\n            return false;\n        }\n        return false;\n    }\n\n    // Relative/same-origin paths are OK\n    return true;\n};\n\n// Pending rule insertions (batched for performance)\nlet pendingRules: Array<{ selector: string; cssText: string; key: string }> = [];\nlet flushScheduled = false;\n\nconst ICON_PROXY_PATH = \"/api/icon-proxy\";\nconst isChromeExtensionRuntime = (): boolean => {\n    try {\n        const chromeRuntime = (globalThis as any)?.chrome?.runtime;\n        return !!chromeRuntime?.id;\n    } catch {\n        return false;\n    }\n};\n\nconst tryRewriteCrossOriginUrlToProxy = (rawUrl: string): string | null => {\n    if (!rawUrl || typeof rawUrl !== \"string\") return null;\n    const trimmed = rawUrl.trim();\n    if (!trimmed) return null;\n\n    // data/blob are already safe in CSS.\n    if (/^(data:|blob:)/i.test(trimmed)) return trimmed;\n\n    // Relative URLs are same-origin.\n    if (/^(\\/|\\.\\/|\\.\\.\\/)/.test(trimmed)) return trimmed;\n\n    // Only rewrite absolute cross-origin URLs.\n    if (!/^https?:/i.test(trimmed)) return trimmed;\n\n    // In extension runtimes (popup/options/content-script), don't rewrite to /api.\n    // Such endpoint is app-specific and usually unavailable there.\n    if (isChromeExtensionRuntime()) return trimmed;\n\n    try {\n        if (typeof location === \"undefined\" || typeof URL !== \"function\") return trimmed;\n        const u = new URL(trimmed);\n        if (u.origin === location.origin) return trimmed;\n        return `${ICON_PROXY_PATH}?url=${encodeURIComponent(trimmed)}`;\n    } catch {\n        return null;\n    }\n};\n\nconst rewriteCssUrlFunctionValue = (cssValue: string): string | null => {\n    if (!cssValue || typeof cssValue !== \"string\") return null;\n    const match = cssValue.match(/url\\(\\s*(['\"]?)([^'\")\\s]+)\\1\\s*\\)/i);\n    if (!match) return cssValue;\n    const rewritten = tryRewriteCrossOriginUrlToProxy(match[2]);\n    if (!rewritten) return null;\n    return `url(\"${rewritten}\")`;\n};\n\n/**\n * Saves the registry state to localStorage for persistence across refreshes\n */\nconst saveRegistryState = (): void => {\n    if (typeof localStorage === 'undefined') return;\n\n    try {\n        const ruleData = Array.from(registeredRuleData.entries())\n            .filter(([, data]) => isPersistableRuleCssText(data.cssText))\n            .map(([key, data]) => ({\n                key,\n                selector: data.selector,\n                cssText: data.cssText\n            }));\n\n        const state = {\n            rules: ruleData,\n            timestamp: Date.now()\n        };\n        localStorage.setItem(PERSISTENT_REGISTRY_KEY, JSON.stringify(state));\n    } catch {\n        // Ignore localStorage errors\n    }\n};\n\n// Store pending rule restorations until stylesheet is available\nlet pendingRuleRestorations: Array<{ key: string; selector: string; cssText: string }> | null = null;\n\n/**\n * Loads the registry state from localStorage and prepares rules for restoration\n */\nconst loadRegistryState = (): void => {\n    if (typeof localStorage === 'undefined') return;\n\n    try {\n        // Clean legacy keys eagerly to avoid restoring unsafe old rules.\n        for (const legacyKey of LEGACY_PERSISTENT_KEYS) {\n            if (legacyKey !== PERSISTENT_REGISTRY_KEY) {\n                try { localStorage.removeItem(legacyKey); } catch { /* ignore */ }\n            }\n        }\n\n        const stored = localStorage.getItem(PERSISTENT_REGISTRY_KEY);\n        if (!stored) return;\n\n        const state = JSON.parse(stored);\n        if (state.rules && Array.isArray(state.rules)) {\n            // Only restore rules from the last 24 hours to avoid stale data\n            const age = Date.now() - (state.timestamp || 0);\n            if (age < 24 * 60 * 60 * 1000) {\n                // Store for later restoration when stylesheet is available\n                pendingRuleRestorations = state.rules.filter((r: any) => isPersistableRuleCssText(r?.cssText));\n                if (typeof console !== 'undefined') {\n                    console.log?.(`[icon-registry] Prepared ${pendingRuleRestorations.length} rules for restoration from cache`);\n                }\n            } else {\n                // Clear expired state\n                localStorage.removeItem(PERSISTENT_REGISTRY_KEY);\n            }\n        }\n    } catch {\n        // Ignore localStorage errors\n    }\n};\n\n/**\n * Restores pending rules to the stylesheet when it becomes available\n */\nconst restorePendingRules = (sheet: CSSStyleSheet): void => {\n    if (!pendingRuleRestorations) return;\n\n    let restoredCount = 0;\n    let skippedCount = 0;\n    pendingRuleRestorations.forEach((ruleData) => {\n        if (ruleData.key && ruleData.selector && ruleData.cssText && !registeredRules.has(ruleData.key)) {\n            if (!isPersistableRuleCssText(ruleData.cssText)) {\n                skippedCount++;\n                return;\n            }\n            try {\n                // Re-insert the rule into the stylesheet\n                const ruleText = `${ruleData.selector} { ${ruleData.cssText} }`;\n                sheet.insertRule(ruleText, sheet.cssRules.length);\n\n                // Restore the tracking data\n                registeredRules.add(ruleData.key);\n                registeredRuleData.set(ruleData.key, {\n                    selector: ruleData.selector,\n                    cssText: ruleData.cssText\n                });\n                restoredCount++;\n            } catch (e) {\n                if (typeof console !== 'undefined') {\n                    console.warn?.(`[icon-registry] Failed to restore rule ${ruleData.key}:`, e);\n                }\n            }\n        }\n    });\n\n    if (typeof console !== 'undefined' && (restoredCount > 0 || skippedCount > 0)) {\n        console.log?.(`[icon-registry] Restored ${restoredCount} CSS rules to stylesheet (skipped ${skippedCount} unsafe/unstable rules)`);\n    }\n\n    pendingRuleRestorations = null; // Clear after restoration\n};\n\n/**\n * Clears the persistent registry state\n */\nexport const clearRegistryState = (): void => {\n    registeredRules.clear();\n    registeredRuleData.clear();\n    pendingRules.length = 0;\n    flushScheduled = false;\n\n    // Reset stylesheet\n    if (iconStyleSheet && document.adoptedStyleSheets) {\n        const index = document.adoptedStyleSheets.indexOf(iconStyleSheet as CSSStyleSheet);\n        if (index !== -1) {\n            document.adoptedStyleSheets.splice(index, 1);\n        }\n    }\n    iconStyleSheet = null;\n    styleElement = null;\n\n    if (typeof localStorage !== 'undefined') {\n        localStorage.removeItem(PERSISTENT_REGISTRY_KEY);\n    }\n\n    if (typeof console !== 'undefined') {\n        console.log?.('[icon-registry] Registry state cleared');\n    }\n};\n\n/**\n * Reinitializes the registry - useful for page refreshes or when needing to reload all rules\n */\nexport const reinitializeRegistry = (): void => {\n    clearRegistryState();\n    ensureStyleSheet();\n\n    if (typeof console !== 'undefined') {\n        console.log?.('[icon-registry] Registry reinitialized');\n    }\n};\n\n/**\n * Gets or creates the shared icon stylesheet\n */\nexport const ensureStyleSheet = (): CSSStyleSheet | null => {\n    if (iconStyleSheet) return iconStyleSheet as CSSStyleSheet;\n    if (typeof document === \"undefined\") return null;\n\n    // Load persistent registry state on first access\n    if (registeredRules.size === 0) {\n        loadRegistryState();\n    }\n\n    // Check for existing style element\n    /*styleElement = document.querySelector<HTMLStyleElement>(\"style[data-icon-registry]\");\n\n    if (!styleElement) {\n        styleElement = document.createElement(\"style\");\n        styleElement.setAttribute(\"data-icon-registry\", \"true\");\n        // Insert early in head for lower specificity\n        const head = document.head || document.documentElement;\n        head.insertBefore(styleElement, head.firstChild);\n    }*/\n\n    iconStyleSheet = new CSSStyleSheet() as CSSStyleSheet;//styleElement.sheet;\n    document.adoptedStyleSheets?.push?.((iconStyleSheet as unknown as CSSStyleSheet));\n\n    //\n    iconStyleSheet.insertRule(`@property --icon-image { syntax: \"<image>\"; inherits: true; initial-value: linear-gradient(#0000, #0000); }`, iconStyleSheet.cssRules.length);\n    iconStyleSheet.insertRule(`:where(ui-icon), :host(ui-icon) { --icon-image: linear-gradient(#0000, #0000); }`, iconStyleSheet.cssRules.length);\n    iconStyleSheet.insertRule(`:where(ui-icon:not([icon])), :where(ui-icon[icon=\"\"]), :host(ui-icon:not([icon])), :host(ui-icon[icon=\"\"]) { background-color: transparent; }`, iconStyleSheet.cssRules.length);\n\n    // Restore any pending rules from localStorage\n    restorePendingRules(iconStyleSheet);\n\n    return iconStyleSheet as CSSStyleSheet;\n};\n\n/**\n * Generates the CSS rule key for deduplication\n */\nconst makeRuleKey = (iconName: string, iconStyle: string, bucket: number): string => {\n    return `${iconStyle}:${iconName}@${bucket}`;\n};\n\n/**\n * Creates image-set value for different resolutions\n * Uses the resolved URL with appropriate resolution descriptors\n */\nconst createImageSetCSS = (\n    url: string,\n    bucket: number,\n): string => {\n    if (!url) return \"linear-gradient(#0000, #0000)\";\n\n    // Build image-set with 1x and 2x variants\n    // The browser will pick the best resolution based on device pixel ratio\n    /*const parts: string[] = [];\n\n    // Base resolution\n    parts.push((url.startsWith(\"url(\") ? url : `url(\"${url}\")`) + \" 1x\");\n\n    // Higher density hint (same URL, browser handles scaling)\n    if (bucket <= MAX_RASTER_SIZE / 2) {\n        parts.push((url.startsWith(\"url(\") ? url : `url(\"${url}\")`) + \" 2x\");\n    }\n\n    return `image-set(${parts.join(\", \")})`;*/\n    // Ensure the CSS doesn't directly reference cross-origin https://... URLs,\n    // because CSS fetches are credentialed and many CDNs respond with ACAO=\"*\".\n    if (url.startsWith(\"url(\")) {\n        return rewriteCssUrlFunctionValue(url) ?? \"linear-gradient(#0000, #0000)\";\n    }\n    const rewritten = tryRewriteCrossOriginUrlToProxy(url);\n    return rewritten ? `url(\"${rewritten}\")` : \"linear-gradient(#0000, #0000)\";\n};\n\n/**\n * Generates the CSS selector for an icon\n * Uses attribute selectors for icon name and style\n */\nconst makeSelector = (iconName: string, iconStyle: string): string => {\n    // Validate and sanitize inputs\n    const safeName = (iconName || '').trim();\n    const safeStyle = (iconStyle || 'duotone').trim().toLowerCase();\n\n    if (!safeName) {\n        return ''; // Invalid selector\n    }\n\n    // Escape special characters in attribute values\n    const escapedName = CSS.escape(safeName);\n    const escapedStyle = CSS.escape(safeStyle);\n\n    // Match both class selector (.ui-icon) and :host selector for shadow DOM\n    return `.ui-icon[icon=\"${escapedName}\"][icon-style=\"${escapedStyle}\"], :host(.ui-icon[icon=\"${escapedName}\"][icon-style=\"${escapedStyle}\"])`;\n};\n\n/**\n * Flushes pending CSS rules in a single batch\n */\nconst flushPendingRules = () => {\n    flushScheduled = false;\n    if (pendingRules.length === 0) return;\n\n    const sheet = ensureStyleSheet();\n    if (!sheet) {\n        // Retry later if document not ready\n        pendingRules = [];\n        return;\n    }\n\n    const rulesToInsert = pendingRules.slice();\n    pendingRules = [];\n\n    for (const { selector, cssText, key } of rulesToInsert) {\n        if (registeredRules.has(key)) continue;\n\n        try {\n            const ruleText = `${selector} { ${cssText} }`;\n            sheet.insertRule(ruleText, sheet.cssRules.length);\n            registeredRules.add(key);\n\n            // Store the rule data for persistence\n            registeredRuleData.set(key, { selector, cssText });\n\n            // Save registry state after successful rule insertion\n            saveRegistryState();\n        } catch (e) {\n            if (typeof console !== \"undefined\") {\n                console.warn?.(\"[icon-registry] Failed to insert rule:\", e);\n            }\n        }\n    }\n};\n\n/**\n * Schedules a batch flush of pending rules\n */\nconst scheduleFlush = () => {\n    if (flushScheduled) return;\n    flushScheduled = true;\n    queueMicrotask(flushPendingRules);\n};\n\n/**\n * Registers an icon rule in the stylesheet\n * Rules are batched and deduplicated automatically\n */\nexport const registerIconRule = (\n    iconName: string,\n    iconStyle: string,\n    imageUrl: string,\n    bucket: number = MIN_RASTER_SIZE,\n): void => {\n    const key = makeRuleKey(iconName, iconStyle, bucket);\n\n    // Skip if already registered\n    if (registeredRules.has(key)) return;\n\n    // Skip if already pending\n    if (pendingRules.some(r => r.key === key)) return;\n\n    const selector = makeSelector(iconName, iconStyle);\n    const imageSetValue = createImageSetCSS(imageUrl, bucket);\n\n    // Queue the rule for batch insertion\n    pendingRules.push({\n        selector,\n        cssText: `--icon-image: ${imageSetValue};`,\n        key,\n    });\n\n    scheduleFlush();\n};\n\n/**\n * Registers multiple bucket sizes for an icon\n * Useful for responsive icons that need different resolutions\n */\nexport const registerIconRuleWithBuckets = (\n    iconName: string,\n    iconStyle: string,\n    imageUrl: string,\n    buckets: number[] = [32, 64, 128, 256],\n): void => {\n    for (const bucket of buckets) {\n        registerIconRule(iconName, iconStyle, imageUrl, bucket);\n    }\n};\n\n/**\n * Checks if an icon rule is already registered\n */\nexport const hasIconRule = (\n    iconName: string,\n    iconStyle: string,\n    bucket: number = MIN_RASTER_SIZE,\n): boolean => {\n    const key = makeRuleKey(iconName, iconStyle, bucket);\n    return registeredRules.has(key) || pendingRules.some(r => r.key === key);\n};\n\n/**\n * Generates a container query based rule for bucket sizing\n * This allows icons to automatically use the right resolution based on their size\n */\nexport const registerResponsiveIconRule = (\n    iconName: string,\n    iconStyle: string,\n    baseUrl: string,\n    bucketUrls: Map<number, string>,\n): void => {\n    const selector = makeSelector(iconName, iconStyle);\n\n    // Register base rule\n    registerIconRule(iconName, iconStyle, baseUrl, MIN_RASTER_SIZE);\n\n    // Add container-query based rules for different sizes\n    // Note: This requires the icon container to have container-type set\n    for (const [bucket, url] of bucketUrls) {\n        const key = `${makeRuleKey(iconName, iconStyle, bucket)}-cq`;\n        if (registeredRules.has(key)) continue;\n\n        const sheet = ensureStyleSheet();\n        if (!sheet) continue;\n\n        try {\n            // Use @container query for responsive sizing (logical property)\n            const cqRule = `\n                @container (min-inline-size: ${bucket}px) {\n                    ${selector} {\n                        --icon-image: ${createImageSetCSS(url, bucket)};\n                    }\n                }\n            `;\n            sheet.insertRule(cqRule, sheet.cssRules.length);\n            registeredRules.add(key);\n        } catch {\n            // Container queries might not be supported\n        }\n    }\n};\n\n/**\n * Clears all registered icon rules\n * Useful for hot reload or cache invalidation\n */\nexport const clearIconRules = (): void => {\n    registeredRules.clear();\n    pendingRules = [];\n\n    if (styleElement?.sheet) {\n        // Remove all rules\n        const sheet = styleElement.sheet;\n        while (sheet.cssRules.length > 0) {\n            sheet.deleteRule(0);\n        }\n    }\n};\n\n/**\n * Gets statistics about registered rules\n */\nexport const getRegistryStats = (): {\n    ruleCount: number;\n    pendingCount: number;\n    hasStyleSheet: boolean;\n} => {\n    return {\n        ruleCount: registeredRules.size,\n        pendingCount: pendingRules.length,\n        hasStyleSheet: iconStyleSheet !== null,\n    };\n};\n\n/**\n * Pre-registers common icon styles to reduce layout shifts\n * Call this early in app initialization if you know which icons will be used\n */\nexport const preregisterIcons = (\n    icons: Array<{ name: string; style: string; url: string }>,\n): void => {\n    for (const { name, style, url } of icons) {\n        registerIconRule(name, style, url);\n    }\n};\n\n/**\n * Pre-initializes registry on module load (non-blocking)\n */\nif (typeof document !== \"undefined\" && typeof window !== \"undefined\") {\n    // Load persisted state immediately (doesn't require DOM)\n    loadRegistryState();\n\n    // Initialize stylesheet on next tick to ensure DOM is ready\n    queueMicrotask(() => {\n        ensureStyleSheet();\n\n        // Listen for page visibility changes to reinitialize if needed\n        document.addEventListener('visibilitychange', () => {\n            if (!document.hidden && !iconStyleSheet) {\n                // Page became visible and we don't have a stylesheet - reinitialize\n                reinitializeRegistry();\n            }\n        });\n\n        // Also reinitialize on focus to handle tab switching\n        window.addEventListener('focus', () => {\n            if (!iconStyleSheet) {\n                reinitializeRegistry();\n            }\n        });\n    });\n}\n","import {\n    isOPFSSupported,\n    getCachedVectorIcon,\n    cacheVectorIcon,\n    getCachedRasterIcon,\n    cacheRasterIcon,\n} from \"./OPFSCache\";\n\nimport {\n    registerIconRule,\n    hasIconRule,\n} from \"./CSSIconRegistry\";\n\n//\n//import * as icons from \"lucide\";\nexport const iconMap = new Map<string, Promise<string>>();\n\n// Minimal caches - only for in-flight operations, not long-term storage\n// CSS stylesheet handles the actual caching via attribute selectors\nexport const resolvedUrlCache = new Map<string, string>();\nexport const imageElementCache = new Map<string, Promise<HTMLImageElement>>();\n\n// Re-export registry functions for external use\nexport { registerIconRule, hasIconRule } from \"./CSSIconRegistry\";\n\nexport const MAX_RASTER_SIZE = 512;\nexport const MIN_RASTER_SIZE = 32;\n\n// Timeout and retry queue configuration\n// Increased timeout for mobile/slow networks\nconst FETCH_TIMEOUT_MS = 5000;\nconst RETRY_DELAY_MS = 1000; // Progressive delay\nconst MAX_RETRIES = 5; // More retries for unreliable networks\n\n// Network detection utilities\nconst isOnline = (): boolean => {\n    try {\n        return navigator.onLine !== false;\n    } catch {\n        return true; // Assume online if can't detect\n    }\n};\n\nconst isSlowConnection = (): boolean => {\n    try {\n        const connection = (navigator as any).connection ||\n                          (navigator as any).mozConnection ||\n                          (navigator as any).webkitConnection;\n        if (!connection) return false;\n\n        // Check for slow connection types\n        const slowTypes = ['slow-2g', '2g', '3g'];\n        return slowTypes.includes(connection.effectiveType) ||\n               connection.saveData === true ||\n               connection.downlink < 1.5; // Less than 1.5 Mbps\n    } catch {\n        return false;\n    }\n};\n\n// Delayed retry queue\ntype QueuedItem = { name: string; creator?: (name: any) => any; resolve: (v: string) => void; reject: (e: Error) => void; retries: number };\nconst retryQueue: QueuedItem[] = [];\nlet retryScheduled = false;\n\nconst scheduleRetryQueue = () => {\n    if (retryScheduled || retryQueue.length === 0) { return; }\n    retryScheduled = true;\n    setTimeout(processRetryQueue, RETRY_DELAY_MS);\n};\n\nconst processRetryQueue = () => {\n    retryScheduled = false;\n\n    // Skip retries if offline\n    if (!isOnline()) {\n        if (typeof console !== \"undefined\") {\n            console.log?.(\"[icon-loader] Skipping retries - device is offline\");\n        }\n        // Clear queue to prevent accumulation\n        retryQueue.length = 0;\n        return;\n    }\n\n    const batch = retryQueue.splice(0, Math.min(2, retryQueue.length)); // Even smaller batches\n    for (const item of batch) {\n        // Add progressive delay for retries\n        const delay = RETRY_DELAY_MS * Math.pow(1.5, item.retries - 1);\n        setTimeout(() => {\n            loadAsImageInternal(item.name, item.creator, item.retries)\n                .then(item.resolve)\n                .catch((error) => {\n                    // Enhanced error logging for debugging\n                    if (typeof console !== \"undefined\") {\n                        console.warn?.(`[icon-loader] Retry ${item.retries}/${MAX_RETRIES} failed for ${item.name}:`, error?.message || error);\n                    }\n                    item.reject(error);\n                });\n        }, delay);\n    }\n\n    // Schedule next batch with longer delay if we have more items\n    if (retryQueue.length > 0) {\n        const nextDelay = isSlowConnection() ? RETRY_DELAY_MS * 2 : RETRY_DELAY_MS;\n        setTimeout(processRetryQueue, nextDelay);\n    }\n};\n\nconst withTimeout = <T>(promise: Promise<T>, ms: number): Promise<T> => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<never>((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), ms);\n    });\n    return Promise.race([promise, timeoutPromise]).finally(() => clearTimeout(timeoutId));\n};\n\nexport type DevicePixelSize = { inline: number; block: number };\n\nconst globalScope = typeof globalThis !== \"undefined\" ? (globalThis as { location?: Location }) : {};\nconst hasChromeRuntime = (): boolean => {\n    try {\n        const chromeRuntime = (globalThis as any)?.chrome?.runtime;\n        return !!chromeRuntime?.id;\n    } catch {\n        return false;\n    }\n};\n\nconst pickBaseUrl = (): string | undefined => {\n    try {\n        if (typeof document !== \"undefined\" && typeof document.baseURI === \"string\" && document.baseURI !== \"about:blank\") {\n            return document.baseURI;\n        }\n    } catch {\n        /* noop */\n    }\n\n    try {\n        const { location } = globalScope;\n        if (location?.href && location.href !== \"about:blank\") {\n            return location.href;\n        }\n        if (location?.origin) {\n            return location.origin;\n        }\n    } catch {\n        /* noop */\n    }\n    return undefined;\n};\n\nconst DEFAULT_BASE_URL = pickBaseUrl();\n\nexport const fallbackMaskValue = (url: string) => (!url ? \"none\" : `url(\"${url}\")`);\n\nexport const resolveAssetUrl = (input: string): string => {\n    if (!input || typeof input !== \"string\") { return \"\"; }\n    const cached = resolvedUrlCache.get(input);\n    if (cached) { return cached; }\n\n    let resolved = input;\n    if (typeof URL === \"function\") {\n        try {\n            resolved = DEFAULT_BASE_URL ? new URL(input, DEFAULT_BASE_URL).href : new URL(input).href;\n        } catch {\n            try {\n                resolved = new URL(input, globalScope.location?.origin ?? undefined).href;\n            } catch {\n                resolved = input;\n            }\n        }\n    }\n\n    resolvedUrlCache.set(input, resolved);\n    if (!resolvedUrlCache.has(resolved)) {\n        resolvedUrlCache.set(resolved, resolved);\n    }\n    return resolved;\n};\n\n// In-flight promise tracking to prevent duplicate loads\nconst inflightPromises = new Map<string, Promise<string>>();\n\nconst isSafeCssMaskUrl = (url: string): boolean => {\n    if (!url || typeof url !== \"string\") return false;\n    const trimmed = url.trim();\n    if (!trimmed) return false;\n    if (trimmed.startsWith(\"data:\") || trimmed.startsWith(\"blob:\")) return true;\n\n    // Allow relative and root-relative paths (same-origin).\n    if (trimmed.startsWith(\"/\") || trimmed.startsWith(\"./\") || trimmed.startsWith(\"../\")) return true;\n\n    // For absolute URLs, only allow same-origin to avoid CSS cross-origin fetch + credentials issues.\n    if (typeof URL === \"function\") {\n        try {\n            const base = globalScope.location?.origin ?? DEFAULT_BASE_URL;\n            const parsed = new URL(trimmed, base);\n            const origin = globalScope.location?.origin;\n            if (origin && parsed.origin === origin) return true;\n        } catch {\n            return false;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Generates cache key for icon lookup\n */\nconst makeCacheKey = (cacheKey: string | undefined, normalizedUrl: string, bucket: number): string => {\n    const sanitizedKey = (cacheKey ?? \"\").trim();\n    return sanitizedKey ? `${sanitizedKey}@${bucket}` : `${normalizedUrl}@${bucket}`;\n};\n\nexport const quantizeToBucket = (value: number): number => {\n    if (!Number.isFinite(value) || value <= 0) { value = MIN_RASTER_SIZE; }\n    const safe = Math.max(value, MIN_RASTER_SIZE);\n    const bucket = 2 ** Math.ceil(Math.log2(safe));\n    return Math.min(MAX_RASTER_SIZE, bucket);\n};\n\nexport const loadImageElement = (url: string): Promise<HTMLImageElement> => {\n    const resolvedUrl = resolveAssetUrl(url);\n    if (!resolvedUrl) { return Promise.reject(new Error(\"Invalid icon URL\")); }\n    if (!imageElementCache.has(resolvedUrl)) {\n        const promise = (async (): Promise<HTMLImageElement> => {\n            // Try OPFS cache first for blob URL\n            let effectiveUrl = resolvedUrl;\n            if (isOPFSSupported()) {\n                try {\n                    const cachedUrl = await getCachedVectorIcon(resolvedUrl);\n                    if (cachedUrl) {\n                        effectiveUrl = cachedUrl;\n                    }\n                } catch {\n                    /* cache miss */\n                }\n            }\n\n            return new Promise<HTMLImageElement>((resolve, reject) => {\n                const img = new Image();\n                let settled = false;\n\n                // Timeout for image loading to prevent stuck preloading\n                const timeoutId = setTimeout(() => {\n                    if (!settled) {\n                        settled = true;\n                        img.onload = img.onerror = null;\n                        reject(new Error(`Timeout loading icon: ${url}`));\n                    }\n                }, FETCH_TIMEOUT_MS);\n\n                // Configure image properties\n                try { img.decoding = \"async\"; } catch (_) { /* noop */ }\n                try { img.crossOrigin = \"anonymous\"; } catch (_) { /* noop */ }\n\n                // Prevent image from being displayed if it accidentally gets added to DOM\n                img.style.display = 'none';\n                img.style.position = 'absolute';\n                img.style.visibility = 'hidden';\n\n                img.onload = () => {\n                    if (settled) { return; }\n                    settled = true;\n                    clearTimeout(timeoutId);\n\n                    // Validate loaded image\n                    if (img.naturalWidth === 0 || img.naturalHeight === 0) {\n                        reject(new Error(`Invalid image dimensions for: ${url}`));\n                        return;\n                    }\n\n                    resolve(img);\n                };\n\n                img.onerror = (_event) => {\n                    if (settled) { return; }\n                    settled = true;\n                    clearTimeout(timeoutId);\n\n                    // If cached URL failed, try original URL\n                    if (effectiveUrl !== resolvedUrl) {\n                        const retryImg = new Image();\n                        try { retryImg.decoding = \"async\"; } catch (_) { /* noop */ }\n                        try { retryImg.crossOrigin = \"anonymous\"; } catch (_) { /* noop */ }\n                        retryImg.style.display = retryImg.style.position = retryImg.style.visibility = 'none';\n\n                        retryImg.onload = () => {\n                            if (retryImg.naturalWidth === 0 || retryImg.naturalHeight === 0) {\n                                reject(new Error(`Invalid retry image dimensions for: ${url}`));\n                                return;\n                            }\n                            resolve(retryImg);\n                        };\n                        retryImg.onerror = () => reject(new Error(`Failed to load icon: ${url}`));\n                        retryImg.src = resolvedUrl;\n                        return;\n                    }\n                    reject(new Error(`Failed to load icon: ${url}`));\n                };\n\n                img.src = effectiveUrl;\n            });\n        })().then(async (img) => {\n            if (typeof img.decode === \"function\") {\n                try { await img.decode(); } catch (_) { /* ignore decode errors */ }\n            }\n\n            // Cache SVG to OPFS if loaded from network\n            if (isOPFSSupported() && img.src === resolvedUrl) {\n                // Fetch and cache in background\n                fetch(resolvedUrl)\n                    .then(r => r.blob())\n                    .then(blob => cacheVectorIcon(resolvedUrl, blob))\n                    .catch(() => { /* silent */ });\n            }\n\n            return img;\n        }).catch((error) => {\n            // Remove from cache on failure to allow retry\n            imageElementCache.delete(resolvedUrl);\n            throw error;\n        });\n        imageElementCache.set(resolvedUrl, promise);\n    }\n    return imageElementCache.get(resolvedUrl)!;\n};\n\nexport const createCanvas = (size: number): OffscreenCanvas | HTMLCanvasElement => {\n    const dimension = Math.max(size, MIN_RASTER_SIZE);\n    if (typeof OffscreenCanvas !== \"undefined\") {\n        return new OffscreenCanvas(dimension, dimension);\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = dimension;\n    canvas.height = dimension;\n    return canvas;\n};\n\nexport const canvasToImageUrl = async (canvas: OffscreenCanvas | HTMLCanvasElement): Promise<string> => {\n    if (\"convertToBlob\" in canvas) {\n        const blob = await (canvas as OffscreenCanvas).convertToBlob({ type: \"image/png\" });\n        return URL.createObjectURL(blob);\n    }\n    const htmlCanvas = canvas as HTMLCanvasElement;\n    if (typeof htmlCanvas.toBlob === \"function\") {\n        const blob = await new Promise<Blob>((resolve, reject) => {\n            htmlCanvas.toBlob((blobValue) => {\n                if (blobValue) { resolve(blobValue); }\n                else { reject(new Error(\"Canvas toBlob returned null\")); }\n            }, \"image/png\");\n        });\n        return URL.createObjectURL(blob);\n    }\n    return htmlCanvas.toDataURL(\"image/png\");\n};\n\n/**\n * Converts canvas to blob for OPFS caching\n */\nconst canvasToBlob = async (canvas: OffscreenCanvas | HTMLCanvasElement): Promise<Blob | null> => {\n    try {\n        if (\"convertToBlob\" in canvas) {\n            return await (canvas as OffscreenCanvas).convertToBlob({ type: \"image/png\" });\n        }\n        const htmlCanvas = canvas as HTMLCanvasElement;\n        if (typeof htmlCanvas.toBlob === \"function\") {\n            return await new Promise<Blob | null>((resolve) => {\n                htmlCanvas.toBlob((blob) => resolve(blob), \"image/png\");\n            });\n        }\n    } catch {\n        /* noop */\n    }\n    return null;\n};\n\nexport const rasterizeSvgToMask = async (url: string, bucket: number, cacheKey?: string): Promise<string> => {\n    const size = Math.max(bucket, MIN_RASTER_SIZE);\n    const opfsCacheKey = cacheKey || url;\n\n    // Check OPFS cache first for raster version\n    if (isOPFSSupported()) {\n        try {\n            const cachedRaster = await getCachedRasterIcon(opfsCacheKey, size);\n            if (cachedRaster) {\n                return fallbackMaskValue(cachedRaster);\n            }\n        } catch (error) {\n            console.warn('[ui-icon] OPFS cache read failed:', error);\n        }\n    }\n\n    const img = await loadImageElement(url);\n    const canvas = createCanvas(size);\n    const context = canvas.getContext(\"2d\", {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n    }) as CanvasRenderingContext2D;\n\n    if (!context) {\n        throw new Error(\"Unable to acquire 2d context for rasterization\");\n    }\n\n    // Configure canvas for high-quality rendering\n    context.clearRect(0, 0, size, size);\n    context.imageSmoothingEnabled = true;\n    context.imageSmoothingQuality = 'high';\n    context.globalCompositeOperation = 'source-over';\n\n    const naturalWidth = img.naturalWidth || img.width || size;\n    const naturalHeight = img.naturalHeight || img.height || size;\n\n    // Ensure we have valid dimensions\n    const safeWidth = Math.max(1, naturalWidth);\n    const safeHeight = Math.max(1, naturalHeight);\n\n    // Calculate scale to fit within canvas while maintaining aspect ratio\n    const scale = Math.min(size / safeWidth, size / safeHeight);\n    const drawWidth = Math.max(1, Math.floor(safeWidth * scale));\n    const drawHeight = Math.max(1, Math.floor(safeHeight * scale));\n\n    // Center the image on the canvas\n    const offsetX = Math.floor((size - drawWidth) / 2);\n    const offsetY = Math.floor((size - drawHeight) / 2);\n\n    // Clear canvas with transparent background\n    context.clearRect(0, 0, size, size);\n\n    // Draw the image with proper scaling and error handling\n    try {\n        context.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n    } catch (error) {\n        console.warn('[ui-icon] Failed to draw image on canvas:', error);\n        // Fallback: create a simple colored rectangle as placeholder\n        context.fillStyle = 'rgba(128, 128, 128, 0.5)';\n        context.fillRect(offsetX, offsetY, drawWidth, drawHeight);\n    }\n\n    // Cache raster to OPFS in background with error handling\n    if (isOPFSSupported()) {\n        canvasToBlob(canvas).then((blob) => {\n            if (blob && blob.size > 0) {\n                return cacheRasterIcon(opfsCacheKey, size, blob);\n            }\n        }).catch((error) => {\n            console.warn('[ui-icon] OPFS cache write failed:', error);\n        });\n    }\n\n    const rasterUrl = await canvasToImageUrl(canvas);\n    return fallbackMaskValue(rasterUrl);\n};\n\n/**\n * Ensures a mask value is available for an icon.\n * Uses CSS registry for caching - the result is registered as a CSS rule\n * with attribute selectors, so the browser handles caching.\n */\nexport const ensureMaskValue = (url: string, cacheKey: string | undefined, bucket: number): Promise<string> => {\n    const safeUrl = typeof url === \"string\" ? url : \"\";\n    const normalizedUrl = resolveAssetUrl(safeUrl);\n    const effectiveUrl = normalizedUrl || safeUrl;\n    const key = makeCacheKey(cacheKey, normalizedUrl, bucket);\n\n    if (!effectiveUrl) {\n        return Promise.resolve(fallbackMaskValue(\"\"));\n    }\n\n    // Check if already in-flight\n    const inflight = inflightPromises.get(key);\n    if (inflight) { return inflight; }\n\n    const promise = loadAsImage(effectiveUrl, /*bucket, cacheKey*/)\n        .catch((error) => {\n            if (effectiveUrl && typeof console !== \"undefined\") {\n                console.warn?.(\"[ui-icon] Mask generation failed; refusing to use cross-origin CSS url() fallback\", error);\n            }\n            // IMPORTANT:\n            // Do not fall back to `url(\"https://...\")` for cross-origin CDNs, because CSS fetches use\n            // credentials=include and many CDNs respond with ACAO=\"*\", which is blocked in that mode.\n            return fallbackMaskValue(isSafeCssMaskUrl(effectiveUrl) ? effectiveUrl : \"\");\n        })\n        .finally(() => {\n            inflightPromises.delete(key);\n        });\n\n    inflightPromises.set(key, promise);\n    return promise;\n};\n\nexport const camelToKebab = (camel: string) => {\n    if (typeof camel !== \"string\") { return \"\"; }\n    return camel\n        .replace(/[_\\s]+/g, \"-\")\n        .replace(/([a-z0-9])([A-Z])/g, \"$1-$2\")\n        .replace(/([A-Z])([A-Z][a-z])/g, \"$1-$2\")\n        .toLowerCase();\n};\n\n/**\n * Creates an image-set CSS value for resolution-aware icons.\n * Used by the CSS registry for generating rules.\n */\nexport const createImageSetValue = (url: string, resolutions: Array<{ scale: number; size: number }> = []): string => {\n    if (!url) { return \"linear-gradient(#0000, #0000)\"; }\n\n    const baseSet = [`url(\"${url}\") 1x`];\n\n    for (const { scale } of resolutions) {\n        if (scale > 1) {\n            baseSet.push(`url(\"${url}\") ${scale}x`);\n        }\n    }\n\n    return `image-set(${baseSet.join(\", \")})`;\n};\n\n/**\n * Registers an icon in the CSS registry.\n * This generates a CSS rule with attribute selectors and image-set.\n *\n * @param iconName - The icon name (e.g., \"house\", \"arrow-right\")\n * @param iconStyle - The icon style (e.g., \"duotone\", \"fill\")\n * @param url - The resolved icon URL\n * @param bucket - The size bucket for the icon\n */\nexport const generateIconImageVariable = (\n    iconName: string,\n    url: string,\n    bucket: number\n): void => {\n    // Parse iconName to extract the style if it's in \"style:name\" format\n    const parts = iconName.split(\":\");\n    const [iconStyle, name] = parts.length === 2 ? parts : [\"duotone\", iconName];\n\n    // Register in the CSS stylesheet via registry\n    registerIconRule(name, iconStyle, url, bucket);\n};\n\nexport const isPathURL = (url: unknown): url is string => {\n    if (typeof url !== \"string\" || !url) { return false; }\n    if (typeof URL === \"undefined\") {\n        return /^([a-z]+:)?\\/\\//i.test(url) || url.startsWith(\"/\") || url.startsWith(\"./\") || url.startsWith(\"../\");\n    }\n\n    if (typeof URL.canParse === \"function\") {\n        try {\n            if (URL.canParse(url, DEFAULT_BASE_URL)) { return true; }\n            if (globalScope.location?.origin && URL.canParse(url, globalScope.location.origin)) { return true; }\n        } catch {\n            /* noop */\n        }\n    }\n\n    try {\n        new URL(url, DEFAULT_BASE_URL ?? globalScope.location?.origin ?? undefined);\n        return true;\n    } catch {\n        return false;\n    }\n};\nexport const rasterizeSVG = (blob: Blob | string)=>{ return isPathURL(blob) ? resolveAssetUrl(blob) : URL.createObjectURL(blob); }\n\n/**\n * Fetches SVG content with a hard timeout and abort support.\n * This prevents fetch storms from piling up and timing out later.\n */\nconst fetchSvgBlob = async (url: string, timeoutMs: number): Promise<Blob> => {\n    const controller = typeof AbortController !== \"undefined\" ? new AbortController() : null;\n    const timeoutId = controller ? setTimeout(() => controller.abort(), timeoutMs) : null;\n\n    try {\n        const response = await fetch(url, {\n            credentials: \"omit\",\n            mode: \"cors\",\n            signal: controller?.signal,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status} ${response.statusText}`);\n        }\n\n        const blob = await response.blob();\n        if (!blob || blob.size === 0) {\n            throw new Error(\"Empty SVG response\");\n        }\n        return blob;\n    } catch (e) {\n        if (e instanceof DOMException && e.name === \"AbortError\") {\n            throw new Error(\"Timeout\");\n        }\n        throw e;\n    } finally {\n        if (timeoutId) { clearTimeout(timeoutId); }\n    }\n};\n\nconst tryLoadFromVectorCache = async (canonicalUrl: string): Promise<string | null> => {\n    if (!canonicalUrl) return null;\n    if (!isOPFSSupported()) return null;\n    try {\n        const cached = await getCachedVectorIcon(canonicalUrl);\n        if (!cached) return null;\n\n        const blob = await fetchSvgBlob(cached, FETCH_TIMEOUT_MS);\n        const svgText = await blob.text();\n        if (!svgText || svgText.trim().length === 0) return null;\n        return toSvgDataUrl(svgText);\n    } catch {\n        return null;\n    }\n};\n\n/**\n * Fallback icon SVG (used when all icon sources fail).\n *\n * Note: This is used as a CSS mask, so we prefer solid filled shapes and avoid\n * odd self-intersections that can look like artifacts at small sizes.\n */\nconst FALLBACK_SVG_TEXT = `<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M6 2a4 4 0 0 0-4 4v12a4 4 0 0 0 4 4h12a4 4 0 0 0 4-4V6a4 4 0 0 0-4-4H6zm0 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z\" clip-rule=\"evenodd\"/>\n  <path fill=\"currentColor\" d=\"M11 7h2v7h-2z\"/>\n  <path fill=\"currentColor\" d=\"M11 16h2v2h-2z\"/>\n</svg>`;\n\n/**\n * Validates and converts SVG text to data URL\n */\nconst toSvgDataUrl = (svgText: string): string => {\n    if (!svgText || typeof svgText !== 'string') {\n        throw new Error('Invalid SVG text: empty or not a string');\n    }\n\n    // Basic validation - check for SVG tag\n    const trimmed = svgText.trim();\n    if (!trimmed.includes('<svg') || !trimmed.includes('</svg>')) {\n        throw new Error('Invalid SVG: missing svg tags');\n    }\n\n    // Check for reasonable size (not empty, not too large)\n    if (trimmed.length < 50) {\n        throw new Error('Invalid SVG: content too small');\n    }\n\n    if (trimmed.length > 1024 * 1024) { // 1MB limit\n        throw new Error('Invalid SVG: content too large');\n    }\n\n    // Basic XML structure check\n    const openTags = trimmed.match(/<[^/?][^>]*>/g) || [];\n    const closeTags = trimmed.match(/<\\/[^>]+>/g) || [];\n    const selfClosingTags = trimmed.match(/<[^>]+\\/>/g) || [];\n\n    // Rough check that we have balanced tags\n    if (openTags.length + selfClosingTags.length < closeTags.length) {\n        throw new Error('Invalid SVG: unbalanced tags');\n    }\n\n    // Ensure proper UTF-8 encoding for SVG data URLs\n    try {\n        // Use TextEncoder for proper UTF-8 handling\n        const encoder = new TextEncoder();\n        const utf8Bytes = encoder.encode(svgText);\n        const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');\n        return `data:image/svg+xml;base64,${btoa(binaryString)}`;\n    } catch {\n        // Fallback to the original method if TextEncoder fails\n        try {\n            return `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svgText)))}`;\n        } catch {\n            // Final fallback: return SVG as-is without base64 encoding\n            return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgText)}`;\n        }\n    }\n};\n\nconst FALLBACK_SVG_DATA_URL = (() => {\n    try {\n        return toSvgDataUrl(FALLBACK_SVG_TEXT);\n    } catch {\n        return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(FALLBACK_SVG_TEXT)}`;\n    }\n})();\n\nexport const FALLBACK_ICON_DATA_URL = FALLBACK_SVG_DATA_URL;\n\nconst rewritePhosphorUrl = (url: string): string => {\n    // Legacy (broken) format used previously:\n    // - https://cdn.jsdelivr.net/gh/phosphor-icons/phosphor-icons/src/{style}/{name}.svg\n    //\n    // Correct/stable format (npm package assets):\n    // - https://cdn.jsdelivr.net/npm/@phosphor-icons/core@2/assets/{style}/{name}.svg\n    //\n    // Keep this rewrite conservative: only rewrite known phosphor patterns.\n    if (!url || typeof url !== 'string') return url;\n\n    try {\n        const isHttpOrigin = (() => {\n            const proto = (globalScope.location as any)?.protocol || \"\";\n            return proto === \"http:\" || proto === \"https:\";\n        })();\n        const isExtensionRuntime = hasChromeRuntime();\n\n        const toNpmAssetUrl = (style: string, baseName: string) => {\n            // For duotone icons, append '-duotone' to the filename\n            // For other styles like 'fill', 'bold', etc., append '-{style}'\n            const iconFileName = style === \"duotone\"\n                ? `${baseName}-duotone`\n                : style !== \"regular\"\n                    ? `${baseName}-${style}`\n                    : baseName;\n            return `https://cdn.jsdelivr.net/npm/@phosphor-icons/core@2/assets/${style}/${iconFileName}.svg`;\n        };\n\n        const urlObj = new URL(url);\n\n        // In extension runtimes (including content scripts on http(s) pages),\n        // `/assets/icons/phosphor/...` is not guaranteed to exist. Rewrite to CDN.\n        if ((isExtensionRuntime || !isHttpOrigin) && urlObj.pathname.startsWith(\"/assets/icons/phosphor/\")) {\n            const parts = urlObj.pathname.split(\"/\").filter(Boolean); // [\"assets\",\"icons\",\"phosphor\",style,name.svg]\n            const style = parts[3] || \"duotone\";\n            const fileName = parts[4] || \"\";\n            const baseName = fileName.replace(/\\.svg$/i, \"\");\n            const validStyles = [\"thin\", \"light\", \"regular\", \"bold\", \"fill\", \"duotone\"];\n            if (validStyles.includes(style) && baseName && /^[a-z0-9-]+$/.test(baseName)) {\n                return toNpmAssetUrl(style, baseName);\n            }\n            return url;\n        }\n\n        // Only rewrite GitHub phosphor URLs\n        if (urlObj.hostname === 'cdn.jsdelivr.net' &&\n            urlObj.pathname.startsWith('/gh/phosphor-icons/phosphor-icons/')) {\n\n            const pathParts = urlObj.pathname.split('/').filter(Boolean);\n            const srcIndex = pathParts.indexOf('src');\n\n            if (srcIndex >= 0 && pathParts.length >= srcIndex + 3) {\n                const style = pathParts[srcIndex + 1];\n                const fileName = pathParts[srcIndex + 2];\n\n                if (style && fileName && fileName.endsWith('.svg')) {\n                    let iconName = fileName.replace(/\\.svg$/i, '');\n\n                    // Remove style suffix from icon name if present (e.g., \"folder-open-duotone\" -> \"folder-open\")\n                    if (style === 'duotone' && iconName.endsWith('-duotone')) {\n                        iconName = iconName.replace(/-duotone$/, '');\n                    } else if (style !== 'regular' && iconName.endsWith(`-${style}`)) {\n                        iconName = iconName.replace(new RegExp(`-${style}$`), '');\n                    }\n\n                    // Validate style and icon name\n                    const validStyles = ['thin', 'light', 'regular', 'bold', 'fill', 'duotone'];\n                    if (validStyles.includes(style) && iconName && /^[a-z0-9-]+$/.test(iconName)) {\n                        // Prefer proxy only on non-extension http(s) origins where /api exists.\n                        return (isHttpOrigin && !isExtensionRuntime)\n                            ? `/assets/icons/phosphor/${style}/${iconName}.svg`\n                            : toNpmAssetUrl(style, iconName);\n                    }\n                }\n            }\n        }\n\n        // Also handle direct npm package URLs that might be used\n        if (urlObj.hostname === 'cdn.jsdelivr.net' &&\n            urlObj.pathname.startsWith('/npm/@phosphor-icons/')) {\n            // Extract style and icon name from npm URL\n            const pathParts = urlObj.pathname.split('/').filter(Boolean);\n            const assetsIndex = pathParts.indexOf('assets');\n\n            if (assetsIndex >= 0 && pathParts.length >= assetsIndex + 3) {\n                const style = pathParts[assetsIndex + 1];\n                const fileName = pathParts[assetsIndex + 2];\n\n                if (style && fileName && fileName.endsWith('.svg')) {\n                    let iconName = fileName.replace(/\\.svg$/i, '');\n\n                    // Remove style suffix from icon name if present (e.g., \"folder-open-duotone\" -> \"folder-open\")\n                    if (style === 'duotone' && iconName.endsWith('-duotone')) {\n                        iconName = iconName.replace(/-duotone$/, '');\n                    } else if (style !== 'regular' && iconName.endsWith(`-${style}`)) {\n                        iconName = iconName.replace(new RegExp(`-${style}$`), '');\n                    }\n\n                    // Validate style and icon name\n                    const validStyles = ['thin', 'light', 'regular', 'bold', 'fill', 'duotone'];\n                    if (validStyles.includes(style) && iconName && /^[a-z0-9-]+$/.test(iconName)) {\n                        // Prefer proxy only on non-extension http(s) origins where /api exists.\n                        return (isHttpOrigin && !isExtensionRuntime)\n                            ? `/assets/icons/phosphor/${style}/${iconName}.svg`\n                            : toNpmAssetUrl(style, iconName);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        // Invalid URL, return as-is\n        console.warn('[ui-icon] Invalid URL for phosphor rewrite:', url, error);\n    }\n\n    return url;\n};\n\nconst isClientErrorStatus = (error: unknown): boolean => {\n    if (!(error instanceof Error)) { return false; }\n\n    // Don't retry 4xx client errors (except 408 Request Timeout which might be network related)\n    if (/\\bHTTP\\s*4\\d\\d\\b/.test(error.message) || /\\b4\\d\\d\\b/.test(error.message)) {\n        return !/408/.test(error.message); // Allow retry for 408\n    }\n\n    // Retry on network-related errors that might be temporary\n    return /network|timeout|offline|connection|aborted/i.test(error.message) ||\n           error.name === 'TypeError' && /fetch/i.test(error.message);\n};\n\n// Internal loader with retry support\n// Internal loader with retry support\n\nconst loadAsImageInternal = async (name: any, creator?: (name: any) => any, attempt = 0): Promise<string> => {\n    if (isPathURL(name)) {\n        const resolvedUrl = resolveAssetUrl(name);\n\n        // Skip if this is already a data URL (from cache or previous processing)\n        if (resolvedUrl.startsWith(\"data:\")) {\n            console.log(`[ui-icon] Already a data URL, returning as-is`);\n            return resolvedUrl;\n        }\n\n        const effectiveUrl = rewritePhosphorUrl(resolvedUrl);\n        if (effectiveUrl !== resolvedUrl) {\n            console.log(`[ui-icon] Rewrote phosphor URL: ${resolvedUrl} -> ${effectiveUrl}`);\n        }\n\n        try {\n            // Try OPFS cache first (fast, local, avoids network storms).\n            if (isOPFSSupported()) {\n                try {\n                    const cached = await withTimeout(getCachedVectorIcon(effectiveUrl), 50);\n                    if (cached) {\n                        const blob = await fetchSvgBlob(cached, FETCH_TIMEOUT_MS);\n                        const svgText = await blob.text();\n                        return toSvgDataUrl(svgText);\n                    }\n                } catch {\n                    /* cache miss or timeout */\n                }\n            }\n\n            // Build a small, correct fallback list (sequential attempts).\n            const candidates: string[] = [effectiveUrl];\n\n            // jsDelivr -> unpkg (correct path mapping for phosphor assets)\n            if (effectiveUrl.startsWith(\"https://cdn.jsdelivr.net/npm/\")) {\n                const unpkg = effectiveUrl.replace(\"https://cdn.jsdelivr.net/npm/\", \"https://unpkg.com/\");\n                candidates.push(unpkg);\n            }\n\n            // Only attempt a second mirror if its an https URL and not already included.\n            if (effectiveUrl.startsWith(\"https://\") && effectiveUrl.includes(\"cdn.jsdelivr.net\")) {\n                const mirror = effectiveUrl.replace(\"cdn.jsdelivr.net\", \"unpkg.com\").replace(\"/npm/\", \"/\");\n                if (!candidates.includes(mirror)) {\n                    candidates.push(mirror);\n                }\n            }\n\n            const errors: Error[] = [];\n            for (const url of candidates) {\n                try {\n                    const blob = await fetchSvgBlob(url, FETCH_TIMEOUT_MS);\n                    if (blob.size > 1024 * 1024) {\n                        throw new Error(`Blob too large (${blob.size} bytes)`);\n                    }\n                    const svgText = await blob.text();\n                    const dataUrl = toSvgDataUrl(svgText);\n\n                    // Cache vector SVG for the canonical URL in background (best-effort),\n                    // even if we succeeded via a mirror.\n                    if (isOPFSSupported()) {\n                        cacheVectorIcon(effectiveUrl, blob).catch(() => { /* silent */ });\n                    }\n\n                    return dataUrl;\n                } catch (e) {\n                    const err = e instanceof Error ? e : new Error(String(e));\n                    errors.push(new Error(`${url}: ${err.message}`));\n                }\n            }\n\n            throw new Error(`All icon sources failed: ${errors.map(e => e.message).join(\"; \")}`);\n\n        } catch (error) {\n            console.warn(`[ui-icon] Failed to load icon: ${effectiveUrl}`, error);\n\n            // Don't spam retries on 404/4xx: it's a deterministic failure.\n            if (attempt < MAX_RETRIES && !isClientErrorStatus(error)) {\n                console.log(`[ui-icon] Queueing retry ${attempt + 1} for ${effectiveUrl}`);\n                return new Promise((resolve, reject) => {\n                    retryQueue.push({ name, creator, resolve, reject, retries: attempt + 1 });\n                    scheduleRetryQueue();\n                });\n            }\n\n            // If everything failed (CORS/offline/etc), prefer returning a cached vector icon if present.\n            const cachedDataUrl = await tryLoadFromVectorCache(effectiveUrl);\n            if (cachedDataUrl) {\n                console.warn(`[ui-icon] Using OPFS cached icon after failures: ${effectiveUrl}`);\n                return cachedDataUrl;\n            }\n\n            // Final fallback: return a simple placeholder SVG\n            console.warn(`[ui-icon] All loading methods failed, using fallback SVG for: ${effectiveUrl}`, error);\n            return FALLBACK_SVG_DATA_URL;\n        }\n    }\n\n    const doLoad = async (): Promise<string> => {\n        const element = await (creator ? creator?.(name) : name);\n        if (isPathURL(element)) {\n            // Recurse to get OPFS caching for path URLs\n            return loadAsImageInternal(element, undefined, attempt);\n        }\n        let file: any = name;\n        if (element instanceof Blob || element instanceof File) { file = element; }\n        else {\n            const text = typeof element == \"string\" ? element : element.outerHTML;\n            file = new Blob([`<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>`, text], { type: \"image/svg+xml\" });\n        }\n        return rasterizeSVG(file);\n    };\n\n    try {\n        // First attempt with timeout\n        return await withTimeout(doLoad(), FETCH_TIMEOUT_MS);\n    } catch (error) {\n        // On timeout, queue for retry if not exceeded max retries\n        if (attempt < MAX_RETRIES && error instanceof Error && error.message === \"Timeout\") {\n            return new Promise((resolve, reject) => {\n                retryQueue.push({ name, creator, resolve, reject, retries: attempt + 1 });\n                scheduleRetryQueue();\n            });\n        }\n        throw error;\n    }\n};\n\nexport const loadAsImage = async (name: any, creator?: (name: any) => any): Promise<string> => {\n    if (isPathURL(name)) { name = resolveAssetUrl(name) || name; }\n    // @ts-ignore // !experimental `getOrInsert` feature!\n    return iconMap.getOrInsertComputed(name, () => loadAsImageInternal(name, creator, 0));\n};\n\n/**\n * Clears in-memory caches for icon loading\n * Useful when switching themes or when cache becomes stale\n */\nexport const clearIconCaches = (): void => {\n    resolvedUrlCache.clear();\n    imageElementCache.clear();\n    iconMap.clear();\n    retryQueue.length = 0; // Clear pending retries\n\n    if (typeof console !== \"undefined\") {\n        console.log?.(\"[icon-loader] Cleared all in-memory caches\");\n    }\n};\n\n/**\n * Forces cache invalidation for a specific icon\n * @param iconName The icon name/URL to invalidate\n */\nexport const invalidateIconCache = (iconName: string): void => {\n    if (!iconName) return;\n\n    // Remove from in-memory caches\n    resolvedUrlCache.delete(iconName);\n    imageElementCache.delete(iconName);\n    iconMap.delete(iconName);\n\n    // Remove from OPFS cache (async, fire-and-forget)\n    if (typeof import('./OPFSCache') !== 'undefined') {\n        import('./OPFSCache').then(({ clearAllCache }) => {\n            // For individual icons, we might want to implement selective clearing\n            // For now, just clear problematic entries\n            clearAllCache().catch(() => { /* silent */ });\n        }).catch(() => { /* silent */ });\n    }\n\n    if (typeof console !== \"undefined\") {\n        console.log?.(`[icon-loader] Invalidated cache for: ${iconName}`);\n    }\n};\n\n/**\n * Tests the racing loading functionality by loading an icon with verbose logging\n * @param iconUrl The icon URL to test\n * @returns Promise that resolves to the loaded data URL\n */\nexport const testIconRacing = async (iconUrl: string): Promise<string> => {\n    console.log(`[icon-test] Testing racing for: ${iconUrl}`);\n\n    // Clear caches to force fresh load\n    clearIconCaches();\n\n    const startTime = performance.now();\n    const result = await loadAsImage(iconUrl);\n    const endTime = performance.now();\n\n    console.log(`[icon-test] Racing test completed in ${(endTime - startTime).toFixed(2)}ms`);\n    console.log(`[icon-test] Result:`, result.substring(0, 100) + '...');\n\n    return result;\n};\n\n/**\n * Debug function to check icon system status\n */\nexport const debugIconSystem = (): void => {\n    console.group('[icon-debug] Icon System Status');\n\n    // Check caches first (always available)\n    console.log('Resolved URL cache size:', resolvedUrlCache.size);\n    console.log('Image element cache size:', imageElementCache.size);\n    console.log('Icon map size:', iconMap.size);\n    console.log('Retry queue length:', retryQueue.length);\n\n    // Check CSS registry and OPFS asynchronously\n    Promise.all([\n        import('./CSSIconRegistry').then(({ getRegistryStats, ensureStyleSheet }) => {\n            const sheet = ensureStyleSheet();\n            const stats = getRegistryStats();\n            console.log('CSS Registry:', stats);\n            console.log('StyleSheet exists:', !!sheet);\n            console.log('Adopted sheets:', document.adoptedStyleSheets?.length || 0);\n            console.log('CSS rules in sheet:', sheet?.cssRules?.length || 0);\n        }).catch(e => console.error('CSS Registry error:', e)),\n\n        import('./OPFSCache').then(({ isOPFSSupported, getCacheStats }) => {\n            console.log('OPFS supported:', isOPFSSupported());\n            return getCacheStats().then(stats => {\n                console.log('OPFS cache stats:', stats);\n            });\n        }).catch(e => console.error('OPFS check error:', e))\n    ]).catch(() => {/* ignore */});\n\n    // Check network status\n    console.log('Network online:', navigator.onLine);\n    console.log('Slow connection:', isSlowConnection());\n\n    console.groupEnd();\n};\n","// should to return from source code to style element (in shadow DOM)\nexport const preloadStyle = (srcCode: string) => {\n    const content = typeof srcCode === \"string\" ? srcCode?.trim?.() : \"\";\n    if (!content) { return () => null as HTMLStyleElement | null; }\n    const styleURL = URL.createObjectURL(new Blob([content], {type: \"text/css\"}));\n\n    //\n    if (typeof document === \"undefined\") { return null; }\n    const styleEl = document.createElement(\"style\");\n    styleEl.setAttribute(\"data-ui-phosphor-icon\", \"true\");\n    styleEl.innerHTML = `@import url(\"${styleURL}\");`;\n\n    //\n    return () => styleEl?.cloneNode?.(true);;\n};\n\n// @ts-ignore  Vite inline import\nimport styles from \"./Phosphor.scss?inline\";\nimport {\n    ensureMaskValue,\n    loadAsImage,\n    FALLBACK_ICON_DATA_URL,\n    MIN_RASTER_SIZE,\n    quantizeToBucket,\n    camelToKebab,\n    generateIconImageVariable,\n    registerIconRule,\n    hasIconRule,\n    type DevicePixelSize,\n} from \"./Loader\";\n\n//\nconst createStyle = preloadStyle(styles);\n\n// Handle non-string or empty inputs gracefully\nconst capitalizeFirstLetter = (str: unknown) => {\n    if (typeof str !== \"string\" || str.length === 0) { return str; }\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n// @ts-ignore\nexport class UIPhosphorIcon extends HTMLElement {\n    static get observedAttributes() {\n        return [\"icon\", \"icon-style\", \"size\", \"width\", \"icon-base\"];\n    }\n\n    #options: { padding?: number | string; icon?: string; iconStyle?: string } = {\n        padding: 0,\n        icon: \"\",\n        iconStyle: \"duotone\",\n    };\n    #resizeObserver?: ResizeObserver;\n    #devicePixelSize: DevicePixelSize = {\n        inline: MIN_RASTER_SIZE,\n        block: MIN_RASTER_SIZE,\n    };\n    #queuedMaskUpdate: Promise<void> | null = null;\n    #currentIconUrl = \"\";\n    #maskKeyBase = \"\";\n    #maskRef = { value: \"\" };\n    #styleAttached = false;\n    #pendingIconName: string | null = null;\n    #intersectionObserver?: IntersectionObserver;\n    #isIntersecting = false;\n\n    constructor(\n        options: Partial<{ icon: string; iconStyle: string; padding: number | string }> = {},\n    ) {\n        super();\n        Object.assign(this.#options, options);\n\n        if (typeof options.icon === \"string\" && options.icon.length > 0) {\n            this.setAttribute(\"icon\", options.icon);\n        }\n\n        if (typeof options.iconStyle === \"string\" && options.iconStyle.length > 0) {\n            this.setAttribute(\"icon-style\", options.iconStyle.toLowerCase());\n        }\n\n        this.#ensureShadowRoot();\n    }\n\n    get icon(): string {\n        return this.getAttribute(\"icon\") ?? \"\";\n    }\n\n    set icon(value: string) {\n        if (value == null || value === \"\") {\n            this.removeAttribute(\"icon\");\n            return;\n        }\n        const normalized = String(value);\n        if (this.getAttribute(\"icon\") !== normalized) {\n            this.setAttribute(\"icon\", normalized);\n        }\n    }\n\n    get iconStyle(): string {\n        return this.getAttribute(\"icon-style\") ?? this.#options.iconStyle ?? \"duotone\";\n    }\n\n    set iconStyle(value: string) {\n        const normalized = (value ?? \"\")?.trim?.()?.toLowerCase?.();\n        if (!normalized) {\n            this.removeAttribute(\"icon-style\");\n            return;\n        }\n        if (this.getAttribute(\"icon-style\") !== normalized) {\n            this.setAttribute(\"icon-style\", normalized);\n        }\n    }\n\n    get size(): string | null {\n        return this.getAttribute(\"size\");\n    }\n\n    set size(value: string | null) {\n        if (value == null || value === \"\") {\n            this.removeAttribute(\"size\");\n            return;\n        }\n        const normalized = String(value);\n        if (this.getAttribute(\"size\") !== normalized) {\n            this.setAttribute(\"size\", normalized);\n        }\n    }\n\n    get width(): string | null {\n        return this.getAttribute(\"width\");\n    }\n\n    set width(value: string | number | null) {\n        if (value == null || value === \"\") {\n            this.removeAttribute(\"width\");\n            return;\n        }\n        const normalized = typeof value === \"number\" ? String(value) : value;\n        if (this.getAttribute(\"width\") !== normalized) {\n            this.setAttribute(\"width\", normalized);\n        }\n    }\n\n    /**\n     * Optional base URL for same-origin icon hosting.\n     * Example: icon-base=\"/assets/phosphor\"\n     * Will be tried before CDNs.\n     */\n    get iconBase(): string {\n        return this.getAttribute(\"icon-base\") ?? \"\";\n    }\n\n    set iconBase(value: string) {\n        const normalized = (value ?? \"\").trim();\n        if (!normalized) {\n            this.removeAttribute(\"icon-base\");\n            return;\n        }\n        if (this.getAttribute(\"icon-base\") !== normalized) {\n            this.setAttribute(\"icon-base\", normalized);\n        }\n    }\n\n    connectedCallback(): void {\n        this.#applyHostDefaults();\n        this.#setupResizeObserver(this);\n        this.#setupVisibilityObserver();\n\n        if (!this.#styleAttached) {\n            const styleNode = createStyle?.() ?? null;\n            if (styleNode) { this.shadowRoot!.appendChild(styleNode); }\n            this.#styleAttached = true;\n        }\n\n        if (!this.hasAttribute(\"icon\") && this.#options.icon) {\n            this.setAttribute(\"icon\", this.#options.icon);\n        }\n        if (!this.hasAttribute(\"icon-style\") && this.#options.iconStyle) {\n            this.setAttribute(\"icon-style\", this.#options.iconStyle);\n        }\n\n        // Force load any pending icon immediately when connected\n        const pendingIcon = this.#pendingIconName ?? this.icon;\n        console.log(`[ui-icon] Element connected, pending icon: ${pendingIcon}, current icon: ${this.icon}`);\n\n        if (pendingIcon) {\n            console.log(`[ui-icon] Loading pending icon: ${pendingIcon}`);\n            this.updateIcon(pendingIcon);\n        } else if (this.icon) {\n            console.log(`[ui-icon] Loading current icon: ${this.icon}`);\n            this.updateIcon(this.icon);\n        } else {\n            console.log(`[ui-icon] No icon to load`);\n        }\n    }\n\n    disconnectedCallback(): void {\n        this.#resizeObserver?.disconnect();\n        this.#resizeObserver = undefined;\n        this.#teardownVisibilityObserver();\n        this.#queuedMaskUpdate = null;\n        this.#retryAttempt = 0;\n    }\n\n    attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n        if (oldValue === newValue) { return; }\n\n        switch (name) {\n            case \"icon\": {\n                if (!this.isConnected) {\n                    this.#pendingIconName = newValue ?? \"\";\n                    return;\n                }\n                this.updateIcon(newValue ?? \"\");\n                break;\n            }\n            case \"icon-style\": {\n                if (newValue) {\n                    const normalized = newValue?.trim?.()?.toLowerCase?.();\n                    if (normalized !== newValue) {\n                        this.setAttribute(\"icon-style\", normalized);\n                        return;\n                    }\n                }\n                this.#maskKeyBase = \"\";\n                if (!this.isConnected) {\n                    this.#pendingIconName = this.icon;\n                    return;\n                }\n                this.updateIcon();\n                break;\n            }\n            case \"size\": {\n                if (newValue) {\n                    this.style.setProperty(\"--icon-size\", (typeof newValue === \"number\" || /^\\d+$/.test(newValue)) ? `${newValue}px` : newValue);\n                } else {\n                    this.style.removeProperty(\"--icon-size\");\n                }\n                if (this.isConnected) {\n                    this.#queueMaskUpdate();\n                }\n                break;\n            }\n            case \"width\": {\n                if (newValue == null || newValue === \"\") {\n                    this.style.removeProperty(\"width\");\n                } else {\n                    const value = (typeof newValue === \"number\" || /^\\d+$/.test(newValue)) ? `${newValue}px` : newValue;\n                    this.style.width = value;\n                }\n                if (this.isConnected) {\n                    this.#queueMaskUpdate();\n                }\n                break;\n            }\n            case \"icon-base\": {\n                // Changing base affects load source; force reload.\n                this.#currentIconUrl = \"\";\n                this.#maskKeyBase = \"\";\n                if (this.isConnected) {\n                    this.updateIcon(this.icon);\n                }\n                break;\n            }\n        }\n    }\n\n    #retryAttempt = 0;\n    static readonly #MAX_ICON_RETRIES = 3;\n    static readonly #RETRY_DELAY_MS = 500;\n\n    public updateIcon(icon?: string) {\n        const candidate = typeof icon === \"string\" && icon.length > 0 ? icon : this.icon;\n        const nextIcon = candidate?.trim?.() ?? \"\";\n\n        if (!this.isConnected) {\n            this.#pendingIconName = nextIcon;\n            return this;\n        }\n\n        if (typeof IntersectionObserver !== \"undefined\" && !this.#isIntersecting) {\n            this.#pendingIconName = nextIcon;\n            return this;\n        }\n\n        this.#pendingIconName = null;\n\n        if (!nextIcon) { return this; }\n\n        let iconStyle = (this.iconStyle ?? \"duotone\")?.trim?.()?.toLowerCase?.();\n        const ICON = camelToKebab(nextIcon);\n        // Use CDN for Phosphor icons (npm package assets; stable paths)\n        // Example:\n        // - https://cdn.jsdelivr.net/npm/@phosphor-icons/core@2/assets/duotone/folder-open-duotone.svg\n        // Validate icon name to prevent invalid requests\n        if (!ICON || !/^[a-z0-9-]+$/.test(ICON)) {\n            console.warn(`[ui-icon] Invalid icon name: ${ICON}`);\n            return this;\n        }\n\n        // Validate icon style\n        const validStyles = ['thin', 'light', 'regular', 'bold', 'fill', 'duotone'];\n        if (!validStyles.includes(iconStyle)) {\n            console.warn(`[ui-icon] Invalid icon style: ${iconStyle}, defaulting to 'duotone'`);\n            iconStyle = 'duotone';\n        }\n\n        // For duotone icons, append '-duotone' to the filename\n        // For other styles like 'fill', 'bold', etc., append '-{style}'\n        const iconFileName = iconStyle === 'duotone' ? `${ICON}-duotone` :\n                            iconStyle !== 'regular' ? `${ICON}-${iconStyle}` :\n                            ICON;\n\n        // Try direct CDN first (most reliable), then proxy (without suffix - proxy adds it), then local\n        const directCdnPath = `https://cdn.jsdelivr.net/npm/@phosphor-icons/core@2/assets/${iconStyle}/${iconFileName}.svg`;\n        const proxyCdnPath = `/assets/icons/phosphor/${iconStyle}/${ICON}.svg`; // Proxy expects base name, adds suffix\n        const base = (this.iconBase ?? \"\").trim().replace(/\\/+$/, \"\");\n        const localPath = base ? `${base}/${iconStyle}/${iconFileName}.svg` : \"\";\n        const requestKey = `${iconStyle}:${ICON}`;\n\n        this.#maskKeyBase = requestKey;\n\n        requestAnimationFrame(() => {\n            // Always attempt to load if we don't have a current icon URL, or if we're intersecting\n            const shouldLoad = !this.#currentIconUrl || this.#isIntersecting ||\n                (this?.checkVisibility?.({\n                    contentVisibilityAuto: true,\n                    opacityProperty: true,\n                    visibilityProperty: true,\n                }) ?? true);\n\n            console.log(`[ui-icon] Checking load conditions for ${requestKey}:`, {\n                hasCurrentUrl: !!this.#currentIconUrl,\n                isIntersecting: this.#isIntersecting,\n                shouldLoad\n            });\n\n            if (shouldLoad) {\n                const sources = (localPath ? [directCdnPath, proxyCdnPath, localPath] : [directCdnPath, proxyCdnPath]);\n                (async () => {\n                    let lastUrl: string | null = null;\n                    let lastError: unknown = null;\n\n                    for (const src of sources) {\n                        try {\n                            const url = await loadAsImage(src);\n                            lastUrl = url;\n\n                            // If local source returns fallback placeholder, try the CDN next.\n                            if (src === localPath && url === FALLBACK_ICON_DATA_URL) {\n                                continue;\n                            }\n                            break;\n                        } catch (e) {\n                            lastError = e;\n                        }\n                    }\n\n                    const url = lastUrl;\n                    console.log(`[ui-icon] Loaded icon ${requestKey} (${localPath ? \"local+proxy+fallback\" : \"proxy+fallback\"}):`, url);\n                    if (!url || typeof url !== \"string\") {\n                        console.warn(`[ui-icon] Invalid URL returned for ${requestKey}:`, url);\n                        return;\n                    }\n                    if (this.#maskKeyBase !== requestKey) {\n                        console.log(`[ui-icon] Ignoring outdated request for ${requestKey}`);\n                        return;\n                    }\n                    this.#currentIconUrl = url;\n                    this.#retryAttempt = 0;\n                    this.#queueMaskUpdate();\n\n                    // If both sources failed and we ended up with fallback, keep the old retry behavior for timeouts.\n                    if (url === FALLBACK_ICON_DATA_URL && lastError instanceof Error) {\n                        const isTimeout = lastError.message.includes(\"Timeout\");\n                        if (isTimeout && this.#retryAttempt < UIPhosphorIcon.#MAX_ICON_RETRIES && this.isConnected) {\n                            this.#retryAttempt++;\n                            setTimeout(() => {\n                                if (this.isConnected && this.#maskKeyBase === requestKey) {\n                                    this.updateIcon(nextIcon);\n                                }\n                            }, UIPhosphorIcon.#RETRY_DELAY_MS * this.#retryAttempt);\n                        }\n                    }\n                })().catch((error) => {\n                    if (typeof console !== \"undefined\") {\n                        console.error?.(\"[ui-icon] Failed to load icon sources\", { directCdnPath, proxyCdnPath, localPath }, error);\n                    }\n                });\n            }\n        });\n\n        return this;\n    }\n\n    #setupVisibilityObserver() {\n        console.log(`[ui-icon] Setting up visibility observer`);\n\n        if (typeof IntersectionObserver === \"undefined\") {\n            console.log(`[ui-icon] IntersectionObserver not available, setting intersecting to true`);\n            this.#isIntersecting = true;\n            return;\n        }\n\n        if (this.#intersectionObserver) {\n            console.log(`[ui-icon] Visibility observer already exists`);\n            return;\n        }\n\n        console.log(`[ui-icon] Creating new IntersectionObserver`);\n        this.#intersectionObserver = new IntersectionObserver((entries) => {\n            const isIntersecting = entries.some((entry) => entry.isIntersecting);\n            console.log(`[ui-icon] IntersectionObserver callback: isIntersecting=${isIntersecting}, was=${this.#isIntersecting}`);\n\n            if (isIntersecting !== this.#isIntersecting) {\n                this.#isIntersecting = isIntersecting;\n                if (isIntersecting) {\n                    console.log(`[ui-icon] Element became visible, updating icon`);\n                    this.updateIcon(this.#pendingIconName ?? this.icon);\n                }\n            }\n        }, { rootMargin: \"100px\" });\n\n        console.log(`[ui-icon] Starting observation`);\n        this.#intersectionObserver.observe(this);\n\n        // Handle content-visibility\n        // @ts-ignore\n        this.addEventListener(\"contentvisibilityautostatechange\", this.#handleContentVisibility);\n\n        // Initially assume intersecting to allow loading\n        console.log(`[ui-icon] Setting initial intersecting state to true`);\n        this.#isIntersecting = true;\n    }\n\n    #teardownVisibilityObserver() {\n        this.#intersectionObserver?.disconnect();\n        this.#intersectionObserver = undefined;\n        // @ts-ignore\n        this.removeEventListener(\"contentvisibilityautostatechange\", this.#handleContentVisibility);\n    }\n\n    #handleContentVisibility = (e: Event) => {\n        // @ts-ignore\n        if (e.skipped === false) {\n            this.updateIcon(this.#pendingIconName ?? this.icon);\n        }\n    }\n\n    #ensureShadowRoot() {\n        if (!this.shadowRoot) {\n            this.attachShadow({ mode: \"open\" });\n        }\n    }\n\n    #applyHostDefaults() {\n        this.classList.add(\"ui-icon\", \"u2-icon\");\n\n        try {\n            (this as unknown as { inert: boolean }).inert = true;\n        } catch {\n            this.setAttribute(\"inert\", \"\");\n        }\n\n        /*if (!this.hasAttribute(\"aria-hidden\")) {\n            this.setAttribute(\"aria-hidden\", \"true\");\n        }*/\n\n        const paddingOption = this.#options.padding;\n        if (\n            !this.style.getPropertyValue(\"--icon-padding\") &&\n            paddingOption !== undefined &&\n            paddingOption !== null &&\n            paddingOption !== \"\"\n        ) {\n            const paddingValue =\n                typeof paddingOption === \"number\" ? `${paddingOption}rem` : String(paddingOption);\n            this.style.setProperty(\"--icon-padding\", paddingValue);\n        }\n\n        const sizeAttr = this.getAttribute(\"size\");\n        if (sizeAttr) {\n            this.style.setProperty(\"--icon-size\", (typeof sizeAttr === \"number\" || /^\\d+$/.test(sizeAttr)) ? `${sizeAttr}px` : sizeAttr);\n        }\n\n        // Note: --icon-image is now set via CSS rules with attribute selectors\n        // e.g., ui-icon[icon=\"house\"][icon-style=\"duotone\"] { --icon-image: image-set(...); }\n        // No inline style needed - the CSS registry handles it lazily\n    }\n\n    #setupResizeObserver(element: HTMLElement) {\n        if (typeof ResizeObserver === \"undefined\" || this.#resizeObserver) { return; }\n        this.#resizeObserver = new ResizeObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.target !== element) { continue; }\n\n                const deviceSize = entry.devicePixelContentBoxSize?.[0];\n                const contentSize = Array.isArray(entry.contentBoxSize)\n                    ? entry.contentBoxSize[0]\n                    : (entry.contentBoxSize as unknown as ResizeObserverSize | undefined);\n\n                const ratio =\n                    typeof devicePixelRatio === \"number\" && isFinite(devicePixelRatio)\n                        ? devicePixelRatio\n                        : 1;\n\n                const inline =\n                    deviceSize?.inlineSize ??\n                    (contentSize?.inlineSize ?? entry.contentRect?.width ?? element.clientWidth ?? MIN_RASTER_SIZE) *\n                        ratio;\n                const block =\n                    deviceSize?.blockSize ??\n                    (contentSize?.blockSize ?? entry.contentRect?.height ?? element.clientHeight ?? MIN_RASTER_SIZE) *\n                        ratio;\n\n                this.#devicePixelSize = {\n                    inline: inline || MIN_RASTER_SIZE,\n                    block: block || MIN_RASTER_SIZE,\n                };\n                this.#queueMaskUpdate();\n            }\n        });\n\n        try {\n            this.#resizeObserver.observe(element, { box: \"device-pixel-content-box\" as const });\n        } catch {\n            this.#resizeObserver.observe(element);\n        }\n    }\n\n    #queueMaskUpdate() {\n        if (!this.#currentIconUrl || !this.isConnected) { return; }\n        if (this.#queuedMaskUpdate) { return; }\n\n        const forResolve = Promise.withResolvers<void>();\n        this.#queuedMaskUpdate = forResolve?.promise;\n        requestAnimationFrame(() => {\n            this.#queuedMaskUpdate = null;\n            forResolve?.resolve();\n            const url = this.#currentIconUrl;\n            if (!url || !this.isConnected) { return; }\n\n            const bucket = this.#getRasterBucket();\n            const iconName = camelToKebab(this.icon);\n            const iconStyle = this.iconStyle;\n\n            // Check if CSS rule already exists for this icon combination\n            if (hasIconRule(iconName, iconStyle, bucket)) {\n                // Rule exists, CSS handles the styling via attribute selectors\n                return;\n            }\n\n            // Generate mask value and register CSS rule\n            ensureMaskValue(url, this.#maskKeyBase, bucket)\n                .then((maskValue) => {\n                    console.log(`[ui-icon] Got mask value for ${iconName}:${iconStyle}:`, maskValue);\n\n                    // Register the icon in CSS registry with attribute-based selector\n                    // The rule: ui-icon[icon=\"name\"][icon-style=\"style\"] { --icon-image: ... }\n                    registerIconRule(iconName, iconStyle, maskValue, bucket);\n                    console.log(`[ui-icon] Registered CSS rule for ${iconName}:${iconStyle}`);\n\n                    // Keep local ref for fallback/debugging\n                    if (this.#maskRef.value !== maskValue) {\n                        this.#maskRef.value = maskValue;\n                    }\n                })\n                .catch((error) => {\n                    if (typeof console !== \"undefined\") {\n                        console.warn?.(\"[ui-icon] Mask update failed\", error);\n                    }\n                });\n        });\n    }\n\n    #getRasterBucket(): number {\n        const self = this as unknown as HTMLElement;\n        const inline = Math.ceil(this.#devicePixelSize?.inline || 0);\n        const block = Math.ceil(this.#devicePixelSize?.block || 0);\n        const candidate = Math.max(inline, block);\n        if (candidate > 0) {\n            return quantizeToBucket(candidate);\n        }\n\n        let fallback = MIN_RASTER_SIZE;\n        const ratio =\n            typeof devicePixelRatio === \"number\" && isFinite(devicePixelRatio)\n                ? devicePixelRatio\n                : 1;\n\n        if (typeof self.getBoundingClientRect === \"function\") {\n            const rect = self.getBoundingClientRect();\n            const maximum = Math.max(rect.width, rect.height) * ratio;\n            if (maximum > 0) {\n                fallback = maximum;\n            }\n        }\n\n        return quantizeToBucket(fallback);\n    }\n}\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        \"ui-icon\": UIPhosphorIcon;\n    }\n}\n\nif (typeof window !== \"undefined\" && !customElements.get(\"ui-icon\")) {\n    console.log(UIPhosphorIcon);\n    customElements.define(\"ui-icon\", UIPhosphorIcon);\n}\n"],"names":["MIN_RASTER_SIZE","url"],"mappings":"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"}