{"version":3,"file":"clipboard-handler.js","sources":["../../src/crx/shared/clipboard-handler.ts"],"sourcesContent":["/**\n * Unified CRX Clipboard Handler\n * Works in both content script and offscreen document contexts\n * Auto-detects context and handles messages appropriately\n */\n\nimport { toText } from \"@rs-core/modules/Clipboard\";\n\nexport type CopyResponse = {\n    ok: boolean;\n    data?: string;\n    method?: string;\n    error?: string;\n};\n\nexport type CRXClipboardContext = \"content\" | \"offscreen\" | \"unknown\";\n\nconst tryParseJson = (input: string): unknown => {\n    const trimmed = input.trim();\n    if (!trimmed) return null;\n    if (!(trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\"))) return null;\n    try { return JSON.parse(trimmed); } catch { return null; }\n};\n\nconst extractLLMContent = (data: unknown): string => {\n    if (data == null) return \"\";\n\n    // If we got a JSON string, try to parse it first.\n    if (typeof data === \"string\") {\n        const parsed = tryParseJson(data);\n        if (parsed != null) {\n            const extracted = extractLLMContent(parsed);\n            if (extracted) return extracted;\n        }\n        return data;\n    }\n\n    // OpenAI Chat Completions: { choices: [ { message: { content } } ] }\n    if (typeof data === \"object\") {\n        const anyData = data as any;\n\n        const choice0 = anyData?.choices?.[0];\n        const chatContent = choice0?.message?.content ?? choice0?.delta?.content ?? choice0?.text;\n        if (typeof chatContent === \"string\" && chatContent.trim()) return chatContent;\n\n        // OpenAI Responses: { output_text } or { output: [ { content: [ { text } ] } ] }\n        const outputText = anyData?.output_text;\n        if (typeof outputText === \"string\" && outputText.trim()) return outputText;\n\n        const output0 = anyData?.output?.[0];\n        const outText =\n            output0?.content?.find?.((c: any) => typeof c?.text === \"string\")?.text ??\n            output0?.content?.[0]?.text ??\n            output0?.content?.[0]?.content ??\n            output0?.text;\n        if (typeof outText === \"string\" && outText.trim()) return outText;\n\n        // Common wrappers: { message: { content } } or { content }\n        const directMessage = anyData?.message?.content;\n        if (typeof directMessage === \"string\" && directMessage.trim()) return directMessage;\n        if (typeof anyData?.content === \"string\" && anyData.content.trim()) return anyData.content;\n\n        // ExecutionCore-like: { result: { ... } } â€“ try recursively.\n        if (anyData?.result != null) {\n            const nested = extractLLMContent(anyData.result);\n            if (nested) return nested;\n        }\n    }\n\n    return \"\";\n};\n\n/**\n * Get the best available timing function for scheduling callbacks\n * Prefers requestAnimationFrame when available, falls back to setTimeout\n */\nexport const getTimingFunction = (): ((callback: () => void) => void) => {\n    if (typeof requestAnimationFrame !== 'undefined') {\n        return requestAnimationFrame;\n    }\n    if (typeof setTimeout !== 'undefined') {\n        return (cb) => setTimeout(cb, 0);\n    }\n    // Last resort: execute immediately\n    return (cb) => cb();\n};\n\n/**\n * Detect current CRX context\n */\nexport const detectContext = (): CRXClipboardContext => {\n    try {\n        // Offscreen documents have limited APIs and specific URL pattern\n        if (typeof location !== \"undefined\" && location.href.includes(\"offscreen\")) {\n            return \"offscreen\";\n        }\n        // Content scripts have access to the page DOM\n        if (typeof document !== \"undefined\" && document.body) {\n            return \"content\";\n        }\n    } catch {\n        // Ignore errors in context detection\n    }\n    return \"unknown\";\n};\n\n/**\n * Show toast feedback (only works in content script context)\n */\nconst showFeedback = (message: string, toastFn?: (message: string) => void): void => {\n    if (toastFn) {\n        toastFn(message);\n    } else {\n        console.log(\"[Clipboard]\", message);\n    }\n};\n\n/**\n * Enhanced clipboard write with RAF timing and multiple retries\n */\nconst writeTextWithRAF = async (text: string, maxRetries = 3): Promise<{ ok: boolean; method?: string; error?: string }> => {\n    const trimmed = text.trim();\n    if (!trimmed) return { ok: false, error: \"Empty content\" };\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n            // Use RAF for proper timing, fallback to setTimeout for service workers\n            const result = await new Promise<{ ok: boolean; method?: string; error?: string }>((resolve) => {\n                const timerFn = getTimingFunction();\n                timerFn(() => {\n                    // Ensure document has focus for clipboard API (if in content script)\n                    if (detectContext() === \"content\" && typeof document !== 'undefined' && document.hasFocus && !document.hasFocus()) {\n                        try {\n                            globalThis?.focus?.();\n                        } catch {\n                            // Ignore focus errors\n                        }\n                    }\n\n                    // Try direct clipboard API first\n                    const tryClipboardAPI = async () => {\n                        try {\n                            if (typeof navigator !== \"undefined\" && navigator.clipboard?.writeText) {\n                                await navigator.clipboard.writeText(trimmed);\n                                return resolve({ ok: true, method: \"clipboard-api\" });\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Direct write failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Try with permissions query (Chrome extension specific)\n                        try {\n                            if (typeof navigator !== \"undefined\" && navigator.permissions) {\n                                const result = await navigator.permissions.query({ name: \"clipboard-write\" } as unknown as PermissionDescriptor);\n                                if (result.state === \"granted\" || result.state === \"prompt\") {\n                                    await navigator.clipboard.writeText(trimmed);\n                                    return resolve({ ok: true, method: \"clipboard-api-permission\" });\n                                }\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Permission check failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Fallback: legacy execCommand (works in content scripts)\n                        try {\n                            if (detectContext() === \"content\" && typeof document !== \"undefined\") {\n                                const textarea = document.createElement(\"textarea\");\n                                textarea.value = trimmed;\n                                textarea.style.cssText = \"position:fixed;left:-9999px;top:-9999px;opacity:0;pointer-events:none;z-index:-1;\";\n                                document.body.appendChild(textarea);\n                                textarea.select();\n\n                                // Focus the textarea for better compatibility\n                                textarea.focus();\n\n                                const success = document.execCommand(\"copy\");\n                                textarea.remove();\n\n                                if (success) {\n                                    return resolve({ ok: true, method: \"legacy-execCommand\" });\n                                }\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Legacy execCommand failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Additional fallback: try again after a short delay\n                        if (attempt < maxRetries - 1) {\n                            setTimeout(() => tryClipboardAPI(), 100);\n                            return;\n                        }\n\n                        resolve({ ok: false, error: \"All clipboard methods failed\" });\n                    };\n\n                    tryClipboardAPI();\n                });\n            });\n\n            if (result.ok) {\n                return result;\n            }\n\n            // If this attempt failed and we have retries left, wait before next attempt\n            if (attempt < maxRetries - 1) {\n                await new Promise(resolve => setTimeout(resolve, 200 * (attempt + 1)));\n            }\n\n        } catch (error) {\n            console.warn(`[Clipboard] Attempt ${attempt + 1} completely failed:`, error);\n            if (attempt < maxRetries - 1) {\n                await new Promise(resolve => setTimeout(resolve, 200 * (attempt + 1)));\n            }\n        }\n    }\n\n    return { ok: false, error: `Failed after ${maxRetries} attempts` };\n};\n\n/**\n * Handle clipboard copy request with enhanced stability\n */\nexport const handleCopyRequest = async (\n    data: unknown,\n    options: { showFeedback?: boolean; errorMessage?: string; maxRetries?: number; toastFn?: (message: string) => void } = {}\n): Promise<CopyResponse> => {\n    const extracted = extractLLMContent(data);\n    const text = (extracted || toText(data)).trim();\n    const { maxRetries = 3 } = options;\n\n    if (!text) {\n        return { ok: false, error: \"Empty content\" };\n    }\n\n    console.log(`[Clipboard] Attempting to copy ${text.length} characters (${detectContext()})`);\n\n    const result = await writeTextWithRAF(text, maxRetries);\n\n    console.log(`[Clipboard] Copy result:`, result);\n\n    // Show feedback if requested and in appropriate context\n    if (options.showFeedback && detectContext() === \"content\") {\n        if (result.ok) {\n            showFeedback(\"Copied to clipboard\", options.toastFn);\n        } else {\n            showFeedback(options.errorMessage || result.error || \"Failed to copy\", options.toastFn);\n        }\n    }\n\n    return {\n        ok: result.ok,\n        data: text,\n        method: result.method || detectContext(),\n        error: result.error\n    };\n};\n\nlet _handlerRegistered = false;\n\n/**\n * Initialize COPY_HACK message handler\n * Auto-configures based on detected context\n */\nexport const initClipboardHandler = (\n    options: {\n        /** Only respond to messages with target matching this value */\n        targetFilter?: string;\n        /** Show toast feedback on copy */\n        showFeedback?: boolean;\n        /** Custom toast function */\n        toastFn?: (message: string) => void;\n    } = {}\n): void => {\n    if (_handlerRegistered) return;\n    _handlerRegistered = true;\n\n    const context = detectContext();\n    const { targetFilter, showFeedback: feedback = context === \"content\", toastFn } = options;\n\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        console.log(`[Clipboard] Received message:`, message, `from:`, sender);\n\n        // Filter by target if specified\n        if (targetFilter && message?.target !== targetFilter) {\n            console.log(`[Clipboard] Message filtered out by target:`, message?.target, `expected:`, targetFilter);\n            return false;\n        }\n\n        // Handle COPY_HACK messages\n        if (message?.type === \"COPY_HACK\") {\n            console.log(`[Clipboard] Processing COPY_HACK message with data:`, message?.data?.substring?.(0, 50) + '...');\n            handleCopyRequest(message?.data, {\n                showFeedback: feedback,\n                errorMessage: message?.error,\n                toastFn: toastFn\n            }).then(response => {\n                console.log(`[Clipboard] COPY_HACK response:`, response);\n                sendResponse(response);\n            }).catch(error => {\n                console.error(`[Clipboard] COPY_HACK error:`, error);\n                sendResponse({ ok: false, error: String(error) });\n            });\n            return true; // async response\n        }\n\n        return false;\n    });\n\n    console.log(`[Clipboard] Handler initialized (${context})`);\n};\n\n// Re-export for convenience\nexport { writeText, toText } from \"@rs-core/modules/Clipboard\";\n\n"],"names":["result"],"mappings":";;;AAiBA,MAAM,YAAA,GAAe,CAAC,KAAA,KAA2B;AAC7C,EAAA,MAAM,OAAA,GAAU,MAAM,IAAA,EAAK;AAC3B,EAAA,IAAI,CAAC,SAAS,OAAO,IAAA;AACrB,EAAA,IAAI,EAAE,QAAQ,UAAA,CAAW,GAAG,KAAK,OAAA,CAAQ,UAAA,CAAW,GAAG,CAAA,CAAA,EAAI,OAAO,IAAA;AAClE,EAAA,IAAI;AAAE,IAAA,OAAO,IAAA,CAAK,MAAM,OAAO,CAAA;AAAA,EAAG,CAAA,CAAA,MAAQ;AAAE,IAAA,OAAO,IAAA;AAAA,EAAM;AAC7D,CAAA;AAEA,MAAM,iBAAA,GAAoB,CAAC,IAAA,KAA0B;AACjD,EAAA,IAAI,IAAA,IAAQ,MAAM,OAAO,EAAA;AAGzB,EAAA,IAAI,OAAO,SAAS,QAAA,EAAU;AAC1B,IAAA,MAAM,MAAA,GAAS,aAAa,IAAI,CAAA;AAChC,IAAA,IAAI,UAAU,IAAA,EAAM;AAChB,MAAA,MAAM,SAAA,GAAY,kBAAkB,MAAM,CAAA;AAC1C,MAAA,IAAI,WAAW,OAAO,SAAA;AAAA,IAC1B;AACA,IAAA,OAAO,IAAA;AAAA,EACX;AAGA,EAAA,IAAI,OAAO,SAAS,QAAA,EAAU;AAC1B,IAAA,MAAM,OAAA,GAAU,IAAA;AAEhB,IAAA,MAAM,OAAA,GAAU,OAAA,EAAS,OAAA,GAAU,CAAC,CAAA;AACpC,IAAA,MAAM,cAAc,OAAA,EAAS,OAAA,EAAS,WAAW,OAAA,EAAS,KAAA,EAAO,WAAW,OAAA,EAAS,IAAA;AACrF,IAAA,IAAI,OAAO,WAAA,KAAgB,QAAA,IAAY,WAAA,CAAY,IAAA,IAAQ,OAAO,WAAA;AAGlE,IAAA,MAAM,aAAa,OAAA,EAAS,WAAA;AAC5B,IAAA,IAAI,OAAO,UAAA,KAAe,QAAA,IAAY,UAAA,CAAW,IAAA,IAAQ,OAAO,UAAA;AAEhE,IAAA,MAAM,OAAA,GAAU,OAAA,EAAS,MAAA,GAAS,CAAC,CAAA;AACnC,IAAA,MAAM,OAAA,GACF,SAAS,OAAA,EAAS,IAAA,GAAO,CAAC,CAAA,KAAW,OAAO,CAAA,EAAG,IAAA,KAAS,QAAQ,CAAA,EAAG,QACnE,OAAA,EAAS,OAAA,GAAU,CAAC,CAAA,EAAG,IAAA,IACvB,SAAS,OAAA,GAAU,CAAC,CAAA,EAAG,OAAA,IACvB,OAAA,EAAS,IAAA;AACb,IAAA,IAAI,OAAO,OAAA,KAAY,QAAA,IAAY,OAAA,CAAQ,IAAA,IAAQ,OAAO,OAAA;AAG1D,IAAA,MAAM,aAAA,GAAgB,SAAS,OAAA,EAAS,OAAA;AACxC,IAAA,IAAI,OAAO,aAAA,KAAkB,QAAA,IAAY,aAAA,CAAc,IAAA,IAAQ,OAAO,aAAA;AACtE,IAAA,IAAI,OAAO,SAAS,OAAA,KAAY,QAAA,IAAY,QAAQ,OAAA,CAAQ,IAAA,EAAK,EAAG,OAAO,OAAA,CAAQ,OAAA;AAGnF,IAAA,IAAI,OAAA,EAAS,UAAU,IAAA,EAAM;AACzB,MAAA,MAAM,MAAA,GAAS,iBAAA,CAAkB,OAAA,CAAQ,MAAM,CAAA;AAC/C,MAAA,IAAI,QAAQ,OAAO,MAAA;AAAA,IACvB;AAAA,EACJ;AAEA,EAAA,OAAO,EAAA;AACX,CAAA;AAMO,MAAM,oBAAoB,MAAwC;AACrE,EAAA,IAAI,OAAO,0BAA0B,WAAA,EAAa;AAC9C,IAAA,OAAO,qBAAA;AAAA,EACX;AACA,EAAA,IAAI,OAAO,eAAe,WAAA,EAAa;AACnC,IAAA,OAAO,CAAC,EAAA,KAAO,UAAA,CAAW,EAAA,EAAI,CAAC,CAAA;AAAA,EACnC;AAEA,EAAA,OAAO,CAAC,OAAO,EAAA,EAAG;AACtB,CAAA;AAKO,MAAM,gBAAgB,MAA2B;AACpD,EAAA,IAAI;AAEA,IAAA,IAAI,OAAO,QAAA,KAAa,WAAA,IAAe,SAAS,IAAA,CAAK,QAAA,CAAS,WAAW,CAAA,EAAG;AACxE,MAAA,OAAO,WAAA;AAAA,IACX;AAEA,IAAA,IAAI,OAAO,QAAA,KAAa,WAAA,IAAe,QAAA,CAAS,IAAA,EAAM;AAClD,MAAA,OAAO,SAAA;AAAA,IACX;AAAA,EACJ,CAAA,CAAA,MAAQ;AAAA,EAER;AACA,EAAA,OAAO,SAAA;AACX,CAAA;AAKA,MAAM,YAAA,GAAe,CAAC,OAAA,EAAiB,OAAA,KAA8C;AACjF,EAAA,IAAI,OAAA,EAAS;AACT,IAAA,OAAA,CAAQ,OAAO,CAAA;AAAA,EACnB,CAAA,MAAO;AACH,IAAA,OAAA,CAAQ,GAAA,CAAI,eAAe,OAAO,CAAA;AAAA,EACtC;AACJ,CAAA;AAKA,MAAM,gBAAA,GAAmB,OAAO,IAAA,EAAc,UAAA,GAAa,CAAA,KAAiE;AACxH,EAAA,MAAM,OAAA,GAAU,KAAK,IAAA,EAAK;AAC1B,EAAA,IAAI,CAAC,OAAA,EAAS,OAAO,EAAE,EAAA,EAAI,KAAA,EAAO,OAAO,eAAA,EAAgB;AAEzD,EAAA,KAAA,IAAS,OAAA,GAAU,CAAA,EAAG,OAAA,GAAU,UAAA,EAAY,OAAA,EAAA,EAAW;AACnD,IAAA,IAAI;AAEA,MAAA,MAAM,MAAA,GAAS,MAAM,IAAI,OAAA,CAA0D,CAAC,OAAA,KAAY;AAC5F,QAAA,MAAM,UAAU,iBAAA,EAAkB;AAClC,QAAA,OAAA,CAAQ,MAAM;AAEV,UAAA,IAAI,aAAA,EAAc,KAAM,SAAA,IAAa,OAAO,QAAA,KAAa,WAAA,IAAe,QAAA,CAAS,QAAA,IAAY,CAAC,QAAA,CAAS,QAAA,EAAS,EAAG;AAC/G,YAAA,IAAI;AACA,cAAA,UAAA,EAAY,KAAA,IAAQ;AAAA,YACxB,CAAA,CAAA,MAAQ;AAAA,YAER;AAAA,UACJ;AAGA,UAAA,MAAM,kBAAkB,YAAY;AAChC,YAAA,IAAI;AACA,cAAA,IAAI,OAAO,SAAA,KAAc,WAAA,IAAe,SAAA,CAAU,WAAW,SAAA,EAAW;AACpE,gBAAA,MAAM,SAAA,CAAU,SAAA,CAAU,SAAA,CAAU,OAAO,CAAA;AAC3C,gBAAA,OAAO,QAAQ,EAAE,EAAA,EAAI,IAAA,EAAM,MAAA,EAAQ,iBAAiB,CAAA;AAAA,cACxD;AAAA,YACJ,SAAS,GAAA,EAAK;AACV,cAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,yCAAA,EAA4C,OAAA,GAAU,CAAC,MAAM,GAAG,CAAA;AAAA,YACjF;AAGA,YAAA,IAAI;AACA,cAAA,IAAI,OAAO,SAAA,KAAc,WAAA,IAAe,SAAA,CAAU,WAAA,EAAa;AAC3D,gBAAA,MAAMA,OAAAA,GAAS,MAAM,SAAA,CAAU,WAAA,CAAY,MAAM,EAAE,IAAA,EAAM,mBAAsD,CAAA;AAC/G,gBAAA,IAAIA,OAAAA,CAAO,KAAA,KAAU,SAAA,IAAaA,OAAAA,CAAO,UAAU,QAAA,EAAU;AACzD,kBAAA,MAAM,SAAA,CAAU,SAAA,CAAU,SAAA,CAAU,OAAO,CAAA;AAC3C,kBAAA,OAAO,QAAQ,EAAE,EAAA,EAAI,IAAA,EAAM,MAAA,EAAQ,4BAA4B,CAAA;AAAA,gBACnE;AAAA,cACJ;AAAA,YACJ,SAAS,GAAA,EAAK;AACV,cAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,6CAAA,EAAgD,OAAA,GAAU,CAAC,MAAM,GAAG,CAAA;AAAA,YACrF;AAGA,YAAA,IAAI;AACA,cAAA,IAAI,aAAA,EAAc,KAAM,SAAA,IAAa,OAAO,aAAa,WAAA,EAAa;AAClE,gBAAA,MAAM,QAAA,GAAW,QAAA,CAAS,aAAA,CAAc,UAAU,CAAA;AAClD,gBAAA,QAAA,CAAS,KAAA,GAAQ,OAAA;AACjB,gBAAA,QAAA,CAAS,MAAM,OAAA,GAAU,mFAAA;AACzB,gBAAA,QAAA,CAAS,IAAA,CAAK,YAAY,QAAQ,CAAA;AAClC,gBAAA,QAAA,CAAS,MAAA,EAAO;AAGhB,gBAAA,QAAA,CAAS,KAAA,EAAM;AAEf,gBAAA,MAAM,OAAA,GAAU,QAAA,CAAS,WAAA,CAAY,MAAM,CAAA;AAC3C,gBAAA,QAAA,CAAS,MAAA,EAAO;AAEhB,gBAAA,IAAI,OAAA,EAAS;AACT,kBAAA,OAAO,QAAQ,EAAE,EAAA,EAAI,IAAA,EAAM,MAAA,EAAQ,sBAAsB,CAAA;AAAA,gBAC7D;AAAA,cACJ;AAAA,YACJ,SAAS,GAAA,EAAK;AACV,cAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,+CAAA,EAAkD,OAAA,GAAU,CAAC,MAAM,GAAG,CAAA;AAAA,YACvF;AAGA,YAAA,IAAI,OAAA,GAAU,aAAa,CAAA,EAAG;AAC1B,cAAA,UAAA,CAAW,MAAM,eAAA,EAAgB,EAAG,GAAG,CAAA;AACvC,cAAA;AAAA,YACJ;AAEA,YAAA,OAAA,CAAQ,EAAE,EAAA,EAAI,KAAA,EAAO,KAAA,EAAO,gCAAgC,CAAA;AAAA,UAChE,CAAA;AAEA,UAAA,eAAA,EAAgB;AAAA,QACpB,CAAC,CAAA;AAAA,MACL,CAAC,CAAA;AAED,MAAA,IAAI,OAAO,EAAA,EAAI;AACX,QAAA,OAAO,MAAA;AAAA,MACX;AAGA,MAAA,IAAI,OAAA,GAAU,aAAa,CAAA,EAAG;AAC1B,QAAA,MAAM,IAAI,QAAQ,CAAA,OAAA,KAAW,UAAA,CAAW,SAAS,GAAA,IAAO,OAAA,GAAU,EAAE,CAAC,CAAA;AAAA,MACzE;AAAA,IAEJ,SAAS,KAAA,EAAO;AACZ,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,oBAAA,EAAuB,OAAA,GAAU,CAAC,uBAAuB,KAAK,CAAA;AAC3E,MAAA,IAAI,OAAA,GAAU,aAAa,CAAA,EAAG;AAC1B,QAAA,MAAM,IAAI,QAAQ,CAAA,OAAA,KAAW,UAAA,CAAW,SAAS,GAAA,IAAO,OAAA,GAAU,EAAE,CAAC,CAAA;AAAA,MACzE;AAAA,IACJ;AAAA,EACJ;AAEA,EAAA,OAAO,EAAE,EAAA,EAAI,KAAA,EAAO,KAAA,EAAO,CAAA,aAAA,EAAgB,UAAU,CAAA,SAAA,CAAA,EAAY;AACrE,CAAA;AAKO,MAAM,iBAAA,GAAoB,OAC7B,IAAA,EACA,OAAA,GAAuH,EAAC,KAChG;AACxB,EAAA,MAAM,SAAA,GAAY,kBAAkB,IAAI,CAAA;AACxC,EAAA,MAAM,IAAA,GAAA,CAAQ,SAAA,IAAa,MAAA,CAAO,IAAI,GAAG,IAAA,EAAK;AAC9C,EAAA,MAAM,EAAE,UAAA,GAAa,CAAA,EAAE,GAAI,OAAA;AAE3B,EAAA,IAAI,CAAC,IAAA,EAAM;AACP,IAAA,OAAO,EAAE,EAAA,EAAI,KAAA,EAAO,KAAA,EAAO,eAAA,EAAgB;AAAA,EAC/C;AAEA,EAAA,OAAA,CAAQ,IAAI,CAAA,+BAAA,EAAkC,IAAA,CAAK,MAAM,CAAA,aAAA,EAAgB,aAAA,EAAe,CAAA,CAAA,CAAG,CAAA;AAE3F,EAAA,MAAM,MAAA,GAAS,MAAM,gBAAA,CAAiB,IAAA,EAAM,UAAU,CAAA;AAEtD,EAAA,OAAA,CAAQ,GAAA,CAAI,4BAA4B,MAAM,CAAA;AAG9C,EAAA,IAAI,OAAA,CAAQ,YAAA,IAAgB,aAAA,EAAc,KAAM,SAAA,EAAW;AACvD,IAAA,IAAI,OAAO,EAAA,EAAI;AACX,MAAA,YAAA,CAAa,qBAAA,EAAuB,QAAQ,OAAO,CAAA;AAAA,IACvD,CAAA,MAAO;AACH,MAAA,YAAA,CAAa,QAAQ,YAAA,IAAgB,MAAA,CAAO,KAAA,IAAS,gBAAA,EAAkB,QAAQ,OAAO,CAAA;AAAA,IAC1F;AAAA,EACJ;AAEA,EAAA,OAAO;AAAA,IACH,IAAI,MAAA,CAAO,EAAA;AAAA,IACX,IAAA,EAAM,IAAA;AAAA,IACN,MAAA,EAAQ,MAAA,CAAO,MAAA,IAAU,aAAA,EAAc;AAAA,IACvC,OAAO,MAAA,CAAO;AAAA,GAClB;AACJ,CAAA;AAEA,IAAI,kBAAA,GAAqB,KAAA;AAMlB,MAAM,oBAAA,GAAuB,CAChC,OAAA,GAOI,EAAC,KACE;AACP,EAAA,IAAI,kBAAA,EAAoB;AACxB,EAAA,kBAAA,GAAqB,IAAA;AAErB,EAAA,MAAM,UAAU,aAAA,EAAc;AAC9B,EAAA,MAAM,EAAE,YAAA,EAAc,YAAA,EAAc,WAAW,OAAA,KAAY,SAAA,EAAW,SAAQ,GAAI,OAAA;AAElF,EAAA,MAAA,CAAO,QAAQ,SAAA,CAAU,WAAA,CAAY,CAAC,OAAA,EAAS,QAAQ,YAAA,KAAiB;AACpE,IAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,6BAAA,CAAA,EAAiC,OAAA,EAAS,CAAA,KAAA,CAAA,EAAS,MAAM,CAAA;AAGrE,IAAA,IAAI,YAAA,IAAgB,OAAA,EAAS,MAAA,KAAW,YAAA,EAAc;AAClD,MAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,2CAAA,CAAA,EAA+C,OAAA,EAAS,MAAA,EAAQ,aAAa,YAAY,CAAA;AACrG,MAAA,OAAO,KAAA;AAAA,IACX;AAGA,IAAA,IAAI,OAAA,EAAS,SAAS,WAAA,EAAa;AAC/B,MAAA,OAAA,CAAQ,GAAA,CAAI,uDAAuD,OAAA,EAAS,IAAA,EAAM,YAAY,CAAA,EAAG,EAAE,IAAI,KAAK,CAAA;AAC5G,MAAA,iBAAA,CAAkB,SAAS,IAAA,EAAM;AAAA,QAC7B,YAAA,EAAc,QAAA;AAAA,QACd,cAAc,OAAA,EAAS,KAAA;AAAA,QACvB;AAAA,OACH,CAAA,CAAE,IAAA,CAAK,CAAA,QAAA,KAAY;AAChB,QAAA,OAAA,CAAQ,GAAA,CAAI,mCAAmC,QAAQ,CAAA;AACvD,QAAA,YAAA,CAAa,QAAQ,CAAA;AAAA,MACzB,CAAC,CAAA,CAAE,KAAA,CAAM,CAAA,KAAA,KAAS;AACd,QAAA,OAAA,CAAQ,KAAA,CAAM,gCAAgC,KAAK,CAAA;AACnD,QAAA,YAAA,CAAa,EAAE,EAAA,EAAI,KAAA,EAAO,OAAO,MAAA,CAAO,KAAK,GAAG,CAAA;AAAA,MACpD,CAAC,CAAA;AACD,MAAA,OAAO,IAAA;AAAA,IACX;AAEA,IAAA,OAAO,KAAA;AAAA,EACX,CAAC,CAAA;AAED,EAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,iCAAA,EAAoC,OAAO,CAAA,CAAA,CAAG,CAAA;AAC9D;;;;"}