import{detectExecutionContext as e,supportsDedicatedWorkers as t}from"./Env.js";import{createQueuedOptimizedWorkerChannel as s}from"./Settings.js";import{BUILT_IN_AI_ACTIONS as n,AI_INSTRUCTIONS as r}from"./templates.js";class o{db=null;dbPromise=null;options;constructor(e={}){this.options={dbName:e.dbName??"UniformMessageQueue",storeName:e.storeName??"messages",maxRetries:e.maxRetries??3,defaultExpirationMs:e.defaultExpirationMs??864e5,fallbackStorageKey:e.fallbackStorageKey??"uniform_message_queue"}}async initDB(){if(this.db)return this.db;if(this.dbPromise)return this.dbPromise;if(!o.isIndexedDBAvailable())return console.warn("[MessageQueue] IndexedDB not available, using sessionStorage fallback"),null;this.dbPromise=new Promise((e,t)=>{const s=indexedDB.open(this.options.dbName,1);s.onerror=()=>{console.warn("[MessageQueue] IndexedDB open failed, falling back to sessionStorage"),t(new Error("IndexedDB not available"))},s.onsuccess=()=>{this.db=s.result,e(this.db)},s.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains(this.options.storeName)){const e=t.createObjectStore(this.options.storeName,{keyPath:"id"});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("type","type",{unique:!1}),e.createIndex("priority","priority",{unique:!1}),e.createIndex("destination","destination",{unique:!1})}}});try{return this.db=await this.dbPromise,this.db}catch{return null}}generateId(){return`msg_${Date.now()}_${Math.random().toString(36).substring(2,11)}`}async queueMessage(e,t,s={}){const n={id:this.generateId(),type:e,data:t,timestamp:Date.now(),priority:s.priority??"normal",retryCount:0,maxRetries:s.maxRetries??this.options.maxRetries,expiresAt:s.expiresAt??Date.now()+this.options.defaultExpirationMs,destination:s.destination,metadata:s.metadata};try{const t=await this.initDB();return t?await this.addToIndexedDB(t,n):this.addToSessionStorage(n),console.log(`[MessageQueue] Queued message: ${e}`,n.id),n.id}catch(r){throw console.error("[MessageQueue] Failed to queue message:",r),r}}async getQueuedMessages(e){try{const t=await this.initDB();let s;s=t?await this.getAllFromIndexedDB(t):this.getAllFromSessionStorage(),e&&(s=s.filter(t=>t.destination===e));const n=Date.now();return s.filter(e=>!e.expiresAt||e.expiresAt>n)}catch(t){return console.error("[MessageQueue] Failed to get queued messages:",t),this.getAllFromSessionStorage()}}async removeMessage(e){try{const t=await this.initDB();t?await this.deleteFromIndexedDB(t,e):this.deleteFromSessionStorage(e)}catch(t){console.error("[MessageQueue] Failed to remove message:",t)}}async updateMessageRetry(e,t){try{const s=await this.initDB();s?await this.updateInIndexedDB(s,e,{retryCount:t}):this.updateInSessionStorage(e,{retryCount:t})}catch(s){console.error("[MessageQueue] Failed to update message retry:",s)}}async clearExpiredMessages(){try{const e=await this.getQueuedMessages(),t=Date.now(),s=e.filter(e=>e.expiresAt&&e.expiresAt<=t).map(e=>e.id);for(const n of s)await this.removeMessage(n);return s.length>0&&console.log(`[MessageQueue] Cleared ${s.length} expired messages`),s.length}catch(e){return console.error("[MessageQueue] Failed to clear expired messages:",e),0}}async clearAll(){try{const e=await this.initDB();e?await this.clearIndexedDB(e):sessionStorage.removeItem(this.options.fallbackStorageKey),console.log("[MessageQueue] Cleared all messages")}catch(e){console.error("[MessageQueue] Failed to clear all messages:",e)}}async getStats(){const e=await this.getQueuedMessages(),t=Date.now(),s={low:0,normal:0,high:0},n={};let r=0;for(const o of e)s[o.priority]++,o.destination&&(n[o.destination]=(n[o.destination]||0)+1),o.expiresAt&&o.expiresAt<=t&&r++;return{total:e.length,byPriority:s,byDestination:n,expired:r}}async addToIndexedDB(e,t){return new Promise((s,n)=>{const r=e.transaction([this.options.storeName],"readwrite").objectStore(this.options.storeName).add(t);r.onsuccess=()=>s(),r.onerror=()=>n(r.error)})}async getAllFromIndexedDB(e){return new Promise((t,s)=>{const n=e.transaction([this.options.storeName],"readonly").objectStore(this.options.storeName).getAll();n.onsuccess=()=>t(n.result),n.onerror=()=>s(n.error)})}async deleteFromIndexedDB(e,t){return new Promise((s,n)=>{const r=e.transaction([this.options.storeName],"readwrite").objectStore(this.options.storeName).delete(t);r.onsuccess=()=>s(),r.onerror=()=>n(r.error)})}async updateInIndexedDB(e,t,s){const n=e.transaction([this.options.storeName],"readwrite").objectStore(this.options.storeName),r=await new Promise((e,s)=>{const r=n.get(t);r.onsuccess=()=>e(r.result),r.onerror=()=>s(r.error)});r&&(Object.assign(r,s),await new Promise((e,t)=>{const s=n.put(r);s.onsuccess=()=>e(),s.onerror=()=>t(s.error)}))}async clearIndexedDB(e){return new Promise((t,s)=>{const n=e.transaction([this.options.storeName],"readwrite").objectStore(this.options.storeName).clear();n.onsuccess=()=>t(),n.onerror=()=>s(n.error)})}getAllFromSessionStorage(){try{const e=sessionStorage.getItem(this.options.fallbackStorageKey);return e?JSON.parse(e):[]}catch{return[]}}addToSessionStorage(e){const t=this.getAllFromSessionStorage();t.push(e),sessionStorage.setItem(this.options.fallbackStorageKey,JSON.stringify(t))}deleteFromSessionStorage(e){const t=this.getAllFromSessionStorage().filter(t=>t.id!==e);sessionStorage.setItem(this.options.fallbackStorageKey,JSON.stringify(t))}updateInSessionStorage(e,t){const s=this.getAllFromSessionStorage(),n=s.find(t=>t.id===e);n&&(Object.assign(n,t),sessionStorage.setItem(this.options.fallbackStorageKey,JSON.stringify(s)))}static isIndexedDBAvailable(){try{return"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBTransaction&&"undefined"!=typeof IDBKeyRange}catch{return!1}}}const i=new Map;class a{storageKey;maxMessages;defaultTTLMs;constructor(e){this.storageKey=e?.storageKey??"uniform-messaging-pending",this.maxMessages=e?.maxMessages??200,this.defaultTTLMs=e?.defaultTTLMs??864e5}read(){if("undefined"==typeof window||"undefined"==typeof localStorage)return[];try{const e=localStorage.getItem(this.storageKey);if(!e)return[];const t=JSON.parse(e);return Array.isArray(t)?t:[]}catch{return[]}}write(e){if("undefined"!=typeof window&&"undefined"!=typeof localStorage)try{localStorage.setItem(this.storageKey,JSON.stringify(e))}catch{}}enqueue(e,t){if(!e)return;const s=Date.now();if((Number(t?.metadata?.expiresAt)?Math.max(0,Number(t.metadata.expiresAt)-s):this.defaultTTLMs)<=0)return;const n=this.read().filter(e=>e&&"object"==typeof e).filter(e=>(Number(e?.message?.metadata?.expiresAt)||Number(e?.storedAt)+this.defaultTTLMs)>s);n.push({destination:e,message:t,storedAt:s}),n.length>this.maxMessages&&n.splice(0,n.length-this.maxMessages),this.write(n)}drain(e){if(!e)return[];const t=Date.now(),s=this.read(),n=[],r=[];for(const o of s){(Number(o?.message?.metadata?.expiresAt)||Number(o?.storedAt)+this.defaultTTLMs)<=t||(o?.destination===e&&o?.message?r.push(o.message):n.push(o))}return this.write(n),r}has(e){if(!e)return!1;const t=Date.now();return this.read().some(s=>{if(!s||"object"!=typeof s)return!1;return(Number(s?.message?.metadata?.expiresAt)||Number(s?.storedAt)+this.defaultTTLMs)>t&&s?.destination===e})}clear(){this.write([])}}class c{handlers=new Map;channels=new Map;workerChannels=new Map;viewChannels=new Map;pipelines=new Map;messageQueue;pendingStore;initializedViews=new Set;viewReadyPromises=new Map;executionContext;channelMappings;componentRegistry=new Map;constructor(t={}){this.executionContext=e(),this.channelMappings=t.channelMappings??{},this.messageQueue=function(e){const t=e?.dbName??"default";return i.has(t)||i.set(t,new o(e)),i.get(t)}(t.queueOptions),this.pendingStore=new a(t.pendingStoreOptions),this.setupGlobalListeners()}registerHandler(e,t){this.handlers.has(e)||this.handlers.set(e,[]),this.handlers.get(e).push(t)}unregisterHandler(e,t){const s=this.handlers.get(e);if(s){const e=s.indexOf(t);e>-1&&s.splice(e,1)}}async sendMessage(e){const t={id:e.id??crypto.randomUUID(),type:e.type,source:e.source??"unified-messaging",destination:e.destination,contentType:e.contentType,data:e.data,metadata:{timestamp:Date.now(),...e.metadata}};return!!(await this.tryDeliverMessage(t))||(t.destination&&(this.pendingStore.enqueue(t.destination,t),await this.messageQueue.queueMessage(t.type,t,{priority:t.metadata?.priority??"normal",maxRetries:t.metadata?.maxRetries??3,destination:t.destination})),!1)}async processMessage(e){const t=e.destination??"general",s=this.handlers.get(t)??[];for(const r of s)if(r.canHandle(e))try{await r.handle(e)}catch(n){console.error(`[UnifiedMessaging] Handler error for ${t}:`,n)}}async tryDeliverMessage(e){if(e.destination&&this.handlers.has(e.destination))return await this.processMessage(e),!0;const t=this.getChannelForDestination(e.destination);if(t&&this.channels.has(t)){const n=this.channels.get(t);if(n instanceof BroadcastChannel)try{return n.postMessage(e),!0}catch(s){console.warn(`[UnifiedMessaging] Failed to post to broadcast channel ${t}:`,s)}else if(n&&"request"in n)try{return await n.request(e.type,[e]),!0}catch(s){console.warn(`[UnifiedMessaging] Failed to post to worker channel ${t}:`,s)}}return!1}registerViewChannels(e,t){const n=new Set;for(const r of t){if(!this.isWorkerSupported(r)){console.log(`[UnifiedMessaging] Skipping worker '${r.name}' in ${this.executionContext} context`);continue}const t=s({name:r.name,script:r.script,options:r.options,context:this.executionContext},r.protocolOptions,()=>{console.log(`[UnifiedMessaging] Channel '${r.name}' ready for view '${e}'`)}),o=`${e}:${r.name}`;this.workerChannels.set(o,t),this.channels.set(o,t),n.add(r.name)}this.viewChannels.set(e,n)}async initializeViewChannels(e){if(this.initializedViews.has(e))return;const t=this.createDeferred();this.viewReadyPromises.set(e,t),console.log(`[UnifiedMessaging] Initializing channels for view: ${e}`);const s=this.viewChannels.get(e);if(!s)return void t.resolve();const n=[];for(const r of s){const t=`${e}:${r}`,s=this.workerChannels.get(t);s&&n.push(s.request("ping",{}).catch(()=>{console.log(`[UnifiedMessaging] Channel '${r}' queued for view '${e}'`)}))}await Promise.allSettled(n),this.initializedViews.add(e),t.resolve()}getWorkerChannel(e,t){return this.workerChannels.get(`${e}:${t}`)??null}getBroadcastChannel(e){if(!this.channels.has(e))try{const t=new BroadcastChannel(e);t.addEventListener("message",t=>{this.handleBroadcastMessage(t.data,e)}),this.channels.set(e,t)}catch(t){console.warn(`[UnifiedMessaging] BroadcastChannel not available: ${e}`,t);const s={postMessage:()=>{},close:()=>{},addEventListener:()=>{},removeEventListener:()=>{}};this.channels.set(e,s)}return this.channels.get(e)}async handleBroadcastMessage(e,t){try{const s=e,n=s?.id?e:{id:crypto.randomUUID(),type:String(s?.type??"unknown"),source:t,data:e,metadata:{timestamp:Date.now()}};await this.processMessage(n)}catch(s){console.error(`[UnifiedMessaging] Error handling broadcast message on ${t}:`,s)}}registerPipeline(e){this.pipelines.set(e.name,e)}async processThroughPipeline(e,t){const s=this.pipelines.get(e);if(!s)throw new Error(`Pipeline '${e}' not found`);let n={...t};const r=s.timeout??3e4;for(const i of s.stages){const t=i.timeout??r,a=i.retries??0;for(let r=0;r<=a;r++)try{n=await Promise.race([i.handler(n),new Promise((e,s)=>setTimeout(()=>s(new Error(`Stage '${i.name}' timeout`)),t))]);break}catch(o){if(r===a)throw s.errorHandler&&s.errorHandler(o,i,n),o;console.warn(`[UnifiedMessaging] Pipeline '${e}' stage '${i.name}' attempt ${r+1} failed:`,o)}}return n}async processQueuedMessages(e){const t=await this.messageQueue.getQueuedMessages(e);for(const s of t){const e=s.data,t=e&&"object"==typeof e&&"string"==typeof e.type&&"string"==typeof e.id?e:{id:s.id,type:s.type,source:"queue",destination:s.destination,data:s.data,metadata:{timestamp:s.timestamp,retryCount:s.retryCount,maxRetries:s.maxRetries,...s.metadata}};await this.tryDeliverMessage(t)&&await this.messageQueue.removeMessage(s.id)}}registerComponent(e,t){this.componentRegistry.set(e,t)}initializeComponent(e){const t=this.componentRegistry.get(e);return t?this.pendingStore.drain(t):[]}hasPendingMessages(e){return this.pendingStore.has(e)}enqueuePendingMessage(e,t){const s=String(e??"").trim();s&&t&&this.pendingStore.enqueue(s,t)}setChannelMappings(e){this.channelMappings={...this.channelMappings,...e}}getChannelForDestination(e){return e?this.channelMappings[e]??null:null}isWorkerSupported(e){return"service-worker"===this.executionContext||("chrome-extension"!==this.executionContext||t())}setupGlobalListeners(){"undefined"!=typeof window&&globalThis.addEventListener("message",e=>{e.data&&"object"==typeof e.data&&e.data.type&&this.handleBroadcastMessage(e.data,"window-message")})}createDeferred(){let e,t;const s=new Promise((s,n)=>{e=s,t=n});return{resolve:e,reject:t,promise:s}}getExecutionContext(){return this.executionContext}destroy(){for(const e of this.channels.values())(e instanceof BroadcastChannel||e&&"close"in e)&&e.close();this.channels.clear(),this.workerChannels.clear(),this.handlers.clear(),this.pipelines.clear()}}let d=null;const l={CLIPBOARD:"rs-clipboard",WORK_CENTER:"rs-workcenter",MARKDOWN_VIEWER:"rs-markdown-viewer",SETTINGS:"rs-settings",FILE_EXPLORER:"file-explorer",PRINT_VIEWER:"print-viewer",HISTORY_CHANNEL:"history",PRINT_CHANNEL:"print"},p={WORK_CENTER:"workcenter",MARKDOWN_VIEWER:"markdown-viewer",MARKDOWN_EDITOR:"markdown-editor",SETTINGS:"settings",HISTORY:"history",FILE_EXPLORER:"file-explorer",BASIC_PRINT:"basic-print"},u={MARKDOWN_VIEWER:"#markdown-viewer",MARKDOWN_EDITOR:"#markdown-editor",SETTINGS:"#settings",HISTORY:"#history",WORKCENTER:"#workcenter",FILE_EXPLORER:"#file-explorer",PRINT:"#print"},g="workcenter",h="clipboard",m="markdown-viewer",f="settings",w="file-explorer",y="print-viewer";Object.fromEntries(Object.entries({"share-target":{processingUrl:"/api/processing",contentAction:{onResult:"write-clipboard",onAccept:"attach-to-associated",doProcess:"instantly",openApp:!0},supportedContentTypes:["text","markdown","image","url"],defaultOverrideFactors:[]},"launch-queue":{processingUrl:"/api/processing",contentAction:{onResult:"none",onAccept:"attach-to-associated",doProcess:"manually",openApp:!0},supportedContentTypes:["file","blob","text","markdown","image"],defaultOverrideFactors:[]},"crx-snip":{processingUrl:"/api/processing",contentAction:{onResult:"write-clipboard",onAccept:"attach-to-associated",doProcess:"instantly",openApp:!1},supportedContentTypes:["text","image"],defaultOverrideFactors:["force-processing"]},paste:{processingUrl:"/api/processing",contentAction:{onResult:"none",onAccept:"attach-to-associated",doProcess:"manually",openApp:!1},supportedContentTypes:["text","markdown","image"],defaultOverrideFactors:[],associationOverrides:{text:["user-action"],markdown:["user-action"]}},drop:{processingUrl:"/api/processing",contentAction:{onResult:"none",onAccept:"attach-to-associated",doProcess:"manually",openApp:!1},supportedContentTypes:["file","blob","text","markdown","image"],defaultOverrideFactors:[],associationOverrides:{file:["user-action"],blob:["user-action"]}},"button-attach-workcenter":{processingUrl:"/api/processing",contentAction:{onResult:"none",onAccept:"attach-to-workcenter",doProcess:"manually",openApp:!1},supportedContentTypes:["text","markdown","image","file"],defaultOverrideFactors:["explicit-workcenter"],associationOverrides:{markdown:["explicit-workcenter"],text:["explicit-workcenter"],image:["explicit-workcenter"],file:["explicit-workcenter"]}}}).map(([e,t])=>[e,{processingUrl:t.processingUrl,contentAction:t.contentAction,...t.supportedContentTypes&&{supportedContentTypes:t.supportedContentTypes}}]));const x=["solve-and-answer","write-code","extract-css","recognize-content","convert-data","extract-entities","general-processing"];n.map(e=>{const t=(e=>{const t=String(e||"").toLowerCase().replace(/_/g,"-");return x.includes(t)?t:null})(e.id);return t?{type:t,instruction:r[e.instructionKey],supportedContentTypes:e.supportedContentTypes,priority:e.priority}:null}).filter(e=>Boolean(e));const M={[g]:l.WORK_CENTER,[h]:l.CLIPBOARD,[m]:l.MARKDOWN_VIEWER,[f]:l.SETTINGS,[w]:l.FILE_EXPLORER,[y]:l.PRINT_VIEWER};let S=null;function b(){var e;return S||(e={channelMappings:M,queueOptions:{dbName:"CrossWordMessageQueue",storeName:"messages",maxRetries:3,defaultExpirationMs:864e5},pendingStoreOptions:{storageKey:"rs-unified-messaging-pending",maxMessages:200,defaultTTLMs:864e5}},d||(d=new c(e)),S=d),S}const C=b();function I(e,t){C.registerHandler(e,t)}function R(e,t){C.unregisterHandler(e,t)}function A(e){return C.initializeComponent(e)}function T(e,t){C.registerComponent(e,t)}const N=Object.freeze(Object.defineProperty({__proto__:null,getUnifiedMessaging:b,initializeComponent:A,registerComponent:T,registerHandler:I,unifiedMessaging:C,unregisterHandler:R},Symbol.toStringTag,{value:"Module"}));export{l as BROADCAST_CHANNELS,p as COMPONENTS,u as ROUTE_HASHES,N as UnifiedMessaging,A as initializeComponent,T as registerComponent,I as registerHandler,R as unregisterHandler};
