{"version":3,"mappings":"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","names":["applyAppTheme"],"ignoreList":[],"sources":["../../../../modules/projects/uniform.ts/src/newer/messaging/ServiceChannelManager.ts","../../src/com/core/ServiceChannels.ts","../../src/frontend/views/ViewChannelMixin.ts","../../src/frontend/registry.ts","../../../../modules/projects/object.ts/src/wrap/AssignObject.ts","../../../../modules/projects/lur.e/src/extension/core/UIState.ts","../../src/core/storage/StateStorage.ts","../../src/core/utils/Theme.ts","../../../../modules/projects/veela.css/src/scss/runtime/core/index.ts","../../../../modules/projects/veela.css/src/scss/runtime/basic/index.ts","../../../../modules/projects/veela.css/src/scss/runtime/advanced/index.ts","../../../../modules/projects/veela.css/src/scss/runtime/beercss/index.ts","../../../../modules/projects/veela.css/src/scss/runtime/index.ts","../../src/frontend/main/BootLoader.ts","../../src/frontend/main/crx-entry.ts"],"sourcesContent":["/**\n * Service Channel Manager\n * Manages BroadcastChannel-based service channels for views and components\n * Part of fest/uniform - configurable without app-specific dependencies\n */\n\nimport { detectExecutionContext } from '../next/utils/Env';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Channel configuration\n */\nexport interface ServiceChannelConfig {\n    broadcastName: string;\n    routeHash?: string;\n    component?: string;\n    description?: string;\n}\n\n/**\n * Channel message format\n */\nexport interface ChannelMessage<T = unknown> {\n    type: string;\n    source: string;\n    target: string;\n    data: T;\n    timestamp: number;\n    correlationId?: string;\n}\n\n/**\n * Channel state\n */\nexport interface ChannelState {\n    connected: boolean;\n    lastActivity: number;\n    pendingMessages: number;\n}\n\n/**\n * Service channel manager configuration\n */\nexport interface ServiceChannelManagerConfig {\n    /** Channel configurations by ID */\n    channels?: Record<string, ServiceChannelConfig>;\n    /** Log prefix for debugging */\n    logPrefix?: string;\n}\n\n// ============================================================================\n// SERVICE CHANNEL MANAGER\n// ============================================================================\n\nexport class ServiceChannelManager<TChannelId extends string = string> {\n    private channels = new Map<TChannelId, BroadcastChannel>();\n    private readyPromises = new Map<TChannelId, { promise: Promise<void>; resolve: () => void }>();\n    private messageHandlers = new Map<TChannelId, Set<(msg: ChannelMessage) => void>>();\n    private channelConfigs: Record<string, ServiceChannelConfig>;\n    private executionContext: string;\n    private logPrefix: string;\n\n    constructor(config: ServiceChannelManagerConfig = {}) {\n        this.channelConfigs = config.channels ?? {};\n        this.logPrefix = config.logPrefix ?? '[ServiceChannels]';\n        this.executionContext = detectExecutionContext();\n        console.log(`${this.logPrefix} Initialized in ${this.executionContext} context`);\n    }\n\n    // ========================================================================\n    // CONFIGURATION\n    // ========================================================================\n\n    /**\n     * Register channel configurations\n     */\n    registerConfigs(configs: Record<string, ServiceChannelConfig>): void {\n        this.channelConfigs = { ...this.channelConfigs, ...configs };\n    }\n\n    /**\n     * Get channel configuration\n     */\n    getConfig(channelId: TChannelId): ServiceChannelConfig | undefined {\n        return this.channelConfigs[channelId];\n    }\n\n    /**\n     * Get all channel configurations\n     */\n    getAllConfigs(): Record<string, ServiceChannelConfig> {\n        return { ...this.channelConfigs };\n    }\n\n    // ========================================================================\n    // CHANNEL LIFECYCLE\n    // ========================================================================\n\n    /**\n     * Initialize a service channel\n     */\n    async initChannel(channelId: TChannelId): Promise<BroadcastChannel> {\n        // Return existing channel if already initialized\n        if (this.channels.has(channelId)) {\n            return this.channels.get(channelId)!;\n        }\n\n        const config = this.channelConfigs[channelId];\n        if (!config) {\n            throw new Error(`Unknown channel: ${channelId}. Register configuration first.`);\n        }\n\n        // Create deferred for ready state\n        let resolveReady!: () => void;\n        const readyPromise = new Promise<void>((resolve) => {\n            resolveReady = resolve;\n        });\n        this.readyPromises.set(channelId, { promise: readyPromise, resolve: resolveReady });\n\n        console.log(`${this.logPrefix} Initializing channel: ${channelId} -> ${config.broadcastName}`);\n\n        // Create broadcast channel\n        const channel = new BroadcastChannel(config.broadcastName);\n        \n        // Setup message handler\n        channel.onmessage = (event) => {\n            this.handleIncomingMessage(channelId, event.data);\n        };\n\n        channel.onmessageerror = (event) => {\n            console.error(`${this.logPrefix} Message error on ${channelId}:`, event);\n        };\n\n        this.channels.set(channelId, channel);\n        \n        // Mark as ready\n        resolveReady();\n        \n        console.log(`${this.logPrefix} Channel ready: ${channelId}`);\n        return channel;\n    }\n\n    /**\n     * Close a service channel\n     */\n    closeChannel(channelId: TChannelId): void {\n        const channel = this.channels.get(channelId);\n        if (channel) {\n            channel.close();\n            this.channels.delete(channelId);\n            this.readyPromises.delete(channelId);\n            this.messageHandlers.delete(channelId);\n            console.log(`${this.logPrefix} Channel closed: ${channelId}`);\n        }\n    }\n\n    /**\n     * Close all channels\n     */\n    closeAll(): void {\n        for (const channelId of this.channels.keys()) {\n            this.closeChannel(channelId);\n        }\n    }\n\n    /**\n     * Wait for a channel to be ready\n     */\n    async waitForChannel(channelId: TChannelId): Promise<void> {\n        const deferred = this.readyPromises.get(channelId);\n        if (deferred) {\n            await deferred.promise;\n        } else {\n            await this.initChannel(channelId);\n        }\n    }\n\n    // ========================================================================\n    // MESSAGING\n    // ========================================================================\n\n    /**\n     * Send a message to a channel\n     */\n    async send<T>(\n        target: TChannelId,\n        type: string,\n        data: T,\n        options: { correlationId?: string; source?: string } = {}\n    ): Promise<void> {\n        await this.waitForChannel(target);\n\n        const channel = this.channels.get(target);\n        if (!channel) {\n            throw new Error(`Channel not ready: ${target}`);\n        }\n\n        const message: ChannelMessage<T> = {\n            type,\n            source: options.source ?? this.executionContext,\n            target,\n            data,\n            timestamp: Date.now(),\n            correlationId: options.correlationId\n        };\n\n        channel.postMessage(message);\n        console.log(`${this.logPrefix} Sent message to ${target}:`, type);\n    }\n\n    /**\n     * Broadcast a message to all initialized channels\n     */\n    broadcast<T>(type: string, data: T, source?: string): void {\n        for (const [channelId, channel] of this.channels) {\n            const message: ChannelMessage<T> = {\n                type,\n                source: source ?? this.executionContext,\n                target: channelId,\n                data,\n                timestamp: Date.now()\n            };\n            channel.postMessage(message);\n        }\n        console.log(`${this.logPrefix} Broadcast message:`, type);\n    }\n\n    /**\n     * Subscribe to messages on a channel\n     */\n    subscribe(\n        channelId: TChannelId,\n        handler: (msg: ChannelMessage) => void\n    ): () => void {\n        if (!this.messageHandlers.has(channelId)) {\n            this.messageHandlers.set(channelId, new Set());\n        }\n\n        this.messageHandlers.get(channelId)!.add(handler);\n\n        // Initialize channel if not already\n        this.initChannel(channelId).catch(console.error);\n\n        // Return unsubscribe function\n        return () => {\n            this.messageHandlers.get(channelId)?.delete(handler);\n        };\n    }\n\n    /**\n     * Handle incoming message\n     */\n    private handleIncomingMessage(channelId: TChannelId, data: unknown): void {\n        const handlers = this.messageHandlers.get(channelId);\n        if (!handlers || handlers.size === 0) {\n            console.log(`${this.logPrefix} No handlers for ${channelId}, message queued`);\n            return;\n        }\n\n        const message = data as ChannelMessage;\n        for (const handler of handlers) {\n            try {\n                handler(message);\n            } catch (error) {\n                console.error(`${this.logPrefix} Handler error on ${channelId}:`, error);\n            }\n        }\n    }\n\n    // ========================================================================\n    // CHANNEL STATE\n    // ========================================================================\n\n    /**\n     * Check if channel is initialized\n     */\n    isInitialized(channelId: TChannelId): boolean {\n        return this.channels.has(channelId);\n    }\n\n    /**\n     * Get all initialized channel IDs\n     */\n    getInitializedChannels(): TChannelId[] {\n        return Array.from(this.channels.keys());\n    }\n\n    /**\n     * Get channel status\n     */\n    getStatus(): Record<string, ChannelState> {\n        const status: Record<string, ChannelState> = {};\n        \n        for (const channelId of Object.keys(this.channelConfigs)) {\n            status[channelId] = {\n                connected: this.channels.has(channelId as TChannelId),\n                lastActivity: Date.now(),\n                pendingMessages: 0\n            };\n        }\n\n        return status;\n    }\n\n    /**\n     * Get execution context\n     */\n    getExecutionContext(): string {\n        return this.executionContext;\n    }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create a new ServiceChannelManager instance\n */\nexport function createServiceChannelManager<TChannelId extends string = string>(\n    config?: ServiceChannelManagerConfig\n): ServiceChannelManager<TChannelId> {\n    return new ServiceChannelManager<TChannelId>(config);\n}\n\n// Default instance (optional singleton pattern)\nlet defaultManager: ServiceChannelManager | null = null;\n\n/**\n * Get or create the default ServiceChannelManager\n */\nexport function getServiceChannelManager(config?: ServiceChannelManagerConfig): ServiceChannelManager {\n    if (!defaultManager) {\n        defaultManager = new ServiceChannelManager(config);\n    } else if (config?.channels) {\n        defaultManager.registerConfigs(config.channels);\n    }\n    return defaultManager;\n}\n\n/**\n * Reset the default manager (useful for testing)\n */\nexport function resetServiceChannelManager(): void {\n    if (defaultManager) {\n        defaultManager.closeAll();\n        defaultManager = null;\n    }\n}\n","/**\n * Service Channels for CrossWord\n * Extends fest/uniform ServiceChannelManager with app-specific configuration\n */\n\nimport {\n    ServiceChannelManager,\n    createServiceChannelManager,\n    type ServiceChannelConfig,\n    type ChannelMessage,\n    type ChannelState\n} from 'fest/uniform';\n\nimport { BROADCAST_CHANNELS, ROUTE_HASHES, COMPONENTS } from '@rs-com/config/Names';\n\n// Re-export types for consumers\nexport type { ServiceChannelConfig, ChannelMessage, ChannelState };\n\n// ============================================================================\n// CHANNEL TYPES\n// ============================================================================\n\n/**\n * Service/view channel identifiers\n */\nexport type ServiceChannelId = \n    | \"workcenter\"\n    | \"settings\"\n    | \"viewer\"\n    | \"explorer\"\n    | \"airpad\"\n    | \"print\"\n    | \"history\"\n    | \"editor\"\n    | \"home\";\n\n// ============================================================================\n// APP-SPECIFIC CHANNEL CONFIGURATION\n// ============================================================================\n\nexport const SERVICE_CHANNEL_CONFIG: Record<ServiceChannelId, ServiceChannelConfig> = {\n    workcenter: {\n        broadcastName: BROADCAST_CHANNELS.WORK_CENTER,\n        routeHash: ROUTE_HASHES.WORKCENTER,\n        component: COMPONENTS.WORK_CENTER,\n        description: \"AI work center for processing files and content\"\n    },\n    settings: {\n        broadcastName: BROADCAST_CHANNELS.SETTINGS,\n        routeHash: ROUTE_HASHES.SETTINGS,\n        component: COMPONENTS.SETTINGS,\n        description: \"Application settings and configuration\"\n    },\n    viewer: {\n        broadcastName: BROADCAST_CHANNELS.MARKDOWN_VIEWER,\n        routeHash: ROUTE_HASHES.MARKDOWN_VIEWER,\n        component: COMPONENTS.MARKDOWN_VIEWER,\n        description: \"Content viewer for markdown and files\"\n    },\n    explorer: {\n        broadcastName: BROADCAST_CHANNELS.FILE_EXPLORER,\n        routeHash: ROUTE_HASHES.FILE_EXPLORER,\n        component: COMPONENTS.FILE_EXPLORER,\n        description: \"File explorer and browser\"\n    },\n    airpad: {\n        broadcastName: \"rs-airpad\",\n        routeHash: \"#airpad\",\n        component: \"airpad\",\n        description: \"Touch-friendly input pad\"\n    },\n    print: {\n        broadcastName: BROADCAST_CHANNELS.PRINT_CHANNEL,\n        routeHash: ROUTE_HASHES.PRINT,\n        component: COMPONENTS.BASIC_PRINT,\n        description: \"Print preview and export\"\n    },\n    history: {\n        broadcastName: BROADCAST_CHANNELS.HISTORY_CHANNEL,\n        routeHash: ROUTE_HASHES.HISTORY,\n        component: COMPONENTS.HISTORY,\n        description: \"Action history and undo/redo\"\n    },\n    editor: {\n        broadcastName: \"rs-editor\",\n        routeHash: ROUTE_HASHES.MARKDOWN_EDITOR,\n        component: COMPONENTS.MARKDOWN_EDITOR,\n        description: \"Content editor\"\n    },\n    home: {\n        broadcastName: \"rs-home\",\n        routeHash: \"#home\",\n        component: \"home\",\n        description: \"Home/landing view\"\n    }\n};\n\n// ============================================================================\n// APP-SPECIFIC SERVICE CHANNEL MANAGER\n// ============================================================================\n\nlet appServiceChannelManager: ServiceChannelManager<ServiceChannelId> | null = null;\n\n/**\n * Get the app-configured ServiceChannelManager\n */\nexport function getServiceChannels(): ServiceChannelManager<ServiceChannelId> {\n    if (!appServiceChannelManager) {\n        appServiceChannelManager = createServiceChannelManager<ServiceChannelId>({\n            channels: SERVICE_CHANNEL_CONFIG,\n            logPrefix: '[ServiceChannels]'\n        });\n    }\n    return appServiceChannelManager;\n}\n\n// Singleton instance for backward compatibility\nexport const serviceChannels = getServiceChannels();\n\n// ============================================================================\n// CONVENIENCE EXPORTS\n// ============================================================================\n\n/**\n * Initialize a service channel\n */\nexport const initServiceChannel = (channelId: ServiceChannelId) => \n    serviceChannels.initChannel(channelId);\n\n/**\n * Send a message to a channel\n */\nexport const sendToChannel = <T>(target: ServiceChannelId, type: string, data: T) =>\n    serviceChannels.send(target, type, data);\n\n/**\n * Subscribe to channel messages\n */\nexport const affectedToChannel = (\n    channelId: ServiceChannelId,\n    handler: (msg: ChannelMessage) => void\n) => serviceChannels.affected(channelId, handler);\n\n/**\n * Broadcast to all channels\n */\nexport const broadcastToAll = <T>(type: string, data: T) =>\n    serviceChannels.broadcast(type, data);\n\n// Re-export the ServiceChannelManager class for advanced usage\nexport { ServiceChannelManager };\n","/**\n * View Channel Mixin\n * \n * Provides uniform channel connectivity for views.\n * Views can use this mixin to:\n * - Connect to service worker channels\n * - Send/receive messages through broadcast channels\n * - Handle share target and launch queue data\n */\n\nimport type { View, ViewLifecycle, ViewOptions, ShellContext } from \"../shells/types\";\nimport { \n    serviceChannels, \n    affectedToChannel,\n    sendToChannel,\n    type ServiceChannelId,\n    type ChannelMessage \n} from \"@rs-com/core/ServiceChannels\";\nimport { BROADCAST_CHANNELS, MESSAGE_TYPES } from \"@rs-com/config/Names\";\nimport {\n    registerHandler,\n    unregisterHandler,\n    registerComponent,\n    initializeComponent,\n    type UnifiedMessage,\n    type MessageHandler\n} from \"@rs-com/core/UnifiedMessaging\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Message handler function type\n */\nexport type ViewMessageHandler<T = unknown> = (message: ChannelMessage<T>) => void | Promise<void>;\n\n/**\n * Channel-connected view interface\n */\nexport interface ChannelConnectedView extends View {\n    /** Channel ID for this view */\n    channelId: ServiceChannelId;\n    /** Connect to the service channel */\n    connectChannel(): Promise<void>;\n    /** Disconnect from the service channel */\n    disconnectChannel(): void;\n    /** Send a message through the channel */\n    sendMessage<T>(type: string, data: T): Promise<void>;\n    /** Check if connected */\n    isChannelConnected(): boolean;\n}\n\n/**\n * Options for channel-connected views\n */\nexport interface ChannelViewOptions extends ViewOptions {\n    /** Channel ID to connect to */\n    channelId?: ServiceChannelId;\n    /** Auto-connect on mount */\n    autoConnect?: boolean;\n    /** Message handlers */\n    messageHandlers?: Map<string, ViewMessageHandler>;\n}\n\n// ============================================================================\n// VIEW CHANNEL MIXIN\n// ============================================================================\n\n/**\n * Creates a channel-connected view by mixing channel functionality into an existing view.\n * \n * Usage:\n * ```ts\n * class MyView implements View { ... }\n * const ConnectedView = withViewChannel(MyView, \"workcenter\");\n * ```\n */\nexport function withViewChannel<T extends new (...args: any[]) => View>(\n    ViewClass: T,\n    defaultChannelId: ServiceChannelId\n) {\n    return class extends ViewClass implements ChannelConnectedView {\n        channelId: ServiceChannelId = defaultChannelId;\n        private _channelUnaffected: (() => void) | null = null;\n        private _channelConnected = false;\n        private _messageHandlers = new Map<string, Set<ViewMessageHandler>>();\n\n        constructor(...args: any[]) {\n            super(...args);\n            \n            // Extract channel options if provided\n            const options = args[0] as ChannelViewOptions | undefined;\n            if (options?.channelId) {\n                this.channelId = options.channelId;\n            }\n        }\n\n        async connectChannel(): Promise<void> {\n            if (this._channelConnected) return;\n\n            console.log(`[ViewChannel] Connecting ${this.id} to channel ${this.channelId}`);\n\n            // Initialize the service channel\n            await serviceChannels.initChannel(this.channelId);\n\n            // Subscribe to messages\n            this._channelUnaffected = affectedToChannel(\n                this.channelId,\n                (message) => this._handleChannelMessage(message)\n            );\n\n            this._channelConnected = true;\n            console.log(`[ViewChannel] ${this.id} connected to ${this.channelId}`);\n        }\n\n        disconnectChannel(): void {\n            if (this._channelUnaffected) {\n                this._channelUnaffected();\n                this._channelUnaffected = null;\n            }\n            this._channelConnected = false;\n            console.log(`[ViewChannel] ${this.id} disconnected from ${this.channelId}`);\n        }\n\n        async sendMessage<D>(type: string, data: D): Promise<void> {\n            if (!this._channelConnected) {\n                await this.connectChannel();\n            }\n            await sendToChannel(this.channelId, type, data);\n        }\n\n        isChannelConnected(): boolean {\n            return this._channelConnected;\n        }\n\n        /**\n         * Register a message handler\n         */\n        onChannelMessage(type: string, handler: ViewMessageHandler): () => void {\n            if (!this._messageHandlers.has(type)) {\n                this._messageHandlers.set(type, new Set());\n            }\n            this._messageHandlers.get(type)!.add(handler);\n\n            return () => {\n                this._messageHandlers.get(type)?.delete(handler);\n            };\n        }\n\n        /**\n         * Handle incoming channel message\n         */\n        private _handleChannelMessage(message: ChannelMessage): void {\n            // Call type-specific handlers\n            const handlers = this._messageHandlers.get(message.type);\n            if (handlers) {\n                for (const handler of handlers) {\n                    try {\n                        handler(message);\n                    } catch (error) {\n                        console.error(`[ViewChannel] Handler error:`, error);\n                    }\n                }\n            }\n\n            // Call the view's handleMessage if it exists\n            if (typeof (this as any).handleMessage === \"function\") {\n                (this as any).handleMessage(message).catch(console.error);\n            }\n        }\n\n        // Override lifecycle to connect/disconnect channel\n        get lifecycle(): ViewLifecycle {\n            const parentLifecycle = super.lifecycle || {};\n            \n            return {\n                ...parentLifecycle,\n                onMount: async () => {\n                    await this.connectChannel();\n                    if (parentLifecycle.onMount) {\n                        await parentLifecycle.onMount();\n                    }\n                },\n                onUnmount: async () => {\n                    this.disconnectChannel();\n                    if (parentLifecycle.onUnmount) {\n                        await parentLifecycle.onUnmount();\n                    }\n                }\n            };\n        }\n    };\n}\n\n// ============================================================================\n// SHARE TARGET HANDLER MIXIN\n// ============================================================================\n\n/**\n * Share target handler interface\n */\nexport interface ShareTargetHandler {\n    /** Handle incoming share target data */\n    handleShareTarget(data: ShareTargetData): Promise<void>;\n    /** Check if view can handle share target */\n    canHandleShareTarget(data: ShareTargetData): boolean;\n}\n\n/**\n * Share target data structure\n */\nexport interface ShareTargetData {\n    title?: string;\n    text?: string;\n    url?: string;\n    files?: File[];\n    timestamp: number;\n    source: \"share-target\" | \"launch-queue\" | \"clipboard\";\n}\n\n/**\n * Mixin for views that can handle share targets\n */\nexport function withShareTargetHandler<T extends new (...args: any[]) => View>(\n    ViewClass: T\n) {\n    return class extends ViewClass implements ShareTargetHandler {\n        private _shareTargetChannel: BroadcastChannel | null = null;\n\n        constructor(...args: any[]) {\n            super(...args);\n        }\n\n        async handleShareTarget(data: ShareTargetData): Promise<void> {\n            console.log(`[ShareTarget] ${this.id} received:`, data);\n            \n            // Default implementation - override in subclass\n            if (typeof (this as any).handleMessage === \"function\") {\n                await (this as any).handleMessage({\n                    type: MESSAGE_TYPES.SHARE_TARGET_INPUT,\n                    data\n                });\n            }\n        }\n\n        canHandleShareTarget(data: ShareTargetData): boolean {\n            // Default: can handle if view has handleMessage method\n            return typeof (this as any).handleMessage === \"function\";\n        }\n\n        /**\n         * Start listening for share target broadcasts\n         */\n        protected startShareTargetListener(): void {\n            if (this._shareTargetChannel) return;\n\n            this._shareTargetChannel = new BroadcastChannel(BROADCAST_CHANNELS.SHARE_TARGET);\n            this._shareTargetChannel.onmessage = async (event) => {\n                const { type, data } = event.data || {};\n                \n                if (type === MESSAGE_TYPES.SHARE_RECEIVED && this.canHandleShareTarget(data)) {\n                    await this.handleShareTarget(data);\n                }\n            };\n        }\n\n        /**\n         * Stop listening for share target broadcasts\n         */\n        protected stopShareTargetListener(): void {\n            if (this._shareTargetChannel) {\n                this._shareTargetChannel.close();\n                this._shareTargetChannel = null;\n            }\n        }\n\n        // Override lifecycle\n        get lifecycle(): ViewLifecycle {\n            const parentLifecycle = super.lifecycle || {};\n            \n            return {\n                ...parentLifecycle,\n                onMount: async () => {\n                    this.startShareTargetListener();\n                    if (parentLifecycle.onMount) {\n                        await parentLifecycle.onMount();\n                    }\n                },\n                onUnmount: async () => {\n                    this.stopShareTargetListener();\n                    if (parentLifecycle.onUnmount) {\n                        await parentLifecycle.onUnmount();\n                    }\n                }\n            };\n        }\n    };\n}\n\n// ============================================================================\n// COMBINED MIXINS\n// ============================================================================\n\n/**\n * Creates a fully connected view with channel and share target support\n */\nexport function withFullChannelSupport<T extends new (...args: any[]) => View>(\n    ViewClass: T,\n    channelId: ServiceChannelId\n) {\n    return withShareTargetHandler(withViewChannel(ViewClass, channelId));\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Check for pending share target data and deliver to view\n */\nexport async function checkAndDeliverShareData(\n    view: View & Partial<ShareTargetHandler>\n): Promise<boolean> {\n    if (!view.handleShareTarget || !view.canHandleShareTarget) {\n        return false;\n    }\n\n    try {\n        // Check for cached content from SW\n        const response = await fetch(\"/sw-content/available\");\n        const { cacheKeys } = await response.json();\n        \n        if (cacheKeys && cacheKeys.length > 0) {\n            const latest = cacheKeys[cacheKeys.length - 1];\n            if (latest.context === \"share-target\") {\n                // Fetch the cached content\n                const contentResponse = await fetch(`/sw-content/${latest.key}`);\n                const { content } = await contentResponse.json();\n                \n                const shareData: ShareTargetData = {\n                    ...content,\n                    timestamp: Date.now(),\n                    source: \"share-target\"\n                };\n\n                if (view.canHandleShareTarget(shareData)) {\n                    await view.handleShareTarget(shareData);\n                    return true;\n                }\n            }\n        }\n    } catch (error) {\n        console.warn(\"[ViewChannel] Failed to check share data:\", error);\n    }\n\n    return false;\n}\n\n/**\n * Check URL params for cached content\n */\nexport function getContentFromUrlParams(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get(\"cached\") || params.get(\"markdown-content\");\n}\n\nexport interface ViewReceiveBindingOptions {\n    destination?: string;\n    componentId?: string;\n}\n\nconst VIEW_MESSAGE_FALLBACKS: Record<string, string[]> = {\n    viewer: [\"content-view\", \"content-load\", \"markdown-content\"],\n    workcenter: [\"content-attach\", \"file-attach\", \"share-target-input\", \"content-share\"],\n    explorer: [\"file-save\", \"navigate-path\", \"content-explorer\"],\n    editor: [\"content-load\", \"content-edit\"],\n    settings: [\"settings-update\"],\n    history: [\"history-update\"],\n    home: [\"home-update\"],\n    airpad: [\"content-load\"],\n    print: [\"content-view\"]\n};\n\nconst inferDestination = (viewId: string): string => {\n    if (viewId === \"viewer\") return \"viewer\";\n    if (viewId === \"workcenter\") return \"workcenter\";\n    if (viewId === \"explorer\") return \"explorer\";\n    if (viewId === \"editor\") return \"editor\";\n    if (viewId === \"settings\") return \"settings\";\n    if (viewId === \"history\") return \"history\";\n    if (viewId === \"print\") return \"print\";\n    if (viewId === \"airpad\") return \"airpad\";\n    return viewId || \"viewer\";\n};\n\nconst selectMessageTypeForView = (view: View, incomingType: string): string | null => {\n    const checks = [incomingType, ...(VIEW_MESSAGE_FALLBACKS[view.id] || [])];\n    for (const type of checks) {\n        if (!type) continue;\n        if (!view.canHandleMessage || view.canHandleMessage(type)) {\n            return type;\n        }\n    }\n    return null;\n};\n\nconst toViewMessage = (view: View, message: UnifiedMessage): { type: string; data: unknown; metadata?: unknown } | null => {\n    const selectedType = selectMessageTypeForView(view, message.type);\n    if (!selectedType) return null;\n\n    return {\n        type: selectedType,\n        data: message.data,\n        metadata: message.metadata\n    };\n};\n\nexport function bindViewReceiveChannel(\n    view: View,\n    options: ViewReceiveBindingOptions = {}\n): () => void {\n    if (!view.handleMessage) {\n        return () => { };\n    }\n\n    const destination = options.destination || inferDestination(String(view.id || \"\"));\n    const componentId = options.componentId || `view:${view.id}`;\n\n    const handler: MessageHandler = {\n        canHandle: (message) => message.destination === destination,\n        handle: async (message) => {\n            const mapped = toViewMessage(view, message as UnifiedMessage);\n            if (!mapped) return;\n            await view.handleMessage?.(mapped);\n        }\n    };\n\n    registerComponent(componentId, destination);\n    registerHandler(destination, handler);\n\n    const pending = initializeComponent(componentId);\n    if (pending.length > 0) {\n        for (const message of pending) {\n            void handler.handle(message);\n        }\n    }\n\n    return () => {\n        unregisterHandler(destination, handler);\n    };\n}\n","/**\n * Shell and View Registry\n *\n * Central registry for shell and view components.\n * Supports lazy loading and caching.\n */\n\nimport type {\n    ShellId,\n    ViewId,\n    ShellRegistration,\n    ViewRegistration,\n    BootConfig,\n    Shell,\n    View,\n    ViewFactory,\n    ShellTheme\n} from \"./shells/types\";\nimport { bindViewReceiveChannel } from \"./views/ViewChannelMixin\";\n\n// ============================================================================\n// SHELL REGISTRY\n// ============================================================================\n\n/**\n * Registry for shell components\n */\nclass ShellRegistryClass {\n    private shells = new Map<ShellId, ShellRegistration>();\n    private loadedShells = new Map<ShellId, Shell>();\n\n    /**\n     * Register a shell\n     */\n    register(registration: ShellRegistration): void {\n        this.shells.set(registration.id, registration);\n    }\n\n    /**\n     * Get a shell registration\n     */\n    get(id: ShellId): ShellRegistration | undefined {\n        return this.shells.get(id);\n    }\n\n    /**\n     * Get all registered shells\n     */\n    getAll(): ShellRegistration[] {\n        return Array.from(this.shells.values());\n    }\n\n    /**\n     * Load and instantiate a shell\n     */\n    async load(id: ShellId, container: HTMLElement): Promise<Shell> {\n        // Return cached instance if available\n        const cached = this.loadedShells.get(id);\n        if (cached) {\n            return cached;\n        }\n\n        const registration = this.shells.get(id);\n        if (!registration) {\n            throw new Error(`Shell not found: ${id}`);\n        }\n\n        const module = await registration.loader();\n        const factory = (module as any).default || (module as any).createShell;\n\n        if (typeof factory !== \"function\") {\n            throw new Error(`Invalid shell module: ${id}`);\n        }\n\n        const shell = factory(container);\n        this.loadedShells.set(id, shell);\n        return shell;\n    }\n\n    /**\n     * Unload a shell\n     */\n    unload(id: ShellId): void {\n        const shell = this.loadedShells.get(id);\n        if (shell) {\n            shell.unmount();\n            this.loadedShells.delete(id);\n        }\n    }\n\n    /**\n     * Check if a shell is loaded\n     */\n    isLoaded(id: ShellId): boolean {\n        return this.loadedShells.has(id);\n    }\n\n    /**\n     * Get a loaded shell instance\n     */\n    getLoaded(id: ShellId): Shell | undefined {\n        return this.loadedShells.get(id);\n    }\n}\n\nexport const ShellRegistry = new ShellRegistryClass();\n\n// ============================================================================\n// VIEW REGISTRY\n// ============================================================================\n\n/**\n * Registry for view components\n */\nclass ViewRegistryClass {\n    private views = new Map<ViewId, ViewRegistration>();\n    private loadedViews = new Map<ViewId, View>();\n    private viewReceiveCleanup = new Map<ViewId, () => void>();\n\n    /**\n     * Register a view\n     */\n    register(registration: ViewRegistration): void {\n        this.views.set(registration.id, registration);\n    }\n\n    /**\n     * Get a view registration\n     */\n    get(id: ViewId): ViewRegistration | undefined {\n        return this.views.get(id);\n    }\n\n    /**\n     * Get all registered views\n     */\n    getAll(): ViewRegistration[] {\n        return Array.from(this.views.values());\n    }\n\n    /**\n     * Load and instantiate a view\n     */\n    async load(id: ViewId, options?: Parameters<ViewFactory>[0]): Promise<View> {\n        // Return cached instance if available and no new options\n        const cached = this.loadedViews.get(id);\n        if (cached && !options) {\n            return cached;\n        }\n\n        const registration = this.views.get(id);\n        if (!registration) {\n            throw new Error(`View not found: ${id}`);\n        }\n\n        const module = await registration.loader();\n        const factory: ViewFactory = (module as any).default || (module as any).createView;\n\n        if (typeof factory !== \"function\") {\n            throw new Error(`Invalid view module: ${id}`);\n        }\n\n        const view = await factory(options);\n\n        const previousCleanup = this.viewReceiveCleanup.get(id);\n        if (previousCleanup) {\n            previousCleanup();\n            this.viewReceiveCleanup.delete(id);\n        }\n\n        this.loadedViews.set(id, view);\n        this.viewReceiveCleanup.set(id, bindViewReceiveChannel(view, {\n            destination: String(id),\n            componentId: `view:${id}`\n        }));\n        return view;\n    }\n\n    /**\n     * Unload a view (clear cache)\n     */\n    unload(id: ViewId): void {\n        const view = this.loadedViews.get(id);\n        if (view?.lifecycle?.onUnmount) {\n            view.lifecycle.onUnmount();\n        }\n        const receiveCleanup = this.viewReceiveCleanup.get(id);\n        if (receiveCleanup) {\n            receiveCleanup();\n            this.viewReceiveCleanup.delete(id);\n        }\n        this.loadedViews.delete(id);\n    }\n\n    /**\n     * Check if a view is loaded\n     */\n    isLoaded(id: ViewId): boolean {\n        return this.loadedViews.has(id);\n    }\n\n    /**\n     * Get a loaded view instance\n     */\n    getLoaded(id: ViewId): View | undefined {\n        return this.loadedViews.get(id);\n    }\n}\n\nexport const ViewRegistry = new ViewRegistryClass();\n\n// ============================================================================\n// DEFAULT REGISTRATIONS\n// ============================================================================\n\n/**\n * Register default shells\n */\nexport function registerDefaultShells(): void {\n    // Raw shell (minimal, no frames)\n    ShellRegistry.register({\n        id: \"base\",\n        name: \"Base\",\n        description: \"Base shell with no frames or navigation\",\n        loader: () => import(\"./shells/base/index\")\n    });\n\n    // Minimalshell (simple toolbar-based navigation)\n    ShellRegistry.register({\n        id: \"minimal\",\n        name: \"Minimal\",\n        description: \"Minimal toolbar-based navigation\",\n        loader: () => import(\"./shells/minimal/index\")\n    });\n\n    // Faint shell (tabbed sidebar navigation)\n    ShellRegistry.register({\n        id: \"faint\",\n        name: \"Faint\",\n        description: \"Experimental tabbed interface with sidebar\",\n        loader: () => import(\"./shells/faint/index\")\n    });\n}\n\n/**\n * Register default views\n */\nexport function registerDefaultViews(): void {\n    ViewRegistry.register({\n        id: \"viewer\",\n        name: \"Viewer\",\n        icon: \"eye\",\n        loader: () => import(\"./views/viewer\")\n    });\n\n    ViewRegistry.register({\n        id: \"workcenter\",\n        name: \"Work Center\",\n        icon: \"lightning\",\n        loader: () => import(\"./views/workcenter\")\n    });\n\n    ViewRegistry.register({\n        id: \"settings\",\n        name: \"Settings\",\n        icon: \"gear\",\n        loader: () => import(\"./views/settings\")\n    });\n\n    ViewRegistry.register({\n        id: \"history\",\n        name: \"History\",\n        icon: \"clock-counter-clockwise\",\n        loader: () => import(\"./views/history\")\n    });\n\n    ViewRegistry.register({\n        id: \"explorer\",\n        name: \"Explorer\",\n        icon: \"folder\",\n        loader: () => import(\"./views/explorer\")\n    });\n\n    ViewRegistry.register({\n        id: \"airpad\",\n        name: \"Airpad\",\n        icon: \"hand-pointing\",\n        loader: () => import(\"./views/airpad\")\n    });\n\n    ViewRegistry.register({\n        id: \"editor\",\n        name: \"Editor\",\n        icon: \"pencil\",\n        loader: () => import(\"./views/editor\")\n    });\n\n    ViewRegistry.register({\n        id: \"home\",\n        name: \"Home\",\n        icon: \"house\",\n        loader: () => import(\"./views/home\")\n    });\n\n    ViewRegistry.register({\n        id: \"print\",\n        name: \"Print\",\n        icon: \"printer\",\n        loader: () => import(\"./views/print\")\n    });\n}\n\n// ============================================================================\n// DEFAULT THEME\n// ============================================================================\n\nexport const defaultTheme: ShellTheme = {\n    id: \"auto\",\n    name: \"Auto\",\n    colorScheme: \"auto\"\n};\n\nexport const lightTheme: ShellTheme = {\n    id: \"light\",\n    name: \"Light\",\n    colorScheme: \"light\"\n};\n\nexport const darkTheme: ShellTheme = {\n    id: \"dark\",\n    name: \"Dark\",\n    colorScheme: \"dark\"\n};\n\n// ============================================================================\n// BOOT CONFIGURATION\n// ============================================================================\n\n/**\n * Get default boot configuration\n */\nexport function getDefaultBootConfig(): BootConfig {\n    return {\n        defaultShell: \"minimal\",\n        defaultView: \"viewer\",\n        theme: defaultTheme,\n        rememberShellChoice: true,\n        availableShells: ShellRegistry.getAll(),\n        availableViews: ViewRegistry.getAll()\n    };\n}\n\n/**\n * Initialize registries with default shells and views\n */\nexport function initializeRegistries(): void {\n    registerDefaultShells();\n    registerDefaultViews();\n}\n","import { objectAssign } from \"fest/core\";\nimport { $originalKey$ } from \"./Symbol\";\nimport { $originalObjects$, type keyType, type observeValid } from \"./Utils\";\n\n//\nexport class AssignObjectHandler {\n    constructor() { }\n    deleteProperty(target, name: keyType) { const result = Reflect.deleteProperty(target, name); return result; }\n    construct(target, args, newT) { return Reflect.construct(target, args, newT); }\n    apply(target, ctx, args) { return Reflect.apply(target, ctx, args); }\n    has(target, prop: keyType) { return Reflect.has(target, prop); }\n    set(target, name: keyType, value) { objectAssign(target, value, name); return true; }\n    get(target, name: keyType, ctx) {\n        if (typeof name == \"symbol\") { return target?.[name] ?? target; }\n        return Reflect.get(target, name, ctx);\n    }\n}\n\n//\nexport const makeObjectAssignable = <Under = any>(obj: Under): observeValid<Under> => {\n    // @ts-ignore\n    if (obj?.[$originalKey$] || $originalObjects$.has(obj)) { return obj; }\n\n    // @ts-ignore\n    const px = new Proxy(obj, new AssignObjectHandler());\n    $originalObjects$.set(px, obj); return px;\n}\n","import { JSOX } from \"jsox\";\nimport { addEvent, setIdleInterval } from \"fest/dom\";\nimport { safe, addToCallChain } from \"fest/object\";\n// Wait, I should not break imports if I overwrite the file.\n// The previous file had everything inline. I will keep everything inline but modified.\n\n// ... helper functions ...\nconst mapEntriesFrom = (source: any) => {\n    if (!source) return [];\n    if (source instanceof Map) return Array.from(source.entries());\n    if (Array.isArray(source)) {\n        return source.map((value, index) => {\n            if (Array.isArray(value) && value.length === 2) {\n                return value as [any, any];\n            }\n            return [index, value] as [any, any];\n        });\n    }\n    if (source instanceof Set) {\n        return Array.from(source.values()).map((value, index) => [index, value] as [any, any]);\n    }\n    if (typeof source === \"object\") {\n        return Object.entries(source as Record<any, any>);\n    }\n    return [];\n};\n\nconst ownProp = Object.prototype.hasOwnProperty;\n\nconst isPlainObject = (value: any): value is Record<PropertyKey, any>=>{\n    if (!value || typeof value !== \"object\") return false;\n    if (Array.isArray(value)) return false;\n    return !(value instanceof Map) && !(value instanceof Set);\n};\n\nconst identityOf = (value: any, fallback?: any)=>{\n    if (value && typeof value === \"object\") {\n        if (\"id\" in value && (value as any).id != null) return (value as any).id;\n        if (\"key\" in value && (value as any).key != null) return (value as any).key;\n    }\n    return fallback;\n};\n\nconst resolveEntryKey = (entryKey: any, value: any, fallback?: any)=>{\n    if (entryKey != null) return entryKey;\n    const identity = identityOf(value);\n    if (identity != null) return identity;\n    return fallback;\n};\n\nconst mergePlainObject = (target: Record<PropertyKey, any>, source: Record<PropertyKey, any>)=>{\n    for (const key of Object.keys(source)) {\n        const nextValue = source[key];\n        const currentValue = target[key];\n        if (isPlainObject(currentValue) && isPlainObject(nextValue)) {\n            mergePlainObject(currentValue, nextValue);\n            continue;\n        }\n        if (currentValue !== nextValue) {\n            target[key] = nextValue;\n        }\n    }\n    return target;\n};\n\nconst mergeValue = (target: any, source: any)=>{\n    if (target === source) return target;\n    const sourceIsObject = source && typeof source === \"object\";\n\n    if (target instanceof Map && sourceIsObject) {\n        reloadInto(target, source);\n        return target;\n    }\n\n    if (target instanceof Set && sourceIsObject) {\n        reloadInto(target, source);\n        return target;\n    }\n\n    if (Array.isArray(target) && sourceIsObject) {\n        reloadInto(target, source);\n        return target;\n    }\n\n    if (isPlainObject(target) && isPlainObject(source)) {\n        mergePlainObject(target, source);\n        return target;\n    }\n\n    return source;\n};\n\nexport const reloadInto = (items: any|any[]|Set<any>|Map<any, any>, map: any)=>{\n    if (!items || !map) return items;\n    const entries = mapEntriesFrom(map);\n    if (!entries.length) return items;\n\n    if (items instanceof Set) {\n        const existingByKey = new Map<any, any>();\n        for (const value of items.values()) {\n            const key = identityOf(value);\n            if (key != null) existingByKey.set(key, value);\n        }\n\n        const usedKeys = new Set<any>();\n        for (const [entryKey, incoming] of entries) {\n            const key = resolveEntryKey(entryKey, incoming);\n            if (key == null) {\n                if (!items.has(incoming)) items.add(incoming);\n                continue;\n            }\n\n            const hasCurrent = existingByKey.has(key);\n            const current = hasCurrent ? existingByKey.get(key) : undefined;\n            if (hasCurrent) {\n                const merged = mergeValue(current, incoming);\n                if (merged !== current) {\n                    items.delete(current);\n                    items.add(merged);\n                    existingByKey.set(key, merged);\n                }\n            } else {\n                items.add(incoming);\n                existingByKey.set(key, incoming);\n            }\n            usedKeys.add(key);\n        }\n\n        if (usedKeys.size) {\n            for (const value of Array.from(items.values())) {\n                const key = identityOf(value);\n                if (key != null && !usedKeys.has(key)) {\n                    items.delete(value);\n                }\n            }\n        }\n        return items;\n    }\n\n    if (items instanceof Map) {\n        const nextMap = new Map(entries);\n\n        for (const key of Array.from(items.keys())) {\n            if (!nextMap.has(key)) items.delete(key);\n        }\n\n        for (const [key, incoming] of nextMap.entries()) {\n            if (items.has(key)) {\n                const current = items.get(key);\n                const merged = mergeValue(current, incoming);\n                if (merged !== current) items.set(key, merged);\n            } else {\n                items.set(key, incoming);\n            }\n        }\n        return items;\n    }\n\n    if (Array.isArray(items)) {\n        const availableIndexes = new Set<number>();\n        const existingByKey = new Map<any, number>();\n        const existingByObject = new WeakMap<object, number>();\n\n        items.forEach((value, index)=>{\n            availableIndexes.add(index);\n            const key = identityOf(value, index);\n            if (key != null && !existingByKey.has(key)) {\n                existingByKey.set(key, index);\n            }\n            if (value && typeof value === \"object\") {\n                existingByObject.set(value, index);\n            }\n        });\n\n        const takeIndex = (index?: number)=>{\n            if (index == null) return undefined;\n            if (!availableIndexes.has(index)) return undefined;\n            availableIndexes.delete(index);\n            return index;\n        };\n\n        const takeNextAvailable = ()=>{\n            const iterator = availableIndexes.values().next();\n            if (iterator.done) return undefined;\n            const index = iterator.value;\n            availableIndexes.delete(index);\n            return index;\n        };\n\n        let writeIndex = 0;\n        let fallbackIndex = 0;\n\n        for (const [entryKey, incoming] of entries) {\n            const key = resolveEntryKey(entryKey, incoming, fallbackIndex++);\n            let claimedIndex = takeIndex(key != null ? existingByKey.get(key) : undefined);\n\n            if (claimedIndex == null && incoming && typeof incoming === \"object\") {\n                claimedIndex = takeIndex(existingByObject.get(incoming));\n            }\n\n            if (claimedIndex == null) {\n                claimedIndex = takeNextAvailable();\n            }\n\n            const current = claimedIndex != null ? items[claimedIndex] : undefined;\n            const merged = current !== undefined ? mergeValue(current, incoming) : incoming;\n\n            if (writeIndex < items.length) {\n                if (items[writeIndex] !== merged) items[writeIndex] = merged;\n            } else {\n                items.push(merged);\n            }\n\n            writeIndex++;\n        }\n\n        while (items.length > writeIndex) items.pop();\n        return items;\n    }\n\n    if (typeof items === \"object\") {\n        const nextKeys = new Set(entries.map(([key])=>String(key)));\n        for (const prop of Object.keys(items)) {\n            if (!nextKeys.has(prop)) delete (items as any)[prop];\n        }\n\n        for (const [entryKey, incoming] of entries) {\n            const prop = String(entryKey);\n            if (ownProp.call(items, prop)) {\n                const current = (items as any)[prop];\n                const merged = mergeValue(current, incoming);\n                if (merged !== current) (items as any)[prop] = merged;\n            } else {\n                (items as any)[prop] = incoming;\n            }\n        }\n        return items;\n    }\n\n    return items;\n}\n\nexport const mergeByKey = (items: any|any[]|Set<any>|Map<any, any>, key = \"id\")=>{\n    if (items && (items instanceof Set || Array.isArray(items))) {\n        const entries = Array.from(items?.values?.() || []).map((I)=>[I?.[key],I]).filter((I)=>I?.[0] != null);\n        return reloadInto(items, new Map(entries as any));\n    }\n    return items;\n}\n\nconst hasChromeStorage = () => typeof chrome !== \"undefined\" && chrome?.storage?.local;\n\nexport const makeUIState = (storageKey, initialCb, unpackCb, packCb = (items) => safe(items), key = \"id\", saveInterval = 6000)=>{\n    let state = null;\n    state = mergeByKey(initialCb?.() || {}, key);\n\n    // Load initial state\n    if (hasChromeStorage()) {\n        chrome.storage.local.get([storageKey], (result) => {\n            if (result[storageKey]) {\n                const unpacked = unpackCb(JSOX.parse(result?.[storageKey] as string || \"{}\"));\n                reloadInto(state, unpacked);\n            }\n        });\n    } else if (typeof localStorage !== \"undefined\") {\n        if (localStorage.getItem(storageKey)) {\n            state = unpackCb(JSOX.parse(localStorage.getItem(storageKey) || \"{}\"));\n            mergeByKey(state, key);\n        } else {\n            localStorage.setItem(storageKey, JSOX.stringify(packCb(state)));\n        }\n    }\n\n    // Save function\n    const saveInStorage = (ev?: any)=>{\n        const packed = JSOX.stringify(packCb(mergeByKey(state, key)));\n        if (hasChromeStorage()) {\n            chrome.storage.local.set({ [storageKey]: packed });\n        } else if (typeof localStorage !== \"undefined\") {\n            localStorage.setItem(storageKey, packed);\n        }\n    }\n\n    // Periodic save\n    setIdleInterval(saveInStorage, saveInterval);\n\n    // Event listeners\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        const listening = [\n            addEvent(document, \"visibilitychange\", (ev)=>{ if (document.visibilityState === \"hidden\") { saveInStorage(ev); } }),\n            addEvent(window, \"beforeunload\", (ev)=>saveInStorage(ev)),\n            addEvent(window, \"pagehide\", (ev)=>saveInStorage(ev)),\n            // Standard storage event for localStorage\n            addEvent(window, \"storage\", (ev)=>{\n                if (ev.storageArea == localStorage && ev.key == storageKey) {\n                    reloadInto(state, unpackCb(JSOX.parse(ev?.newValue || JSOX.stringify(packCb(mergeByKey(state, key))))));\n                }\n            })\n        ];\n\n        addToCallChain(state, Symbol.dispose, ()=>listening.forEach(ub=>ub?.()));\n    }\n\n    // Chrome storage listener\n    if (hasChromeStorage()) {\n        const listener = (changes, area) => {\n            if (area === 'local' && changes[storageKey]) {\n                const newValue = changes[storageKey].newValue;\n                if (newValue) {\n                    reloadInto(state, unpackCb(JSOX.parse(newValue)));\n                }\n            }\n        };\n        chrome.storage.onChanged.addListener(listener);\n        // Cleanup listener on dispose? (UIState usually lives for app lifetime, but good to know)\n    }\n\n    if (state && typeof state === \"object\") {\n        try {\n            Object.defineProperty(state, \"$save\", {\n                value: saveInStorage,\n                configurable: true,\n                enumerable: false,\n                writable: true\n            });\n        } catch (e) {\n            (state as any).$save = saveInStorage;\n        }\n    }\n    return state;\n}\n","import { makeObjectAssignable, observe, stringRef, safe } from \"fest/object\";\nimport { makeUIState } from \"fest/lure/extension/core/UIState\";\nimport { JSOX } from \"jsox\";\nimport { readText } from \"@rs-core/modules/Clipboard\";\n\nexport type GridCell = [number, number];\n\nexport interface SpeedDialItemMeta {\n    action?: string;\n    view?: string;\n    href?: string;\n    description?: string;\n    entityType?: string;\n    tags?: string[];\n    [key: string]: any;\n}\n\nexport interface SpeedDialPersistedItem {\n    id: string;\n    cell: ReturnType<typeof observe<GridCell>>;\n    icon: string;\n    label: string;\n    action: string;\n    meta?: SpeedDialItemMeta;\n}\n\ntype SpeedDialRecord = Omit<SpeedDialPersistedItem, \"meta\">;\n\nexport interface SpeedDialItem {\n    id: string;\n    cell: ReturnType<typeof observe>;\n    icon: ReturnType<typeof stringRef>;\n    label: ReturnType<typeof stringRef>;\n    action: string;\n}\n\nexport const NAVIGATION_SHORTCUTS = [\n    { view: \"home\", label: \"Home\", icon: \"house-line\" },\n    { view: \"task\", label: \"Plan\", icon: \"calendar-dots\" },\n    { view: \"event\", label: \"Events\", icon: \"calendar-star\" },\n    { view: \"bonus\", label: \"Bonuses\", icon: \"ticket\" },\n    { view: \"person\", label: \"Contacts\", icon: \"address-book\" },\n    { view: \"explorer\", label: \"Explorer\", icon: \"books\" },\n    { view: \"settings\", label: \"Settings\", icon: \"gear-six\" }\n] as const;\n\nconst STORAGE_KEY = \"cw::workspace::speed-dial\";\nconst META_STORAGE_KEY = `${STORAGE_KEY}::meta`;\n\nconst fallbackClone = <T>(value: T): T => {\n    if (typeof structuredClone === \"function\") {\n        return structuredClone(safe(value));\n    }\n    return JSOX.parse(JSOX.stringify(value)) as any;\n};\n\nconst generateItemId = () => {\n    if (typeof crypto !== \"undefined\" && typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    return `sd-${Date.now().toString(36)}-${Math.floor(Math.random() * 1_000)}`;\n};\n\nconst EXTERNAL_SHORTCUTS: SpeedDialPersistedItem[] = [\n    {\n        id: \"shortcut-docs\",\n        cell: observe([0, 1]),\n        icon: \"book-open-text\",\n        label: \"Docs\",\n        action: \"open-link\",\n        meta: { href: \"https://github.com/fest-live\", description: \"Project documentation\" }\n    },\n    {\n        id: \"shortcut-roadmap\",\n        cell: observe([1, 1]),\n        icon: \"signpost\",\n        label: \"Roadmap\",\n        action: \"open-link\",\n        meta: { href: \"https://github.com/u2re-space/unite-2.man\", description: \"Manifest notes\" }\n    },\n    {\n        id: \"shortcut-fest-live\",\n        cell: observe([2, 1]),\n        icon: \"github-logo\",\n        label: \"Fest Live\",\n        action: \"open-link\",\n        meta: { href: \"https://github.com/fest-live\", description: \"Fest Live Organization\" }\n    },\n    {\n        id: \"shortcut-l2ne-dev\",\n        cell: observe([3, 1]),\n        icon: \"user\",\n        label: \"L2NE Dev\",\n        action: \"open-link\",\n        meta: { href: \"https://github.com/L2NE-dev\", description: \"L2NE Developer Profile\" }\n    },\n    {\n        id: \"shortcut-u2re-space\",\n        cell: observe([0, 2]),\n        icon: \"planet\",\n        label: \"U2RE Space\",\n        action: \"open-link\",\n        meta: { href: \"https://github.com/u2re-space/\", description: \"U2RE Space Organization\" }\n    },\n    {\n        id: \"shortcut-telegram\",\n        cell: observe([1, 2]),\n        icon: \"telegram-logo\",\n        label: \"Telegram\",\n        action: \"open-link\",\n        meta: { href: \"https://t.me/u2re_space\", description: \"U2RE Space Telegram\" }\n    }\n];\n\nconst DEFAULT_SPEED_DIAL_DATA: SpeedDialPersistedItem[] = [\n    {\n        id: \"shortcut-explorer\",\n        cell: observe([2, 0]),\n        icon: \"books\",\n        label: \"Explorer\",\n        action: \"open-view\",\n        meta: { view: \"explorer\" }\n    },\n    {\n        id: \"shortcut-settings\",\n        cell: observe([3, 0]),\n        icon: \"gear-six\",\n        label: \"Settings\",\n        action: \"open-view\",\n        meta: { view: \"settings\" }\n    },\n    ...EXTERNAL_SHORTCUTS\n];\n\n\n\nconst splitDefaultEntries = (entries: SpeedDialPersistedItem[]) => {\n    const records: SpeedDialRecord[] = [];\n    const metaEntries: Array<[string, SpeedDialItemMeta]> = [];\n    entries.forEach((entry) => {\n        const { meta, ...record } = entry;\n        records.push(record as SpeedDialRecord);\n        const normalizedMeta: SpeedDialItemMeta = { action: entry.action, ...(meta || {}) };\n        metaEntries.push([entry.id, normalizedMeta]);\n    });\n    return { records, metaEntries };\n};\n\nconst { records: DEFAULT_SPEED_DIAL_RECORDS, metaEntries: DEFAULT_META_ENTRIES } = splitDefaultEntries(DEFAULT_SPEED_DIAL_DATA);\nconst legacyMetaBuffer: Array<[string, SpeedDialItemMeta]> = [];\n\nconst ensureCell = (cell?: ReturnType<typeof observe<GridCell>>): ReturnType<typeof observe<GridCell>> => {\n    if (cell && Array.isArray(cell) && cell.length >= 2) {\n        return observe([Number(cell[0]) || 0, Number(cell[1]) || 0]);\n    }\n    return observe([0, 0]);\n};\n\nconst createMetaState = (meta: SpeedDialItemMeta = {}) => {\n    return makeObjectAssignable(observe({\n        action: meta.action || \"open-view\",\n        view: meta.view || \"\",\n        href: meta.href || \"\",\n        description: meta.description || \"\",\n        entityType: meta.entityType || \"\",\n        tags: Array.isArray(meta.tags) ? [...meta.tags] : [],\n        ...meta\n    }));\n};\n\nexport type SpeedDialMetaEntry = ReturnType<typeof createMetaState>;\nexport type SpeedDialMetaRegistry = Map<string, SpeedDialMetaEntry>;\n\nconst registryFromEntries = (entries: Iterable<[string, SpeedDialItemMeta]>) => {\n    const registry = new Map<string, SpeedDialMetaEntry>();\n    for (const [id, meta] of entries) {\n        registry.set(id, createMetaState(meta));\n    }\n    return registry as SpeedDialMetaRegistry;\n};\n\nconst normalizeMetaEntries = (raw?: any): Array<[string, SpeedDialItemMeta]> => {\n    if (!raw) return [];\n    if (raw instanceof Map) {\n        return Array.from(raw.entries());\n    }\n    if (Array.isArray(raw)) {\n        return raw\n            .map((entry: any) => {\n                if (entry && typeof entry === \"object\" && \"id\" in entry) {\n                    return [entry.id, (entry.meta || entry) as SpeedDialItemMeta] as [string, SpeedDialItemMeta];\n                }\n                return null;\n            })\n            .filter(Boolean) as Array<[string, SpeedDialItemMeta]>;\n    }\n    if (typeof raw === \"object\") {\n        return Object.entries(raw as Record<string, SpeedDialItemMeta>) as Array<[string, SpeedDialItemMeta]>;\n    }\n    return [];\n};\n\nconst packMetaRegistry = (registry: SpeedDialMetaRegistry) => {\n    const payload: Record<string, SpeedDialItemMeta> = {};\n    registry?.forEach((meta, id) => {\n        payload[id] = fallbackClone(meta ?? {});\n    });\n    return payload;\n};\n\nconst createInitialMetaRegistry = () => registryFromEntries(DEFAULT_META_ENTRIES);\nconst unpackMetaRegistry = (raw?: any) => {\n    const entries = normalizeMetaEntries(raw);\n    return registryFromEntries(entries.length ? entries : DEFAULT_META_ENTRIES);\n};\n\nconst unwrapRef = (value: any, fallback?: string) => {\n    if (value && typeof value === \"object\" && \"value\" in value) {\n        return value.value ?? fallback;\n    }\n    return value ?? fallback;\n};\n\nconst serializeItemState = (item: SpeedDialItem): SpeedDialRecord => {\n    return {\n        id: item.id,\n        cell: observe([item.cell?.[0] ?? 0, item.cell?.[1] ?? 0]),\n        icon: unwrapRef(item.icon, \"sparkle\"),\n        label: unwrapRef(item.label, \"Shortcut\"),\n        action: item.action\n    };\n};\n\n\n\nconst createStatefulItem = (config: SpeedDialRecord): SpeedDialItem => {\n    return observe({\n        id: config.id || generateItemId(),\n        cell: observe(ensureCell(config.cell)),\n        icon: stringRef(config.icon || \"sparkle\"),\n        label: stringRef(config.label || \"Shortcut\"),\n        action: config.action || \"open-view\"\n    }) as any;\n};\n\n\nconst createInitialState = () => observe(DEFAULT_SPEED_DIAL_RECORDS.map(createStatefulItem));\nconst unpackState = (raw?: SpeedDialPersistedItem[]) => {\n    const source = Array.isArray(raw) && raw.length ? raw : DEFAULT_SPEED_DIAL_DATA;\n    const records = source.map((entry) => {\n        const { meta, ...record } = entry;\n        if (meta) {\n            legacyMetaBuffer.push([entry.id, { action: entry.action, ...meta }]);\n        } else {\n            legacyMetaBuffer.push([entry.id, { action: entry.action }]);\n        }\n        return record as SpeedDialRecord;\n    });\n    return observe(records.map(createStatefulItem));\n};\nconst packState = (collection: SpeedDialItem[]) => collection.map(serializeItemState);\n\n//\nexport const speedDialMeta = makeUIState(META_STORAGE_KEY, createInitialMetaRegistry, unpackMetaRegistry, packMetaRegistry) as unknown as SpeedDialMetaRegistry;\nexport const speedDialItems = makeUIState(STORAGE_KEY, createInitialState, unpackState, packState) as unknown as SpeedDialItem[];\nexport const persistSpeedDialItems = () => (speedDialItems as any)?.$save?.();\nexport const persistSpeedDialMeta = () => (speedDialMeta as any)?.$save?.();\n\n//\nexport const getSpeedDialMeta = (id?: string | null) => {\n    if (!id) return null;\n    return speedDialMeta?.get?.(id) ?? null;\n};\n\nexport const ensureSpeedDialMeta = (id: string, defaults: SpeedDialItemMeta = {}) => {\n    let meta = speedDialMeta?.get?.(id);\n    if (!meta) {\n        meta = createMetaState(defaults);\n        speedDialMeta?.set?.(id, meta);\n        persistSpeedDialMeta();\n    }\n    if (defaults?.action && meta.action !== defaults.action) {\n        meta.action = defaults.action;\n    }\n    return meta;\n};\n\nexport const removeSpeedDialMeta = (id: string) => {\n    const removed = speedDialMeta?.delete?.(id);\n    if (removed) {\n        persistSpeedDialMeta();\n    }\n    return removed;\n};\n\n\n\n\n\n\nconst syncMetaActionFromItem = (item?: SpeedDialItem | null) => {\n    if (!item) return false;\n    const desiredAction = item.action || \"open-view\";\n    const meta = ensureSpeedDialMeta(item.id, { action: desiredAction });\n    if (meta.action !== desiredAction) {\n        meta.action = desiredAction;\n        return true;\n    }\n    return false;\n};\n\nconst syncMetaActionsForAllItems = () => {\n    let changed = false;\n    speedDialItems?.forEach?.((item) => {\n        if (syncMetaActionFromItem(item)) {\n            changed = true;\n        }\n    });\n    if (changed) {\n        persistSpeedDialMeta();\n    }\n};\n\nconst flushLegacyMetaBuffer = () => {\n    if (!legacyMetaBuffer.length) return;\n    legacyMetaBuffer.forEach(([id, meta]) => {\n        const target = ensureSpeedDialMeta(id, meta);\n        Object.assign(target, meta);\n    });\n    legacyMetaBuffer.length = 0;\n    persistSpeedDialMeta();\n};\n\nflushLegacyMetaBuffer();\nsyncMetaActionsForAllItems();\n\nconst ensureExternalShortcuts = () => {\n    let changed = false;\n    EXTERNAL_SHORTCUTS.forEach((shortcut) => {\n        const exists = speedDialItems?.find?.((item) => item?.id === shortcut.id);\n        if (!exists) {\n            const item = createStatefulItem(shortcut);\n            // Ensure label and icon are set correctly if they are refs in item but strings in shortcut\n            if (shortcut.label && item.label && typeof item.label === 'object' && 'value' in item.label) {\n                item.label.value = shortcut.label;\n            }\n            if (shortcut.icon && item.icon && typeof item.icon === 'object' && 'value' in item.icon) {\n                item.icon.value = shortcut.icon;\n            }\n\n            speedDialItems.push(observe(item) as any);\n            ensureSpeedDialMeta(item.id, shortcut.meta);\n            changed = true;\n        } else {\n            // Update existing items with potentially new meta (e.g. links)\n            const currentMeta = getSpeedDialMeta(shortcut.id);\n            if (shortcut.meta && currentMeta) {\n                if (shortcut.meta.href !== currentMeta.href) {\n                    currentMeta.href = shortcut.meta.href;\n                    changed = true;\n                }\n                if (shortcut.meta.description !== currentMeta.description) {\n                    currentMeta.description = shortcut.meta.description;\n                    changed = true;\n                }\n            } else if (shortcut.meta && !currentMeta) {\n                 ensureSpeedDialMeta(shortcut.id, shortcut.meta);\n                 changed = true;\n            }\n        }\n    });\n    if (changed) {\n        persistSpeedDialItems();\n        persistSpeedDialMeta();\n    }\n};\nensureExternalShortcuts();\n\nexport const findSpeedDialItem = (id?: string | null) => {\n    if (!id) return null;\n    return speedDialItems?.find?.((item) => item?.id === id) || null;\n};\n\nexport const createEmptySpeedDialItem = (cell: ReturnType<typeof observe> = observe([0, 0])): SpeedDialItem => {\n    const item = createStatefulItem({\n        id: generateItemId(),\n        cell,\n        icon: \"sparkle\",\n        label: \"New shortcut\",\n        action: \"open-link\"\n    });\n    ensureSpeedDialMeta(item.id, { action: item.action, href: \"\", description: \"\" });\n    return item;\n};\n\nexport const addSpeedDialItem = (item: SpeedDialItem) => {\n    speedDialItems?.push?.(observe(item) as any);\n    const metaChanged = syncMetaActionFromItem(item);\n    persistSpeedDialItems();\n    if (metaChanged) {\n        persistSpeedDialMeta();\n    }\n    return item;\n};\n\nexport const upsertSpeedDialItem = (item: SpeedDialItem) => {\n    const existingIndex = speedDialItems?.findIndex?.((entry) => entry?.id === item?.id) ?? -1;\n    if (existingIndex === -1) {\n        speedDialItems?.push?.(observe(item) as any);\n    } else if (speedDialItems[existingIndex] !== item) {\n        speedDialItems.splice(existingIndex, 1, observe(item) as any);\n    }\n    const metaChanged = syncMetaActionFromItem(item);\n    persistSpeedDialItems();\n    if (metaChanged) {\n        persistSpeedDialMeta();\n    }\n    return item;\n};\n\nexport const removeSpeedDialItem = (id: string) => {\n    const index = speedDialItems?.findIndex?.((entry) => entry?.id === id) ?? -1;\n    if (index === -1) return false;\n    speedDialItems.splice(index, 1);\n    removeSpeedDialMeta(id);\n    persistSpeedDialItems();\n    return true;\n};\n\nexport const snapshotSpeedDialItem = (item: SpeedDialItem) => {\n    const meta = getSpeedDialMeta(item.id);\n    const resolvedAction = meta?.action || item.action;\n    const metaSnapshot = fallbackClone(meta ?? {});\n    if (!metaSnapshot.action) {\n        metaSnapshot.action = resolvedAction;\n    }\n    return {\n        state: {\n            id: item.id,\n            cell: observe([item.cell?.[0] ?? 0, item.cell?.[1] ?? 0]),\n            icon: unwrapRef(item.icon, \"\"),\n            label: unwrapRef(item.label, \"\")\n        },\n            desc: {\n            action: resolvedAction,\n            meta: metaSnapshot\n        }\n    };\n};\n\nconst WALLPAPER_KEY = \"cw::workspace::wallpaper\";\nexport const wallpaperState = makeUIState(WALLPAPER_KEY, () => observe({\n    src: \"./assets/imgs/test.webp\",\n    opacity: 1,\n    blur: 0\n}), (raw) => observe(raw || {\n    src: \"./assets/imgs/test.webp\",\n    opacity: 1,\n    blur: 0\n}), (state) => ({ ...state })) as unknown as { src: string; opacity: number; blur: number };\n\nexport const persistWallpaper = () => (wallpaperState as any)?.$save?.();\n\nexport type GridShape = \"square\" | \"squircle\" | \"circle\" | \"rounded\" | \"hexagon\" | \"diamond\";\n\nexport interface GridLayoutSettings {\n    columns: number;\n    rows: number;\n    shape: GridShape;\n}\n\nconst GRID_LAYOUT_KEY = \"cw::workspace::grid-layout\";\nexport const gridLayoutState = makeUIState(GRID_LAYOUT_KEY, () => observe({\n    columns: 4,\n    rows: 8,\n    shape: \"square\" as GridShape\n}), (raw) => observe(raw || {\n    columns: 4,\n    rows: 8,\n    shape: \"square\" as GridShape\n}), (state) => ({ ...state })) as unknown as GridLayoutSettings;\n\nexport const persistGridLayout = () => (gridLayoutState as any)?.$save?.();\n\nexport const applyGridSettings = (settings?: { grid?: GridLayoutSettings }) => {\n    const gridConfig = settings?.grid || gridLayoutState;\n    const columns = gridConfig?.columns ?? 4;\n    const rows = gridConfig?.rows ?? 8;\n    const shape = gridConfig?.shape ?? \"square\";\n\n    // Update the reactive state\n    if (gridLayoutState) {\n        gridLayoutState.columns = columns;\n        gridLayoutState.rows = rows;\n        gridLayoutState.shape = shape;\n        persistGridLayout();\n    }\n\n    // Apply to all speed-dial grids via data attributes (for CSS to consume)\n    document.querySelectorAll('.speed-dial-grid').forEach(grid => {\n        const el = grid as HTMLElement;\n        el.dataset.gridColumns = String(columns);\n        el.dataset.gridRows = String(rows);\n        el.dataset.gridShape = shape;\n    });\n\n    // Update CSS custom properties on root for grid layout\n    document.documentElement.dataset.gridColumns = String(columns);\n    document.documentElement.dataset.gridRows = String(rows);\n    document.documentElement.dataset.gridShape = shape;\n};\n\n// Apply grid settings on load\nif (typeof window !== \"undefined\") {\n    requestAnimationFrame(() => applyGridSettings());\n}\n\n//\nexport const parseSpeedDialItemFromJSON = (jsonText: string, suggestedCell?: GridCell): SpeedDialItem | null => {\n    try {\n        const parsed = JSOX.parse(jsonText) as any;\n        if (!parsed || typeof parsed !== \"object\") return null;\n\n        const state = parsed.state || parsed;\n        const desc = parsed.desc || parsed.meta || {};\n\n        if (!state || typeof state !== \"object\") return null;\n\n        const cellValue = state.cell && Array.isArray(state.cell) && state.cell.length >= 2\n            ? [Number(state.cell[0]) || 0, Number(state.cell[1]) || 0] as GridCell\n            : (suggestedCell || [0, 0] as GridCell);\n\n        const item = createStatefulItem({\n            id: state.id || generateItemId(),\n            cell: cellValue,\n            icon: state.icon || desc.icon || \"sparkle\",\n            label: state.label || desc.label || \"Shortcut\",\n            action: desc.action || state.action || \"open-view\"\n        });\n\n        const meta: SpeedDialItemMeta = {\n            action: desc.action || state.action || \"open-view\",\n            ...(desc.meta || desc || {}),\n            ...(state.meta || {})\n        };\n\n        if (meta.href) {\n            meta.action = meta.action || \"open-link\";\n        } else if (meta.view) {\n            meta.action = meta.action || \"open-view\";\n        }\n\n        ensureSpeedDialMeta(item.id, meta);\n        return item;\n    } catch (e) {\n        console.warn(\"Failed to parse JSON for speed dial item:\", e);\n        return null;\n    }\n};\n\n//\nexport const parseSpeedDialItemFromURL = (urlText: string, suggestedCell?: GridCell): SpeedDialItem | null => {\n    try {\n        const trimmed = urlText.trim();\n        if (!trimmed) return null;\n\n        let url: URL;\n        try {\n            url = new URL(trimmed);\n        } catch {\n            try {\n                url = new URL(trimmed, typeof window !== \"undefined\" ? window.location.href : undefined);\n            } catch {\n                return null;\n            }\n        }\n\n        const hostname = url.hostname || \"\";\n        const domain = hostname.replace(/^www\\./, \"\");\n        const pathname = url.pathname || \"\";\n        const label = domain || url.host || \"Link\";\n\n        const item = createStatefulItem({\n            id: generateItemId(),\n            cell: suggestedCell || [0, 0],\n            icon: \"link\",\n            label,\n            action: \"open-link\"\n        });\n\n        const meta: SpeedDialItemMeta = {\n            action: \"open-link\",\n            href: url.href,\n            description: `${label}${pathname ? ` - ${pathname}` : \"\"}`\n        };\n\n        ensureSpeedDialMeta(item.id, meta);\n        return item;\n    } catch (e) {\n        console.warn(\"Failed to parse URL for speed dial item:\", e);\n        return null;\n    }\n};\n\n//\nexport const createSpeedDialItemFromClipboard = async (suggestedCell?: GridCell): Promise<SpeedDialItem | null> => {\n    try {\n        const clipboardResult = await readText();\n        if (!clipboardResult.ok || !clipboardResult.data) {\n            console.warn(\"Failed to read clipboard text:\", clipboardResult.error);\n            return null;\n        }\n\n        const clipboardText = String(clipboardResult.data);\n        if (!clipboardText.trim()) return null;\n\n        const trimmed = clipboardText.trim();\n\n        const isURL = /^https?:\\/\\/[^\\s]+$/i.test(trimmed) || /^[^\\s]+\\.[a-z]{2,}(\\/|$)/i.test(trimmed);\n\n        if (isURL && URL.canParse(trimmed, typeof window !== \"undefined\" ? window.location.origin : undefined)) {\n            return parseSpeedDialItemFromURL(trimmed, suggestedCell);\n        }\n\n        const isJSON = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) || (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n        if (isJSON) {\n            const parsed = parseSpeedDialItemFromJSON(trimmed, suggestedCell);\n            if (parsed) return parsed;\n        }\n\n        return null;\n    } catch (e) {\n        console.warn(\"Failed to create speed dial item from clipboard:\", e);\n        return null;\n    }\n};\n\n","import { loadSettings } from \"@rs-com/config/Settings\";\nimport type { AppSettings } from \"@rs-com/config/SettingsTypes\";\nimport { applyGridSettings } from \"@rs-core/storage/StateStorage\";\n\n//\nconst resolveColorScheme = (theme: AppSettings[\"appearance\"] extends { theme?: infer T } ? T : never) => {\n    if (theme === \"dark\" || theme === \"light\") return theme;\n    return window.matchMedia?.(\"(prefers-color-scheme: dark)\")?.matches ? \"dark\" : \"light\";\n};\n\nconst resolveFontSize = (size?: AppSettings[\"appearance\"] extends { fontSize?: infer T } ? T : never) => {\n    switch (size) {\n        case \"small\":\n            return \"14px\";\n        case \"large\":\n            return \"18px\";\n        case \"medium\":\n        default:\n            return \"16px\";\n    }\n};\n\n//\nexport const applyTheme = (settings: AppSettings) => {\n    const root = document.documentElement;\n    const theme = settings.appearance?.theme || \"auto\";\n    const resolvedScheme = resolveColorScheme(theme);\n\n    // implemented in veela.css\n    root.setAttribute(\"data-scheme\", theme);\n    root.setAttribute(\"data-theme\", resolvedScheme);\n    root.style.colorScheme = resolvedScheme;\n    root.style.fontSize = resolveFontSize(settings.appearance?.fontSize);\n    if (settings.appearance?.color) {\n        document.body.style.setProperty(\"--current\", settings.appearance.color);\n        document.body.style.setProperty(\"--primary\", settings.appearance.color);\n        root.style.setProperty(\"--current\", settings.appearance.color);\n        root.style.setProperty(\"--primary\", settings.appearance.color);\n    }\n\n    // Apply grid settings\n    if (settings.grid) {\n        applyGridSettings(settings);\n    }\n};\n\n//\nexport const initTheme = async () => {\n    try {\n        const settings = await loadSettings();\n        applyTheme(settings);\n\n        // Listen for system changes if in auto mode?\n        // CSS handles this mostly, but if we add listeners here we can be more reactive.\n        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', async () => {\n            applyTheme(await loadSettings());\n        });\n    } catch (e) {\n        console.warn(\"Failed to init theme\", e);\n    }\n};\n","/**\n * Veela CSS - Core Runtime Loader\n *\n * Provides the shared foundation styles for all veela variants.\n * Use this when you only need the essential normalize and layout utilities.\n *\n * @example\n * ```ts\n * import { loadCoreStyles } from \"fest/veela/core\";\n * await loadCoreStyles();\n * ```\n */\n\nimport { loadAsAdopted } from \"fest/dom\";\n\nimport styles from \"./index.scss?inline\";\n\n/**\n * Load core veela styles (normalize + layout + states)\n */\nexport async function loadCoreStyles(): Promise<void> {\n    try {\n        await loadAsAdopted(styles);\n        console.log(\"[Veela/Core] Core styles loaded\");\n    } catch (e) {\n        console.warn(\"[Veela/Core] Failed to load core styles:\", e);\n    }\n}\n\nexport default loadCoreStyles;\n","/**\n * Veela CSS - Basic Runtime Loader\n *\n * Provides lightweight styling for minimal applications.\n * Inherits core foundation + adds basic component styles.\n *\n * @example\n * ```ts\n * import { loadBasicStyles } from \"fest/veela/basic\";\n * await loadBasicStyles();\n * ```\n */\n\nimport { loadAsAdopted } from \"fest/dom\";\n\nimport basicStyles from \"./index.scss?inline\";\n\n/**\n * Load basic veela styles\n */\nexport async function loadBasicStyles(): Promise<void> {\n    try {\n        if (basicStyles) {\n            await loadAsAdopted(basicStyles);\n            console.log(\"[Veela/Basic] Basic styles loaded\");\n        }\n    } catch (e) {\n        console.warn(\"[Veela/Basic] Failed to load basic styles:\", e);\n    }\n}\n\n// Re-export core utilities\nexport * from \"../core/index\";\n\nexport default loadBasicStyles;\n","/**\n * Veela CSS - Advanced Runtime Loader\n *\n * Provides full-featured styling with advanced components and effects.\n * Inherits core foundation + adds comprehensive component library.\n *\n * @example\n * ```ts\n * import { loadAdvancedStyles } from \"fest/veela/advanced\";\n * await loadAdvancedStyles();\n * ```\n */\n\nimport { loadAsAdopted } from \"fest/dom\";\n\nimport advancedStyles from \"./index.scss?inline\";\n\n/**\n * Load advanced veela styles\n */\nexport async function loadAdvancedStyles(): Promise<void> {\n    try {\n        if (advancedStyles) {\n            await loadAsAdopted(advancedStyles);\n            console.log(\"[Veela/Advanced] Advanced styles loaded\");\n        }\n    } catch (e) {\n        console.warn(\"[Veela/Advanced] Failed to load advanced styles:\", e);\n    }\n}\n\n// Re-export core utilities\nexport * from \"../core/index\";\n\nexport default loadAdvancedStyles;\n","/**\n * Veela CSS - Beer CSS Compatible Runtime Loader\n *\n * Provides styling compatible with Beer CSS (https://www.beercss.com/)\n * Inherits basic foundation + adds Beer CSS class names and variables.\n *\n * @example\n * ```ts\n * import { loadBeerCssStyles } from \"fest/veela/beercss\";\n * await loadBeerCssStyles();\n * ```\n *\n * @see https://www.beercss.com/ for Beer CSS documentation\n */\n\nimport { loadAsAdopted } from \"fest/dom\";\n\n/**\n * Load Beer CSS compatible styles\n */\nexport async function loadBeerCssStyles(): Promise<void> {\n    try {\n        const beerStyles = await import(\"./_index.scss?inline\");\n        if (beerStyles.default) {\n            await loadAsAdopted(beerStyles.default);\n            console.log(\"[Veela/BeerCSS] Beer CSS compatible styles loaded\");\n        }\n    } catch (e) {\n        console.warn(\"[Veela/BeerCSS] Failed to load Beer CSS styles:\", e);\n    }\n}\n\n// Re-export basic utilities\nexport * from \"../basic/index\";\n\nexport default loadBeerCssStyles;\n","/**\n * Veela CSS - Runtime Entry Point\n *\n * Unified runtime module providing access to all veela style variants.\n *\n * Variants:\n * - core: Shared foundation (normalize, layout, states)\n * - basic: Lightweight styles (core + essential components)\n * - advanced: Full-featured styles (core + comprehensive library)\n * - beercss: Beer CSS compatible (basic + Beer CSS class names)\n *\n * @example\n * ```ts\n * // Load specific variant\n * import { loadBasicStyles } from \"fest/veela/runtime\";\n * await loadBasicStyles();\n *\n * // Or use the variant loader\n * import { loadVeelaVariant } from \"fest/veela/runtime\";\n * await loadVeelaVariant(\"advanced\");\n * ```\n */\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type VeelaVariant = \"core\" | \"basic\" | \"advanced\" | \"beercss\";\n\nexport interface VeelaConfig {\n    variant: VeelaVariant;\n    loaded: boolean;\n}\n\n// ============================================================================\n// STATE\n// ============================================================================\n\nlet _loadedVariant: VeelaVariant | null = null;\n\n// ============================================================================\n// VARIANT LOADERS\n// ============================================================================\n\nimport { loadCoreStyles } from \"./core/index\";\nimport { loadBasicStyles } from \"./basic/index\";\nimport { loadAdvancedStyles } from \"./advanced/index\";\nimport { loadBeerCssStyles } from \"./beercss/index\";\n\n// ============================================================================\n// UNIFIED LOADER\n// ============================================================================\n\n/**\n * Load a specific veela style variant\n *\n * @param variant - The style variant to load\n * @returns Promise that resolves when styles are loaded\n */\nexport async function loadVeelaVariant(variant: VeelaVariant): Promise<void> {\n    if (_loadedVariant === variant) {\n        console.log(`[Veela] Variant '${variant}' already loaded`);\n        return;\n    }\n\n    console.log(`[Veela] Loading variant: ${variant}`);\n\n    await loadCoreStyles();\n\n    switch (variant) {\n        case \"core\": {\n            await loadCoreStyles();\n            break;\n        }\n        case \"basic\": {\n            await loadBasicStyles();\n            break;\n        }\n        case \"advanced\": {\n            await loadAdvancedStyles();\n            break;\n        }\n        case \"beercss\": {\n            await loadBeerCssStyles();\n            break;\n        }\n        default:\n            console.warn(`[Veela] Unknown variant: ${variant}, using basic`);\n            await loadBasicStyles();\n            break;\n    }\n\n    _loadedVariant = variant;\n}\n\n/**\n * Get the currently loaded variant\n */\nexport function getLoadedVariant(): VeelaVariant | null {\n    return _loadedVariant;\n}\n\n/**\n * Check if a specific variant is loaded\n */\nexport function isVariantLoaded(variant: VeelaVariant): boolean {\n    return _loadedVariant === variant;\n}\n\n// ============================================================================\n// DEFAULT EXPORT\n// ============================================================================\n\nexport default loadVeelaVariant;\n","/**\n * Boot Loader - Shell/Style Initialization System\n * \n * Manages the boot sequence for the CrossWord application:\n * 1. Load style system (Veela CSS or Minimal)\n * 2. Initialize shell (frame/layout/environment)\n * 3. Load view/component/module\n * 4. Connect uniform channels\n * \n * Shell/Style Matrix:\n * | Shells/Styles: | Faint | Minimal | Raw |\n * |----------------|-------|-------|-----|\n * | Veela          |  [r]  |  [o]  | [o] |\n * | Minimal        |  [o]  |  [r]  | [r] |\n * \n * [r] - recommended, [o] - optional\n */\n\nimport { loadAsAdopted } from \"fest/dom\";\nimport { ShellRegistry, initializeRegistries } from \"../registry\";\nimport { defaultTheme, darkTheme, lightTheme } from \"../registry\";\nimport type { ShellId, ViewId, Shell, ShellTheme } from \"../shells/types\";\nimport { serviceChannels, type ServiceChannelId } from \"@rs-com/core/ServiceChannels\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport { applyTheme as applyAppTheme } from \"@rs-core/utils/Theme\";\nimport type { AppSettings } from \"@rs-com/config/SettingsTypes\";\n\nimport { loadVeelaVariant, type VeelaVariant } from \"fest/veela\";\n\n// ============================================================================\n// BOOT TYPES\n// ============================================================================\n\n/**\n * Style system identifiers\n */\nexport type StyleSystem = \"raw\" | \"vl-core\" | \"vl-basic\" | \"vl-advanced\" | \"vl-beercss\";\n\n/**\n * Boot configuration\n */\nexport interface BootConfig {\n    /** Style system to use */\n    styleSystem: StyleSystem;\n    /** Shell to initialize */\n    shell: ShellId;\n    /** Initial view to load */\n    defaultView: ViewId;\n    /** Initial theme */\n    theme?: ShellTheme;\n    /** Service channels to initialize */\n    channels?: ServiceChannelId[];\n    /** Remember preferences */\n    rememberChoice?: boolean;\n}\n\n/**\n * Boot state\n */\nexport interface BootState {\n    phase: \"idle\" | \"styles\" | \"shell\" | \"view\" | \"channels\" | \"ready\" | \"error\";\n    styleSystem: StyleSystem | null;\n    shell: ShellId | null;\n    view: ViewId | null;\n    error: Error | null;\n}\n\n/**\n * Boot phase handler\n */\nexport type BootPhaseHandler = (state: BootState) => void | Promise<void>;\n\n// ============================================================================\n// STYLE SYSTEM CONFIGURATION\n// ============================================================================\n\n/**\n * Style system configurations\n */\nconst STYLE_CONFIGS: Record<StyleSystem, {\n    name: string;\n    stylesheets: string[];\n    description: string;\n    recommendedShells: ShellId[];\n}> = {\n    \"raw\": {\n        name: \"Raw (No Framework)\",\n        stylesheets: [],\n        description: \"No CSS framework, raw browser defaults\",\n        recommendedShells: [\"base\"]\n    },\n    \"vl-core\": {\n        name: \"Core (Shared Foundation)\",\n        stylesheets: [],\n        description: \"Shared foundation styles for all veela variants\",\n        recommendedShells: [\"faint\", \"base\"]\n    },\n    \"vl-basic\": {\n        name: \"Basic Veela Styles\",\n        stylesheets: [],\n        description: \"Minimal styling for basic functionality\",\n        recommendedShells: [\"minimal\", \"base\"]\n    },\n    \"vl-advanced\": {\n        name: \"Advanced (Full-Featured Styling)\",\n        stylesheets: [],\n        description: \"Full-featured styling with design tokens and effects\",\n        recommendedShells: [\"faint\", \"minimal\"]\n    },\n    \"vl-beercss\": {\n        name: \"BeerCSS (Beer CSS Compatible)\",\n        stylesheets: [],\n        description: \"Beer CSS compatible styling with Material Design 3\",\n        recommendedShells: [\"faint\"]\n    }\n};\n\n/**\n * Get recommended style system for a shell\n */\nexport function getRecommendedStyle(shell: ShellId): StyleSystem {\n    switch (shell) {\n        case \"faint\":\n            return \"vl-basic\";\n        case \"minimal\":\n            return \"vl-basic\";\n        case \"base\":\n            return \"vl-core\";\n        default:\n            return \"vl-core\";\n    }\n}\n\n// ============================================================================\n// BOOT LOADER CLASS\n// ============================================================================\n\n/**\n * Boot Loader\n * \n * Manages the application boot sequence with proper ordering:\n * Styles  Shell  View  Channels\n */\nexport class BootLoader {\n    private static instance: BootLoader;\n    \n    // State (use object for mutable state tracking)\n    private state: BootState = {\n        phase: \"idle\",\n        styleSystem: null,\n        shell: null,\n        view: null,\n        error: null\n    };\n    \n    // State change handlers\n    private stateChangeHandlers = new Set<(state: BootState) => void>();\n    \n    // Loaded shell instance\n    private shellInstance: Shell | null = null;\n    \n    \n    // Phase handlers for customization\n    private phaseHandlers = new Map<BootState[\"phase\"], Set<BootPhaseHandler>>();\n\n    private constructor() {\n        // Initialize registries\n        initializeRegistries();\n    }\n\n    static getInstance(): BootLoader {\n        if (!BootLoader.instance) {\n            BootLoader.instance = new BootLoader();\n        }\n        return BootLoader.instance;\n    }\n\n    // ========================================================================\n    // BOOT SEQUENCE\n    // ========================================================================\n\n    /**\n     * Execute the boot sequence\n     */\n    async boot(container: HTMLElement, config: BootConfig): Promise<Shell> {\n        console.log(\"[BootLoader] Starting boot sequence:\", config);\n        \n        try {\n            // Phase 0: Load persisted settings early (theme/font-size/etc.)\n            const persistedSettings = await loadSettings().catch((error) => {\n                console.warn(\"[BootLoader] Failed to load settings:\", error);\n                return null;\n            });\n            const persistedTheme = this.resolveThemeFromSettings(persistedSettings);\n\n            // Phase 1: Load Style System\n            await this.loadStyles(config.styleSystem);\n            \n            // Phase 2: Initialize Shell\n            const shell = await this.loadShell(config.shell, container);\n            \n            // Phase 3: Apply Theme\n            shell.setTheme(config.theme || persistedTheme);\n            \n            // Phase 4: Mount Shell\n            await shell.mount(container);\n\n            // Phase 4.5: Apply document-level theme/settings\n            if (persistedSettings) {\n                applyAppTheme(persistedSettings);\n            }\n            \n            // Phase 5: Initialize Channels\n            if (config.channels && config.channels.length > 0) {\n                await this.initChannels(config.channels);\n            }\n            \n            // Phase 6: Navigate to Default View\n            await shell.navigate(config.defaultView);\n            \n            // Mark as ready\n            this.setPhase(\"ready\");\n            \n            // Save preferences\n            if (config.rememberChoice) {\n                this.savePreferences(config);\n            }\n            \n            console.log(\"[BootLoader] Boot complete\");\n            return shell;\n            \n        } catch (error) {\n            console.error(\"[BootLoader] Boot failed:\", error);\n            this.updateState({\n                phase: \"error\",\n                error: error as Error\n            });\n            throw error;\n        }\n    }\n\n    private resolveThemeFromSettings(settings: AppSettings | null | undefined): ShellTheme {\n        const theme = settings?.appearance?.theme || \"auto\";\n        if (theme === \"dark\") return darkTheme;\n        if (theme === \"light\") return lightTheme;\n        return defaultTheme;\n    }\n\n    /**\n     * Load style system\n     */\n    private async loadStyles(styleSystem: StyleSystem): Promise<void> {\n        this.setPhase(\"styles\");\n        console.log(`[BootLoader] Loading style system: ${styleSystem}`);\n        \n        const config = STYLE_CONFIGS[styleSystem] || STYLE_CONFIGS[\"vl-basic\"];\n\n        // Load Veela CSS framework if selected\n        try {\n            // Load the main stylesheet using loadCss helper\n            // Try loading via fest/veela's loadCss which handles paths correctly\n            // Accept only VeelaVariant (type-safe)\n            const veelaVariant = styleSystem?.replace?.(\"veela-\", \"\")?.replace?.(\"vl-\", \"\") || \"basic\";\n            console.log(`[BootLoader] Loading Veela variant: ${veelaVariant}`);\n            await loadVeelaVariant(veelaVariant as VeelaVariant);\n            console.log(\"[BootLoader] Veela CSS loaded\");\n        } catch (error) {\n            console.warn(\"[BootLoader] Failed to load Veela CSS, using fallback:\", error);\n        }\n        \n        // Load any additional stylesheets\n        for (const sheet of config.stylesheets) {\n            try {\n                await loadAsAdopted(sheet);\n            } catch (error) {\n                console.warn(`[BootLoader] Failed to load stylesheet: ${sheet}`, error);\n            }\n        }\n        \n        this.updateState({ styleSystem });\n        console.log(`[BootLoader] Style system ${styleSystem} loaded`);\n    }\n\n    /**\n     * Load and initialize shell\n     */\n    private async loadShell(shellId: ShellId, container: HTMLElement): Promise<Shell> {\n        this.setPhase(\"shell\");\n        console.log(`[BootLoader] Loading shell: ${shellId}`);\n        \n        const shell = await ShellRegistry.load(shellId, container);\n        \n        this.shellInstance = shell;\n        this.updateState({ shell: shellId });\n        \n        console.log(`[BootLoader] Shell ${shellId} loaded`);\n        return shell;\n    }\n\n    /**\n     * Initialize service channels\n     */\n    private async initChannels(channelIds: ServiceChannelId[]): Promise<void> {\n        this.setPhase(\"channels\");\n        console.log(`[BootLoader] Initializing channels:`, channelIds);\n        \n        for (const channelId of channelIds) {\n            try {\n                await serviceChannels.initChannel(channelId);\n            } catch (error) {\n                console.warn(`[BootLoader] Failed to init channel ${channelId}:`, error);\n            }\n        }\n        \n        console.log(`[BootLoader] Channels initialized`);\n    }\n\n    // ========================================================================\n    // STATE MANAGEMENT\n    // ========================================================================\n\n    /**\n     * Update state and notify handlers\n     */\n    private updateState(partial: Partial<BootState>): void {\n        Object.assign(this.state, partial);\n        this.notifyStateChange();\n    }\n\n    /**\n     * Set current phase and notify handlers\n     */\n    private setPhase(phase: BootState[\"phase\"]): void {\n        this.updateState({ phase });\n        \n        const handlers = this.phaseHandlers.get(phase);\n        if (handlers) {\n            for (const handler of handlers) {\n                try {\n                    handler(this.state);\n                } catch (error) {\n                    console.error(`[BootLoader] Phase handler error:`, error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify all state change handlers\n     */\n    private notifyStateChange(): void {\n        for (const handler of this.stateChangeHandlers) {\n            try {\n                handler(this.state);\n            } catch (error) {\n                console.error(`[BootLoader] State handler error:`, error);\n            }\n        }\n    }\n\n    /**\n     * Subscribe to state changes\n     */\n    onStateChange(handler: (state: BootState) => void): () => void {\n        this.stateChangeHandlers.add(handler);\n        return () => {\n            this.stateChangeHandlers.delete(handler);\n        };\n    }\n\n    /**\n     * Register a phase handler\n     */\n    onPhase(phase: BootState[\"phase\"], handler: BootPhaseHandler): () => void {\n        if (!this.phaseHandlers.has(phase)) {\n            this.phaseHandlers.set(phase, new Set());\n        }\n        this.phaseHandlers.get(phase)!.add(handler);\n        \n        return () => {\n            this.phaseHandlers.get(phase)?.delete(handler);\n        };\n    }\n\n    /**\n     * Get current state\n     */\n    getState(): BootState {\n        return { ...this.state };\n    }\n\n    /**\n     * Get current shell instance\n     */\n    getShell(): Shell | null {\n        return this.shellInstance;\n    }\n\n    // ========================================================================\n    // PREFERENCES\n    // ========================================================================\n\n    /**\n     * Save boot preferences\n     */\n    private savePreferences(config: BootConfig): void {\n        try {\n            localStorage.setItem(\"rs-boot-style\", config.styleSystem);\n            localStorage.setItem(\"rs-boot-shell\", config.shell);\n            localStorage.setItem(\"rs-boot-view\", config.defaultView);\n            localStorage.setItem(\"rs-boot-remember\", \"1\");\n        } catch (error) {\n            console.warn(\"[BootLoader] Failed to save preferences:\", error);\n        }\n    }\n\n    /**\n     * Load boot preferences\n     */\n    loadPreferences(): Partial<BootConfig> | null {\n        try {\n            const remember = localStorage.getItem(\"rs-boot-remember\");\n            if (remember !== \"1\") return null;\n            \n            return {\n                styleSystem: (localStorage.getItem(\"rs-boot-style\") as StyleSystem) || undefined,\n                shell: (localStorage.getItem(\"rs-boot-shell\") as ShellId) || undefined,\n                defaultView: (localStorage.getItem(\"rs-boot-view\") as ViewId) || undefined\n            };\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Clear preferences\n     */\n    clearPreferences(): void {\n        try {\n            localStorage.removeItem(\"rs-boot-style\");\n            localStorage.removeItem(\"rs-boot-shell\");\n            localStorage.removeItem(\"rs-boot-view\");\n            localStorage.removeItem(\"rs-boot-remember\");\n        } catch {\n            // Ignore\n        }\n    }\n}\n\n// ============================================================================\n// CONVENIENCE EXPORTS\n// ============================================================================\n\n/**\n * Get the singleton boot loader\n */\nexport const bootLoader = BootLoader.getInstance();\n\n/**\n * Quick boot with default configuration\n */\nexport async function quickBoot(\n    container: HTMLElement,\n    shell: ShellId = \"minimal\",\n    view: ViewId = \"viewer\"\n): Promise<Shell> {\n    return bootLoader.boot(container, {\n        styleSystem: getRecommendedStyle(shell),\n        shell,\n        defaultView: view,\n        channels: [view as ServiceChannelId],\n        rememberChoice: false\n    });\n}\n\n/**\n * Boot with Veela + Faint shell\n */\nexport async function bootFaint(\n    container: HTMLElement,\n    view: ViewId = \"viewer\"\n): Promise<Shell> {\n    return bootLoader.boot(container, {\n        styleSystem: \"vl-basic\",\n        shell: \"faint\",\n        defaultView: view,\n        channels: [\"workcenter\", \"settings\", \"viewer\", \"explorer\"],\n        rememberChoice: true\n    });\n}\n\n/**\n * Boot with Minimal shell\n */\nexport async function bootMinimal(\n    container: HTMLElement,\n    view: ViewId = \"viewer\"\n): Promise<Shell> {\n    return bootLoader.boot(container, {\n        styleSystem: \"vl-basic\",\n        shell: \"minimal\",\n        defaultView: view,\n        channels: [\"workcenter\", \"settings\", \"viewer\"],\n        rememberChoice: true\n    });\n}\n\n/**\n * Boot with Raw shell (minimal)\n */\nexport async function bootBase(\n    container: HTMLElement,\n    view: ViewId = \"viewer\"\n): Promise<Shell> {\n    return bootLoader.boot(container, {\n        styleSystem: \"vl-core\",\n        shell: \"base\",\n        defaultView: view,\n        channels: [],\n        rememberChoice: false\n    });\n}\n\n// ============================================================================\n// DEFAULT EXPORT\n// ============================================================================\n\nexport default bootLoader;\n","/**\n * CRX Frontend Entry Point\n *\n * Entry point for Chrome extension pages (settings, newtab, viewer, etc.).\n * Uses the Raw shell (no toolbar / tabs / navigation chrome).\n * Loads basic styles and lets each view manage its own styling.\n *\n * Usage:\n *   import crxFrontend from \"./crx-entry\";\n *   crxFrontend(document.getElementById(\"app\")!, { initialView: \"settings\" });\n */\n\nimport { bootLoader } from \"./BootLoader\";\nimport type { ViewId, Shell } from \"../shells/types\";\nimport { ViewRegistry } from \"../registry\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport type CrxAppOptions = {\n    /** View to display - accepts both shell ViewId and legacy MinimalView names */\n    initialView?: ViewId | \"markdown\" | \"markdown-viewer\";\n    /** Optional URL-style params passed to the launched view */\n    viewParams?: Record<string, string>;\n    /** Optional initial payload passed to the launched view */\n    viewPayload?: unknown;\n};\n\n// ============================================================================\n// VIEW NAME MAPPING\n// ============================================================================\n\n/**\n * Map legacy / CRX-specific view names  canonical ViewId\n */\nconst CRX_VIEW_MAP: Record<string, ViewId> = {\n    \"markdown\":         \"viewer\",\n    \"markdown-viewer\":  \"viewer\",\n};\n\nconst resolveViewId = (input?: string): ViewId =>\n    (input && CRX_VIEW_MAP[input]) ?? (input as ViewId) ?? \"viewer\";\n\n// ============================================================================\n// ENTRY POINT\n// ============================================================================\n\n/**\n * Mount the frontend for a Chrome extension page.\n *\n * - Uses the **raw** shell (no toolbar, no tabs).\n * - Loads \"vl-basic\" style system (shell + view own styles handle the rest).\n * - No channels or preference persistence (CRX pages are single-purpose).\n *\n * @param mountElement - DOM element to mount into\n * @param options      - Optional view configuration\n * @returns The mounted shell instance\n */\nexport default async function crxFrontend(\n    mountElement: HTMLElement,\n    options: CrxAppOptions = {},\n): Promise<Shell> {\n    const view = resolveViewId(options.initialView);\n    const hasViewParams = Boolean(options.viewParams && Object.keys(options.viewParams).length > 0);\n    const hasPayload = options.viewPayload !== undefined && options.viewPayload !== null;\n\n    const shell = await bootLoader.boot(mountElement, {\n        styleSystem: \"vl-basic\",\n        shell:       \"base\",\n        defaultView: view,\n        channels:    [],\n        rememberChoice: false,\n    });\n\n    if (hasViewParams) {\n        await shell.navigate(view, options.viewParams);\n    }\n\n    if (hasPayload) {\n        const loadedView = ViewRegistry.getLoaded(view);\n        const asMessageCapable = loadedView as {\n            canHandleMessage?: (messageType: string) => boolean;\n            handleMessage?: (message: unknown) => Promise<void> | void;\n        } | undefined;\n\n        if (asMessageCapable?.canHandleMessage?.(\"content-load\") && asMessageCapable.handleMessage) {\n            await asMessageCapable.handleMessage({\n                type: \"content-load\",\n                data: options.viewPayload\n            });\n        } else if (asMessageCapable?.handleMessage) {\n            await asMessageCapable.handleMessage({\n                type: \"launch\",\n                data: options.viewPayload\n            });\n        }\n    }\n\n    return shell;\n}\n\nexport { crxFrontend };\n"],"file":"crx-entry.js"}