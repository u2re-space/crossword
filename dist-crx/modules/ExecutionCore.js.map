{"version":3,"mappings":"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","names":["result","options"],"ignoreList":[],"sources":["../../src/com/service/shared/gpt-utils.ts","../../src/com/service/platform/adapters.ts","../../src/com/service/processing/settings.ts","../../src/com/service/recognition/core.ts","../../src/com/service/recognition/smart.ts","../../src/com/service/processing/core.ts","../../src/com/service/processing/entities.ts","../../src/com/service/recognition/cache.ts","../../src/com/service/processing/unified.ts","../../src/com/service/misc/ActionHistory.ts","../../src/com/service/misc/ExecutionCore.ts"],"sourcesContent":["import { loadSettings } from \"@rs-com/config/Settings\";\nimport { GPTResponses, createGPTInstance } from \"../model/GPT-Responses\";\nimport type { AIConfig, OutputFormat } from \"./types\";\n\nconst DEFAULT_MODEL = \"gpt-5.2\";\nconst DEFAULT_API_URL = \"https://api.proxyapi.ru/openai/v1\";\n\nexport { DEFAULT_MODEL, DEFAULT_API_URL };\n\nexport const getGPTInstance = async (config?: AIConfig): Promise<GPTResponses | null> => {\n\tconst settings = await loadSettings();\n\tconst apiKey = config?.apiKey || settings?.ai?.apiKey;\n\n\tif (!apiKey) {\n\t\treturn null;\n\t}\n\n\tconst baseUrl = config?.baseUrl || settings?.ai?.baseUrl || DEFAULT_API_URL;\n\tconst model = config?.model || settings?.ai?.model || DEFAULT_MODEL;\n\n\treturn createGPTInstance(apiKey, baseUrl, model);\n};\n\nexport function unwrapUnwantedCodeBlocks(content: string): string {\n\tif (!content) return content;\n\n\tconst codeBlockRegex = /^```(?:katex|md|markdown|html|xml|json|text)?\\n([\\s\\S]*?)\\n```$/;\n\n\tconst match = content.trim().match(codeBlockRegex);\n\tif (match) {\n\t\tconst unwrapped = match[1].trim();\n\t\tconst lines = unwrapped.split(\"\\n\");\n\n\t\tif (lines.length === 1 ||\n\t\t\tunwrapped.includes(\"<math\") ||\n\t\t\tunwrapped.includes('<span class=\"katex') ||\n\t\t\tunwrapped.includes(\"<content\") ||\n\t\t\tunwrapped.startsWith(\"<\") && unwrapped.endsWith(\">\") ||\n\t\t\t/^\\s*<[^>]+>/.test(unwrapped)) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (lines.length > 3 ||\n\t\t\tlines.some(line => line.match(/^\\s{4,}/) || line.includes(\"function\") || line.includes(\"const \") || line.includes(\"let \"))) {\n\t\t\treturn content;\n\t\t}\n\n\t\treturn unwrapped;\n\t}\n\n\treturn content;\n}\n\nexport function isImageData(data: any): boolean {\n\treturn (data instanceof File && data.type.startsWith(\"image/\")) ||\n\t\t(data instanceof Blob && data.type?.startsWith(\"image/\")) ||\n\t\t(typeof data === \"string\" && (data.startsWith(\"data:image/\") || data.startsWith(\"http\") || data.startsWith(\"https://\")));\n}\n\nexport function getResponseFormat(format: OutputFormat): \"json\" | \"text\" {\n\tconst jsonFormats: OutputFormat[] = [\"json\", \"xml\", \"yaml\"];\n\treturn jsonFormats.includes(format) ? \"json\" : \"text\";\n}\n\nexport const pickFirstError = (raw: any): string | undefined => {\n\tif (!raw) return undefined;\n\tif (typeof raw.error === \"string\" && raw.error.trim()) return raw.error;\n\tif (Array.isArray(raw.errors) && typeof raw.errors[0] === \"string\" && raw.errors[0].trim()) return raw.errors[0];\n\treturn undefined;\n};\n\nexport const extractText = (raw: any): string | undefined => {\n\tif (!raw) return undefined;\n\n\tif (typeof raw.data === \"string\") {\n\t\tconst t = raw.data.trim();\n\t\tif (t) return t;\n\t}\n\n\tif (typeof raw.verbose_data === \"string\") {\n\t\tconst t = raw.verbose_data.trim();\n\t\tif (t) return t;\n\t}\n\n\tconst rd = raw.recognized_data;\n\tif (typeof rd === \"string\") {\n\t\tconst t = rd.trim();\n\t\tif (t) return t;\n\t}\n\n\tif (Array.isArray(rd)) {\n\t\tconst parts: string[] = [];\n\t\tfor (const item of rd) {\n\t\t\tif (typeof item === \"string\") {\n\t\t\t\tif (item.trim()) parts.push(item.trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst maybe = (item?.output ?? item?.text ?? item?.content ?? item?.value) as unknown;\n\t\t\tif (typeof maybe === \"string\" && maybe.trim()) parts.push(maybe.trim());\n\t\t}\n\t\tconst joined = parts.join(\"\\n\").trim();\n\t\tif (joined) return joined;\n\t}\n\n\treturn undefined;\n};\n\nexport const toCrxResult = (raw: any): { ok: boolean; data?: string; error?: string; raw?: any } => {\n\tconst ok = !!raw?.ok;\n\tconst data = extractText(raw);\n\tconst error = pickFirstError(raw) ?? (ok && !data ? \"No data recognized\" : undefined);\n\n\treturn {\n\t\tok: ok && !!data,\n\t\tdata,\n\t\terror,\n\t\traw,\n\t};\n};\n","import type { ClipboardResult, ImageProcessingOptions, PlatformAdapter } from \"../shared/types\";\n\nconst createPwaAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tconst { writeText } = await import(\"@rs-core/modules/Clipboard\");\n\t\t\treturn (await writeText(data)) as ClipboardResult;\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync processImage(dataUrl: string): Promise<string> {\n\t\treturn dataUrl;\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\ttry {\n\t\t\timport(\"@rs-frontend/items/Toast\").then(({ showToast }) => {\n\t\t\t\tshowToast({\n\t\t\t\t\tmessage,\n\t\t\t\t\tkind: options?.type || \"info\",\n\t\t\t\t\tduration: options?.duration || 3000,\n\t\t\t\t});\n\t\t\t});\n\t\t} catch {\n\t\t\tconsole.log(message);\n\t\t}\n\t},\n});\n\nconst createCrxAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tconst { requestCopyViaCRX } = await import(\"@rs-core/modules/Clipboard\");\n\t\t\tconst result = await requestCopyViaCRX(data);\n\t\t\treturn { ok: result.ok, data: result.data as string | undefined };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) as string | undefined };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync processImage(dataUrl: string): Promise<string> {\n\t\ttry {\n\t\t\tconst isServiceWorker = typeof globalThis === \"undefined\" || !globalThis?.document;\n\n\t\t\tif (isServiceWorker) {\n\t\t\t\tconsole.warn(\"[RecognizeData] Image processing not available in service worker context\");\n\t\t\t\treturn dataUrl;\n\t\t\t}\n\n\t\t\tconst { encodeWithJSquash, removeAnyPrefix } = await import(\"@rs-core/workers/ImageProcess\");\n\t\t\tconst SIZE_THRESHOLD = 2 * 1024 * 1024;\n\t\t\tif (dataUrl.length <= SIZE_THRESHOLD) return dataUrl;\n\n\t\t\ttry {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst binary = Uint8Array.fromBase64(removeAnyPrefix(dataUrl), { alphabet: \"base64\" });\n\t\t\t\tconst blob = new Blob([binary], { type: \"image/png\" });\n\t\t\t\tconst bitmap = await createImageBitmap(blob);\n\t\t\t\tconst arrayBuffer = await encodeWithJSquash(bitmap);\n\t\t\t\tbitmap?.close?.();\n\n\t\t\t\tif (arrayBuffer) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst base64 = new Uint8Array(arrayBuffer).toBase64({ alphabet: \"base64\" });\n\t\t\t\t\treturn `data:image/jpeg;base64,${base64}`;\n\t\t\t\t}\n\t\t\t} catch (processingError) {\n\t\t\t\tconsole.warn(\"[RecognizeData] Image compression failed:\", processingError);\n\t\t\t}\n\n\t\t\treturn dataUrl;\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"[RecognizeData] Image processing failed:\", e);\n\t\t\treturn dataUrl;\n\t\t}\n\t},\n\n\tasync captureScreenshot(rect?: {\n\t\tx: number;\n\t\ty: number;\n\t\twidth: number;\n\t\theight: number;\n\t}): Promise<string> {\n\t\ttry {\n\t\t\tif (typeof chrome !== \"undefined\" && chrome.tabs?.captureVisibleTab) {\n\t\t\t\tconst captureOptions: any = { format: \"png\", scale: 1 };\n\t\t\t\tif (rect) {\n\t\t\t\t\tcaptureOptions.rect = rect;\n\t\t\t\t}\n\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tchrome.tabs.captureVisibleTab(captureOptions, (dataUrl) => {\n\t\t\t\t\t\tif (chrome.runtime.lastError) {\n\t\t\t\t\t\t\treject(new Error(chrome.runtime.lastError.message));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(dataUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow new Error(\"Screenshot capture not available\");\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Screenshot capture failed: ${e}`);\n\t\t}\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\tconsole.log(`[${options?.type || \"info\"}] ${message}`);\n\t},\n});\n\nconst createCoreAdapter = (): PlatformAdapter => ({\n\tasync copyToClipboard(data: string): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.writeText) {\n\t\t\t\tawait navigator.clipboard.writeText(data);\n\t\t\t\treturn { ok: true, data, method: \"clipboard-api\" };\n\t\t\t}\n\n\t\t\tconst textArea = document.createElement(\"textarea\");\n\t\t\ttextArea.value = data;\n\t\t\ttextArea.style.cssText = \"position:fixed;left:-9999px;top:-9999px;opacity:0;\";\n\t\t\tdocument.body.appendChild(textArea);\n\t\t\ttextArea.select();\n\n\t\t\tconst success = document.execCommand(\"copy\");\n\t\t\ttextArea.remove();\n\n\t\t\treturn success ? { ok: true, data, method: \"legacy\" } : { ok: false, error: \"Copy failed\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tasync readFromClipboard(): Promise<ClipboardResult> {\n\t\ttry {\n\t\t\tif (navigator.clipboard?.readText) {\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\treturn { ok: true, data: text };\n\t\t\t}\n\t\t\treturn { ok: false, error: \"Clipboard access not available\" };\n\t\t} catch (e) {\n\t\t\treturn { ok: false, error: String(e) };\n\t\t}\n\t},\n\n\tshowNotification(\n\t\tmessage: string,\n\t\toptions?: { type?: \"info\" | \"success\" | \"warning\" | \"error\"; duration?: number },\n\t): void {\n\t\tconsole.log(`[${options?.type || \"info\"}] ${message}`);\n\t},\n});\n\nexport const detectPlatform = (): \"pwa\" | \"crx\" | \"core\" | \"unknown\" => {\n\ttry {\n\t\tif (typeof chrome !== \"undefined\" && chrome?.runtime?.id) {\n\t\t\treturn \"crx\";\n\t\t}\n\n\t\tif (typeof self !== \"undefined\" && \"ServiceWorkerGlobalScope\" in self) {\n\t\t\treturn \"pwa\";\n\t\t}\n\n\t\tif (typeof navigator !== \"undefined\" && \"standalone\" in navigator) {\n\t\t\treturn \"pwa\";\n\t\t}\n\n\t\treturn \"core\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n};\n\nexport const getPlatformAdapter = (): PlatformAdapter => {\n\tconst platform = detectPlatform();\n\n\tswitch (platform) {\n\t\tcase \"crx\":\n\t\t\treturn createCrxAdapter();\n\t\tcase \"pwa\":\n\t\t\treturn createPwaAdapter();\n\t\tcase \"core\":\n\t\tdefault:\n\t\t\treturn createCoreAdapter();\n\t}\n};\n","import { getRuntimeSettings } from \"@rs-com/config/RuntimeSettings\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport type { ResponseLanguage } from \"@rs-com/config/SettingsTypes\";\nimport { detectPlatform } from \"../platform/adapters\";\nimport { SVG_GRAPHICS_ADDON, LANGUAGE_INSTRUCTIONS, TRANSLATE_INSTRUCTION } from \"../instructions/utils\";\n\nexport const loadAISettings = async () => {\n\tconst platform = detectPlatform();\n\n\ttry {\n\t\tif (platform === \"crx\") {\n\t\t\treturn await loadSettings();\n\t\t} else {\n\t\t\treturn await getRuntimeSettings();\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(`[AI-Service] Failed to load settings for platform ${platform}:`, e);\n\t\treturn null;\n\t}\n};\n\nexport const getActiveCustomInstruction = async (): Promise<string> => {\n\ttry {\n\t\tconst { getActiveInstructionText } = await import(\"../misc/CustomInstructions\");\n\t\treturn await getActiveInstructionText();\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n\nexport const getLanguageInstruction = async (): Promise<string> => {\n\ttry {\n\t\tconst settings = await loadAISettings();\n\t\tconst lang = (settings?.ai?.responseLanguage || \"auto\") as ResponseLanguage;\n\t\tconst translate = settings?.ai?.translateResults || false;\n\n\t\tlet instruction = LANGUAGE_INSTRUCTIONS[lang] || \"\";\n\t\tif (translate && lang !== \"auto\") {\n\t\t\tinstruction += TRANSLATE_INSTRUCTION;\n\t\t}\n\t\treturn instruction;\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n\nexport const getSvgGraphicsAddon = async (): Promise<string> => {\n\ttry {\n\t\tconst settings = await loadAISettings();\n\t\treturn settings?.ai?.generateSvgGraphics ? SVG_GRAPHICS_ADDON : \"\";\n\t} catch {\n\t\treturn \"\";\n\t}\n};\n","import { getUsableData } from \"@rs-com/service/model/GPT-Responses\";\nimport { detectDataKindFromContent, type DataContext, type DataKind } from \"@rs-com/service/model/GPT-Config\";\nimport { extractJSONFromAIResponse } from \"@rs-core/document/AIResponseParser\";\nimport { getGPTInstance } from \"@rs-com/service/shared/gpt-utils\";\nimport { CORE_IMAGE_INSTRUCTION, CORE_DATA_CONVERSION_INSTRUCTION, CORE_ENTITY_EXTRACTION_INSTRUCTION } from \"@rs-com/service/instructions/core\";\nimport type {\n\tAIConfig,\n\tRecognitionMode,\n\tRecognitionResult,\n\tBatchRecognitionResult,\n\tRecognizeByInstructionsOptions,\n} from \"@rs-com/service/shared/types\";\n\nexport const recognizeImageData = async (\n\tinput: any,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst { recognizeByInstructions } = await import(\"@rs-com/service/processing/unified\");\n\treturn recognizeByInstructions(input, CORE_IMAGE_INSTRUCTION, sendResponse, config, options);\n};\n\nexport const convertTextualData = async (\n\tinput: any,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst { recognizeByInstructions } = await import(\"@rs-com/service/processing/unified\");\n\treturn recognizeByInstructions(input, CORE_DATA_CONVERSION_INSTRUCTION, sendResponse, config, options);\n};\n\nexport const analyzeRecognizeUnified = async (\n\trawData: File | Blob | string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst content = await getUsableData({ dataSource: rawData });\n\tconst input = [\n\t\t{\n\t\t\ttype: \"message\",\n\t\t\trole: \"user\",\n\t\t\tcontent: [content],\n\t\t},\n\t];\n\treturn (content?.[0]?.type === \"input_image\" || content?.type === \"input_image\")\n\t\t? recognizeImageData(input, sendResponse, config, options)\n\t\t: convertTextualData(input, sendResponse, config, options);\n};\n\nexport const recognizeWithContext = async (\n\tdata: File | Blob | string,\n\tcontext?: DataContext,\n\tmode: RecognitionMode = \"auto\",\n\tconfig?: AIConfig,\n): Promise<RecognitionResult> => {\n\tconst startTime = performance.now();\n\n\tconst result: RecognitionResult = {\n\t\tok: false,\n\t\trecognized_data: [],\n\t\tkeywords_and_tags: [],\n\t\tverbose_data: \"\",\n\t\tsuggested_type: null,\n\t\tconfidence: 0,\n\t\tsource_kind: \"input_text\",\n\t\tprocessing_time_ms: 0,\n\t\terrors: [],\n\t\twarnings: [],\n\t};\n\n\ttry {\n\t\tconst gpt = await getGPTInstance(config);\n\t\tif (!gpt) {\n\t\t\tresult.errors.push(\"No GPT instance available\");\n\t\t\treturn result;\n\t\t}\n\n\t\tgpt.setContext(context || null);\n\n\t\tlet dataKind: DataKind = \"input_text\";\n\t\tif (data instanceof File || data instanceof Blob) {\n\t\t\tif (data.type.startsWith(\"image/\")) {\n\t\t\t\tdataKind = \"input_image\";\n\t\t\t} else if (data.type.includes(\"json\")) {\n\t\t\t\tdataKind = \"json\";\n\t\t\t}\n\t\t} else if (typeof data === \"string\") {\n\t\t\tdataKind = detectDataKindFromContent(data);\n\t\t}\n\t\tresult.source_kind = dataKind;\n\n\t\tif (mode === \"image\") dataKind = \"input_image\";\n\t\telse if (mode === \"text\") dataKind = \"input_text\";\n\t\telse if (mode === \"structured\") dataKind = \"json\";\n\n\t\tif (Array.isArray(data) && (data?.[0]?.type === \"message\" || data?.[0]?.[\"role\"])) {\n\t\t\tawait gpt?.getPending?.()?.push?.(...data);\n\t\t} else {\n\t\t\tawait gpt?.attachToRequest?.(data, dataKind);\n\t\t}\n\n\t\tconst instruction =\n\t\t\tdataKind === \"input_image\" ? CORE_IMAGE_INSTRUCTION : CORE_DATA_CONVERSION_INSTRUCTION;\n\n\t\tconst contextAddition = context?.entityType ? `\\n\\nExpected entity type context: ${context?.entityType}` : \"\";\n\t\tconst searchAddition = context?.searchTerms?.length\n\t\t\t? `\\n\\nFocus on finding: ${context?.searchTerms?.join?.(\", \")}`\n\t\t\t: \"\";\n\n\t\tawait gpt.askToDoAction(instruction + contextAddition + searchAddition);\n\n\t\tconst raw = await gpt.sendRequest(context?.priority === \"high\" ? \"high\" : \"medium\", \"medium\", null, {\n\t\t\tresponseFormat: \"json\",\n\t\t\ttemperature: 0.3,\n\t\t});\n\n\t\tif (!raw) {\n\t\t\tresult.errors.push(\"No response from AI\");\n\t\t\treturn result;\n\t\t}\n\n\t\tconst parseResult = extractJSONFromAIResponse<any>(raw);\n\t\tif (!parseResult.ok) {\n\t\t\tresult.errors.push(parseResult.error || \"Failed to parse AI response\");\n\t\t\tresult.verbose_data = raw;\n\t\t\treturn result;\n\t\t}\n\n\t\tconst parsed = parseResult.data;\n\t\tresult.ok = true;\n\t\tresult.recognized_data = parsed?.recognized_data || [parsed?.verbose_data || raw];\n\t\tresult.keywords_and_tags = parsed?.keywords_and_tags || parsed?.keywords || [];\n\t\tresult.verbose_data = parsed?.verbose_data || \"\";\n\t\tresult.suggested_type = parsed?.document_type || parsed?.source_format || null;\n\t\tresult.confidence = parsed?.confidence || 0.7;\n\t} catch (e) {\n\t\tresult.errors.push(String(e));\n\t}\n\n\tresult.processing_time_ms = performance.now() - startTime;\n\treturn result;\n};\n\nexport const batchRecognize = async (\n\titems: (File | Blob | string)[],\n\tcontext?: DataContext,\n\tconcurrency: number = 3,\n\tconfig?: AIConfig,\n): Promise<BatchRecognitionResult> => {\n\tconst startTime = performance.now();\n\n\tconst result: BatchRecognitionResult = {\n\t\tok: true,\n\t\tresults: [],\n\t\ttotal_processed: items.length,\n\t\ttotal_successful: 0,\n\t\ttotal_failed: 0,\n\t\tcombined_keywords: [],\n\t\tprocessing_time_ms: 0,\n\t};\n\n\tconst keywordSet = new Set<string>();\n\n\tfor (let i = 0; i < items.length; i += concurrency) {\n\t\tconst batch = items.slice(i, i + concurrency);\n\n\t\tconst promises = batch.map((item) => recognizeWithContext(item, context || {}, \"auto\", config));\n\n\t\tconst batchResults = await Promise.all(promises);\n\n\t\tfor (const r of batchResults) {\n\t\t\tresult.results.push(r);\n\n\t\t\tif (r.ok) {\n\t\t\t\tresult.total_successful++;\n\t\t\t\tr.keywords_and_tags.forEach((k) => keywordSet.add(k));\n\t\t\t} else {\n\t\t\t\tresult.total_failed++;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.ok = result.total_failed === 0;\n\tresult.combined_keywords = Array.from(keywordSet);\n\tresult.processing_time_ms = performance.now() - startTime;\n\n\treturn result;\n};\n","import { extractJSONFromAIResponse } from \"@rs-core/document/AIResponseParser\";\nimport { getGPTInstance } from \"@rs-com/service/shared/gpt-utils\";\nimport { recognizeWithContext } from \"./core\";\nimport type { AIConfig, RecognitionResult } from \"@rs-com/service/shared/types\";\n\nexport const smartRecognize = async (\n\tdata: File | Blob | string,\n\thints?: {\n\t\texpectedType?: string;\n\t\tlanguage?: string;\n\t\tdomain?: string;\n\t\textractEntities?: boolean;\n\t},\n\tconfig?: AIConfig,\n): Promise<RecognitionResult & { entities?: any[] }> => {\n\tconst { extractEntities } = await import(\"@rs-com/service/processing/entities\");\n\n\tconst baseResult = await recognizeWithContext(\n\t\tdata,\n\t\t{\n\t\t\tentityType: hints?.expectedType,\n\t\t\tsearchTerms: hints?.domain ? [hints.domain] : undefined,\n\t\t},\n\t\t\"auto\",\n\t\tconfig,\n\t);\n\n\tif (!baseResult.ok) {\n\t\treturn baseResult;\n\t}\n\n\tif (hints?.extractEntities) {\n\t\tconst entityResult = await extractEntities(data, config);\n\t\treturn {\n\t\t\t...baseResult,\n\t\t\tentities: entityResult.ok ? entityResult.data : undefined,\n\t\t};\n\t}\n\n\treturn baseResult;\n};\n\nexport const recognizeAndNormalize = async (\n\tdata: File | Blob | string,\n\tnormalizations: {\n\t\tphones?: boolean;\n\t\temails?: boolean;\n\t\turls?: boolean;\n\t\tdates?: boolean;\n\t\taddresses?: boolean;\n\t} = {},\n): Promise<RecognitionResult & { normalized: Record<string, any[]> }> => {\n\tconst baseResult = await recognizeWithContext(data, {});\n\n\tconst normalized: Record<string, any[]> = {\n\t\tphones: [],\n\t\temails: [],\n\t\turls: [],\n\t\tdates: [],\n\t\taddresses: [],\n\t};\n\n\tif (!baseResult.ok) {\n\t\treturn { ...baseResult, normalized };\n\t}\n\n\ttry {\n\t\tconst gpt = await getGPTInstance();\n\t\tif (!gpt) {\n\t\t\treturn { ...baseResult, normalized };\n\t\t}\n\n\t\tconst enabledNormalizations = Object.entries(normalizations)\n\t\t\t.filter(([_, v]) => v)\n\t\t\t.map(([k]) => k);\n\n\t\tif (enabledNormalizations.length === 0) {\n\t\t\treturn { ...baseResult, normalized };\n\t\t}\n\n\t\tawait gpt.giveForRequest(`\nRecognized data:\n\\`\\`\\`\n${baseResult.verbose_data || baseResult.recognized_data.join(\"\\n\")}\n\\`\\`\\`\n\t\t`);\n\n\t\tawait gpt.askToDoAction(`\nExtract and normalize the following types: ${enabledNormalizations.join(\", \")}\n\nNormalization rules:\n- phones: E.164 format or local format with country code\n- emails: lowercase, trimmed\n- urls: full URL with protocol\n- dates: ISO 8601 format (YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)\n- addresses: structured with street, city, country if detectable\n\nCRITICAL OUTPUT FORMAT: Return ONLY valid JSON. No markdown code blocks, no explanations.\nYour response must start with { and end with }.\n\nExpected output structure:\n{\n    \"phones\": [\"...\"],\n    \"emails\": [\"...\"],\n    \"urls\": [\"...\"],\n    \"dates\": [\"...\"],\n    \"addresses\": [{ \"raw\": \"...\", \"structured\": {...} }]\n}\n\t\t`);\n\n\t\tconst raw = await gpt.sendRequest(\"medium\", \"low\", null, {\n\t\t\tresponseFormat: \"json\",\n\t\t\ttemperature: 0.1,\n\t\t});\n\n\t\tif (raw) {\n\t\t\tconst parseResult = extractJSONFromAIResponse<any>(raw);\n\t\t\tif (parseResult.ok && parseResult.data) {\n\t\t\t\tObject.assign(normalized, parseResult.data);\n\t\t\t} else {\n\t\t\t\tbaseResult.warnings.push(\"Normalization JSON parsing partially failed\");\n\t\t\t}\n\t\t}\n\t} catch {\n\t\tbaseResult.warnings.push(\"Normalization partially failed\");\n\t}\n\n\treturn { ...baseResult, normalized };\n};\n\nexport const recognizeFromClipboard = async (): Promise<RecognitionResult | null> => {\n\ttry {\n\t\tconst clipboardItems = await navigator.clipboard.read().catch(() => null);\n\n\t\tif (clipboardItems) {\n\t\t\tfor (const item of clipboardItems) {\n\t\t\t\tfor (const type of item.types) {\n\t\t\t\t\tif (type.startsWith(\"image/\")) {\n\t\t\t\t\t\tconst blob = await item.getType(type);\n\t\t\t\t\t\treturn recognizeWithContext(blob, {});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst text = await navigator.clipboard.readText().catch(() => null);\n\t\tif (text) {\n\t\t\treturn recognizeWithContext(text, {});\n\t\t}\n\n\t\treturn null;\n\t} catch {\n\t\treturn null;\n\t}\n};\n","import { SOLVE_AND_ANSWER_INSTRUCTION, WRITE_CODE_INSTRUCTION, EXTRACT_CSS_INSTRUCTION } from \"../instructions/core\";\nimport { getGPTInstance } from \"../shared/gpt-utils\";\nimport { getActiveCustomInstruction, getLanguageInstruction, getSvgGraphicsAddon } from \"./settings\";\nimport type { DataKind } from \"../model/GPT-Config\";\nimport type { RecognitionResult, RecognizeByInstructionsOptions } from \"../shared/types\";\n\nconst emptyResult = (errors: string[], processingTime: number): RecognitionResult => ({\n\tok: false,\n\trecognized_data: [],\n\tkeywords_and_tags: [],\n\tverbose_data: \"\",\n\tsuggested_type: null,\n\tconfidence: 0,\n\tsource_kind: \"unknown\" as unknown as DataKind,\n\tprocessing_time_ms: processingTime,\n\terrors,\n\twarnings: [],\n});\n\nconst runInstructionTask = async (\n\tinput: any,\n\tinstructionConst: string,\n\tresultTags: string[],\n\tresultType: string,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\tconst gpt = await getGPTInstance();\n\tif (!gpt) return emptyResult([\"AI service not available\"], 0);\n\n\tconst startTime = Date.now();\n\n\ttry {\n\t\tconst languageInstruction = await getLanguageInstruction();\n\t\tconst svgAddon = await getSvgGraphicsAddon();\n\t\tconst instruction = instructionConst + languageInstruction + svgAddon;\n\n\t\tlet customInstruction = \"\";\n\t\tif (options?.customInstruction) {\n\t\t\tcustomInstruction = options.customInstruction;\n\t\t} else if (options?.useActiveInstruction) {\n\t\t\tcustomInstruction = await getActiveCustomInstruction();\n\t\t}\n\n\t\tif (customInstruction) {\n\t\t\tawait gpt.askToDoAction(customInstruction);\n\t\t}\n\n\t\tawait gpt.askToDoAction(instruction);\n\t\tawait gpt.giveForRequest(input);\n\n\t\tconst rawResponse = await gpt.sendRequest(\"high\", \"medium\");\n\t\tconst processingTime = Date.now() - startTime;\n\n\t\tif (rawResponse) {\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\trecognized_data: [rawResponse],\n\t\t\t\tkeywords_and_tags: resultTags,\n\t\t\t\tverbose_data: rawResponse,\n\t\t\t\tsuggested_type: resultType,\n\t\t\t\tconfidence: 0.9,\n\t\t\t\tsource_kind: \"text\" as unknown as DataKind,\n\t\t\t\tprocessing_time_ms: processingTime,\n\t\t\t\terrors: [],\n\t\t\t\twarnings: [],\n\t\t\t};\n\t\t} else {\n\t\t\treturn emptyResult([`Failed to get ${resultType} response`], processingTime);\n\t\t}\n\t} catch (e) {\n\t\treturn emptyResult([String(e)], Date.now() - startTime);\n\t}\n};\n\nexport const solveAndAnswer = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, SOLVE_AND_ANSWER_INSTRUCTION, [\"solution\", \"answer\"], \"solution\", options);\n};\n\nexport const writeCode = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, WRITE_CODE_INSTRUCTION, [\"code\", \"programming\"], \"code\", options);\n};\n\nexport const extractCSS = async (\n\tinput: any,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<RecognitionResult> => {\n\treturn runInstructionTask(input, EXTRACT_CSS_INSTRUCTION, [\"css\", \"styles\", \"stylesheet\"], \"css\", options);\n};\n\nexport const solveEquation = solveAndAnswer;\nexport const answerQuestion = solveAndAnswer;\n","import { detectDataKindFromContent } from \"@rs-com/service/model/GPT-Config\";\nimport { extractJSONFromAIResponse } from \"@rs-core/document/AIResponseParser\";\nimport { loadSettings } from \"@rs-com/config/Settings\";\nimport { getGPTInstance } from \"../shared/gpt-utils\";\nimport {\n\tCORE_ENTITY_EXTRACTION_INSTRUCTION,\n\tDATA_MODIFICATION_INSTRUCTION,\n} from \"../instructions/core\";\nimport type { AIConfig, ExtractionRule, ExtractionResult } from \"../shared/types\";\nimport type { AIResponse } from \"@rs-com/service/model/GPT-Responses\";\n\nexport const extractEntities = async (\n\tdata: File | Blob | string,\n\tconfig?: AIConfig,\n): Promise<AIResponse<any[]>> => {\n\ttry {\n\t\tconst gpt = await getGPTInstance(config);\n\t\tif (!gpt) {\n\t\t\treturn { ok: false, error: \"No GPT instance\" };\n\t\t}\n\n\t\tconst dataKind =\n\t\t\ttypeof data === \"string\"\n\t\t\t\t? detectDataKindFromContent(data)\n\t\t\t\t: (data instanceof File || data instanceof Blob) && data.type.startsWith(\"image/\")\n\t\t\t\t\t? \"input_image\"\n\t\t\t\t\t: \"input_text\";\n\n\t\tif (Array.isArray(data) && (data?.[0]?.type === \"message\" || data?.[0]?.[\"role\"])) {\n\t\t\tawait gpt?.getPending?.()?.push?.(...data);\n\t\t} else {\n\t\t\tawait gpt?.attachToRequest?.(data, dataKind);\n\t\t}\n\n\t\tawait gpt.askToDoAction(CORE_ENTITY_EXTRACTION_INSTRUCTION);\n\n\t\tconst raw = await gpt.sendRequest(\"high\", \"medium\", null, {\n\t\t\tresponseFormat: \"json\",\n\t\t\ttemperature: 0.2,\n\t\t});\n\n\t\tif (!raw) {\n\t\t\treturn { ok: false, error: \"No response\" };\n\t\t}\n\n\t\tconst parseResult = extractJSONFromAIResponse<any>(raw);\n\t\tif (!parseResult.ok) {\n\t\t\treturn { ok: false, error: parseResult.error || \"Failed to parse AI response\" };\n\t\t}\n\n\t\treturn {\n\t\t\tok: true,\n\t\t\tdata: parseResult.data?.entities || [],\n\t\t\tresponseId: gpt.getResponseId(),\n\t\t};\n\t} catch (e) {\n\t\treturn { ok: false, error: String(e) };\n\t}\n};\n\nexport const modifyEntityData = async (\n\texistingEntity: any,\n\tmodificationPrompt: string,\n\tsendResponse?: (result: any) => void,\n): Promise<{ ok: boolean; data?: string; error?: string }> => {\n\tconst settings = (await loadSettings())?.ai;\n\tconst token = settings?.apiKey;\n\n\tif (!token) {\n\t\tconst result = { ok: false, error: \"No API key\" };\n\t\tsendResponse?.(result);\n\t\treturn result;\n\t}\n\n\tconst instructions = `\n${DATA_MODIFICATION_INSTRUCTION}\n\nExisting entity to modify:\n\\`\\`\\`json\n${JSON.stringify(existingEntity, null, 2)}\n\\`\\`\\`\n\nUser modification request: ${modificationPrompt}\n`;\n\n\tconst input = [\n\t\t{\n\t\t\ttype: \"message\",\n\t\t\trole: \"user\",\n\t\t\tcontent: [{ type: \"input_text\", text: instructions }],\n\t\t},\n\t];\n\n\tconst { recognizeByInstructions } = await import(\"@rs-com/service/processing/unified\");\n\treturn recognizeByInstructions(input, \"\", sendResponse);\n};\n\nexport const extractByRules = async (data: string, rules: ExtractionRule[]): Promise<ExtractionResult[]> => {\n\tconst results: ExtractionResult[] = [];\n\n\ttry {\n\t\tconst gpt = await getGPTInstance();\n\t\tif (!gpt) {\n\t\t\treturn results;\n\t\t}\n\n\t\tconst rulesDescription = rules\n\t\t\t.map(\n\t\t\t\t(r) =>\n\t\t\t\t\t`- ${r.name} (${r.type}): ${r.pattern ? `pattern: ${r.pattern}` : \"auto-detect\"}${r.format ? `, format as: ${r.format}` : \"\"}${r.required ? \" [REQUIRED]\" : \"\"}`,\n\t\t\t)\n\t\t\t.join(\"\\n\");\n\n\t\tawait gpt.giveForRequest(`\nInput data:\n\\`\\`\\`\n${data}\n\\`\\`\\`\n\nExtraction rules:\n${rulesDescription}\n\t\t`);\n\n\t\tawait gpt.askToDoAction(`\nExtract data according to the rules.\nFor each rule, find matching content and normalize it.\n\nCRITICAL OUTPUT FORMAT: Return ONLY valid JSON. No markdown code blocks, no explanations.\nYour response must start with { and end with }.\n\nExpected output structure:\n{\n    \"extractions\": [\n        {\n            \"field\": \"rule name\",\n            \"value\": \"normalized value\",\n            \"confidence\": 0.0-1.0,\n            \"raw\": \"original text\",\n            \"normalized\": \"formatted value\"\n        }\n    ],\n    \"missing_required\": [\"list of required fields not found\"]\n}\n\t\t`);\n\n\t\tconst raw = await gpt.sendRequest(\"medium\", \"low\", null, {\n\t\t\tresponseFormat: \"json\",\n\t\t\ttemperature: 0.1,\n\t\t});\n\n\t\tif (!raw) return results;\n\n\t\tconst parseResult = extractJSONFromAIResponse<any>(raw);\n\t\tif (!parseResult.ok || !parseResult.data) {\n\t\t\treturn results;\n\t\t}\n\n\t\treturn parseResult.data?.extractions || [];\n\t} catch {\n\t\treturn results;\n\t}\n};\n","import type { OutputFormat, RecognitionCacheEntry } from \"@rs-com/service/shared/types\";\n\nexport class RecognitionCache {\n\tprivate cache = new Map<string, RecognitionCacheEntry>();\n\tprivate maxEntries = 100;\n\tprivate ttl = 24 * 60 * 60 * 1000;\n\n\tprivate generateDataHash(data: any): string {\n\t\tif (data instanceof File) {\n\t\t\treturn `${data.name}-${data.size}-${data.lastModified}`;\n\t\t}\n\t\tif (typeof data === \"string\") {\n\t\t\treturn btoa(data).substring(0, 32);\n\t\t}\n\t\treturn JSON.stringify(data).substring(0, 32);\n\t}\n\n\tget(data: any, format?: OutputFormat): RecognitionCacheEntry | null {\n\t\tconst hash = this.generateDataHash(data);\n\t\tconst entry = this.cache.get(hash);\n\n\t\tif (!entry) return null;\n\n\t\tif (Date.now() - entry.timestamp > this.ttl) {\n\t\t\tthis.cache.delete(hash);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (format && entry.recognizedAs !== format) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry;\n\t}\n\n\tset(\n\t\tdata: any,\n\t\trecognizedData: string,\n\t\trecognizedAs: OutputFormat,\n\t\tresponseId: string,\n\t\tmetadata?: Record<string, any>,\n\t): void {\n\t\tconst hash = this.generateDataHash(data);\n\n\t\tif (this.cache.size >= this.maxEntries) {\n\t\t\tconst oldestKey = Array.from(this.cache.entries()).sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];\n\t\t\tthis.cache.delete(oldestKey);\n\t\t}\n\n\t\tthis.cache.set(hash, {\n\t\t\tdataHash: hash,\n\t\t\trecognizedData,\n\t\t\trecognizedAs,\n\t\t\ttimestamp: Date.now(),\n\t\t\tresponseId,\n\t\t\tmetadata,\n\t\t});\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n\n\tgetStats() {\n\t\treturn {\n\t\t\tentries: this.cache.size,\n\t\t\tmaxEntries: this.maxEntries,\n\t\t\tttl: this.ttl,\n\t\t};\n\t}\n}\n","import { loadSettings } from \"@rs-com/config/Settings\";\nimport { createGPTInstance } from \"@rs-com/service/model/GPT-Responses\";\nimport { buildInstructionPrompt, getOutputFormatInstruction, getIntermediateRecognitionInstruction } from \"@rs-com/service/instructions/utils\";\nimport { DEFAULT_API_URL, DEFAULT_MODEL, isImageData, unwrapUnwantedCodeBlocks, getResponseFormat } from \"@rs-com/service/shared/gpt-utils\";\nimport { loadAISettings, getActiveCustomInstruction, getLanguageInstruction, getSvgGraphicsAddon } from \"@rs-com/service/processing/settings\";\nimport { RecognitionCache } from \"@rs-com/service/recognition/cache\";\nimport { detectPlatform, getPlatformAdapter } from \"@rs-com/service/platform/adapters\";\nimport { solveAndAnswer, writeCode, extractCSS } from \"@rs-com/service/processing/core\";\nimport { extractEntities } from \"@rs-com/service/processing/entities\";\nimport { smartRecognize } from \"@rs-com/service/recognition/smart\";\nimport type {\n\tAIConfig,\n\tProcessDataWithInstructionOptions,\n\tProcessDataWithInstructionResult,\n\tRecognizeByInstructionsOptions,\n} from \"@rs-com/service/shared/types\";\n\nconst recognitionCache = new RecognitionCache();\n\nexport const processDataWithInstruction = async (\n\tinput: any,\n\toptions: ProcessDataWithInstructionOptions = {},\n\tsendResponse?: (result: ProcessDataWithInstructionResult) => void,\n): Promise<ProcessDataWithInstructionResult> => {\n\tconst settings = (await loadSettings())?.ai;\n\n\tconst {\n\t\tinstruction = \"\",\n\t\toutputFormat = \"auto\",\n\t\toutputLanguage = \"auto\",\n\t\tenableSVGImageGeneration = \"auto\",\n\t\tintermediateRecognition,\n\t\tprocessingEffort = \"low\",\n\t\tprocessingVerbosity = \"low\",\n\t\tcustomInstruction,\n\t\tuseActiveInstruction = false,\n\t\tincludeImageRecognition,\n\t\tdataType,\n\t} = options;\n\n\tconst token = settings?.apiKey;\n\tif (!token) {\n\t\tconst result: ProcessDataWithInstructionResult = { ok: false, error: \"No API key available\" };\n\t\tsendResponse?.(result);\n\t\treturn result;\n\t}\n\n\tif (!input) {\n\t\tconst result: ProcessDataWithInstructionResult = { ok: false, error: \"No input provided\" };\n\t\tsendResponse?.(result);\n\t\treturn result;\n\t}\n\n\tlet finalInstruction = instruction;\n\n\tif (customInstruction) {\n\t\tfinalInstruction = buildInstructionPrompt(finalInstruction, customInstruction);\n\t} else if (useActiveInstruction) {\n\t\tconst activeInstruction = await getActiveCustomInstruction();\n\t\tif (activeInstruction) {\n\t\t\tfinalInstruction = buildInstructionPrompt(finalInstruction, activeInstruction);\n\t\t}\n\t}\n\n\tconst languageInstruction = await getLanguageInstruction();\n\tif (languageInstruction) {\n\t\tfinalInstruction += languageInstruction;\n\t}\n\n\tconst shouldEnableSVG =\n\t\tenableSVGImageGeneration === true || (enableSVGImageGeneration === \"auto\" && outputFormat === \"html\");\n\tif (shouldEnableSVG) {\n\t\tconst svgAddon = await getSvgGraphicsAddon();\n\t\tif (svgAddon) {\n\t\t\tfinalInstruction += svgAddon;\n\t\t}\n\t}\n\n\tif (outputFormat !== \"auto\") {\n\t\tconst formatInstruction = getOutputFormatInstruction(outputFormat);\n\t\tif (formatInstruction) {\n\t\t\tfinalInstruction += formatInstruction;\n\t\t}\n\t}\n\n\tconst gpt = createGPTInstance(token, settings?.baseUrl || DEFAULT_API_URL, settings?.model || DEFAULT_MODEL);\n\tgpt.clearPending();\n\n\tlet processingStages = 1;\n\tlet recognizedImages = false;\n\tconst intermediateRecognizedData: ProcessDataWithInstructionResult[\"intermediateRecognizedData\"] = [];\n\n\tif (Array.isArray(input) && (input?.[0]?.type === \"message\" || input?.[0]?.[\"role\"])) {\n\t\tawait gpt.getPending()?.push(...input);\n\t} else {\n\t\tconst inputData = Array.isArray(input) ? input : [input];\n\n\t\tfor (const item of inputData) {\n\t\t\tlet processedItem = item;\n\n\t\t\tif (\n\t\t\t\t(typeof item === \"string\" && dataType === \"svg\") ||\n\t\t\t\t(typeof item === \"string\" && item.trim().startsWith(\"<svg\"))\n\t\t\t) {\n\t\t\t\tprocessedItem = item;\n\t\t\t} else if (isImageData(item)) {\n\t\t\t\trecognizedImages = true;\n\n\t\t\t\tconst useIntermediateRecognition =\n\t\t\t\t\tintermediateRecognition?.enabled !== false &&\n\t\t\t\t\t(intermediateRecognition?.enabled || includeImageRecognition);\n\n\t\t\t\tif (useIntermediateRecognition) {\n\t\t\t\t\tprocessingStages = 2;\n\n\t\t\t\t\tconst cachedResult = !intermediateRecognition?.forceRefresh\n\t\t\t\t\t\t? recognitionCache.get(item, intermediateRecognition?.outputFormat)\n\t\t\t\t\t\t: null;\n\n\t\t\t\t\tlet recognizedContent: string;\n\t\t\t\t\tlet recognitionResponseId: string;\n\n\t\t\t\t\tif (cachedResult) {\n\t\t\t\t\t\trecognizedContent = cachedResult.recognizedData;\n\t\t\t\t\t\trecognitionResponseId = cachedResult.responseId;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst recognitionInstruction =\n\t\t\t\t\t\t\tintermediateRecognition?.dataPriorityInstruction ||\n\t\t\t\t\t\t\tgetIntermediateRecognitionInstruction(intermediateRecognition?.outputFormat || \"markdown\");\n\n\t\t\t\t\t\tconst recognitionResult = await recognizeByInstructions(\n\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\trecognitionInstruction,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t{ apiKey: token, baseUrl: settings?.baseUrl, model: settings?.model },\n\t\t\t\t\t\t\t{ customInstruction: undefined, useActiveInstruction: false },\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (!recognitionResult.ok || !recognitionResult.data) {\n\t\t\t\t\t\t\trecognizedContent = \"\";\n\t\t\t\t\t\t\trecognitionResponseId = \"\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trecognizedContent = recognitionResult.data;\n\t\t\t\t\t\t\trecognitionResponseId = recognitionResult.responseId || \"\";\n\n\t\t\t\t\t\t\tif (intermediateRecognition?.cacheResults !== false) {\n\t\t\t\t\t\t\t\tconst recognizedAs = intermediateRecognition?.outputFormat || \"markdown\";\n\t\t\t\t\t\t\t\trecognitionCache.set(item, recognizedContent, recognizedAs, recognitionResponseId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tintermediateRecognizedData.push({\n\t\t\t\t\t\toriginalData: item,\n\t\t\t\t\t\trecognizedData: recognizedContent,\n\t\t\t\t\t\trecognizedAs: intermediateRecognition?.outputFormat || \"markdown\",\n\t\t\t\t\t\tresponseId: recognitionResponseId,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (recognizedContent) {\n\t\t\t\t\t\tprocessedItem = recognizedContent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (processedItem !== null && processedItem !== undefined) {\n\t\t\t\tawait gpt?.attachToRequest?.(processedItem);\n\t\t\t}\n\t\t}\n\t}\n\n\tawait gpt.askToDoAction(finalInstruction);\n\n\tlet response: any;\n\tlet error: string | undefined;\n\ttry {\n\t\tresponse = await gpt?.sendRequest?.(processingEffort, processingVerbosity, null, {\n\t\t\tresponseFormat: getResponseFormat(outputFormat),\n\t\t\ttemperature: 0.3,\n\t\t});\n\t} catch (e) {\n\t\terror = String(e);\n\t}\n\n\tlet parsedResponse = response;\n\tif (typeof response === \"string\") {\n\t\ttry {\n\t\t\tparsedResponse = JSON.parse(response);\n\t\t} catch {\n\t\t\tparsedResponse = null;\n\t\t}\n\t}\n\n\tconst responseContent = parsedResponse?.choices?.[0]?.message?.content;\n\tlet cleanedResponse = responseContent ? unwrapUnwantedCodeBlocks(responseContent.trim()) : null;\n\n\tlet finalData = cleanedResponse;\n\tif (cleanedResponse && instruction?.includes(\"Recognize data from image\")) {\n\t\ttry {\n\t\t\tconst parsedJson = JSON.parse(cleanedResponse);\n\t\t\tif (parsedJson?.recognized_data) {\n\t\t\t\tif (Array.isArray(parsedJson.recognized_data)) {\n\t\t\t\t\tfinalData = parsedJson.recognized_data.join(\"\\n\");\n\t\t\t\t} else if (typeof parsedJson.recognized_data === \"string\") {\n\t\t\t\t\tfinalData = parsedJson.recognized_data;\n\t\t\t\t} else {\n\t\t\t\t\tfinalData = JSON.stringify(parsedJson.recognized_data);\n\t\t\t\t}\n\t\t\t} else if (parsedJson?.ok === false) {\n\t\t\t\tfinalData = null;\n\t\t\t} else {\n\t\t\t\tfinalData = cleanedResponse;\n\t\t\t}\n\t\t} catch {\n\t\t\tfinalData = cleanedResponse;\n\t\t}\n\t}\n\n\tconst result: ProcessDataWithInstructionResult = {\n\t\tok: !!finalData && !error,\n\t\tdata: finalData || undefined,\n\t\terror: error || (!finalData ? \"No data recognized\" : undefined),\n\t\tresponseId: parsedResponse?.id || gpt?.getResponseId?.(),\n\t\tprocessingStages,\n\t\trecognizedImages,\n\t\tintermediateRecognizedData: intermediateRecognizedData.length > 0 ? intermediateRecognizedData : undefined,\n\t};\n\n\tsendResponse?.(result);\n\treturn result;\n};\n\nexport const recognizeByInstructions = async (\n\tinput: any,\n\tinstructions: string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: RecognizeByInstructionsOptions,\n): Promise<{ ok: boolean; data?: string; error?: string; responseId?: string }> => {\n\tconst result = await processDataWithInstruction(input, {\n\t\tinstruction: instructions,\n\t\tcustomInstruction: options?.customInstruction,\n\t\tuseActiveInstruction: options?.useActiveInstruction,\n\t\tprocessingEffort: options?.recognitionEffort || \"low\",\n\t\tprocessingVerbosity: options?.recognitionVerbosity || \"low\",\n\t\toutputFormat: \"auto\",\n\t\toutputLanguage: \"auto\",\n\t\tenableSVGImageGeneration: \"auto\",\n\t});\n\n\tconst legacyResult = {\n\t\tok: result.ok,\n\t\tdata: result.data,\n\t\terror: result.error,\n\t\tresponseId: result.responseId,\n\t};\n\n\tsendResponse?.(legacyResult);\n\treturn legacyResult;\n};\n\nexport const processDataByInstruction = async (\n\tinput: any,\n\tinstructions: string,\n\tsendResponse?: (result: any) => void,\n\tconfig?: AIConfig,\n\toptions?: ProcessDataWithInstructionOptions,\n): Promise<{\n\tok: boolean;\n\tdata?: string;\n\terror?: string;\n\tresponseId?: string;\n\tprocessingStages?: number;\n\trecognizedImages?: boolean;\n}> => {\n\tconst result = await processDataWithInstruction(input, {\n\t\tinstruction: instructions,\n\t\t...options,\n\t\toutputFormat: options?.outputFormat || \"auto\",\n\t\toutputLanguage: options?.outputLanguage || \"auto\",\n\t\tenableSVGImageGeneration: options?.enableSVGImageGeneration || \"auto\",\n\t});\n\n\tconst legacyResult = {\n\t\tok: result.ok,\n\t\tdata: result.data,\n\t\terror: result.error,\n\t\tresponseId: result.responseId,\n\t\tprocessingStages: result.processingStages,\n\t\trecognizedImages: result.recognizedImages,\n\t};\n\n\tsendResponse?.(legacyResult);\n\treturn legacyResult;\n};\n\nexport const UnifiedAIService = {\n\tdetectPlatform,\n\tgetPlatformAdapter,\n\tloadAISettings,\n\tgetLanguageInstruction,\n\tgetSvgGraphicsAddon,\n\tgetActiveCustomInstruction,\n\tprocessDataWithInstruction,\n\tclearRecognitionCache: () => recognitionCache.clear(),\n\tgetRecognitionCacheStats: () => recognitionCache.getStats(),\n\trecognizeByInstructions,\n\tprocessDataByInstruction,\n\tsolveAndAnswer,\n\twriteCode,\n\textractCSS,\n\textractEntities,\n\tsmartRecognize,\n};\n\nexport default UnifiedAIService;\n","export interface ActionContext {\n    source: 'workcenter' | 'share-target' | 'launch-queue' | 'chrome-extension' | 'service-worker';\n    sessionId?: string;\n    userAgent?: string;\n    referrer?: string;\n}\n\nexport interface RecognizedData {\n    content: string;\n    timestamp: number;\n    source: 'files' | 'text' | 'url' | 'markdown' | 'image' | 'mixed';\n    recognizedAs: 'markdown' | 'html' | 'text' | 'json' | 'xml' | 'other'; // Format recognized as\n    metadata?: Record<string, any>;\n    responseId?: string; // GPT/AI response ID from HTTP level\n}\n\nexport interface ProcessedData {\n    content: string;\n    timestamp: number;\n    action: string; // Template/action applied\n    sourceData: RecognizedData; // Reference to recognized data that was processed\n    metadata?: Record<string, any>;\n    responseId?: string; // GPT/AI response ID from HTTP level\n}\n\nexport interface ActionInput {\n    type: 'files' | 'text' | 'url' | 'markdown' | 'image' | 'mixed';\n    files?: File[];\n    text?: string;\n    url?: string;\n    recognizedData?: RecognizedData; // New: structured recognized data\n    processedData?: ProcessedData[]; // New: chain of processed data\n    recognizedContent?: string; // Legacy: keep for backward compatibility\n    metadata?: Record<string, any>;\n}\n\nexport interface ActionResult {\n    type: 'markdown' | 'json' | 'text' | 'html' | 'error';\n    content: string;\n    rawData?: any;\n    processingTime?: number;\n    tokenUsage?: number;\n    model?: string;\n    autoCopied?: boolean;\n    responseId?: string; // GPT/AI response ID from HTTP level\n    dataCategory?: 'recognized' | 'processed'; // Whether this is raw recognition or processed result\n    processingChain?: ProcessedData[]; // Chain of processing steps if applicable\n}\n\nexport interface ActionEntry {\n    id: string;\n    timestamp: number;\n    context: ActionContext;\n    action: string; // 'recognize', 'analyze', 'solve', 'generate', etc.\n    input: ActionInput;\n    result?: ActionResult;\n    status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';\n    error?: string;\n    ruleSet?: string; // Which rule set was applied\n    executionId?: string; // Links to execution core\n    dataCategory?: 'recognized' | 'processed'; // Core-level data categorization\n    parentActionId?: string; // Links to parent recognized action for processed entries\n}\n\nexport interface ActionHistoryState {\n    entries: ActionEntry[];\n    maxEntries: number;\n    autoSave: boolean;\n    filters: {\n        source?: ActionContext['source'];\n        action?: string;\n        status?: ActionEntry['status'];\n        dateRange?: { start: number; end: number };\n    };\n}\n\nexport class ActionHistoryStore {\n    private state: ActionHistoryState;\n    private storageKey = 'rs-action-history';\n\n    constructor(maxEntries: number = 500, autoSave: boolean = true) {\n        this.state = {\n            entries: [],\n            maxEntries,\n            autoSave,\n            filters: {}\n        };\n\n        this.loadHistory();\n    }\n\n    /**\n     * Add a new action entry\n     */\n    addEntry(entry: Omit<ActionEntry, 'id' | 'timestamp'>): ActionEntry {\n        const fullEntry: ActionEntry = {\n            ...entry,\n            id: this.generateId(),\n            timestamp: Date.now()\n        };\n\n        this.state.entries.unshift(fullEntry);\n\n        // Maintain max entries limit\n        if (this.state.entries.length > this.state.maxEntries) {\n            this.state.entries = this.state.entries.slice(0, this.state.maxEntries);\n        }\n\n        return fullEntry;\n    }\n\n    /**\n     * Update an existing entry\n     */\n    updateEntry(id: string, updates: Partial<ActionEntry>): boolean {\n        const index = this.state.entries.findIndex(entry => entry.id === id);\n        if (index === -1) return false;\n\n        Object.assign(this.state.entries[index], updates);\n        return true;\n    }\n\n    /**\n     * Get entry by ID\n     */\n    getEntry(id: string): ActionEntry | undefined {\n        return this.state.entries.find(entry => entry.id === id);\n    }\n\n    /**\n     * Get filtered entries\n     */\n    getEntries(filters?: Partial<ActionHistoryState['filters']>): ActionEntry[] {\n        let entries = [...this.state.entries];\n\n        if (filters?.source) {\n            entries = entries.filter(entry => entry.context.source === filters.source);\n        }\n\n        if (filters?.action) {\n            entries = entries.filter(entry => entry.action === filters.action);\n        }\n\n        if (filters?.status) {\n            entries = entries.filter(entry => entry.status === filters.status);\n        }\n\n        if (filters?.dateRange) {\n            entries = entries.filter(entry =>\n                entry.timestamp >= filters.dateRange!.start &&\n                entry.timestamp <= filters.dateRange!.end\n            );\n        }\n\n        return entries;\n    }\n\n    /**\n     * Get recent entries\n     */\n    getRecentEntries(limit: number = 50): ActionEntry[] {\n        return this.state.entries.slice(0, limit);\n    }\n\n    /**\n     * Remove entry\n     */\n    removeEntry(id: string): boolean {\n        const index = this.state.entries.findIndex(entry => entry.id === id);\n        if (index === -1) return false;\n\n        this.state.entries.splice(index, 1);\n        return true;\n    }\n\n    /**\n     * Clear all entries\n     */\n    clearEntries(): void {\n        this.state.entries = [];\n    }\n\n    /**\n     * Set filters\n     */\n    setFilters(filters: Partial<ActionHistoryState['filters']>): void {\n        Object.assign(this.state.filters, filters);\n    }\n\n    /**\n     * Get statistics\n     */\n    getStats() {\n        const entries = this.state.entries;\n        const total = entries.length;\n        const completed = entries.filter(e => e.status === 'completed').length;\n        const failed = entries.filter(e => e.status === 'failed').length;\n        const pending = entries.filter(e => e.status === 'pending' || e.status === 'processing').length;\n\n        const bySource = entries.reduce((acc, entry) => {\n            acc[entry.context.source] = (acc[entry.context.source] || 0) + 1;\n            return acc;\n        }, {} as Record<string, number>);\n\n        const byAction = entries.reduce((acc, entry) => {\n            acc[entry.action] = (acc[entry.action] || 0) + 1;\n            return acc;\n        }, {} as Record<string, number>);\n\n        return {\n            total,\n            completed,\n            failed,\n            pending,\n            successRate: total > 0 ? (completed / total) * 100 : 0,\n            bySource,\n            byAction\n        };\n    }\n\n    /**\n     * Export entries\n     */\n    exportEntries(format: 'json' | 'csv' = 'json', filters?: Partial<ActionHistoryState['filters']>): string {\n        const entries = this.getEntries(filters);\n\n        if (format === 'csv') {\n            const headers = ['ID', 'Timestamp', 'Source', 'Action', 'Status', 'Input Type', 'Result Type', 'Processing Time'];\n            const rows = entries.map(entry => [\n                entry.id,\n                new Date(entry.timestamp).toISOString(),\n                entry.context.source,\n                entry.action,\n                entry.status,\n                entry.input.type,\n                entry.result?.type || '',\n                entry.result?.processingTime || ''\n            ]);\n\n            return [headers, ...rows].map(row => row.map(cell => `\"${cell}\"`).join(',')).join('\\n');\n        }\n\n        return JSON.stringify(entries, null, 2);\n    }\n\n    /**\n     * Import entries\n     */\n    importEntries(data: string, format: 'json' | 'csv' = 'json'): number {\n        let entries: ActionEntry[] = [];\n\n        if (format === 'json') {\n            try {\n                entries = JSON.parse(data);\n            } catch (e) {\n                throw new Error('Invalid JSON format');\n            }\n        } else {\n            // CSV parsing would be implemented here\n            throw new Error('CSV import not implemented yet');\n        }\n\n        // Validate entries\n        const validEntries = entries.filter(entry =>\n            entry.id && entry.timestamp && entry.context && entry.action\n        );\n\n        // Add valid entries\n        validEntries.forEach(entry => {\n            if (!this.getEntry(entry.id)) {\n                this.state.entries.push(entry);\n            }\n        });\n\n        // Sort by timestamp (newest first)\n        this.state.entries.sort((a, b) => b.timestamp - a.timestamp);\n\n        // Maintain max entries limit\n        if (this.state.entries.length > this.state.maxEntries) {\n            this.state.entries = this.state.entries.slice(0, this.state.maxEntries);\n        }\n\n        this.saveHistory();\n        return validEntries.length;\n    }\n\n    private generateId(): string {\n        return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private loadHistory(): void {\n        try {\n            if (typeof localStorage === \"undefined\") return;\n            const stored = localStorage.getItem(this.storageKey);\n            if (stored) {\n                const data = JSON.parse(stored);\n                if (Array.isArray(data)) {\n                    this.state.entries = data.map(entry => ({\n                        ...entry,\n                        // Ensure backward compatibility\n                        context: entry.context || { source: 'unknown' },\n                        input: entry.input || { type: 'unknown' },\n                        status: entry.status || 'completed'\n                    }));\n                }\n            }\n        } catch (e) {\n            console.warn('Failed to load action history:', e);\n            this.state.entries = [];\n        }\n    }\n\n    private saveHistory(): void {\n        if (!this.state.autoSave) return;\n\n        try {\n            if (typeof localStorage === \"undefined\") return;\n            localStorage.setItem(this.storageKey, JSON.stringify(this.state.entries));\n        } catch (e) {\n            console.warn('Failed to save action history:', e);\n        }\n    }\n}\n\n// Singleton instance\nexport const actionHistory = new ActionHistoryStore();","import { processDataWithInstruction } from '@rs-com/service/service/RecognizeData';\nimport { toBase64 } from '@rs-com/service/model/GPT-Responses';\nimport { actionHistory, type ActionEntry, type ActionContext, type ActionInput, type ActionResult } from './ActionHistory';\n\nexport interface ExecutionRule {\n    id: string;\n    name: string;\n    description: string;\n    source: ActionContext['source'];\n    inputTypes: ActionInput['type'][];\n    action: string;\n    condition: (input: ActionInput, context: ActionContext) => boolean;\n    processor: (input: ActionInput, context: ActionContext, options?: ExecutionOptions) => Promise<ActionResult>;\n    autoCopy: boolean;\n    autoSave: boolean;\n    priority: number; // Higher priority rules are checked first\n}\n\nexport interface ExecutionOptions {\n    ruleSet?: string;\n    forceAction?: string;\n    skipHistory?: boolean;\n    customInstruction?: string;\n    recognitionFormat?: \"auto\" | \"markdown\" | \"html\" | \"text\" | \"json\" | \"most-suitable\" | \"most-optimized\" | \"most-legibility\";\n    processingFormat?: \"markdown\" | \"html\" | \"json\" | \"text\" | \"typescript\" | \"javascript\" | \"python\" | \"java\" | \"cpp\" | \"csharp\" | \"php\" | \"ruby\" | \"go\" | \"rust\" | \"xml\" | \"yaml\" | \"css\" | \"scss\";\n}\n\nexport class ExecutionCore {\n    private rules: ExecutionRule[] = [];\n    private ruleSets: Map<string, ExecutionRule[]> = new Map();\n\n    constructor(rules?: ExecutionOptions) {\n        this.initializeDefaultRules(rules ?? {\n            recognitionFormat: 'markdown',\n            processingFormat: 'markdown'\n        });\n    }\n\n    /**\n     * Register a new execution rule\n     */\n    registerRule(rule: ExecutionRule): void {\n        this.rules.push(rule);\n        this.rules.sort((a, b) => b.priority - a.priority); // Higher priority first\n    }\n\n    /**\n     * Register a rule set\n     */\n    registerRuleSet(name: string, rules: ExecutionRule[]): void {\n        this.ruleSets.set(name, rules);\n    }\n\n    /**\n     * Execute an action based on input and context\n     */\n    async execute(input: ActionInput, context: ActionContext, options: ExecutionOptions = {}): Promise<ActionResult> {\n        const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n        // Create history entry\n        const entry: Omit<ActionEntry, 'id' | 'timestamp' | 'result'> = {\n            context,\n            action: options.forceAction || 'auto',\n            input,\n            status: 'processing',\n            ruleSet: options.ruleSet,\n            executionId\n        };\n\n        const historyEntry = actionHistory.addEntry(entry);\n\n        try {\n            // Find matching rule\n            const rule = this.findMatchingRule(input, context, options);\n\n            if (!rule) {\n                throw new Error('No matching execution rule found');\n            }\n\n            // Update action in history\n            actionHistory.updateEntry(historyEntry.id, { action: rule.action });\n\n            // Execute the processor\n            const startTime = Date.now();\n            const result = await rule.processor(input, context, options);\n            const processingTime = Date.now() - startTime;\n\n            // Enhance result with metadata\n            const enhancedResult: ActionResult = {\n                ...result,\n                processingTime,\n                autoCopied: rule.autoCopy\n            };\n\n            // Update history with result\n            actionHistory.updateEntry(historyEntry.id, {\n                result: enhancedResult,\n                status: 'completed',\n                dataCategory: enhancedResult.dataCategory\n            });\n\n            // Auto-copy if enabled\n            if (rule.autoCopy && enhancedResult.type !== 'error') {\n                await this.autoCopyResult(enhancedResult, context);\n            }\n\n            return enhancedResult;\n\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n\n            // Update history with error\n            actionHistory.updateEntry(historyEntry.id, {\n                status: 'failed',\n                error: errorMessage\n            });\n\n            // Return error result\n            return {\n                type: 'error',\n                content: errorMessage\n            };\n        }\n    }\n\n    /**\n     * Find the best matching rule for the given input and context\n     */\n    private findMatchingRule(input: ActionInput, context: ActionContext, options: ExecutionOptions): ExecutionRule | null {\n        // Check forced action first\n        if (options.forceAction) {\n            const forcedRule = this.rules.find(rule =>\n                rule.action === options.forceAction &&\n                rule.source === context.source &&\n                rule.inputTypes.includes(input.type)\n            );\n            if (forcedRule) return forcedRule;\n        }\n\n        // Check rule set if specified\n        if (options.ruleSet) {\n            const ruleSet = this.ruleSets.get(options.ruleSet);\n            if (ruleSet) {\n                const matchingRule = ruleSet.find(rule =>\n                    rule.source === context.source &&\n                    rule.inputTypes.includes(input.type) &&\n                    rule.condition(input, context)\n                );\n                if (matchingRule) return matchingRule;\n            }\n        }\n\n        // Find best matching rule from all rules\n        return this.rules.find(rule =>\n            rule.source === context.source &&\n            rule.inputTypes.includes(input.type) &&\n            rule.condition(input, context)\n        ) || null;\n    }\n\n    /**\n     * Auto-copy result to clipboard\n     */\n    private async autoCopyResult(result: ActionResult, context: ActionContext): Promise<void> {\n        try {\n            let textToCopy = '';\n\n            // Extract text content based on result type\n            switch (result.type) {\n                case 'markdown':\n                case 'text':\n                    textToCopy = result.content;\n                    break;\n                case 'json':\n                    // For JSON, try to extract meaningful text content\n                    try {\n                        const data = JSON.parse(result.content);\n                        if (typeof data === 'string') {\n                            textToCopy = data;\n                        } else if (data.recognized_data) {\n                            textToCopy = Array.isArray(data.recognized_data)\n                                ? data.recognized_data.join('\\n\\n')\n                                : String(data.recognized_data);\n                        } else {\n                            textToCopy = result.content; // Fallback to raw JSON\n                        }\n                    } catch {\n                        textToCopy = result.content;\n                    }\n                    break;\n                case 'html':\n                    // Strip HTML tags for clipboard\n                    textToCopy = result.content.replace(/<[^>]*>/g, '');\n                    break;\n                default:\n                    return; // Don't auto-copy errors\n            }\n\n            if (textToCopy.trim()) {\n                // Use different copy methods based on context\n                if (context.source === 'chrome-extension') {\n                    // Use Chrome extension clipboard API\n                    if (typeof chrome !== 'undefined' && chrome.runtime) {\n                        // This will be handled by the extension's background script\n                        return;\n                    }\n                } else if (typeof navigator !== 'undefined' && navigator.clipboard) {\n                    await navigator.clipboard.writeText(textToCopy.trim());\n                } else if (typeof document !== 'undefined' && document.body) {\n                    // Fallback method - only available in main thread context\n                    const textArea = document.createElement('textarea');\n                    textArea.value = textToCopy.trim();\n                    document.body.appendChild(textArea);\n                    textArea.select();\n                    document.execCommand('copy');\n                    document.body.removeChild(textArea);\n                } else {\n                    // Service worker context - cannot access DOM\n                    console.log('[ExecutionCore] Cannot auto-copy in service worker context - DOM not available');\n                    return;\n                }\n\n                // Broadcast copy notification\n                this.notifyCopySuccess(context);\n            }\n        } catch (error) {\n            console.warn('Failed to auto-copy result:', error);\n        }\n    }\n\n    /**\n     * Notify about successful copy\n     */\n    private notifyCopySuccess(context: ActionContext): void {\n        // Broadcast to different contexts based on source\n        const message = { type: 'copy-success', context };\n\n        if (context.source === 'chrome-extension') {\n            // Chrome extension notification\n            if (typeof chrome !== 'undefined' && chrome.runtime) {\n                chrome.runtime.sendMessage(message);\n            }\n        } else {\n            // Broadcast channel for web contexts\n            try {\n                const bc = new BroadcastChannel('rs-clipboard');\n                bc.postMessage(message);\n                bc.close();\n            } catch (e) {\n                console.warn('Failed to broadcast copy success:', e);\n            }\n        }\n    }\n\n    /**\n     * Initialize default execution rules\n     */\n    private initializeDefaultRules(options?: ExecutionOptions): void {\n        // Work Center Rules\n        // Text/Markdown files - treat as source data, no recognition needed\n        this.registerRule({\n            id: 'workcenter-text-files-source',\n            name: 'Work Center Text File Source',\n            description: 'Process text/markdown files as source data',\n            source: 'workcenter',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 11 // Higher than recognition, lower than analysis\n        });\n\n        this.registerRule({\n            id: 'workcenter-files-recognize',\n            name: 'Work Center File Recognition',\n            description: 'Recognize content from uploaded files',\n            source: 'workcenter',\n            inputTypes: ['files', 'image'],\n            action: 'recognize',\n            condition: (input) => Boolean((input?.files?.length ?? 0) > 0),\n            processor: async (input, context, options) => {\n                let result;\n\n                // Determine recognition format instruction\n                const formatInstruction = this.getRecognitionFormatInstruction(options?.recognitionFormat);\n\n                // Handle multiple files by creating a combined message\n                if (input.files!.length > 1) {\n                    // Create a message array with multiple file attachments\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Analyze and recognize content from the following ${input.files!.length} files. ${formatInstruction}` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    // Convert each file to the proper format\n                                    const FileCtor = (globalThis as any).File;\n                                    const isFile = FileCtor && file instanceof FileCtor;\n\n                                    const header = { type: \"input_text\", text: `\\n--- File ${index + 1}: ${file.name} ---\\n` };\n\n                                    if (isFile && file.type.startsWith('image/')) {\n                                        try {\n                                            const arrayBuffer = await file.arrayBuffer();\n                                            const bytes = new Uint8Array(arrayBuffer);\n                                            const base64 = toBase64(bytes);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_image\",\n                                                    detail: \"auto\",\n                                                    image_url: `data:${file.type};base64,${base64}`\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to process image ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to process image: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    } else {\n                                        try {\n                                            const text = await file.text();\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: text\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to read file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to read file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    }\n                                }))).flat()\n                            ].filter(item => item !== null)\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: `Analyze and recognize content from the provided files. ${formatInstruction}`,\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false } // Already processed\n                        }\n                    );\n                } else {\n                    // Single file - use the original approach\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single image file, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: `Analyze and recognize content from the provided image. ${formatInstruction}`,\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process image ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: `Analyze and recognize content from the provided file. ${formatInstruction}`,\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Analyze and recognize content from the provided file',\n                                outputFormat: options?.recognitionFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 10\n        });\n\n        this.registerRule({\n            id: 'workcenter-text-analyze',\n            name: 'Work Center Text Analysis',\n            description: 'Analyze provided text content',\n            source: 'workcenter',\n            inputTypes: ['text', 'markdown'],\n            action: 'analyze',\n            condition: (input) => Boolean(input.text || input.recognizedContent),\n            processor: async (input, context, options) => {\n                const content = input.recognizedContent || input.recognizedData?.content || input.text || '';\n\n                // Determine if we have files that need special processing\n                const hasImages = input.files?.some(f => f.type.startsWith('image/') || f.type === 'image/svg+xml') || false;\n                const hasSvgContent = typeof content === 'string' && content.includes('<svg');\n\n                // Use user-provided instruction if available, otherwise default to analysis\n                const userInstruction = input.text && input.text.trim() && input.text.trim() !== \"Analyze and process the provided content intelligently\";\n                const instructions = userInstruction\n                    ? input?.text?.trim?.()\n                    : `Analyze the provided content. ${this.getProcessingFormatInstruction(options?.processingFormat)}`;\n\n                const result = await processDataWithInstruction(\n                    hasImages || hasSvgContent ? [content, ...(input.files || [])] : content,\n                    {\n                        instruction: instructions,\n                        outputFormat: options?.processingFormat || 'auto',\n                        outputLanguage: 'auto',\n                        enableSVGImageGeneration: 'auto',\n                        intermediateRecognition: {\n                            enabled: hasImages,\n                            outputFormat: options?.recognitionFormat || 'markdown',\n                            dataPriorityInstruction: undefined,\n                            cacheResults: true\n                        },\n                        dataType: hasSvgContent ? 'svg' : (hasImages ? 'image' : 'text'),\n                        processingEffort: 'medium',\n                        processingVerbosity: 'medium'\n                    }\n                );\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'processed'\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 9\n        });\n\n        // Share Target Rules\n        // Share target text/markdown files - treat as source data\n        this.registerRule({\n            id: 'share-target-text-files-source',\n            name: 'Share Target Text File Source',\n            description: 'Process shared text/markdown files as source data',\n            source: 'share-target',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `share_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 16 // Higher priority for share target\n        });\n\n        this.registerRule({\n            id: 'share-target-images-recognize',\n            name: 'Share Target Image Recognition',\n            description: 'Recognize content from shared images',\n            source: 'share-target',\n            inputTypes: ['image', 'files'],\n            action: 'recognize',\n            condition: (input) => input.files?.some(f => f.type.startsWith('image/')) || false,\n            processor: async (input) => {\n                const imageFiles = input.files!.filter(f => f.type.startsWith('image/'));\n                let result;\n\n                if (imageFiles.length > 1) {\n                    // Handle multiple images\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Recognize and extract text/content from the following ${imageFiles.length} shared images:` },\n                                ...(await Promise.all(imageFiles.map(async (file, index) => {\n                                    try {\n                                        const arrayBuffer = await file.arrayBuffer();\n                                        const bytes = new Uint8Array(arrayBuffer);\n                                        const base64 = btoa(String.fromCharCode(...bytes));\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Image ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_image\",\n                                                detail: \"auto\",\n                                                image_url: `data:${file.type};base64,${base64}`\n                                            }\n                                        ];\n                                    } catch (error) {\n                                        console.warn(`Failed to process image ${file.name}:`, error);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Image ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_text\",\n                                                text: `[Failed to process image: ${file.name}]`\n                                            }\n                                        ];\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Recognize and extract text/content from the shared images',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single image\n                    result = await processDataWithInstruction(\n                        imageFiles[0],\n                        {\n                            instruction: 'Recognize and extract text/content from the shared image',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 15\n        });\n\n        this.registerRule({\n            id: 'share-target-markdown-view',\n            name: 'Share Target Markdown View',\n            description: 'View shared markdown content',\n            source: 'share-target',\n            inputTypes: ['text', 'markdown'],\n            action: 'view',\n            condition: (input) => this.isMarkdownContent(input.text || ''),\n            processor: async (input) => {\n                // For markdown content shared via share target, just return it as-is\n                return {\n                    type: 'markdown',\n                    content: input.text || ''\n                };\n            },\n            autoCopy: false,\n            autoSave: true,\n            priority: 14\n        });\n\n        this.registerRule({\n            id: 'share-target-url-analyze',\n            name: 'Share Target URL Analysis',\n            description: 'Analyze shared URL content',\n            source: 'share-target',\n            inputTypes: ['url'],\n            action: 'analyze',\n            condition: () => true,\n            processor: async (input, context, options) => {\n                const instructions = `Analyze the content from this URL and provide insights. ${this.getProcessingFormatInstruction(options?.processingFormat)}`;\n                const result = await processDataWithInstruction(\n                    input.url!,\n                    {\n                        instruction: instructions,\n                        outputFormat: options?.processingFormat || 'auto',\n                        outputLanguage: 'auto',\n                        enableSVGImageGeneration: 'auto',\n                        intermediateRecognition: { enabled: false },\n                        dataType: 'text'\n                    }\n                );\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 13\n        });\n\n        // Chrome Extension Rules\n        // Chrome extension text/markdown files - treat as source data\n        this.registerRule({\n            id: 'chrome-extension-text-files-source',\n            name: 'Chrome Extension Text File Source',\n            description: 'Process Chrome extension text/markdown files as source data',\n            source: 'chrome-extension',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `crx_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: true, // Chrome extension often wants immediate results\n            autoSave: true,\n            priority: 26 // Higher priority for Chrome extension\n        });\n\n        this.registerRule({\n            id: 'chrome-extension-screenshot-recognize',\n            name: 'Chrome Extension Screenshot Recognition',\n            description: 'Recognize content from screenshot',\n            source: 'chrome-extension',\n            inputTypes: ['image'],\n            action: 'recognize',\n            condition: () => true,\n            processor: async (input) => {\n                let result;\n\n                if (input.files!.length > 1) {\n                    // Handle multiple screenshots\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Analyze the following ${input.files!.length} screenshots and extract any visible text or content:` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    try {\n                                        const arrayBuffer = await file.arrayBuffer();\n                                        const bytes = new Uint8Array(arrayBuffer);\n                                        const base64 = toBase64(bytes);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Screenshot ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_image\",\n                                                detail: \"auto\",\n                                                image_url: `data:${file.type};base64,${base64}`\n                                            }\n                                        ];\n                                    } catch (error) {\n                                        console.warn(`Failed to process screenshot ${file.name}:`, error);\n                                        return [\n                                            { type: \"input_text\", text: `\\n--- Screenshot ${index + 1}: ${file.name} ---\\n` },\n                                            {\n                                                type: \"input_text\",\n                                                text: `[Failed to process screenshot: ${file.name}]`\n                                            }\n                                        ];\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Analyze the screenshots and extract any visible text or content',\n                            outputFormat: options?.recognitionFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single screenshot\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single screenshot, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: 'Analyze the screenshot and extract any visible text or content',\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process screenshot ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: 'Analyze the screenshot and extract any visible text or content',\n                                    outputFormat: options?.recognitionFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Analyze the screenshot and extract any visible text or content',\n                                outputFormat: options?.recognitionFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 20\n        });\n\n        // Launch Queue Rules (similar to share target)\n        // Launch queue text/markdown files - treat as source data\n        this.registerRule({\n            id: 'launch-queue-text-files-source',\n            name: 'Launch Queue Text File Source',\n            description: 'Process launch queue text/markdown files as source data',\n            source: 'launch-queue',\n            inputTypes: ['files'],\n            action: 'source',\n            condition: (input) => {\n                return input.files?.some(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                ) ?? false;\n            },\n            processor: async (input) => {\n                // Read text/markdown files and return as source data\n                const textFiles = input.files!.filter(f =>\n                    f.type.startsWith('text/') ||\n                    f.type === 'application/markdown' ||\n                    f.name?.endsWith('.md') ||\n                    f.name?.endsWith('.txt')\n                );\n\n                let combinedContent = '';\n                for (const file of textFiles) {\n                    try {\n                        const content = await file.text();\n                        combinedContent += content + '\\n\\n';\n                    } catch (error) {\n                        console.warn(`Failed to read text file ${file.name}:`, error);\n                    }\n                }\n\n                return {\n                    type: 'markdown',\n                    content: combinedContent.trim(),\n                    dataCategory: 'recognized', // Text files are already \"recognized\"\n                    responseId: `launch_source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n                };\n            },\n            autoCopy: true, // Launch queue often wants immediate results\n            autoSave: true,\n            priority: 21 // Higher priority for launch queue\n        });\n\n        this.registerRule({\n            id: 'launch-queue-files-process',\n            name: 'Launch Queue File Processing',\n            description: 'Process files from launch queue',\n            source: 'launch-queue',\n            inputTypes: ['files', 'mixed'],\n            action: 'process',\n            condition: () => true,\n            processor: async (input) => {\n                let result;\n\n                if (input.files!.length > 1) {\n                    // Handle multiple files from launch queue\n                    const messages = [\n                        {\n                            type: \"message\",\n                            role: \"user\",\n                            content: [\n                                { type: \"input_text\", text: `Process the following ${input.files!.length} files:` },\n                                ...(await Promise.all(input.files!.map(async (file, index) => {\n                                    const FileCtor = (globalThis as any).File;\n                                    const isFile = FileCtor && file instanceof FileCtor;\n\n                                    const header = { type: \"input_text\", text: `\\n--- File ${index + 1}: ${file.name} ---\\n` };\n\n                                    if (isFile && file.type.startsWith('image/')) {\n                                        try {\n                                            const arrayBuffer = await file.arrayBuffer();\n                                            const bytes = new Uint8Array(arrayBuffer);\n                                            const base64 = toBase64(bytes);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_image\",\n                                                    detail: \"auto\",\n                                                    image_url: `data:${file.type};base64,${base64}`\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to process file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to process file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    } else {\n                                        try {\n                                            const text = await file.text();\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: text\n                                                }\n                                            ];\n                                        } catch (error) {\n                                            console.warn(`Failed to read file ${file.name}:`, error);\n                                            return [\n                                                header,\n                                                {\n                                                    type: \"input_text\",\n                                                    text: `[Failed to read file: ${file.name}]`\n                                                }\n                                            ];\n                                        }\n                                    }\n                                }))).flat()\n                            ]\n                        }\n                    ];\n\n                    result = await processDataWithInstruction(\n                        messages,\n                        {\n                            instruction: 'Process the provided content',\n                            outputFormat: options?.processingFormat || 'auto',\n                            intermediateRecognition: { enabled: false }\n                        }\n                    );\n                } else {\n                    // Single file\n                    const file = input.files![0];\n                    const FileCtor = (globalThis as any).File;\n                    const isFile = FileCtor && file instanceof FileCtor;\n\n                    if (isFile && file.type.startsWith('image/')) {\n                        // For single image file, convert to data URL\n                        try {\n                            const arrayBuffer = await file.arrayBuffer();\n                            const bytes = new Uint8Array(arrayBuffer);\n                            const base64 = toBase64(bytes);\n                            const dataUrl = `data:${file.type};base64,${base64}`;\n                            result = await processDataWithInstruction(\n                                dataUrl,\n                                {\n                                    instruction: 'Process the provided image content',\n                                    outputFormat: options?.processingFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        } catch (error) {\n                            console.warn(`Failed to process image ${file.name}:`, error);\n                            result = await processDataWithInstruction(\n                                file,\n                                {\n                                    instruction: 'Process the provided content',\n                                    outputFormat: options?.processingFormat || 'auto',\n                                    intermediateRecognition: { enabled: false }\n                                }\n                            );\n                        }\n                    } else {\n                        result = await processDataWithInstruction(\n                            file,\n                            {\n                                instruction: 'Process the provided content',\n                                outputFormat: options?.processingFormat || 'auto',\n                                intermediateRecognition: { enabled: false }\n                            }\n                        );\n                    }\n                }\n\n                return {\n                    type: this.detectResultFormat(result),\n                    content: this.formatAIResult(result),\n                    rawData: result,\n                    responseId: result.responseId,\n                    dataCategory: 'recognized'\n                };\n            },\n            autoCopy: true,\n            autoSave: true,\n            priority: 12\n        });\n    }\n\n    /**\n     * Check if content is markdown\n     */\n    private isMarkdownContent(text: string): boolean {\n        if (!text || typeof text !== 'string') return false;\n\n        const trimmed = text.trim();\n        if (trimmed.startsWith(\"<\") && trimmed.endsWith(\">\")) return false;\n        if (/<[a-zA-Z][^>]*>/.test(trimmed)) return false;\n\n        // Check for markdown patterns\n        const patterns = [\n            /^---[\\s\\S]+?---/, // YAML frontmatter\n            /^#{1,6}\\s+.+$/m, // Headings\n            /^\\s*[-*+]\\s+\\S+/m, // Unordered lists\n            /^\\s*\\d+\\.\\s+\\S+/m, // Ordered lists\n            /`{1,3}[^`]*`{1,3}/, // Code blocks/inline code\n            /\\[([^\\]]+)\\]\\(([^)]+)\\)/, // Links\n            /!\\[([^\\]]+)\\]\\(([^)]+)\\)/, // Images\n        ];\n\n        return patterns.some(pattern => pattern.test(text));\n    }\n\n    /**\n     * Format AI result for display\n     */\n    private detectResultFormat(result: any): 'json' | 'markdown' | 'text' | 'html' {\n        if (!result) return 'text';\n\n        try {\n            // Check if result.data exists and is an object\n            const data = result.data || result;\n\n            // If it's structured recognition data (has specific fields), return JSON\n            if (data && typeof data === 'object') {\n                const hasStructuredFields = [\n                    'recognized_data',\n                    'verbose_data',\n                    'keywords_and_tags',\n                    'confidence',\n                    'suggested_type',\n                    'using_ready'\n                ].some(field => field in data);\n\n                if (hasStructuredFields) {\n                    return 'json';\n                }\n\n                // If it's any other object, check if it looks like markdown content\n                if (data.content || data.text || data.message) {\n                    return 'markdown';\n                }\n\n                // Default to JSON for objects\n                return 'json';\n            }\n\n            // If it's a string, check if it looks like markdown\n            if (typeof data === 'string') {\n                // Simple heuristic: if it contains markdown-like elements or is multi-line\n                if (data.includes('\\n') || data.includes('#') || data.includes('*') || data.includes('`')) {\n                    return 'markdown';\n                }\n                return 'text';\n            }\n\n            // Default fallback\n            return 'json';\n        } catch (error) {\n            console.warn('Failed to detect result format:', error);\n            return 'text';\n        }\n    }\n\n    private formatAIResult(result: any): string {\n        if (!result) return 'No result';\n\n        try {\n            // Extract meaningful content from AI response\n            let content = '';\n\n            if (result.data) {\n                if (typeof result.data === 'string') {\n                    content = result.data;\n                } else if (result.data.recognized_data) {\n                    const recognized = result.data.recognized_data;\n                    content = Array.isArray(recognized) ? recognized.join('\\n\\n') : String(recognized);\n                } else {\n                    content = JSON.stringify(result.data, null, 2);\n                }\n            } else if (typeof result === 'string') {\n                content = result;\n            } else {\n                content = JSON.stringify(result, null, 2);\n            }\n\n            // Unwrap unwanted code block formatting\n            content = this.unwrapUnwantedCodeBlocks(content);\n\n            return content;\n        } catch (error) {\n            console.warn('Failed to format AI result:', error);\n            return String(result);\n        }\n    }\n\n    private unwrapUnwantedCodeBlocks(content: string): string {\n        if (!content) return content;\n\n        // Remove wrapping code blocks that are not intended for code\n        // Pattern: ```language\\ncontent\\n```\n        const codeBlockRegex = /^```(?:katex|md|markdown|html|xml|json|text)?\\n([\\s\\S]*?)\\n```$/;\n\n        const match = content.trim().match(codeBlockRegex);\n        if (match) {\n            const unwrapped = match[1].trim();\n\n            // Additional check: if the unwrapped content looks like it should be wrapped\n            // (e.g., actual code, or multiple lines that are clearly formatted content),\n            // keep the original. Otherwise, unwrap it.\n            const lines = unwrapped.split('\\n');\n\n            // If it's a single line or looks like markup/math, unwrap\n            if (lines.length === 1 ||\n                unwrapped.includes('<math') ||\n                unwrapped.includes('<span class=\"katex') ||\n                unwrapped.includes('<content') ||\n                unwrapped.startsWith('<') && unwrapped.endsWith('>') ||\n                /^\\s*<[^>]+>/.test(unwrapped)) {\n                console.log('[AI Response] Unwrapped unwanted code block formatting');\n                return unwrapped;\n            }\n\n            // If it looks like actual code (multiple lines, indentation, etc.), keep wrapped\n            if (lines.length > 3 ||\n                lines.some(line => line.match(/^\\s{4,}/) || line.includes('function') || line.includes('const ') || line.includes('let '))) {\n                return content; // Keep the code block\n            }\n\n            // Default to unwrapping for single/multiple simple lines\n            console.log('[AI Response] Unwrapped unwanted code block formatting');\n            return unwrapped;\n        }\n\n        return content;\n    }\n\n    private getRecognitionFormatInstruction(format?: \"auto\" | \"markdown\" | \"html\" | \"text\" | \"json\" | \"most-suitable\" | \"most-optimized\" | \"most-legibility\"): string {\n        if (!format || format === 'auto') {\n            return 'Output the content in the most appropriate format (markdown is preferred for structured content).';\n        }\n\n        switch (format) {\n            case 'most-suitable':\n                return 'Analyze the content and output it in the most suitable format for its type and structure. Choose the format that best represents the content\\'s nature and purpose.';\n            case 'most-optimized':\n                return 'Output the content in the most optimized format for storage and transmission efficiency. Prefer compact representations while maintaining essential information.';\n            case 'most-legibility':\n                return 'Output the content in the most human-readable and legible format. Prioritize clarity, readability, and ease of understanding over compactness.';\n            case 'markdown':\n                return 'Output the recognized content in Markdown format.';\n            case 'html':\n                return 'Output the recognized content in HTML format.';\n            case 'text':\n                return 'Output the recognized content as plain text.';\n            case 'json':\n                return 'Output the recognized content as structured JSON data.';\n            default:\n                return 'Output the content in the most appropriate format (markdown is preferred for structured content).';\n        }\n    }\n\n    private getProcessingFormatInstruction(format?: \"markdown\" | \"html\" | \"json\" | \"text\" | \"typescript\" | \"javascript\" | \"python\" | \"java\" | \"cpp\" | \"csharp\" | \"php\" | \"ruby\" | \"go\" | \"rust\" | \"xml\" | \"yaml\" | \"css\" | \"scss\"): string {\n        if (!format || format === 'markdown') {\n            return 'Output the processed result in Markdown format.';\n        }\n\n        switch (format) {\n            case 'html':\n                return 'Output the processed result in HTML format.';\n            case 'json':\n                return 'Output the processed result as structured JSON data.';\n            case 'text':\n                return 'Output the processed result as plain text.';\n            case 'typescript':\n                return 'Output the processed result as TypeScript code.';\n            case 'javascript':\n                return 'Output the processed result as JavaScript code.';\n            case 'python':\n                return 'Output the processed result as Python code.';\n            case 'java':\n                return 'Output the processed result as Java code.';\n            case 'cpp':\n                return 'Output the processed result as C++ code.';\n            case 'csharp':\n                return 'Output the processed result as C# code.';\n            case 'php':\n                return 'Output the processed result as PHP code.';\n            case 'ruby':\n                return 'Output the processed result as Ruby code.';\n            case 'go':\n                return 'Output the processed result as Go code.';\n            case 'rust':\n                return 'Output the processed result as Rust code.';\n            case 'xml':\n                return 'Output the processed result in XML format.';\n            case 'yaml':\n                return 'Output the processed result in YAML format.';\n            case 'css':\n                return 'Output the processed result as CSS code.';\n            case 'scss':\n                return 'Output the processed result as SCSS code.';\n            default:\n                return 'Output the processed result in Markdown format.';\n        }\n    }\n}\n\n// Singleton instance\nexport const executionCore = new ExecutionCore();"],"file":"ExecutionCore.js"}