{"version":3,"file":"Base64Data.js","sources":["../../../../modules/projects/lur.e/src/extension/core/Base64Data.ts"],"sourcesContent":["export type Base64Alphabet = \"base64\" | \"base64url\";\nexport type Base64LastChunkHandling = \"loose\" | \"strict\" | \"stop-before-partial\";\n\nexport type DataUrlParts = {\n    mimeType: string;\n    isBase64: boolean;\n    data: string;\n};\n\nexport type DecodeBase64Options = {\n    alphabet?: Base64Alphabet;\n    lastChunkHandling?: Base64LastChunkHandling;\n};\n\nexport type EncodeBase64Options = {\n    alphabet?: Base64Alphabet;\n};\n\nexport type BlobToStringOptions = {\n    /**\n     * When true, encode raw text payload with encodeURIComponent().\n     * Common for SVG: data:image/svg+xml,${encodeURIComponent(svg)}.\n     */\n    uriComponent?: boolean;\n    /**\n     * If provided, overrides blob.type when producing a data URL.\n     */\n    mimeType?: string;\n    /**\n     * Output as base64 (default true for non-text). If false, output as text (optionally URI-encoded).\n     */\n    base64?: boolean;\n    /**\n     * Base64 encoding options for base64/base64url.\n     */\n    base64Options?: EncodeBase64Options;\n    /**\n     * For text serialization.\n     */\n    textEncoding?: \"utf-8\";\n};\n\nexport type StringToBinaryOptions = {\n    /**\n     * Prefer/force decoding a URL-encoded payload via decodeURIComponent.\n     * If omitted, we auto-detect by trying to decode only when it looks encoded.\n     */\n    uriComponent?: boolean;\n    /**\n     * If provided, overrides any mime type derived from a data URL.\n     */\n    mimeType?: string;\n    /**\n     * When creating a File, use this filename.\n     */\n    filename?: string;\n    /**\n     * When true, return a File. Otherwise return a Blob.\n     */\n    asFile?: boolean;\n    /**\n     * If true, treat input as base64 (or base64url) bytes (not UTF-8 text).\n     * If omitted, auto-detect via data URL or base64 shape.\n     */\n    isBase64?: boolean;\n    /**\n     * Decode options for base64/base64url.\n     */\n    base64?: DecodeBase64Options;\n    /**\n     * Max bytes allowed for decoded binary data.\n     */\n    maxBytes?: number;\n};\n\nexport type DataAssetInput = File | Blob | string | URL;\nexport type DataAssetSource = \"file\" | \"blob\" | \"data-url\" | \"base64\" | \"url\" | \"uri\" | \"text\";\n\nexport type DataAsset = {\n    hash: string;\n    name: string;\n    type: string;\n    size: number;\n    source: DataAssetSource;\n    file: File;\n};\n\nexport type NormalizeDataAssetOptions = {\n    mimeType?: string;\n    /**\n     * Prefix for generated hash-based filenames.\n     */\n    namePrefix?: string;\n    /**\n     * Optional explicit filename override.\n     */\n    filename?: string;\n    /**\n     * When true, keep input File name instead of hash-name.\n     */\n    preserveFileName?: boolean;\n    uriComponent?: boolean;\n    maxBytes?: number;\n};\n\nconst DEFAULT_MIME = \"application/octet-stream\";\n\nconst DATA_URL_RE = /^data:(?<mime>[^;,]+)?(?<params>(?:;[^,]*)*?),(?<data>[\\s\\S]*)$/i;\n\nfunction canUseFromBase64(): boolean {\n    return typeof (Uint8Array as any).fromBase64 === \"function\";\n}\n\nfunction canUseToBase64(u8: Uint8Array): boolean {\n    return typeof (u8 as any).toBase64 === \"function\";\n}\n\nfunction tryDecodeURIComponent(s: string): string {\n    try {\n        return decodeURIComponent(s);\n    } catch {\n        return s;\n    }\n}\n\nfunction likelyUriComponent(s: string): boolean {\n    return /%[0-9A-Fa-f]{2}/.test(s) || s.includes(\"+\");\n}\n\nfunction isTextMime(mimeType: string): boolean {\n    const t = (mimeType || \"\").toLowerCase();\n    return (\n        t.startsWith(\"text/\") ||\n        t.includes(\"json\") ||\n        t.includes(\"xml\") ||\n        t.includes(\"svg\") ||\n        t.includes(\"javascript\") ||\n        t.includes(\"ecmascript\")\n    );\n}\n\nfunction bytesToArrayBuffer(bytes: Uint8Array): ArrayBuffer {\n    const buf: ArrayBufferLike = bytes.buffer;\n    if (buf instanceof ArrayBuffer) {\n        return buf.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n    }\n    const ab = new ArrayBuffer(bytes.byteLength);\n    new Uint8Array(ab).set(bytes);\n    return ab;\n}\n\nexport function parseDataUrl(input: string): DataUrlParts | null {\n    const s = (input || \"\").trim();\n    if (!s.toLowerCase().startsWith(\"data:\")) return null;\n\n    const m = s.match(DATA_URL_RE);\n    if (!m?.groups) return null;\n\n    const mimeType = (m.groups.mime || DEFAULT_MIME).trim() || DEFAULT_MIME;\n    const params = (m.groups.params || \"\").toLowerCase();\n    const isBase64 = params.includes(\";base64\");\n    const data = m.groups.data ?? \"\";\n    return { mimeType, isBase64, data };\n}\n\nexport function decodeBase64ToBytes(base64: string, options: DecodeBase64Options = {}): Uint8Array {\n    const alphabet: Base64Alphabet = options.alphabet || \"base64\";\n    const lastChunkHandling: Base64LastChunkHandling = options.lastChunkHandling || \"loose\";\n    const s = (base64 || \"\").trim();\n\n    if (canUseFromBase64()) {\n        // Modern native: Uint8Array.fromBase64()\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/fromBase64\n        return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling });\n    }\n\n    // Fallback: atob() for base64 only.\n    // For base64url, convert to base64 first.\n    const normalized =\n        alphabet === \"base64url\"\n            ? s.replace(/-/g, \"+\").replace(/_/g, \"/\")\n            : s;\n\n    // pad to multiple of 4\n    const padLen = (4 - (normalized.length % 4)) % 4;\n    const padded = normalized + \"=\".repeat(padLen);\n\n    const binary = typeof atob === \"function\" ? atob(padded) : \"\";\n    const out = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) out[i] = binary.charCodeAt(i);\n    return out;\n}\n\nexport function encodeBytesToBase64(bytes: Uint8Array, options: EncodeBase64Options = {}): string {\n    const alphabet: Base64Alphabet = options.alphabet || \"base64\";\n\n    if (canUseToBase64(bytes)) {\n        // Modern native: Uint8Array.prototype.toBase64()\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toBase64\n        return (bytes as any).toBase64({ alphabet });\n    }\n\n    // Fallback: btoa() with chunking\n    const chunkSize = 0x8000;\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i += chunkSize) {\n        binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));\n    }\n    const b64 = typeof btoa === \"function\" ? btoa(binary) : \"\";\n    if (alphabet !== \"base64url\") return b64;\n    return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\nexport async function blobToBytes(blob: Blob): Promise<Uint8Array> {\n    const ab = await blob.arrayBuffer();\n    return new Uint8Array(ab);\n}\n\nexport async function blobToText(blob: Blob, encoding: \"utf-8\" = \"utf-8\"): Promise<string> {\n    // Prefer native Blob.text() when available.\n    if (typeof blob.text === \"function\") return await blob.text();\n    const bytes = await blobToBytes(blob);\n    const dec = new TextDecoder(encoding);\n    return dec.decode(bytes);\n}\n\nexport async function blobToBase64(blob: Blob, options: EncodeBase64Options = {}): Promise<string> {\n    const bytes = await blobToBytes(blob);\n    return encodeBytesToBase64(bytes, options);\n}\n\nexport async function blobToDataUrl(blob: Blob, options: BlobToStringOptions = {}): Promise<string> {\n    const mimeType = (options.mimeType || blob.type || DEFAULT_MIME).trim() || DEFAULT_MIME;\n    const wantsBase64 = options.base64 ?? !isTextMime(mimeType);\n\n    if (wantsBase64) {\n        const b64 = await blobToBase64(blob, options.base64Options || {});\n        return `data:${mimeType};base64,${b64}`;\n    }\n\n    const text = await blobToText(blob, options.textEncoding || \"utf-8\");\n    const payload = options.uriComponent ? encodeURIComponent(text) : text;\n    return `data:${mimeType},${payload}`;\n}\n\nexport async function fileToDataUrl(file: File, options: BlobToStringOptions = {}): Promise<string> {\n    return await blobToDataUrl(file, options);\n}\n\nfunction looksLikeBase64(s: string): { isBase64: boolean; alphabet: Base64Alphabet } {\n    const t = (s || \"\").trim();\n    if (!t) return { isBase64: false, alphabet: \"base64\" };\n\n    const hasUrlAlphabet = /[-_]/.test(t) && !/[+/]/.test(t);\n    const alphabet: Base64Alphabet = hasUrlAlphabet ? \"base64url\" : \"base64\";\n\n    const normalized = alphabet === \"base64url\" ? t.replace(/-/g, \"+\").replace(/_/g, \"/\") : t;\n    const cleaned = normalized.replace(/[\\r\\n\\s]/g, \"\");\n    const allowed = /^[A-Za-z0-9+/]*={0,2}$/.test(cleaned);\n    if (!allowed) return { isBase64: false, alphabet };\n\n    // Not perfect; good enough for \"try base64 decode\"\n    if (cleaned.length < 8) return { isBase64: false, alphabet };\n    return { isBase64: true, alphabet };\n}\n\nfunction canParseUrl(value: string): boolean {\n    try {\n        if (typeof URL === \"undefined\") return false;\n        if (typeof (URL as any).canParse === \"function\") return (URL as any).canParse(value);\n        // Fallback for environments without URL.canParse\n        new URL(value);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nfunction extensionByMimeType(mimeType: string): string {\n    const t = (mimeType || \"\").toLowerCase().split(\";\")[0].trim();\n    if (!t) return \"bin\";\n\n    const mapped: Record<string, string> = {\n        \"text/plain\": \"txt\",\n        \"text/markdown\": \"md\",\n        \"text/html\": \"html\",\n        \"application/json\": \"json\",\n        \"application/xml\": \"xml\",\n        \"image/jpeg\": \"jpg\",\n        \"image/png\": \"png\",\n        \"image/webp\": \"webp\",\n        \"image/gif\": \"gif\",\n        \"image/svg+xml\": \"svg\",\n        \"application/pdf\": \"pdf\",\n    };\n    if (mapped[t]) return mapped[t];\n\n    const slashIdx = t.indexOf(\"/\");\n    if (slashIdx <= 0 || slashIdx >= t.length - 1) return \"bin\";\n    let subtype = t.slice(slashIdx + 1);\n    if (subtype.includes(\"+\")) subtype = subtype.split(\"+\")[0];\n    if (subtype.includes(\".\")) subtype = subtype.split(\".\").pop() || subtype;\n    return subtype || \"bin\";\n}\n\nfunction fallbackHashHex(bytes: Uint8Array): string {\n    // Non-cryptographic fallback only for environments without SubtleCrypto.\n    let h = 2166136261;\n    for (let i = 0; i < bytes.length; i++) {\n        h ^= bytes[i];\n        h = Math.imul(h, 16777619);\n    }\n    return (h >>> 0).toString(16).padStart(8, \"0\").repeat(8);\n}\n\nasync function sha256Hex(bytes: Uint8Array): Promise<string> {\n    try {\n        const subtle = (globalThis.crypto as Crypto | undefined)?.subtle;\n        if (!subtle) return fallbackHashHex(bytes);\n        const digest = await subtle.digest(\"SHA-256\", bytes);\n        const out = new Uint8Array(digest);\n        return Array.from(out, (b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    } catch {\n        return fallbackHashHex(bytes);\n    }\n}\n\nexport function isBase64Like(input: string): boolean {\n    return looksLikeBase64(input).isBase64;\n}\n\nexport async function normalizeDataAsset(input: DataAssetInput, options: NormalizeDataAssetOptions = {}): Promise<DataAsset> {\n    const maxBytes = options.maxBytes ?? 50 * 1024 * 1024;\n    const namePrefix = (options.namePrefix || \"asset\").trim() || \"asset\";\n    const preserveFileName = options.preserveFileName ?? false;\n\n    let source: DataAssetSource = \"text\";\n    let blob: Blob;\n    let incomingFile: File | null = null;\n\n    if (input instanceof File) {\n        source = \"file\";\n        incomingFile = input;\n        blob = options.mimeType && options.mimeType !== input.type\n            ? new Blob([await input.arrayBuffer()], { type: options.mimeType })\n            : input;\n    } else if (input instanceof Blob) {\n        source = \"blob\";\n        blob = options.mimeType && options.mimeType !== input.type\n            ? new Blob([await input.arrayBuffer()], { type: options.mimeType })\n            : input;\n    } else {\n        const raw = (input instanceof URL ? input.toString() : String(input ?? \"\")).trim();\n        const parsed = parseDataUrl(raw);\n        const decodedUri = options.uriComponent ? tryDecodeURIComponent(raw) : (likelyUriComponent(raw) ? tryDecodeURIComponent(raw) : raw);\n\n        if (parsed) {\n            source = \"data-url\";\n        } else if (canParseUrl(raw)) {\n            source = \"url\";\n        } else if (isBase64Like(raw)) {\n            source = \"base64\";\n        } else if (decodedUri !== raw && (parseDataUrl(decodedUri) || isBase64Like(decodedUri) || canParseUrl(decodedUri))) {\n            source = \"uri\";\n        } else {\n            source = \"text\";\n        }\n\n        const stringSource = source === \"uri\" ? decodedUri : raw;\n        blob = await stringToBlob(stringSource, {\n            mimeType: options.mimeType,\n            uriComponent: options.uriComponent,\n            isBase64: source === \"base64\" ? true : undefined,\n            maxBytes,\n        });\n    }\n\n    const bytes = await blobToBytes(blob);\n    if (bytes.byteLength > maxBytes) throw new Error(`Data too large: ${bytes.byteLength} bytes`);\n\n    const hash = await sha256Hex(bytes);\n    const mimeType = (options.mimeType || blob.type || DEFAULT_MIME).trim() || DEFAULT_MIME;\n    const extension = extensionByMimeType(mimeType);\n    const hashedName = options.filename || `${namePrefix}-${hash.slice(0, 16)}.${extension}`;\n    const finalName = preserveFileName && incomingFile?.name ? incomingFile.name : hashedName;\n\n    const file = incomingFile && preserveFileName && !options.mimeType\n        ? incomingFile\n        : new File([blob], finalName, { type: mimeType });\n\n    return {\n        hash,\n        name: file.name,\n        type: file.type || mimeType,\n        size: file.size,\n        source,\n        file,\n    };\n}\n\nexport async function stringToBlobOrFile(input: string, options: StringToBinaryOptions = {}): Promise<Blob | File> {\n    const maxBytes = options.maxBytes ?? 50 * 1024 * 1024;\n    const raw = (input ?? \"\").trim();\n\n    const parsedDataUrl = parseDataUrl(raw);\n    if (parsedDataUrl) {\n        const mimeType = options.mimeType || parsedDataUrl.mimeType || DEFAULT_MIME;\n        const payload = options.uriComponent ? tryDecodeURIComponent(parsedDataUrl.data) : (likelyUriComponent(parsedDataUrl.data) ? tryDecodeURIComponent(parsedDataUrl.data) : parsedDataUrl.data);\n        const isBase64 = options.isBase64 ?? parsedDataUrl.isBase64;\n\n        if (isBase64) {\n            const bytes = decodeBase64ToBytes(payload, {\n                alphabet: options.base64?.alphabet || \"base64\",\n                lastChunkHandling: options.base64?.lastChunkHandling || \"loose\",\n            });\n            if (bytes.byteLength > maxBytes) throw new Error(`Decoded data too large: ${bytes.byteLength} bytes`);\n            const blob = new Blob([bytesToArrayBuffer(bytes)], { type: mimeType });\n            if (!options.asFile) return blob;\n            return new File([blob], options.filename || \"file\", { type: mimeType });\n        }\n\n        // Non-base64 data URL: treat as URL-encoded bytes/string. We keep it as UTF-8 text by default.\n        const blob = new Blob([payload], { type: mimeType });\n        if (!options.asFile) return blob;\n        return new File([blob], options.filename || \"file\", { type: mimeType });\n    }\n\n    // If it's a normal URL, fetch it.\n    try {\n        if (typeof URL !== \"undefined\" && (URL as any).canParse?.(raw)) {\n            const res = await fetch(raw);\n            const blob = await res.blob();\n            const mimeType = options.mimeType || blob.type || DEFAULT_MIME;\n            const typed = blob.type === mimeType ? blob : new Blob([await blob.arrayBuffer()], { type: mimeType });\n            if (!options.asFile) return typed;\n            return new File([typed], options.filename || \"file\", { type: mimeType });\n        }\n    } catch {\n        // fall through to treat as plain string / base64\n    }\n\n    // Plain string case: base64 bytes OR text.\n    const maybeDecoded = options.uriComponent ? tryDecodeURIComponent(raw) : (likelyUriComponent(raw) ? tryDecodeURIComponent(raw) : raw);\n    const base64Hint = looksLikeBase64(maybeDecoded);\n    const isBase64 = options.isBase64 ?? base64Hint.isBase64;\n    const mimeType = options.mimeType || (isBase64 ? DEFAULT_MIME : \"text/plain;charset=utf-8\");\n\n    if (isBase64) {\n        const bytes = decodeBase64ToBytes(maybeDecoded, {\n            alphabet: options.base64?.alphabet || base64Hint.alphabet,\n            lastChunkHandling: options.base64?.lastChunkHandling || \"loose\",\n        });\n        if (bytes.byteLength > maxBytes) throw new Error(`Decoded data too large: ${bytes.byteLength} bytes`);\n        const blob = new Blob([bytesToArrayBuffer(bytes)], { type: mimeType });\n        if (!options.asFile) return blob;\n        return new File([blob], options.filename || \"file\", { type: mimeType });\n    }\n\n    const blob = new Blob([maybeDecoded], { type: mimeType });\n    if (!options.asFile) return blob;\n    return new File([blob], options.filename || \"file\", { type: mimeType });\n}\n\nexport async function stringToBlob(input: string, options: Omit<StringToBinaryOptions, \"asFile\" | \"filename\"> = {}): Promise<Blob> {\n    return (await stringToBlobOrFile(input, { ...options, asFile: false })) as Blob;\n}\n\nexport async function stringToFile(input: string, filename: string, options: Omit<StringToBinaryOptions, \"asFile\" | \"filename\"> = {}): Promise<File> {\n    return (await stringToBlobOrFile(input, { ...options, asFile: true, filename })) as File;\n}\n\n"],"names":["mimeType","isBase64","blob"],"mappings":"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"}