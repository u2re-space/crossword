{"version":3,"file":"GPT-Responses.js","sources":["../../../../node_modules/@toon-format/toon/dist/index.mjs","../../src/com/service/model/GPT-Config.ts","../../src/core/document/AIResponseParser.ts","../../src/com/service/model/GPT-Responses.ts"],"sourcesContent":["//#region src/constants.ts\nconst LIST_ITEM_MARKER = \"-\";\nconst LIST_ITEM_PREFIX = \"- \";\nconst COMMA = \",\";\nconst COLON = \":\";\nconst SPACE = \" \";\nconst PIPE = \"|\";\nconst DOT = \".\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst OPEN_BRACE = \"{\";\nconst CLOSE_BRACE = \"}\";\nconst NULL_LITERAL = \"null\";\nconst TRUE_LITERAL = \"true\";\nconst FALSE_LITERAL = \"false\";\nconst BACKSLASH = \"\\\\\";\nconst DOUBLE_QUOTE = \"\\\"\";\nconst NEWLINE = \"\\n\";\nconst CARRIAGE_RETURN = \"\\r\";\nconst TAB = \"\t\";\nconst DELIMITERS = {\n\tcomma: COMMA,\n\ttab: TAB,\n\tpipe: PIPE\n};\nconst DEFAULT_DELIMITER = DELIMITERS.comma;\n\n//#endregion\n//#region src/shared/string-utils.ts\n/**\n* Escapes special characters in a string for encoding.\n*\n* @remarks\n* Handles backslashes, quotes, newlines, carriage returns, and tabs.\n*/\nfunction escapeString(value) {\n\treturn value.replace(/\\\\/g, `${BACKSLASH}${BACKSLASH}`).replace(/\"/g, `${BACKSLASH}${DOUBLE_QUOTE}`).replace(/\\n/g, `${BACKSLASH}n`).replace(/\\r/g, `${BACKSLASH}r`).replace(/\\t/g, `${BACKSLASH}t`);\n}\n/**\n* Unescapes a string by processing escape sequences.\n*\n* @remarks\n* Handles `\\n`, `\\t`, `\\r`, `\\\\`, and `\\\"` escape sequences.\n*/\nfunction unescapeString(value) {\n\tlet unescaped = \"\";\n\tlet i = 0;\n\twhile (i < value.length) {\n\t\tif (value[i] === BACKSLASH) {\n\t\t\tif (i + 1 >= value.length) throw new SyntaxError(\"Invalid escape sequence: backslash at end of string\");\n\t\t\tconst next = value[i + 1];\n\t\t\tif (next === \"n\") {\n\t\t\t\tunescaped += NEWLINE;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === \"t\") {\n\t\t\t\tunescaped += TAB;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === \"r\") {\n\t\t\t\tunescaped += CARRIAGE_RETURN;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === BACKSLASH) {\n\t\t\t\tunescaped += BACKSLASH;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === DOUBLE_QUOTE) {\n\t\t\t\tunescaped += DOUBLE_QUOTE;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow new SyntaxError(`Invalid escape sequence: \\\\${next}`);\n\t\t}\n\t\tunescaped += value[i];\n\t\ti++;\n\t}\n\treturn unescaped;\n}\n/**\n* Finds the index of the closing double quote, accounting for escape sequences.\n*/\nfunction findClosingQuote(content, start) {\n\tlet i = start + 1;\n\twhile (i < content.length) {\n\t\tif (content[i] === BACKSLASH && i + 1 < content.length) {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === DOUBLE_QUOTE) return i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n/**\n* Finds the index of a character outside of quoted sections.\n*/\nfunction findUnquotedChar(content, char, start = 0) {\n\tlet inQuotes = false;\n\tlet i = start;\n\twhile (i < content.length) {\n\t\tif (content[i] === BACKSLASH && i + 1 < content.length && inQuotes) {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === DOUBLE_QUOTE) {\n\t\t\tinQuotes = !inQuotes;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === char && !inQuotes) return i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n\n//#endregion\n//#region src/shared/literal-utils.ts\nfunction isBooleanOrNullLiteral(token) {\n\treturn token === TRUE_LITERAL || token === FALSE_LITERAL || token === NULL_LITERAL;\n}\n/**\n* Checks if a token represents a valid numeric literal.\n*\n* @remarks\n* Rejects numbers with leading zeros (except `\"0\"` itself or decimals like `\"0.5\"`).\n*/\nfunction isNumericLiteral(token) {\n\tif (!token) return false;\n\tif (token.length > 1 && token[0] === \"0\" && token[1] !== \".\") return false;\n\tconst numericValue = Number(token);\n\treturn !Number.isNaN(numericValue) && Number.isFinite(numericValue);\n}\n\n//#endregion\n//#region src/decode/parser.ts\nfunction parseArrayHeaderLine(content, defaultDelimiter) {\n\tconst trimmed = content.trimStart();\n\tlet bracketStart = -1;\n\tif (trimmed.startsWith(DOUBLE_QUOTE)) {\n\t\tconst closingQuoteIndex = findClosingQuote(trimmed, 0);\n\t\tif (closingQuoteIndex === -1) return;\n\t\tif (!trimmed.slice(closingQuoteIndex + 1).startsWith(OPEN_BRACKET)) return;\n\t\tconst keyEndIndex = content.length - trimmed.length + closingQuoteIndex + 1;\n\t\tbracketStart = content.indexOf(OPEN_BRACKET, keyEndIndex);\n\t} else bracketStart = content.indexOf(OPEN_BRACKET);\n\tif (bracketStart === -1) return;\n\tconst bracketEnd = content.indexOf(CLOSE_BRACKET, bracketStart);\n\tif (bracketEnd === -1) return;\n\tlet colonIndex = bracketEnd + 1;\n\tlet braceEnd = colonIndex;\n\tconst braceStart = content.indexOf(OPEN_BRACE, bracketEnd);\n\tif (braceStart !== -1 && braceStart < content.indexOf(COLON, bracketEnd)) {\n\t\tconst foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);\n\t\tif (foundBraceEnd !== -1) braceEnd = foundBraceEnd + 1;\n\t}\n\tcolonIndex = content.indexOf(COLON, Math.max(bracketEnd, braceEnd));\n\tif (colonIndex === -1) return;\n\tlet key;\n\tif (bracketStart > 0) {\n\t\tconst rawKey = content.slice(0, bracketStart).trim();\n\t\tkey = rawKey.startsWith(DOUBLE_QUOTE) ? parseStringLiteral(rawKey) : rawKey;\n\t}\n\tconst afterColon = content.slice(colonIndex + 1).trim();\n\tconst bracketContent = content.slice(bracketStart + 1, bracketEnd);\n\tlet parsedBracket;\n\ttry {\n\t\tparsedBracket = parseBracketSegment(bracketContent, defaultDelimiter);\n\t} catch {\n\t\treturn;\n\t}\n\tconst { length, delimiter } = parsedBracket;\n\tlet fields;\n\tif (braceStart !== -1 && braceStart < colonIndex) {\n\t\tconst foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);\n\t\tif (foundBraceEnd !== -1 && foundBraceEnd < colonIndex) fields = parseDelimitedValues(content.slice(braceStart + 1, foundBraceEnd), delimiter).map((field) => parseStringLiteral(field.trim()));\n\t}\n\treturn {\n\t\theader: {\n\t\t\tkey,\n\t\t\tlength,\n\t\t\tdelimiter,\n\t\t\tfields\n\t\t},\n\t\tinlineValues: afterColon || void 0\n\t};\n}\nfunction parseBracketSegment(seg, defaultDelimiter) {\n\tlet content = seg;\n\tlet delimiter = defaultDelimiter;\n\tif (content.endsWith(TAB)) {\n\t\tdelimiter = DELIMITERS.tab;\n\t\tcontent = content.slice(0, -1);\n\t} else if (content.endsWith(PIPE)) {\n\t\tdelimiter = DELIMITERS.pipe;\n\t\tcontent = content.slice(0, -1);\n\t}\n\tconst length = Number.parseInt(content, 10);\n\tif (Number.isNaN(length)) throw new TypeError(`Invalid array length: ${seg}`);\n\treturn {\n\t\tlength,\n\t\tdelimiter\n\t};\n}\n/**\n* Parses a delimited string into values, respecting quoted strings and escape sequences.\n*\n* @remarks\n* Uses a state machine that tracks:\n* - `inQuotes`: Whether we're inside a quoted string (to ignore delimiters)\n* - `valueBuffer`: Accumulates characters for the current value\n* - Escape sequences: Handled within quoted strings\n*/\nfunction parseDelimitedValues(input, delimiter) {\n\tconst values = [];\n\tlet valueBuffer = \"\";\n\tlet inQuotes = false;\n\tlet i = 0;\n\twhile (i < input.length) {\n\t\tconst char = input[i];\n\t\tif (char === BACKSLASH && i + 1 < input.length && inQuotes) {\n\t\t\tvalueBuffer += char + input[i + 1];\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === DOUBLE_QUOTE) {\n\t\t\tinQuotes = !inQuotes;\n\t\t\tvalueBuffer += char;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === delimiter && !inQuotes) {\n\t\t\tvalues.push(valueBuffer.trim());\n\t\t\tvalueBuffer = \"\";\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tvalueBuffer += char;\n\t\ti++;\n\t}\n\tif (valueBuffer || values.length > 0) values.push(valueBuffer.trim());\n\treturn values;\n}\nfunction mapRowValuesToPrimitives(values) {\n\treturn values.map((v) => parsePrimitiveToken(v));\n}\nfunction parsePrimitiveToken(token) {\n\tconst trimmed = token.trim();\n\tif (!trimmed) return \"\";\n\tif (trimmed.startsWith(DOUBLE_QUOTE)) return parseStringLiteral(trimmed);\n\tif (isBooleanOrNullLiteral(trimmed)) {\n\t\tif (trimmed === TRUE_LITERAL) return true;\n\t\tif (trimmed === FALSE_LITERAL) return false;\n\t\tif (trimmed === NULL_LITERAL) return null;\n\t}\n\tif (isNumericLiteral(trimmed)) {\n\t\tconst parsedNumber = Number.parseFloat(trimmed);\n\t\treturn Object.is(parsedNumber, -0) ? 0 : parsedNumber;\n\t}\n\treturn trimmed;\n}\nfunction parseStringLiteral(token) {\n\tconst trimmedToken = token.trim();\n\tif (trimmedToken.startsWith(DOUBLE_QUOTE)) {\n\t\tconst closingQuoteIndex = findClosingQuote(trimmedToken, 0);\n\t\tif (closingQuoteIndex === -1) throw new SyntaxError(\"Unterminated string: missing closing quote\");\n\t\tif (closingQuoteIndex !== trimmedToken.length - 1) throw new SyntaxError(\"Unexpected characters after closing quote\");\n\t\treturn unescapeString(trimmedToken.slice(1, closingQuoteIndex));\n\t}\n\treturn trimmedToken;\n}\nfunction parseUnquotedKey(content, start) {\n\tlet parsePosition = start;\n\twhile (parsePosition < content.length && content[parsePosition] !== COLON) parsePosition++;\n\tif (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError(\"Missing colon after key\");\n\tconst key = content.slice(start, parsePosition).trim();\n\tparsePosition++;\n\treturn {\n\t\tkey,\n\t\tend: parsePosition\n\t};\n}\nfunction parseQuotedKey(content, start) {\n\tconst closingQuoteIndex = findClosingQuote(content, start);\n\tif (closingQuoteIndex === -1) throw new SyntaxError(\"Unterminated quoted key\");\n\tconst key = unescapeString(content.slice(start + 1, closingQuoteIndex));\n\tlet parsePosition = closingQuoteIndex + 1;\n\tif (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError(\"Missing colon after key\");\n\tparsePosition++;\n\treturn {\n\t\tkey,\n\t\tend: parsePosition\n\t};\n}\nfunction parseKeyToken(content, start) {\n\tconst isQuoted = content[start] === DOUBLE_QUOTE;\n\treturn {\n\t\t...isQuoted ? parseQuotedKey(content, start) : parseUnquotedKey(content, start),\n\t\tisQuoted\n\t};\n}\nfunction isArrayHeaderContent(content) {\n\treturn content.trim().startsWith(OPEN_BRACKET) && findUnquotedChar(content, COLON) !== -1;\n}\nfunction isKeyValueContent(content) {\n\treturn findUnquotedChar(content, COLON) !== -1;\n}\n\n//#endregion\n//#region src/decode/scanner.ts\nfunction createScanState() {\n\treturn {\n\t\tlineNumber: 0,\n\t\tblankLines: []\n\t};\n}\nfunction parseLineIncremental(raw, state, indentSize, strict) {\n\tstate.lineNumber++;\n\tconst lineNumber = state.lineNumber;\n\tlet indent = 0;\n\twhile (indent < raw.length && raw[indent] === SPACE) indent++;\n\tconst content = raw.slice(indent);\n\tif (!content.trim()) {\n\t\tconst depth$1 = computeDepthFromIndent(indent, indentSize);\n\t\tstate.blankLines.push({\n\t\t\tlineNumber,\n\t\t\tindent,\n\t\t\tdepth: depth$1\n\t\t});\n\t\treturn;\n\t}\n\tconst depth = computeDepthFromIndent(indent, indentSize);\n\tif (strict) {\n\t\tlet whitespaceEndIndex = 0;\n\t\twhile (whitespaceEndIndex < raw.length && (raw[whitespaceEndIndex] === SPACE || raw[whitespaceEndIndex] === TAB)) whitespaceEndIndex++;\n\t\tif (raw.slice(0, whitespaceEndIndex).includes(TAB)) throw new SyntaxError(`Line ${lineNumber}: Tabs are not allowed in indentation in strict mode`);\n\t\tif (indent > 0 && indent % indentSize !== 0) throw new SyntaxError(`Line ${lineNumber}: Indentation must be exact multiple of ${indentSize}, but found ${indent} spaces`);\n\t}\n\treturn {\n\t\traw,\n\t\tindent,\n\t\tcontent,\n\t\tdepth,\n\t\tlineNumber\n\t};\n}\nfunction* parseLinesSync(source, indentSize, strict, state) {\n\tfor (const raw of source) {\n\t\tconst parsedLine = parseLineIncremental(raw, state, indentSize, strict);\n\t\tif (parsedLine !== void 0) yield parsedLine;\n\t}\n}\nasync function* parseLinesAsync(source, indentSize, strict, state) {\n\tfor await (const raw of source) {\n\t\tconst parsedLine = parseLineIncremental(raw, state, indentSize, strict);\n\t\tif (parsedLine !== void 0) yield parsedLine;\n\t}\n}\nfunction computeDepthFromIndent(indentSpaces, indentSize) {\n\treturn Math.floor(indentSpaces / indentSize);\n}\n\n//#endregion\n//#region src/decode/validation.ts\n/**\n* Asserts that the actual count matches the expected count in strict mode.\n*/\nfunction assertExpectedCount(actual, expected, itemType, options) {\n\tif (options.strict && actual !== expected) throw new RangeError(`Expected ${expected} ${itemType}, but got ${actual}`);\n}\n/**\n* Validates that there are no extra list items beyond the expected count.\n*/\nfunction validateNoExtraListItems(nextLine, itemDepth, expectedCount) {\n\tif (nextLine?.depth === itemDepth && nextLine.content.startsWith(LIST_ITEM_PREFIX)) throw new RangeError(`Expected ${expectedCount} list array items, but found more`);\n}\n/**\n* Validates that there are no extra tabular rows beyond the expected count.\n*/\nfunction validateNoExtraTabularRows(nextLine, rowDepth, header) {\n\tif (nextLine?.depth === rowDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX) && isDataRow(nextLine.content, header.delimiter)) throw new RangeError(`Expected ${header.length} tabular rows, but found more`);\n}\n/**\n* Validates that there are no blank lines within a specific line range in strict mode.\n*/\nfunction validateNoBlankLinesInRange(startLine, endLine, blankLines, strict, context) {\n\tif (!strict) return;\n\tconst firstBlank = blankLines.find((blank) => blank.lineNumber > startLine && blank.lineNumber < endLine);\n\tif (firstBlank) throw new SyntaxError(`Line ${firstBlank.lineNumber}: Blank lines inside ${context} are not allowed in strict mode`);\n}\n/**\n* Checks if a line is a data row (vs a key-value pair) in a tabular array.\n*/\nfunction isDataRow(content, delimiter) {\n\tconst colonPos = content.indexOf(COLON);\n\tconst delimiterPos = content.indexOf(delimiter);\n\tif (colonPos === -1) return true;\n\tif (delimiterPos !== -1 && delimiterPos < colonPos) return true;\n\treturn false;\n}\n\n//#endregion\n//#region src/decode/decoders.ts\nvar StreamingLineCursor = class {\n\tbuffer = [];\n\tgenerator;\n\tdone = false;\n\tlastLine;\n\tscanState;\n\tconstructor(generator, scanState) {\n\t\tthis.generator = generator;\n\t\tthis.scanState = scanState;\n\t}\n\tgetBlankLines() {\n\t\treturn this.scanState.blankLines;\n\t}\n\tasync peek() {\n\t\tif (this.buffer.length > 0) return this.buffer[0];\n\t\tif (this.done) return;\n\t\tconst result = await this.generator.next();\n\t\tif (result.done) {\n\t\t\tthis.done = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.buffer.push(result.value);\n\t\treturn result.value;\n\t}\n\tasync next() {\n\t\tconst line = await this.peek();\n\t\tif (line !== void 0) {\n\t\t\tthis.buffer.shift();\n\t\t\tthis.lastLine = line;\n\t\t}\n\t\treturn line;\n\t}\n\tasync advance() {\n\t\tawait this.next();\n\t}\n\tcurrent() {\n\t\treturn this.lastLine;\n\t}\n\tasync atEnd() {\n\t\treturn await this.peek() === void 0;\n\t}\n\tpeekSync() {\n\t\tif (this.buffer.length > 0) return this.buffer[0];\n\t\tif (this.done) return;\n\t\tconst result = this.generator.next();\n\t\tif (result.done) {\n\t\t\tthis.done = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.buffer.push(result.value);\n\t\treturn result.value;\n\t}\n\tnextSync() {\n\t\tconst line = this.peekSync();\n\t\tif (line !== void 0) {\n\t\t\tthis.buffer.shift();\n\t\t\tthis.lastLine = line;\n\t\t}\n\t\treturn line;\n\t}\n\tadvanceSync() {\n\t\tthis.nextSync();\n\t}\n\tatEndSync() {\n\t\treturn this.peekSync() === void 0;\n\t}\n};\nfunction* decodeStreamSync$1(source, options) {\n\tif (options?.expandPaths !== void 0) throw new Error(\"expandPaths is not supported in streaming decode\");\n\tconst resolvedOptions = {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true\n\t};\n\tconst scanState = createScanState();\n\tconst cursor = new StreamingLineCursor(parseLinesSync(source, resolvedOptions.indent, resolvedOptions.strict, scanState), scanState);\n\tconst first = cursor.peekSync();\n\tif (!first) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(first.content)) {\n\t\tconst headerInfo = parseArrayHeaderLine(first.content, DEFAULT_DELIMITER);\n\t\tif (headerInfo) {\n\t\t\tcursor.advanceSync();\n\t\t\tyield* decodeArrayFromHeaderSync(headerInfo.header, headerInfo.inlineValues, cursor, 0, resolvedOptions);\n\t\t\treturn;\n\t\t}\n\t}\n\tcursor.advanceSync();\n\tif (!!cursor.atEndSync() && !isKeyValueLineSync(first)) {\n\t\tyield {\n\t\t\ttype: \"primitive\",\n\t\t\tvalue: parsePrimitiveToken(first.content.trim())\n\t\t};\n\t\treturn;\n\t}\n\tyield { type: \"startObject\" };\n\tyield* decodeKeyValueSync(first.content, cursor, 0, resolvedOptions);\n\twhile (!cursor.atEndSync()) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth !== 0) break;\n\t\tcursor.advanceSync();\n\t\tyield* decodeKeyValueSync(line.content, cursor, 0, resolvedOptions);\n\t}\n\tyield { type: \"endObject\" };\n}\nfunction* decodeKeyValueSync(content, cursor, baseDepth, options) {\n\tconst arrayHeader = parseArrayHeaderLine(content, DEFAULT_DELIMITER);\n\tif (arrayHeader && arrayHeader.header.key) {\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: arrayHeader.header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\treturn;\n\t}\n\tconst { key, isQuoted } = parseKeyToken(content, 0);\n\tconst colonIndex = content.indexOf(COLON, key.length);\n\tconst rest = colonIndex >= 0 ? content.slice(colonIndex + 1).trim() : \"\";\n\tyield isQuoted ? {\n\t\ttype: \"key\",\n\t\tkey,\n\t\twasQuoted: true\n\t} : {\n\t\ttype: \"key\",\n\t\tkey\n\t};\n\tif (!rest) {\n\t\tconst nextLine = cursor.peekSync();\n\t\tif (nextLine && nextLine.depth > baseDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield* decodeObjectFieldsSync(cursor, baseDepth + 1, options);\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(rest)\n\t};\n}\nfunction* decodeObjectFieldsSync(cursor, baseDepth, options) {\n\tlet computedDepth;\n\twhile (!cursor.atEndSync()) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < baseDepth) break;\n\t\tif (computedDepth === void 0 && line.depth >= baseDepth) computedDepth = line.depth;\n\t\tif (line.depth === computedDepth) {\n\t\t\tcursor.advanceSync();\n\t\t\tyield* decodeKeyValueSync(line.content, cursor, computedDepth, options);\n\t\t} else break;\n\t}\n}\nfunction* decodeArrayFromHeaderSync(header, inlineValues, cursor, baseDepth, options) {\n\tyield {\n\t\ttype: \"startArray\",\n\t\tlength: header.length\n\t};\n\tif (inlineValues) {\n\t\tyield* decodeInlinePrimitiveArraySync(header, inlineValues, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tif (header.fields && header.fields.length > 0) {\n\t\tyield* decodeTabularArraySync(header, cursor, baseDepth, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tyield* decodeListArraySync(header, cursor, baseDepth, options);\n\tyield { type: \"endArray\" };\n}\nfunction* decodeInlinePrimitiveArraySync(header, inlineValues, options) {\n\tif (!inlineValues.trim()) {\n\t\tassertExpectedCount(0, header.length, \"inline array items\", options);\n\t\treturn;\n\t}\n\tconst primitives = mapRowValuesToPrimitives(parseDelimitedValues(inlineValues, header.delimiter));\n\tassertExpectedCount(primitives.length, header.length, \"inline array items\", options);\n\tfor (const primitive of primitives) yield {\n\t\ttype: \"primitive\",\n\t\tvalue: primitive\n\t};\n}\nfunction* decodeTabularArraySync(header, cursor, baseDepth, options) {\n\tconst rowDepth = baseDepth + 1;\n\tlet rowCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!cursor.atEndSync() && rowCount < header.length) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < rowDepth) break;\n\t\tif (line.depth === rowDepth) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tcursor.advanceSync();\n\t\t\tconst values = parseDelimitedValues(line.content, header.delimiter);\n\t\t\tassertExpectedCount(values.length, header.fields.length, \"tabular row values\", options);\n\t\t\tconst primitives = mapRowValuesToPrimitives(values);\n\t\t\tyield { type: \"startObject\" };\n\t\t\tfor (let i = 0; i < header.fields.length; i++) {\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"key\",\n\t\t\t\t\tkey: header.fields[i]\n\t\t\t\t};\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"primitive\",\n\t\t\t\t\tvalue: primitives[i]\n\t\t\t\t};\n\t\t\t}\n\t\t\tyield { type: \"endObject\" };\n\t\t\trowCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(rowCount, header.length, \"tabular rows\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"tabular array\");\n\tif (options.strict) validateNoExtraTabularRows(cursor.peekSync(), rowDepth, header);\n}\nfunction* decodeListArraySync(header, cursor, baseDepth, options) {\n\tconst itemDepth = baseDepth + 1;\n\tlet itemCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!cursor.atEndSync() && itemCount < header.length) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < itemDepth) break;\n\t\tconst isListItem = line.content.startsWith(LIST_ITEM_PREFIX) || line.content === LIST_ITEM_MARKER;\n\t\tif (line.depth === itemDepth && isListItem) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tyield* decodeListItemSync(cursor, itemDepth, options);\n\t\t\tconst currentLine = cursor.current();\n\t\t\tif (currentLine) endLine = currentLine.lineNumber;\n\t\t\titemCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(itemCount, header.length, \"list array items\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"list array\");\n\tif (options.strict) validateNoExtraListItems(cursor.peekSync(), itemDepth, header.length);\n}\nfunction* decodeListItemSync(cursor, baseDepth, options) {\n\tconst line = cursor.nextSync();\n\tif (!line) throw new ReferenceError(\"Expected list item\");\n\tlet afterHyphen;\n\tif (line.content === LIST_ITEM_MARKER) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t} else if (line.content.startsWith(LIST_ITEM_PREFIX)) afterHyphen = line.content.slice(LIST_ITEM_PREFIX.length);\n\telse throw new SyntaxError(`Expected list item to start with \"${LIST_ITEM_PREFIX}\"`);\n\tif (!afterHyphen.trim()) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(afterHyphen)) {\n\t\tconst arrayHeader = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\t\tif (arrayHeader) {\n\t\t\tyield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isKeyValueContent(afterHyphen)) {\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueSync(afterHyphen, cursor, baseDepth, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!cursor.atEndSync()) {\n\t\t\tconst nextLine = cursor.peekSync();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tcursor.advanceSync();\n\t\t\t\tyield* decodeKeyValueSync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(afterHyphen)\n\t};\n}\nfunction isKeyValueLineSync(line) {\n\tconst content = line.content;\n\tif (content.startsWith(\"\\\"\")) {\n\t\tconst closingQuoteIndex = findClosingQuote(content, 0);\n\t\tif (closingQuoteIndex === -1) return false;\n\t\treturn content.slice(closingQuoteIndex + 1).includes(COLON);\n\t} else return content.includes(COLON);\n}\nasync function* decodeStream$1(source, options) {\n\tif (options?.expandPaths !== void 0) throw new Error(\"expandPaths is not supported in streaming decode\");\n\tconst resolvedOptions = {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true\n\t};\n\tconst scanState = createScanState();\n\tif (Symbol.asyncIterator in source) {\n\t\tconst cursor = new StreamingLineCursor(parseLinesAsync(source, resolvedOptions.indent, resolvedOptions.strict, scanState), scanState);\n\t\tconst first = await cursor.peek();\n\t\tif (!first) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tif (isArrayHeaderContent(first.content)) {\n\t\t\tconst headerInfo = parseArrayHeaderLine(first.content, DEFAULT_DELIMITER);\n\t\t\tif (headerInfo) {\n\t\t\t\tawait cursor.advance();\n\t\t\t\tyield* decodeArrayFromHeaderAsync(headerInfo.header, headerInfo.inlineValues, cursor, 0, resolvedOptions);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait cursor.advance();\n\t\tif (!!await cursor.atEnd() && !isKeyValueLineSync(first)) {\n\t\t\tyield {\n\t\t\t\ttype: \"primitive\",\n\t\t\t\tvalue: parsePrimitiveToken(first.content.trim())\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueAsync(first.content, cursor, 0, resolvedOptions);\n\t\twhile (!await cursor.atEnd()) {\n\t\t\tconst line = await cursor.peek();\n\t\t\tif (!line || line.depth !== 0) break;\n\t\t\tawait cursor.advance();\n\t\t\tyield* decodeKeyValueAsync(line.content, cursor, 0, resolvedOptions);\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t} else yield* decodeStreamSync$1(source, options);\n}\nasync function* decodeKeyValueAsync(content, cursor, baseDepth, options) {\n\tconst arrayHeader = parseArrayHeaderLine(content, DEFAULT_DELIMITER);\n\tif (arrayHeader && arrayHeader.header.key) {\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: arrayHeader.header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderAsync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\treturn;\n\t}\n\tconst { key, isQuoted } = parseKeyToken(content, 0);\n\tconst colonIndex = content.indexOf(COLON, key.length);\n\tconst rest = colonIndex >= 0 ? content.slice(colonIndex + 1).trim() : \"\";\n\tyield isQuoted ? {\n\t\ttype: \"key\",\n\t\tkey,\n\t\twasQuoted: true\n\t} : {\n\t\ttype: \"key\",\n\t\tkey\n\t};\n\tif (!rest) {\n\t\tconst nextLine = await cursor.peek();\n\t\tif (nextLine && nextLine.depth > baseDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield* decodeObjectFieldsAsync(cursor, baseDepth + 1, options);\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(rest)\n\t};\n}\nasync function* decodeObjectFieldsAsync(cursor, baseDepth, options) {\n\tlet computedDepth;\n\twhile (!await cursor.atEnd()) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < baseDepth) break;\n\t\tif (computedDepth === void 0 && line.depth >= baseDepth) computedDepth = line.depth;\n\t\tif (line.depth === computedDepth) {\n\t\t\tawait cursor.advance();\n\t\t\tyield* decodeKeyValueAsync(line.content, cursor, computedDepth, options);\n\t\t} else break;\n\t}\n}\nasync function* decodeArrayFromHeaderAsync(header, inlineValues, cursor, baseDepth, options) {\n\tyield {\n\t\ttype: \"startArray\",\n\t\tlength: header.length\n\t};\n\tif (inlineValues) {\n\t\tyield* decodeInlinePrimitiveArraySync(header, inlineValues, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tif (header.fields && header.fields.length > 0) {\n\t\tyield* decodeTabularArrayAsync(header, cursor, baseDepth, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tyield* decodeListArrayAsync(header, cursor, baseDepth, options);\n\tyield { type: \"endArray\" };\n}\nasync function* decodeTabularArrayAsync(header, cursor, baseDepth, options) {\n\tconst rowDepth = baseDepth + 1;\n\tlet rowCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!await cursor.atEnd() && rowCount < header.length) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < rowDepth) break;\n\t\tif (line.depth === rowDepth) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tawait cursor.advance();\n\t\t\tconst values = parseDelimitedValues(line.content, header.delimiter);\n\t\t\tassertExpectedCount(values.length, header.fields.length, \"tabular row values\", options);\n\t\t\tconst primitives = mapRowValuesToPrimitives(values);\n\t\t\tyield { type: \"startObject\" };\n\t\t\tfor (let i = 0; i < header.fields.length; i++) {\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"key\",\n\t\t\t\t\tkey: header.fields[i]\n\t\t\t\t};\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"primitive\",\n\t\t\t\t\tvalue: primitives[i]\n\t\t\t\t};\n\t\t\t}\n\t\t\tyield { type: \"endObject\" };\n\t\t\trowCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(rowCount, header.length, \"tabular rows\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"tabular array\");\n\tif (options.strict) validateNoExtraTabularRows(await cursor.peek(), rowDepth, header);\n}\nasync function* decodeListArrayAsync(header, cursor, baseDepth, options) {\n\tconst itemDepth = baseDepth + 1;\n\tlet itemCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!await cursor.atEnd() && itemCount < header.length) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < itemDepth) break;\n\t\tconst isListItem = line.content.startsWith(LIST_ITEM_PREFIX) || line.content === LIST_ITEM_MARKER;\n\t\tif (line.depth === itemDepth && isListItem) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tyield* decodeListItemAsync(cursor, itemDepth, options);\n\t\t\tconst currentLine = cursor.current();\n\t\t\tif (currentLine) endLine = currentLine.lineNumber;\n\t\t\titemCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(itemCount, header.length, \"list array items\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"list array\");\n\tif (options.strict) validateNoExtraListItems(await cursor.peek(), itemDepth, header.length);\n}\nasync function* decodeListItemAsync(cursor, baseDepth, options) {\n\tconst line = await cursor.next();\n\tif (!line) throw new ReferenceError(\"Expected list item\");\n\tlet afterHyphen;\n\tif (line.content === LIST_ITEM_MARKER) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t} else if (line.content.startsWith(LIST_ITEM_PREFIX)) afterHyphen = line.content.slice(LIST_ITEM_PREFIX.length);\n\telse throw new SyntaxError(`Expected list item to start with \"${LIST_ITEM_PREFIX}\"`);\n\tif (!afterHyphen.trim()) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(afterHyphen)) {\n\t\tconst arrayHeader = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\t\tif (arrayHeader) {\n\t\t\tyield* decodeArrayFromHeaderAsync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isKeyValueContent(afterHyphen)) {\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueAsync(afterHyphen, cursor, baseDepth, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!await cursor.atEnd()) {\n\t\t\tconst nextLine = await cursor.peek();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tawait cursor.advance();\n\t\t\t\tyield* decodeKeyValueAsync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(afterHyphen)\n\t};\n}\n\n//#endregion\n//#region src/encode/normalize.ts\nfunction normalizeValue(value) {\n\tif (value === null) return null;\n\tif (typeof value === \"string\" || typeof value === \"boolean\") return value;\n\tif (typeof value === \"number\") {\n\t\tif (Object.is(value, -0)) return 0;\n\t\tif (!Number.isFinite(value)) return null;\n\t\treturn value;\n\t}\n\tif (typeof value === \"bigint\") {\n\t\tif (value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) return Number(value);\n\t\treturn value.toString();\n\t}\n\tif (value instanceof Date) return value.toISOString();\n\tif (Array.isArray(value)) return value.map(normalizeValue);\n\tif (value instanceof Set) return Array.from(value).map(normalizeValue);\n\tif (value instanceof Map) return Object.fromEntries(Array.from(value, ([k, v]) => [String(k), normalizeValue(v)]));\n\tif (isPlainObject(value)) {\n\t\tconst normalized = {};\n\t\tfor (const key in value) if (Object.prototype.hasOwnProperty.call(value, key)) normalized[key] = normalizeValue(value[key]);\n\t\treturn normalized;\n\t}\n\treturn null;\n}\nfunction isJsonPrimitive(value) {\n\treturn value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\";\n}\nfunction isJsonArray(value) {\n\treturn Array.isArray(value);\n}\nfunction isJsonObject(value) {\n\treturn value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\nfunction isEmptyObject(value) {\n\treturn Object.keys(value).length === 0;\n}\nfunction isPlainObject(value) {\n\tif (value === null || typeof value !== \"object\") return false;\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n}\nfunction isArrayOfPrimitives(value) {\n\treturn value.length === 0 || value.every((item) => isJsonPrimitive(item));\n}\nfunction isArrayOfArrays(value) {\n\treturn value.length === 0 || value.every((item) => isJsonArray(item));\n}\nfunction isArrayOfObjects(value) {\n\treturn value.length === 0 || value.every((item) => isJsonObject(item));\n}\n\n//#endregion\n//#region src/shared/validation.ts\n/**\n* Checks if a key can be used without quotes.\n*\n* @remarks\n* Valid unquoted keys must start with a letter or underscore,\n* followed by letters, digits, underscores, or dots.\n*/\nfunction isValidUnquotedKey(key) {\n\treturn /^[A-Z_][\\w.]*$/i.test(key);\n}\n/**\n* Checks if a key segment is a valid identifier for safe folding/expansion.\n*\n* @remarks\n* Identifier segments are more restrictive than unquoted keys:\n* - Must start with a letter or underscore\n* - Followed only by letters, digits, or underscores (no dots)\n* - Used for safe key folding and path expansion\n*/\nfunction isIdentifierSegment(key) {\n\treturn /^[A-Z_]\\w*$/i.test(key);\n}\n/**\n* Determines if a string value can be safely encoded without quotes.\n*\n* @remarks\n* A string needs quoting if it:\n* - Is empty\n* - Has leading or trailing whitespace\n* - Could be confused with a literal (boolean, null, number)\n* - Contains structural characters (colons, brackets, braces)\n* - Contains quotes or backslashes (need escaping)\n* - Contains control characters (newlines, tabs, etc.)\n* - Contains the active delimiter\n* - Starts with a list marker (hyphen)\n*/\nfunction isSafeUnquoted(value, delimiter = DEFAULT_DELIMITER) {\n\tif (!value) return false;\n\tif (value !== value.trim()) return false;\n\tif (isBooleanOrNullLiteral(value) || isNumericLike(value)) return false;\n\tif (value.includes(\":\")) return false;\n\tif (value.includes(\"\\\"\") || value.includes(\"\\\\\")) return false;\n\tif (/[[\\]{}]/.test(value)) return false;\n\tif (/[\\n\\r\\t]/.test(value)) return false;\n\tif (value.includes(delimiter)) return false;\n\tif (value.startsWith(LIST_ITEM_MARKER)) return false;\n\treturn true;\n}\n/**\n* Checks if a string looks like a number.\n*\n* @remarks\n* Match numbers like `42`, `-3.14`, `1e-6`, `05`, etc.\n*/\nfunction isNumericLike(value) {\n\treturn /^-?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?$/i.test(value) || /^0\\d+$/.test(value);\n}\n\n//#endregion\n//#region src/decode/expand.ts\n/**\n* Symbol used to mark object keys that were originally quoted in the TOON source.\n* Quoted dotted keys should not be expanded, even if they meet expansion criteria.\n*/\nconst QUOTED_KEY_MARKER = Symbol(\"quotedKey\");\n/**\n* Expands dotted keys into nested objects in safe mode.\n*\n* @remarks\n* This function recursively traverses a decoded TOON value and expands any keys\n* containing dots (`.`) into nested object structures, provided all segments\n* are valid identifiers.\n*\n* Expansion rules:\n* - Keys containing dots are split into segments\n* - All segments must pass `isIdentifierSegment` validation\n* - Non-eligible keys (with special characters) are left as literal dotted keys\n* - Deep merge: When multiple dotted keys expand to the same path, their values are merged if both are objects\n* - Conflict handling:\n*   - `strict=true`: Throws TypeError on conflicts (non-object collision)\n*   - `strict=false`: LWW (silent overwrite)\n*\n* @param value - The decoded value to expand\n* @param strict - Whether to throw errors on conflicts\n* @returns The expanded value with dotted keys reconstructed as nested objects\n* @throws TypeError if conflicts occur in strict mode\n*/\nfunction expandPathsSafe(value, strict) {\n\tif (Array.isArray(value)) return value.map((item) => expandPathsSafe(item, strict));\n\tif (isJsonObject(value)) {\n\t\tconst expandedObject = {};\n\t\tconst quotedKeys = value[QUOTED_KEY_MARKER];\n\t\tfor (const [key, keyValue] of Object.entries(value)) {\n\t\t\tconst isQuoted = quotedKeys?.has(key);\n\t\t\tif (key.includes(DOT) && !isQuoted) {\n\t\t\t\tconst segments = key.split(DOT);\n\t\t\t\tif (segments.every((seg) => isIdentifierSegment(seg))) {\n\t\t\t\t\tinsertPathSafe(expandedObject, segments, expandPathsSafe(keyValue, strict), strict);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst expandedValue = expandPathsSafe(keyValue, strict);\n\t\t\tif (key in expandedObject) {\n\t\t\t\tconst conflictingValue = expandedObject[key];\n\t\t\t\tif (canMerge(conflictingValue, expandedValue)) mergeObjects(conflictingValue, expandedValue, strict);\n\t\t\t\telse {\n\t\t\t\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${key}\": cannot merge ${typeof conflictingValue} with ${typeof expandedValue}`);\n\t\t\t\t\texpandedObject[key] = expandedValue;\n\t\t\t\t}\n\t\t\t} else expandedObject[key] = expandedValue;\n\t\t}\n\t\treturn expandedObject;\n\t}\n\treturn value;\n}\n/**\n* Inserts a value at a nested path, creating intermediate objects as needed.\n*\n* @remarks\n* This function walks the segment path, creating nested objects as needed.\n* When an existing value is encountered:\n* - If both are objects: deep merge (continue insertion)\n* - If values differ: conflict\n*   - strict=true: throw TypeError\n*   - strict=false: overwrite with new value (LWW)\n*\n* @param target - The object to insert into\n* @param segments - Array of path segments (e.g., ['data', 'metadata', 'items'])\n* @param value - The value to insert at the end of the path\n* @param strict - Whether to throw on conflicts\n* @throws TypeError if a conflict occurs in strict mode\n*/\nfunction insertPathSafe(target, segments, value, strict) {\n\tlet currentNode = target;\n\tfor (let i = 0; i < segments.length - 1; i++) {\n\t\tconst currentSegment = segments[i];\n\t\tconst segmentValue = currentNode[currentSegment];\n\t\tif (segmentValue === void 0) {\n\t\t\tconst newObj = {};\n\t\t\tcurrentNode[currentSegment] = newObj;\n\t\t\tcurrentNode = newObj;\n\t\t} else if (isJsonObject(segmentValue)) currentNode = segmentValue;\n\t\telse {\n\t\t\tif (strict) throw new TypeError(`Path expansion conflict at segment \"${currentSegment}\": expected object but found ${typeof segmentValue}`);\n\t\t\tconst newObj = {};\n\t\t\tcurrentNode[currentSegment] = newObj;\n\t\t\tcurrentNode = newObj;\n\t\t}\n\t}\n\tconst lastSeg = segments[segments.length - 1];\n\tconst destinationValue = currentNode[lastSeg];\n\tif (destinationValue === void 0) currentNode[lastSeg] = value;\n\telse if (canMerge(destinationValue, value)) mergeObjects(destinationValue, value, strict);\n\telse {\n\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${lastSeg}\": cannot merge ${typeof destinationValue} with ${typeof value}`);\n\t\tcurrentNode[lastSeg] = value;\n\t}\n}\n/**\n* Deep merges properties from source into target.\n*\n* @remarks\n* For each key in source:\n* - If key doesn't exist in target: copy it\n* - If both values are objects: recursively merge\n* - Otherwise: conflict (strict throws, non-strict overwrites)\n*\n* @param target - The target object to merge into\n* @param source - The source object to merge from\n* @param strict - Whether to throw on conflicts\n* @throws TypeError if a conflict occurs in strict mode\n*/\nfunction mergeObjects(target, source, strict) {\n\tfor (const [key, sourceValue] of Object.entries(source)) {\n\t\tconst targetValue = target[key];\n\t\tif (targetValue === void 0) target[key] = sourceValue;\n\t\telse if (canMerge(targetValue, sourceValue)) mergeObjects(targetValue, sourceValue, strict);\n\t\telse {\n\t\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${key}\": cannot merge ${typeof targetValue} with ${typeof sourceValue}`);\n\t\t\ttarget[key] = sourceValue;\n\t\t}\n\t}\n}\nfunction canMerge(a, b) {\n\treturn isJsonObject(a) && isJsonObject(b);\n}\n\n//#endregion\n//#region src/decode/event-builder.ts\nfunction buildValueFromEvents(events) {\n\tconst stack = [];\n\tlet root;\n\tfor (const event of events) switch (event.type) {\n\t\tcase \"startObject\": {\n\t\t\tconst obj = {};\n\t\t\tconst quotedKeys = /* @__PURE__ */ new Set();\n\t\t\tif (stack.length === 0) stack.push({\n\t\t\t\ttype: \"object\",\n\t\t\t\tobj,\n\t\t\t\tquotedKeys\n\t\t\t});\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Object startObject event without preceding key\");\n\t\t\t\t\tparent.obj[parent.currentKey] = obj;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(obj);\n\t\t\t\tstack.push({\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tobj,\n\t\t\t\t\tquotedKeys\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"endObject\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Unexpected endObject event\");\n\t\t\tconst context = stack.pop();\n\t\t\tif (context.type !== \"object\") throw new Error(\"Mismatched endObject event\");\n\t\t\tif (context.quotedKeys.size > 0) Object.defineProperty(context.obj, QUOTED_KEY_MARKER, {\n\t\t\t\tvalue: context.quotedKeys,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: false,\n\t\t\t\tconfigurable: false\n\t\t\t});\n\t\t\tif (stack.length === 0) root = context.obj;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"startArray\": {\n\t\t\tconst arr = [];\n\t\t\tif (stack.length === 0) stack.push({\n\t\t\t\ttype: \"array\",\n\t\t\t\tarr\n\t\t\t});\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Array startArray event without preceding key\");\n\t\t\t\t\tparent.obj[parent.currentKey] = arr;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(arr);\n\t\t\t\tstack.push({\n\t\t\t\t\ttype: \"array\",\n\t\t\t\t\tarr\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"endArray\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Unexpected endArray event\");\n\t\t\tconst context = stack.pop();\n\t\t\tif (context.type !== \"array\") throw new Error(\"Mismatched endArray event\");\n\t\t\tif (stack.length === 0) root = context.arr;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"key\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Key event outside of object context\");\n\t\t\tconst parent = stack[stack.length - 1];\n\t\t\tif (parent.type !== \"object\") throw new Error(\"Key event in non-object context\");\n\t\t\tparent.currentKey = event.key;\n\t\t\tif (event.wasQuoted) parent.quotedKeys.add(event.key);\n\t\t\tbreak;\n\t\t}\n\t\tcase \"primitive\":\n\t\t\tif (stack.length === 0) root = event.value;\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Primitive event without preceding key in object\");\n\t\t\t\t\tparent.obj[parent.currentKey] = event.value;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(event.value);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (stack.length !== 0) throw new Error(\"Incomplete event stream: stack not empty at end\");\n\tif (root === void 0) throw new Error(\"No root value built from events\");\n\treturn root;\n}\n\n//#endregion\n//#region src/encode/folding.ts\n/**\n* Attempts to fold a single-key object chain into a dotted path.\n*\n* @remarks\n* Folding traverses nested objects with single keys, collapsing them into a dotted path.\n* It stops when:\n* - A non-single-key object is encountered\n* - An array is encountered (arrays are not \"single-key objects\")\n* - A primitive value is reached\n* - The flatten depth limit is reached\n* - Any segment fails safe mode validation\n*\n* Safe mode requirements:\n* - `options.keyFolding` must be `'safe'`\n* - Every segment must be a valid identifier (no dots, no special chars)\n* - The folded key must not collide with existing sibling keys\n* - No segment should require quoting\n*\n* @param key - The starting key to fold\n* @param value - The value associated with the key\n* @param siblings - Array of all sibling keys at this level (for collision detection)\n* @param options - Resolved encoding options\n* @returns A FoldResult if folding is possible, undefined otherwise\n*/\nfunction tryFoldKeyChain(key, value, siblings, options, rootLiteralKeys, pathPrefix, flattenDepth) {\n\tif (options.keyFolding !== \"safe\") return;\n\tif (!isJsonObject(value)) return;\n\tconst { segments, tail, leafValue } = collectSingleKeyChain(key, value, flattenDepth ?? options.flattenDepth);\n\tif (segments.length < 2) return;\n\tif (!segments.every((seg) => isIdentifierSegment(seg))) return;\n\tconst foldedKey = buildFoldedKey(segments);\n\tconst absolutePath = pathPrefix ? `${pathPrefix}${DOT}${foldedKey}` : foldedKey;\n\tif (siblings.includes(foldedKey)) return;\n\tif (rootLiteralKeys && rootLiteralKeys.has(absolutePath)) return;\n\treturn {\n\t\tfoldedKey,\n\t\tremainder: tail,\n\t\tleafValue,\n\t\tsegmentCount: segments.length\n\t};\n}\n/**\n* Collects a chain of single-key objects into segments.\n*\n* @remarks\n* Traverses nested objects, collecting keys until:\n* - A non-single-key object is found\n* - An array is encountered\n* - A primitive is reached\n* - An empty object is reached\n* - The depth limit is reached\n*\n* @param startKey - The initial key to start the chain\n* @param startValue - The value to traverse\n* @param maxDepth - Maximum number of segments to collect\n* @returns Object containing segments array, tail value, and leaf value\n*/\nfunction collectSingleKeyChain(startKey, startValue, maxDepth) {\n\tconst segments = [startKey];\n\tlet currentValue = startValue;\n\twhile (segments.length < maxDepth) {\n\t\tif (!isJsonObject(currentValue)) break;\n\t\tconst keys = Object.keys(currentValue);\n\t\tif (keys.length !== 1) break;\n\t\tconst nextKey = keys[0];\n\t\tconst nextValue = currentValue[nextKey];\n\t\tsegments.push(nextKey);\n\t\tcurrentValue = nextValue;\n\t}\n\tif (!isJsonObject(currentValue) || isEmptyObject(currentValue)) return {\n\t\tsegments,\n\t\ttail: void 0,\n\t\tleafValue: currentValue\n\t};\n\treturn {\n\t\tsegments,\n\t\ttail: currentValue,\n\t\tleafValue: currentValue\n\t};\n}\nfunction buildFoldedKey(segments) {\n\treturn segments.join(DOT);\n}\n\n//#endregion\n//#region src/encode/primitives.ts\nfunction encodePrimitive(value, delimiter) {\n\tif (value === null) return NULL_LITERAL;\n\tif (typeof value === \"boolean\") return String(value);\n\tif (typeof value === \"number\") return String(value);\n\treturn encodeStringLiteral(value, delimiter);\n}\nfunction encodeStringLiteral(value, delimiter = DEFAULT_DELIMITER) {\n\tif (isSafeUnquoted(value, delimiter)) return value;\n\treturn `${DOUBLE_QUOTE}${escapeString(value)}${DOUBLE_QUOTE}`;\n}\nfunction encodeKey(key) {\n\tif (isValidUnquotedKey(key)) return key;\n\treturn `${DOUBLE_QUOTE}${escapeString(key)}${DOUBLE_QUOTE}`;\n}\nfunction encodeAndJoinPrimitives(values, delimiter = DEFAULT_DELIMITER) {\n\treturn values.map((v) => encodePrimitive(v, delimiter)).join(delimiter);\n}\nfunction formatHeader(length, options) {\n\tconst key = options?.key;\n\tconst fields = options?.fields;\n\tconst delimiter = options?.delimiter ?? COMMA;\n\tlet header = \"\";\n\tif (key) header += encodeKey(key);\n\theader += `[${length}${delimiter !== DEFAULT_DELIMITER ? delimiter : \"\"}]`;\n\tif (fields) {\n\t\tconst quotedFields = fields.map((f) => encodeKey(f));\n\t\theader += `{${quotedFields.join(delimiter)}}`;\n\t}\n\theader += \":\";\n\treturn header;\n}\n\n//#endregion\n//#region src/encode/encoders.ts\nfunction* encodeJsonValue(value, options, depth) {\n\tif (isJsonPrimitive(value)) {\n\t\tconst encodedPrimitive = encodePrimitive(value, options.delimiter);\n\t\tif (encodedPrimitive !== \"\") yield encodedPrimitive;\n\t\treturn;\n\t}\n\tif (isJsonArray(value)) yield* encodeArrayLines(void 0, value, depth, options);\n\telse if (isJsonObject(value)) yield* encodeObjectLines(value, depth, options);\n}\nfunction* encodeObjectLines(value, depth, options, rootLiteralKeys, pathPrefix, remainingDepth) {\n\tconst keys = Object.keys(value);\n\tif (depth === 0 && !rootLiteralKeys) rootLiteralKeys = new Set(keys.filter((k) => k.includes(\".\")));\n\tconst effectiveFlattenDepth = remainingDepth ?? options.flattenDepth;\n\tfor (const [key, val] of Object.entries(value)) yield* encodeKeyValuePairLines(key, val, depth, options, keys, rootLiteralKeys, pathPrefix, effectiveFlattenDepth);\n}\nfunction* encodeKeyValuePairLines(key, value, depth, options, siblings, rootLiteralKeys, pathPrefix, flattenDepth) {\n\tconst currentPath = pathPrefix ? `${pathPrefix}${DOT}${key}` : key;\n\tconst effectiveFlattenDepth = flattenDepth ?? options.flattenDepth;\n\tif (options.keyFolding === \"safe\" && siblings) {\n\t\tconst foldResult = tryFoldKeyChain(key, value, siblings, options, rootLiteralKeys, pathPrefix, effectiveFlattenDepth);\n\t\tif (foldResult) {\n\t\t\tconst { foldedKey, remainder, leafValue, segmentCount } = foldResult;\n\t\t\tconst encodedFoldedKey = encodeKey(foldedKey);\n\t\t\tif (remainder === void 0) {\n\t\t\t\tif (isJsonPrimitive(leafValue)) {\n\t\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}: ${encodePrimitive(leafValue, options.delimiter)}`, options.indent);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (isJsonArray(leafValue)) {\n\t\t\t\t\tyield* encodeArrayLines(foldedKey, leafValue, depth, options);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (isJsonObject(leafValue) && isEmptyObject(leafValue)) {\n\t\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}:`, options.indent);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isJsonObject(remainder)) {\n\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}:`, options.indent);\n\t\t\t\tconst remainingDepth = effectiveFlattenDepth - segmentCount;\n\t\t\t\tconst foldedPath = pathPrefix ? `${pathPrefix}${DOT}${foldedKey}` : foldedKey;\n\t\t\t\tyield* encodeObjectLines(remainder, depth + 1, options, rootLiteralKeys, foldedPath, remainingDepth);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tconst encodedKey = encodeKey(key);\n\tif (isJsonPrimitive(value)) yield indentedLine(depth, `${encodedKey}: ${encodePrimitive(value, options.delimiter)}`, options.indent);\n\telse if (isJsonArray(value)) yield* encodeArrayLines(key, value, depth, options);\n\telse if (isJsonObject(value)) {\n\t\tyield indentedLine(depth, `${encodedKey}:`, options.indent);\n\t\tif (!isEmptyObject(value)) yield* encodeObjectLines(value, depth + 1, options, rootLiteralKeys, currentPath, effectiveFlattenDepth);\n\t}\n}\nfunction* encodeArrayLines(key, value, depth, options) {\n\tif (value.length === 0) {\n\t\tyield indentedLine(depth, formatHeader(0, {\n\t\t\tkey,\n\t\t\tdelimiter: options.delimiter\n\t\t}), options.indent);\n\t\treturn;\n\t}\n\tif (isArrayOfPrimitives(value)) {\n\t\tyield indentedLine(depth, encodeInlineArrayLine(value, options.delimiter, key), options.indent);\n\t\treturn;\n\t}\n\tif (isArrayOfArrays(value)) {\n\t\tif (value.every((arr) => isArrayOfPrimitives(arr))) {\n\t\t\tyield* encodeArrayOfArraysAsListItemsLines(key, value, depth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isArrayOfObjects(value)) {\n\t\tconst header = extractTabularHeader(value);\n\t\tif (header) yield* encodeArrayOfObjectsAsTabularLines(key, value, header, depth, options);\n\t\telse yield* encodeMixedArrayAsListItemsLines(key, value, depth, options);\n\t\treturn;\n\t}\n\tyield* encodeMixedArrayAsListItemsLines(key, value, depth, options);\n}\nfunction* encodeArrayOfArraysAsListItemsLines(prefix, values, depth, options) {\n\tyield indentedLine(depth, formatHeader(values.length, {\n\t\tkey: prefix,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tfor (const arr of values) if (isArrayOfPrimitives(arr)) {\n\t\tconst arrayLine = encodeInlineArrayLine(arr, options.delimiter);\n\t\tyield indentedListItem(depth + 1, arrayLine, options.indent);\n\t}\n}\nfunction encodeInlineArrayLine(values, delimiter, prefix) {\n\tconst header = formatHeader(values.length, {\n\t\tkey: prefix,\n\t\tdelimiter\n\t});\n\tconst joinedValue = encodeAndJoinPrimitives(values, delimiter);\n\tif (values.length === 0) return header;\n\treturn `${header} ${joinedValue}`;\n}\nfunction* encodeArrayOfObjectsAsTabularLines(prefix, rows, header, depth, options) {\n\tyield indentedLine(depth, formatHeader(rows.length, {\n\t\tkey: prefix,\n\t\tfields: header,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tyield* writeTabularRowsLines(rows, header, depth + 1, options);\n}\nfunction extractTabularHeader(rows) {\n\tif (rows.length === 0) return;\n\tconst firstRow = rows[0];\n\tconst firstKeys = Object.keys(firstRow);\n\tif (firstKeys.length === 0) return;\n\tif (isTabularArray(rows, firstKeys)) return firstKeys;\n}\nfunction isTabularArray(rows, header) {\n\tfor (const row of rows) {\n\t\tif (Object.keys(row).length !== header.length) return false;\n\t\tfor (const key of header) {\n\t\t\tif (!(key in row)) return false;\n\t\t\tif (!isJsonPrimitive(row[key])) return false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction* writeTabularRowsLines(rows, header, depth, options) {\n\tfor (const row of rows) yield indentedLine(depth, encodeAndJoinPrimitives(header.map((key) => row[key]), options.delimiter), options.indent);\n}\nfunction* encodeMixedArrayAsListItemsLines(prefix, items, depth, options) {\n\tyield indentedLine(depth, formatHeader(items.length, {\n\t\tkey: prefix,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tfor (const item of items) yield* encodeListItemValueLines(item, depth + 1, options);\n}\nfunction* encodeObjectAsListItemLines(obj, depth, options) {\n\tif (isEmptyObject(obj)) {\n\t\tyield indentedLine(depth, LIST_ITEM_MARKER, options.indent);\n\t\treturn;\n\t}\n\tconst entries = Object.entries(obj);\n\tconst [firstKey, firstValue] = entries[0];\n\tconst encodedKey = encodeKey(firstKey);\n\tif (isJsonPrimitive(firstValue)) yield indentedListItem(depth, `${encodedKey}: ${encodePrimitive(firstValue, options.delimiter)}`, options.indent);\n\telse if (isJsonArray(firstValue)) if (isArrayOfPrimitives(firstValue)) yield indentedListItem(depth, encodeInlineArrayLine(firstValue, options.delimiter, firstKey), options.indent);\n\telse if (isArrayOfObjects(firstValue)) {\n\t\tconst header = extractTabularHeader(firstValue);\n\t\tif (header) {\n\t\t\tyield indentedListItem(depth, formatHeader(firstValue.length, {\n\t\t\t\tkey: firstKey,\n\t\t\t\tfields: header,\n\t\t\t\tdelimiter: options.delimiter\n\t\t\t}), options.indent);\n\t\t\tyield* writeTabularRowsLines(firstValue, header, depth + 1, options);\n\t\t} else {\n\t\t\tyield indentedListItem(depth, `${encodedKey}[${firstValue.length}]:`, options.indent);\n\t\t\tfor (const item of firstValue) yield* encodeObjectAsListItemLines(item, depth + 1, options);\n\t\t}\n\t} else {\n\t\tyield indentedListItem(depth, `${encodedKey}[${firstValue.length}]:`, options.indent);\n\t\tfor (const item of firstValue) yield* encodeListItemValueLines(item, depth + 1, options);\n\t}\n\telse if (isJsonObject(firstValue)) {\n\t\tyield indentedListItem(depth, `${encodedKey}:`, options.indent);\n\t\tif (!isEmptyObject(firstValue)) yield* encodeObjectLines(firstValue, depth + 2, options);\n\t}\n\tfor (let i = 1; i < entries.length; i++) {\n\t\tconst [key, value] = entries[i];\n\t\tyield* encodeKeyValuePairLines(key, value, depth + 1, options);\n\t}\n}\nfunction* encodeListItemValueLines(value, depth, options) {\n\tif (isJsonPrimitive(value)) yield indentedListItem(depth, encodePrimitive(value, options.delimiter), options.indent);\n\telse if (isJsonArray(value)) if (isArrayOfPrimitives(value)) yield indentedListItem(depth, encodeInlineArrayLine(value, options.delimiter), options.indent);\n\telse {\n\t\tyield indentedListItem(depth, formatHeader(value.length, { delimiter: options.delimiter }), options.indent);\n\t\tfor (const item of value) yield* encodeListItemValueLines(item, depth + 1, options);\n\t}\n\telse if (isJsonObject(value)) yield* encodeObjectAsListItemLines(value, depth, options);\n}\nfunction indentedLine(depth, content, indentSize) {\n\treturn \" \".repeat(indentSize * depth) + content;\n}\nfunction indentedListItem(depth, content, indentSize) {\n\treturn indentedLine(depth, LIST_ITEM_PREFIX + content, indentSize);\n}\n\n//#endregion\n//#region src/index.ts\n/**\n* Encodes a JavaScript value into TOON format string.\n*\n* @param input - Any JavaScript value (objects, arrays, primitives)\n* @param options - Optional encoding configuration\n* @returns TOON formatted string\n*\n* @example\n* ```ts\n* encode({ name: 'Alice', age: 30 })\n* // name: Alice\n* // age: 30\n*\n* encode({ users: [{ id: 1 }, { id: 2 }] })\n* // users[]:\n* //   - id: 1\n* //   - id: 2\n*\n* encode(data, { indent: 4, keyFolding: 'safe' })\n* ```\n*/\nfunction encode(input, options) {\n\treturn Array.from(encodeLines(input, options)).join(\"\\n\");\n}\n/**\n* Decodes a TOON format string into a JavaScript value.\n*\n* @param input - TOON formatted string\n* @param options - Optional decoding configuration\n* @returns Parsed JavaScript value (object, array, or primitive)\n*\n* @example\n* ```ts\n* decode('name: Alice\\nage: 30')\n* // { name: 'Alice', age: 30 }\n*\n* decode('users[]:\\n  - id: 1\\n  - id: 2')\n* // { users: [{ id: 1 }, { id: 2 }] }\n*\n* decode(toonString, { strict: false, expandPaths: 'safe' })\n* ```\n*/\nfunction decode(input, options) {\n\treturn decodeFromLines(input.split(\"\\n\"), options);\n}\n/**\n* Encodes a JavaScript value into TOON format as a sequence of lines.\n*\n* This function yields TOON lines one at a time without building the full string,\n* making it suitable for streaming large outputs to files, HTTP responses, or process stdout.\n*\n* @param input - Any JavaScript value (objects, arrays, primitives)\n* @param options - Optional encoding configuration\n* @returns Iterable of TOON lines (without trailing newlines)\n*\n* @example\n* ```ts\n* // Stream to stdout\n* for (const line of encodeLines({ name: 'Alice', age: 30 })) {\n*   console.log(line)\n* }\n*\n* // Collect to array\n* const lines = Array.from(encodeLines(data))\n*\n* // Equivalent to encode()\n* const toonString = Array.from(encodeLines(data, options)).join('\\n')\n* ```\n*/\nfunction encodeLines(input, options) {\n\treturn encodeJsonValue(normalizeValue(input), resolveOptions(options), 0);\n}\n/**\n* Decodes TOON format from pre-split lines into a JavaScript value.\n*\n* This is a convenience wrapper around the streaming decoder that builds\n* the full value in memory. Useful when you already have lines as an array\n* or iterable and want the standard decode behavior with path expansion support.\n*\n* @param lines - Iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (supports expandPaths)\n* @returns Parsed JavaScript value (object, array, or primitive)\n*\n* @example\n* ```ts\n* const lines = ['name: Alice', 'age: 30']\n* decodeFromLines(lines)\n* // { name: 'Alice', age: 30 }\n* ```\n*/\nfunction decodeFromLines(lines, options) {\n\tconst resolvedOptions = resolveDecodeOptions(options);\n\tconst decodedValue = buildValueFromEvents(decodeStreamSync$1(lines, {\n\t\tindent: resolvedOptions.indent,\n\t\tstrict: resolvedOptions.strict\n\t}));\n\tif (resolvedOptions.expandPaths === \"safe\") return expandPathsSafe(decodedValue, resolvedOptions.strict);\n\treturn decodedValue;\n}\n/**\n* Synchronously decodes TOON lines into a stream of JSON events.\n*\n* This function yields structured events (startObject, endObject, startArray, endArray,\n* key, primitive) that represent the JSON data model without building the full value tree.\n* Useful for streaming processing, custom transformations, or memory-efficient parsing.\n*\n* @remarks\n* Path expansion (`expandPaths: 'safe'`) is not supported in streaming mode.\n*\n* @param lines - Iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (expandPaths not supported)\n* @returns Iterable of JSON stream events\n*\n* @example\n* ```ts\n* const lines = ['name: Alice', 'age: 30']\n* for (const event of decodeStreamSync(lines)) {\n*   console.log(event)\n*   // { type: 'startObject' }\n*   // { type: 'key', key: 'name' }\n*   // { type: 'primitive', value: 'Alice' }\n*   // ...\n* }\n* ```\n*/\nfunction decodeStreamSync(lines, options) {\n\treturn decodeStreamSync$1(lines, options);\n}\n/**\n* Asynchronously decodes TOON lines into a stream of JSON events.\n*\n* This function yields structured events (startObject, endObject, startArray, endArray,\n* key, primitive) that represent the JSON data model without building the full value tree.\n* Supports both sync and async iterables for maximum flexibility with file streams,\n* network responses, or other async sources.\n*\n* @remarks\n* Path expansion (`expandPaths: 'safe'`) is not supported in streaming mode.\n*\n* @param source - Async or sync iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (expandPaths not supported)\n* @returns Async iterable of JSON stream events\n*\n* @example\n* ```ts\n* const fileStream = createReadStream('data.toon', 'utf-8')\n* const lines = splitLines(fileStream) // Async iterable of lines\n*\n* for await (const event of decodeStream(lines)) {\n*   console.log(event)\n*   // { type: 'startObject' }\n*   // { type: 'key', key: 'name' }\n*   // { type: 'primitive', value: 'Alice' }\n*   // ...\n* }\n* ```\n*/\nfunction decodeStream(source, options) {\n\treturn decodeStream$1(source, options);\n}\nfunction resolveOptions(options) {\n\treturn {\n\t\tindent: options?.indent ?? 2,\n\t\tdelimiter: options?.delimiter ?? DEFAULT_DELIMITER,\n\t\tkeyFolding: options?.keyFolding ?? \"off\",\n\t\tflattenDepth: options?.flattenDepth ?? Number.POSITIVE_INFINITY\n\t};\n}\nfunction resolveDecodeOptions(options) {\n\treturn {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true,\n\t\texpandPaths: options?.expandPaths ?? \"off\"\n\t};\n}\n\n//#endregion\nexport { DEFAULT_DELIMITER, DELIMITERS, decode, decodeFromLines, decodeStream, decodeStreamSync, encode, encodeLines };","import { canParseURL } from \"@rs-core/utils/Runtime\";\nexport type DataKind = \"math\" | \"url\" | \"output_text\" | \"input_text\" | \"image\" | \"image_url\" | \"text\" | \"input_image\" | \"input_url\" | \"json\" | \"markdown\" | \"code\" | \"entity\" | \"structured\" | \"unknown\" | \"svg\" | \"xml\";\nexport type DataInput = {\n    dataSource: string | Blob | File | any,\n    dataKind?: DataKind | null,\n    context?: DataContext | null\n}\n\nexport type DataContext = {\n    existingData?: any;\n    entityType?: string;\n    operation?: \"create\" | \"modify\" | \"merge\" | \"analyze\" | \"extract\";\n    filters?: DataFilter[];\n    searchTerms?: string[];\n    priority?: \"low\" | \"medium\" | \"high\";\n}\n\nexport type DataFilter = {\n    field: string;\n    operator: \"eq\" | \"neq\" | \"contains\" | \"startsWith\" | \"endsWith\" | \"gt\" | \"lt\" | \"gte\" | \"lte\" | \"in\" | \"nin\" | \"exists\" | \"regex\";\n    value: any;\n    caseSensitive?: boolean;\n}\n\nexport type ModificationInstruction = {\n    action: \"update\" | \"delete\" | \"merge\" | \"append\" | \"replace\" | \"transform\";\n    target: string;\n    value?: any;\n    conditions?: DataFilter[];\n    transformFn?: string;\n}\n\n//\nexport const PROMPT_COMPUTE_EFFORT = (data: DataInput): \"low\" | \"medium\" | \"high\" => {\n    const context = data?.context;\n\n    // High effort for complex operations\n    if (context?.operation === \"merge\" || context?.operation === \"modify\") return \"high\";\n    if (context?.filters && context.filters.length > 3) return \"high\";\n    if (data?.dataKind === \"math\") return \"high\";\n    if (data?.dataKind === \"structured\" || data?.dataKind === \"entity\") return \"high\";\n\n    // Blob/File handling\n    if (data?.dataSource instanceof Blob || data?.dataSource instanceof File) {\n        const size = data.dataSource.size;\n        if (size > 1024 * 1024) return \"high\"; // >1MB (keep existing logic for effort calculation)\n        if (data?.dataKind === \"image\") return \"medium\";\n        return \"medium\";\n    }\n\n    // String handling with context\n    if (typeof data?.dataSource === \"string\") {\n        const len = data.dataSource.length;\n        if (len > 10000) return \"high\";\n        if (data?.dataSource?.includes?.(\"math\")) return \"high\";\n        if (data?.dataKind === \"json\" || data?.dataKind === \"code\") return \"medium\";\n        if (context?.searchTerms?.length) return \"medium\";\n        return \"medium\";\n    }\n\n    // Object handling\n    if (typeof data?.dataSource === \"object\" && data?.dataSource !== null) {\n        const keys = Object.keys(data.dataSource);\n        if (keys.length > 20) return \"high\";\n        if (context?.existingData) return \"high\";\n        return \"medium\";\n    }\n\n    return \"medium\";\n}\n\n//\nexport const COMPUTE_TEMPERATURE = (data: DataInput): number => {\n    const context = data?.context;\n\n    // Deterministic operations need low temperature\n    if (context?.operation === \"extract\" || context?.operation === \"analyze\") return 0.1;\n    if (context?.operation === \"modify\" && context?.existingData) return 0.2;\n    if (data?.dataKind === \"math\") return 0.1;\n    if (data?.dataKind === \"json\" || data?.dataKind === \"structured\") return 0.2;\n    if (data?.dataKind === \"code\") return 0.3;\n\n    // Creative operations can use higher temperature\n    if (context?.operation === \"create\") return 0.6;\n\n    // Default by kind\n    if (data?.dataKind === \"url\") return 0.3;\n    if (data?.dataKind === \"input_image\") return 0.4;\n    if (data?.dataKind === \"input_text\") return 0.5;\n    if (data?.dataKind === \"markdown\") return 0.5;\n\n    return 0.4;\n}\n\n//\nexport const typesForKind: Record<DataKind, \"input_text\" | \"image_url\" | \"input_image\" | \"input_url\" | \"text_search_result\" | \"json_schema\" | \"json_schema_search_result\"> = {\n    \"math\": \"input_text\",\n    \"url\": \"input_image\",\n    \"text\": \"input_text\",\n    \"input_text\": \"input_text\",\n    \"output_text\": \"input_text\",\n    \"image_url\": \"input_image\",\n    \"image\": \"input_image\",\n    \"input_image\": \"input_image\",\n    \"input_url\": \"input_image\",\n    \"json\": \"input_text\",\n    \"markdown\": \"input_text\",\n    \"code\": \"input_text\",\n    \"entity\": \"input_text\",\n    \"structured\": \"input_text\",\n    \"unknown\": \"input_text\",\n    \"svg\": \"input_text\",\n    \"xml\": \"input_text\"\n}\n\n//\nexport const getDataKindByMIMEType = (mime: string): DataKind => {\n    if (!mime) return \"input_text\";\n    const lower = mime.toLowerCase();\n    if (lower.includes(\"image\")) return \"input_image\";\n    if (lower.includes(\"json\")) return \"json\";\n    if (lower.includes(\"javascript\") || lower.includes(\"typescript\")) return \"code\";\n    if (lower.includes(\"markdown\") || lower.includes(\"md\")) return \"markdown\";\n    if (lower.includes(\"url\")) return \"input_url\";\n    if (lower.includes(\"text/html\")) return \"markdown\";\n    if (lower.includes(\"text/plain\")) return \"input_text\";\n    return \"input_text\";\n}\n\n//\nexport const detectDataKindFromContent = (content: string): DataKind => {\n    if (!content || typeof content !== \"string\") return \"input_text\";\n\n    const trimmed = content.trim();\n\n    // Check for JSON\n    if ((trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n        (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"))) {\n        try { JSON.parse(trimmed); return \"json\"; } catch { /* not valid JSON */ }\n    }\n\n    // Check for URL\n    if (canParseURL(trimmed)) return \"url\";\n\n    // Check for SVG - treat as XML/text, not image\n    if (trimmed.includes('<svg') && trimmed.includes('</svg>')) return \"xml\";\n\n    // Check for base64 image - only if the entire content is a data URL\n    if (trimmed.startsWith(\"data:image/\") && trimmed.includes(\";base64,\") && !trimmed.includes(\"\\n\") && trimmed.length < 100000) {\n        // Additional validation: try to parse as data URL\n        try {\n            const url = new URL(trimmed);\n            if (url.protocol === \"data:\" && url.pathname.startsWith(\"image/\")) {\n                return \"input_image\";\n            }\n        } catch {\n            // Not a valid data URL\n        }\n    }\n\n    // Check for math expressions\n    if (/\\$\\$[\\s\\S]+\\$\\$|\\$[^$]+\\$|\\\\begin\\{equation\\}/.test(trimmed)) return \"math\";\n\n    // Check for code\n    if (/```[\\s\\S]+```|^(function|const|let|var|class|import|export)\\s/m.test(trimmed)) return \"code\";\n\n    // Check for markdown\n    if (/^#{1,6}\\s|^\\*\\*|^-\\s|\\[.+\\]\\(.+\\)|^>\\s/m.test(trimmed)) return \"markdown\";\n\n    return \"input_text\";\n}\n\n//\nexport const actionWithDataType = (data: DataInput): string => {\n    const context = data?.context;\n    const kindType = typesForKind?.[data?.dataKind || \"input_text\"];\n\n    // Build context-aware prompt based on operation\n    const contextPrompt = buildContextPrompt(context);\n\n    switch (kindType) {\n        case \"input_image\":\n            return `${contextPrompt}\n\nRecognize data from image, also preferred to orient by fonts in image.\n\nAfter recognition, do not include or remember image itself.\n\n---\n\nIn (\\`recognized_data\\` key), can be written phone numbers, emails, URLs, dates, times, codes, etc. Additional formatting rules:\n\nIn recognized from image data (what you seen in image), do:\n- If textual content, format as Markdown string (multiline).\n- If phone number, format as as correct phone number (in normalized format).\n  - Also, if phone numbers (for example starts with +7, format as 8), replace to correct regional code.\n  - Remove brackets, parentheses, spaces or other symbols from phone number.\n  - Trim spaces from phone number.\n- If email, format as as correct email (in normalized format), and trim spaces from email.\n- If URL, format as as correct URL (in normalized format), and unicode codes to human readable, and trim spaces from URL.\n- If date, format as as correct date (in normalized format).\n- If time, format as as correct time (in normalized format).\n- If math (expression, equation, formula), format as $KaTeX$\n- If table (or looks alike table), format as | table |\n- If image, format as [$image$]($image$)\n- If code, format as \\`\\`\\`$code$\\`\\`\\` (multiline) or \\`$code$\\` (single-line)\n- If JSON, format as correct JSON string, and trim spaces from JSON string.\n- If other, format as $text$.\n- If seen alike list, format as list (in markdown format).\n\n---\n\nSome additional actions:\n- Collect some special data tags and keywords (if has any).\n- Also, can you provide in markdown pre-formatted free-form analyzed or recognized verbose data (in \\`verbose_data\\` key).\n\n---\n\nCRITICAL OUTPUT FORMAT: Return ONLY valid JSON. No markdown code blocks, no explanations, no prose.\nYour response must start with { or [ and end with } or ].\n\nExpected output structure:\n{\n    \"keywords_and_tags\": [\"string array\"],\n    \"recognized_data\": [\"any array\"],\n    \"verbose_data\": \"markdown string\",\n    \"using_ready\": true,\n    \"confidence\": 0.95,\n    \"suggested_type\": \"document_type\"\n}\n`;\n\n        case \"input_text\":\n            return `${contextPrompt}\n\nAnalyze text and extract specific or special data from it, also normalize data by those rules...\n\n---\n\nIn (\\`recognized_data\\` key), can be written phone numbers, emails, URLs, dates, times, codes, etc. Additional formatting rules:\n\nNormalize phone numbers, emails, URLs, dates, times, codes, etc for best efforts and by those rules.\n- If phone number, format as as correct phone number (in normalized format).\n  - If phone numbers (for example starts with +7, format as 8), replace to correct regional code.\n  - Trim spaces from phone numbers, emails, URLs, dates, times, codes, etc.\n  - Remove brackets, parentheses, spaces or other symbols from phone numbers.\n- If email, format as as correct email (in normalized format), and trim spaces from email.\n- If URL, format as as correct URL (in normalized format), and unicode codes to human readable, and trim spaces from URL.\n- If date, format as as correct date (in normalized format).\n- If time, format as as correct time (in normalized format).\n- If math, format as $KaTeX$\n- If table, format as | table |\n- If image, format as [$image$]($image$)\n- If code, format as \\`\\`\\`$code$\\`\\`\\` (multiline) or \\`$code$\\` (single-line)\n- If JSON, format as correct JSON string, and trim spaces from JSON string.\n- If other, format as $text$.\n- If seen alike list, format as list (in markdown format).\n\n---\n\nSome additional actions:\n- Collect some special data tags and keywords (if has any).\n- Also, can you provide in markdown pre-formatted free-form analyzed or recognized verbose data (in \\`verbose_data\\` key).\n- Detect entity type if applicable (task, event, person, place, service, item, etc.)\n\n---\n\nCRITICAL OUTPUT FORMAT: Return ONLY valid JSON. No markdown code blocks, no explanations, no prose.\nYour response must start with { or [ and end with } or ].\n\nExpected output structure:\n{\n    \"keywords_and_tags\": [\"string array\"],\n    \"recognized_data\": [\"any array\"],\n    \"verbose_data\": \"markdown string\",\n    \"using_ready\": true,\n    \"confidence\": 0.95,\n    \"suggested_type\": \"entity_type\",\n    \"suggested_modifications\": []\n}\n`;\n    }\n    return contextPrompt || \"\";\n}\n\n//\nconst buildContextPrompt = (context?: DataContext | null): string => {\n    if (!context) return \"\";\n\n    const parts: string[] = [];\n\n    if (context.operation) {\n        const opDescriptions: Record<string, string> = {\n            create: \"Create new data entries based on provided information.\",\n            modify: \"Modify existing data with provided changes while preserving structure.\",\n            merge: \"Intelligently merge new data with existing data, avoiding duplicates.\",\n            analyze: \"Analyze and extract structured information from the data.\",\n            extract: \"Extract specific data points matching the criteria.\"\n        };\n        parts.push(`Operation: ${opDescriptions[context.operation] || context.operation}`);\n    }\n\n    if (context.entityType) {\n        parts.push(`Target entity type: ${context.entityType}`);\n    }\n\n    if (context.existingData) {\n        parts.push(`Existing data context provided - consider for merge/update operations.`);\n    }\n\n    if (context.filters?.length) {\n        const filterDesc = context.filters.map(f =>\n            `${f.field} ${f.operator} ${JSON.stringify(f.value)}`\n        ).join(\", \");\n        parts.push(`Apply filters: ${filterDesc}`);\n    }\n\n    if (context.searchTerms?.length) {\n        parts.push(`Search terms: ${context.searchTerms.join(\", \")}`);\n    }\n\n    if (context.priority) {\n        parts.push(`Priority level: ${context.priority}`);\n    }\n\n    return parts.length ? `Context:\\n${parts.join(\"\\n\")}\\n\\n---\\n` : \"\";\n}\n\n//\nexport const buildModificationPrompt = (instructions: ModificationInstruction[]): string => {\n    if (!instructions?.length) return \"\";\n\n    const parts = instructions.map((inst, i) => {\n        const condStr = inst.conditions?.length\n            ? ` when ${inst.conditions.map(c => `${c.field} ${c.operator} ${JSON.stringify(c.value)}`).join(\" AND \")}`\n            : \"\";\n\n        switch (inst.action) {\n            case \"update\":\n                return `${i + 1}. UPDATE field \"${inst.target}\" to ${JSON.stringify(inst.value)}${condStr}`;\n            case \"delete\":\n                return `${i + 1}. DELETE field \"${inst.target}\"${condStr}`;\n            case \"merge\":\n                return `${i + 1}. MERGE into \"${inst.target}\" with ${JSON.stringify(inst.value)}${condStr}`;\n            case \"append\":\n                return `${i + 1}. APPEND ${JSON.stringify(inst.value)} to \"${inst.target}\"${condStr}`;\n            case \"replace\":\n                return `${i + 1}. REPLACE \"${inst.target}\" with ${JSON.stringify(inst.value)}${condStr}`;\n            case \"transform\":\n                return `${i + 1}. TRANSFORM \"${inst.target}\" using: ${inst.transformFn}${condStr}`;\n            default:\n                return \"\";\n        }\n    }).filter(Boolean);\n\n    return parts.length\n        ? `\\nModification instructions:\\n${parts.join(\"\\n\")}\\n`\n        : \"\";\n}\n\n//\nexport const DATA_MODIFICATION_PROMPT = `\nYou are a data modification assistant. Your task is to modify existing data based on the provided instructions.\n\nRules for modification:\n1. Preserve the original data structure unless explicitly asked to change it.\n2. Apply modifications in order, one by one.\n3. Validate data types match the schema.\n4. Return the complete modified entity, not just the changes.\n5. If a modification cannot be applied, include it in the \"errors\" array with explanation.\n\nCRITICAL: Output ONLY valid JSON. No markdown code blocks, no explanations, no prose.\nYour response must start with { and end with }.\n\nExpected output structure:\n{\n    \"modified_entity\": { /* complete modified entity */ },\n    \"changes_made\": [ /* list of applied changes */ ],\n    \"errors\": [ /* list of failed modifications with reasons */ ],\n    \"warnings\": [ /* non-critical issues */ ]\n}\n`;\n\n//\nexport const DATA_SELECTION_PROMPT = `\nYou are a data selection and filtering assistant. Your task is to find and select data matching the criteria.\n\nSelection rules:\n1. Apply all filters in order (AND logic by default).\n2. Rank results by relevance to search terms.\n3. Include confidence scores for fuzzy matches.\n4. Group similar results to avoid duplicates.\n\nCRITICAL: Output ONLY valid JSON. No markdown code blocks, no explanations, no prose.\nYour response must start with { and end with }.\n\nExpected output structure:\n{\n    \"selected_items\": [ /* items matching criteria */ ],\n    \"total_matches\": number,\n    \"filter_stats\": { /* breakdown by filter */ },\n    \"suggestions\": [ /* related items that might be relevant */ ]\n}\n`;\n\n//\nexport const ENTITY_MERGE_PROMPT = `\nYou are an entity merging assistant. Your task is to intelligently merge multiple entities or data sources.\n\nMerge rules:\n1. Prefer newer/more complete data when conflicts arise.\n2. Combine arrays without duplicates.\n3. Merge nested objects recursively.\n4. Preserve IDs and relationships.\n5. Track the source of each merged field.\n\nCRITICAL: Output ONLY valid JSON. No markdown code blocks, no explanations, no prose.\nYour response must start with { and end with }.\n\nExpected output structure:\n{\n    \"merged_entity\": { /* result of merge */ },\n    \"conflicts_resolved\": [ /* list of conflicts and how they were resolved */ ],\n    \"sources_used\": [ /* which source contributed what */ ],\n    \"merge_confidence\": number\n}\n`;\n","/**\n * Robust AI Response Parser\n *\n * Handles extraction of JSON from AI responses that may include:\n * - Pure JSON strings\n * - JSON wrapped in markdown code blocks (```json ... ```)\n * - Multiple JSON code blocks (returns first valid one)\n * - JSON with trailing/leading whitespace\n * - JSON with BOM characters\n * - Partial or malformed JSON (best-effort recovery)\n *\n * @see https://platform.openai.com/docs/api-reference/responses\n */\n\nimport { JSOX } from \"jsox\";\n\nexport type ParseResult<T = unknown> = {\n    ok: boolean;\n    data?: T;\n    raw?: string;\n    error?: string;\n    source?: \"direct\" | \"markdown_block\" | \"recovered\" | \"fallback\";\n};\n\n/**\n * Regex patterns for extracting JSON from various formats.\n * Ordered by specificity - most specific patterns first.\n */\nconst JSON_EXTRACTION_PATTERNS = [\n    // ```json ... ``` or ```JSON ... ``` (case insensitive)\n    /```json\\s*\\n?([\\s\\S]*?)\\n?```/i,\n    // ```toon ... ``` (custom format used in project)\n    /```toon\\s*\\n?([\\s\\S]*?)\\n?```/i,\n    // Generic code block ``` ... ```\n    /```\\s*\\n?([\\s\\S]*?)\\n?```/,\n    // JSON in curly braces (object)\n    /(\\{[\\s\\S]*\\})/,\n    // JSON array\n    /(\\[[\\s\\S]*\\])/,\n] as const;\n\n/**\n * Clean raw text from common issues before parsing.\n */\nconst cleanRawText = (text: string): string => {\n    if (!text || typeof text !== \"string\") return \"\";\n\n    return text\n        // Remove BOM\n        .replace(/^\\uFEFF/, \"\")\n        // Remove zero-width characters\n        .replace(/[\\u200B-\\u200D\\uFEFF]/g, \"\")\n        // Normalize line endings\n        .replace(/\\r\\n/g, \"\\n\")\n        .replace(/\\r/g, \"\\n\")\n        // Trim whitespace\n        .trim();\n};\n\n/**\n * Attempt to fix common JSON issues.\n */\nconst attemptJSONRecovery = (text: string): string => {\n    let cleaned = text;\n\n    // Remove trailing commas before ] or }\n    cleaned = cleaned.replace(/,(\\s*[}\\]])/g, \"$1\");\n\n    // Fix unescaped newlines in strings (very basic)\n    // This is a simple heuristic - won't catch all cases\n    cleaned = cleaned.replace(/:\\s*\"([^\"]*)\\n([^\"]*)\"/g, (match, p1, p2) => {\n        return `: \"${p1}\\\\n${p2}\"`;\n    });\n\n    // Remove control characters except newlines and tabs\n    cleaned = cleaned.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g, \"\");\n\n    return cleaned;\n};\n\n/**\n * Try to parse JSON using multiple strategies.\n */\nexport const tryParseJSON = <T = unknown>(text: string): { ok: boolean; data?: T; error?: string } => {\n    if (!text) return { ok: false, error: \"Empty input\" };\n\n    // Strategy 1: Direct JSOX parse (more lenient than JSON.parse)\n    try {\n        const data = JSOX.parse(text) as T;\n        return { ok: true, data };\n    } catch { /* continue */ }\n\n    // Strategy 2: Standard JSON.parse\n    try {\n        const data = JSON.parse(text) as T;\n        return { ok: true, data };\n    } catch { /* continue */ }\n\n    // Strategy 3: Try with recovery\n    try {\n        const recovered = attemptJSONRecovery(text);\n        const data = JSOX.parse(recovered) as T;\n        return { ok: true, data };\n    } catch { /* continue */ }\n\n    // Strategy 4: Try removing any leading/trailing non-JSON characters\n    try {\n        const match = text.match(/^[^{[]*([{\\[][\\s\\S]*[}\\]])[^}\\]]*$/);\n        if (match?.[1]) {\n            const data = JSOX.parse(match[1]) as T;\n            return { ok: true, data };\n        }\n    } catch { /* continue */ }\n\n    return { ok: false, error: \"Failed to parse JSON with all strategies\" };\n};\n\n/**\n * Extract JSON from AI response text.\n * Handles markdown code blocks, raw JSON, and various edge cases.\n *\n * @param response - Raw AI response string\n * @returns ParseResult with extracted data or error\n */\nexport const extractJSONFromAIResponse = <T = unknown>(response: string | null | undefined): ParseResult<T> => {\n    if (response == null) {\n        return { ok: false, error: \"Response is null or undefined\" };\n    }\n\n    if (typeof response !== \"string\") {\n        // If already an object, return as-is\n        if (typeof response === \"object\") {\n            return { ok: true, data: response as T, source: \"direct\" };\n        }\n        return { ok: false, error: `Expected string, got ${typeof response}` };\n    }\n\n    const cleaned = cleanRawText(response);\n    if (!cleaned) {\n        return { ok: false, error: \"Response is empty after cleaning\", raw: response };\n    }\n\n    // First, try direct parsing (fastest path)\n    const directResult = tryParseJSON<T>(cleaned);\n    if (directResult.ok) {\n        return { ok: true, data: directResult.data, raw: response, source: \"direct\" };\n    }\n\n    // Try extracting from markdown code blocks\n    for (const pattern of JSON_EXTRACTION_PATTERNS) {\n        const match = cleaned.match(pattern);\n        if (match?.[1]) {\n            const extracted = cleanRawText(match[1]);\n            const result = tryParseJSON<T>(extracted);\n            if (result.ok) {\n                return {\n                    ok: true,\n                    data: result.data,\n                    raw: response,\n                    source: \"markdown_block\"\n                };\n            }\n        }\n    }\n\n    // Try to find any JSON-like structure and parse it\n    const jsonLikeMatch = cleaned.match(/(\\{[\\s\\S]+\\}|\\[[\\s\\S]+\\])/);\n    if (jsonLikeMatch?.[1]) {\n        const recovered = attemptJSONRecovery(jsonLikeMatch[1]);\n        const result = tryParseJSON<T>(recovered);\n        if (result.ok) {\n            return {\n                ok: true,\n                data: result.data,\n                raw: response,\n                source: \"recovered\"\n            };\n        }\n    }\n\n    // Last resort: return as text in a structured format\n    return {\n        ok: false,\n        error: \"Could not extract valid JSON from response\",\n        raw: response\n    };\n};\n\n/**\n * Parse AI response with guaranteed JSON output.\n * Falls back to a wrapper object if parsing fails.\n *\n * @param response - Raw AI response\n * @param fallbackKey - Key to use for wrapping raw text (default: \"data\")\n */\nexport const parseAIResponseSafe = <T = unknown>(\n    response: string | null | undefined,\n    fallbackKey: string = \"data\"\n): { ok: boolean; data: T | { [key: string]: string }; raw?: any; source: ParseResult[\"source\"]; wasRecovered: boolean; error?: string } => {\n    const result = extractJSONFromAIResponse<T>(response) as { ok: boolean; data?: T; error?: string; source: ParseResult[\"source\"]; raw?: any };\n\n    if (result.ok && result.data !== undefined) {\n        return {\n            raw: result.raw || response,\n            ok: true,\n            data: result.data,\n            source: result.source,\n            wasRecovered: result.source === \"recovered\",\n            error: result.error || undefined\n        };\n    }\n\n    // Return fallback wrapper\n    return {\n        raw: result.raw || response,\n        ok: false,\n        data: { [fallbackKey]: result.raw || String(response) } as { [key: string]: string },\n        source: \"fallback\",\n        wasRecovered: false,\n        error: result.error || undefined\n    };\n};\n\n/**\n * Extract all JSON blocks from a response (for responses with multiple JSON objects).\n */\nexport const extractAllJSONBlocks = <T = unknown>(response: string): ParseResult<T>[] => {\n    if (!response || typeof response !== \"string\") return [];\n\n    const results: ParseResult<T>[] = [];\n    const cleaned = cleanRawText(response);\n\n    // Find all markdown code blocks\n    const blockPattern = /```(?:json|toon)?\\s*\\n?([\\s\\S]*?)\\n?```/gi;\n    let match: RegExpExecArray | null;\n\n    while ((match = blockPattern.exec(cleaned)) !== null) {\n        if (match[1]) {\n            const extracted = cleanRawText(match[1]);\n            const result = tryParseJSON<T>(extracted);\n            if (result.ok) {\n                results.push({\n                    ok: true,\n                    data: result.data,\n                    raw: match[0],\n                    source: \"markdown_block\"\n                });\n            }\n        }\n    }\n\n    // If no markdown blocks found, try direct parse\n    if (results.length === 0) {\n        const directResult = extractJSONFromAIResponse<T>(response);\n        if (directResult.ok) {\n            results.push(directResult);\n        }\n    }\n\n    return results;\n};\n\n/**\n * Strict JSON instructions to include in AI prompts.\n * Following OpenAI Responses API best practices.\n *\n * @see https://platform.openai.com/docs/api-reference/responses\n */\nexport const STRICT_JSON_INSTRUCTIONS = `\nCRITICAL OUTPUT FORMAT REQUIREMENTS:\n\n1. Your response MUST be ONLY valid JSON - no markdown, no explanations, no prose.\n2. Do NOT wrap the JSON in code blocks (\\`\\`\\`json or \\`\\`\\`).\n3. Do NOT include any text before or after the JSON object.\n4. The response must start with { or [ and end with } or ].\n5. All strings must be properly escaped (newlines as \\\\n, quotes as \\\\\").\n6. Use null for missing/unknown values, not undefined or empty strings.\n7. Numbers should be unquoted. Booleans should be true/false (lowercase).\n8. Arrays should not have trailing commas.\n9. The JSON must be parseable by JSON.parse() without modification.\n\nIf you cannot provide the requested data, return: {\"error\": \"description of the issue\", \"ok\": false}\n`;\n\n/**\n * Shorter version of JSON instructions for context-limited prompts.\n */\nexport const COMPACT_JSON_INSTRUCTIONS = `OUTPUT ONLY: Valid JSON. No markdown, no code blocks, no explanations. Start with { or [, end with } or ]. All strings escaped. Must pass JSON.parse().`;\n\n/**\n * Build a complete prompt that enforces JSON output.\n */\nexport const buildJSONEnforcedPrompt = (\n    basePrompt: string,\n    outputSchema?: string\n): string => {\n    const schemaHint = outputSchema\n        ? `\\n\\nExpected output schema:\\n${outputSchema}`\n        : \"\";\n\n    return `${basePrompt}${schemaHint}\\n\\n${STRICT_JSON_INSTRUCTIONS}`;\n};\n\n","import { encode } from \"@toon-format/toon\";\nimport {\n    actionWithDataType,\n    getDataKindByMIMEType,\n    typesForKind,\n    detectDataKindFromContent,\n    buildModificationPrompt,\n    DATA_MODIFICATION_PROMPT,\n    DATA_SELECTION_PROMPT,\n    ENTITY_MERGE_PROMPT,\n    type DataInput,\n    type DataKind,\n    type DataContext,\n    type DataFilter,\n    type ModificationInstruction\n} from \"./GPT-Config\";\nimport { JSOX } from \"jsox\";\nimport {\n    extractJSONFromAIResponse,\n    STRICT_JSON_INSTRUCTIONS\n} from \"../../../core/document/AIResponseParser\";\nimport { canParseURL } from \"@rs-core/utils/Runtime\";\n\nconst hasFile = () => typeof (globalThis as any).File !== \"undefined\";\nconst hasBlob = () => typeof (globalThis as any).Blob !== \"undefined\";\n\n// Standardized file size limits across the service layer\nexport const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB for file processing\nexport const MAX_BASE64_SIZE = 10 * 1024 * 1024; // 10MB for base64 encoding\n\n// Default request timeout configurations based on effort level (in milliseconds)\nexport const DEFAULT_REQUEST_TIMEOUTS = {\n    low: 60 * 1000,      // 1 minute\n    medium: 5 * 60 * 1000, // 5 minutes\n    high: 15 * 60 * 1000   // 15 minutes\n} as const;\n\nexport const DEFAULT_MAX_RETRIES = 2;\nexport const RETRY_DELAY = 2000; // 2 seconds\n\n/**\n * Get timeout configuration from settings or use defaults\n */\nfunction getTimeoutConfig(effort: \"low\" | \"medium\" | \"high\"): { timeout: number; maxRetries: number } {\n    try {\n        // Try to get settings from runtime or load them\n        const settings = ((globalThis as any).runtimeSettings as any)?.ai ||\n                        require(\"../../config/RuntimeSettings\").getRuntimeSettings?.()?.ai ||\n                        require(\"../../config/Settings\").loadSettings?.()?.ai;\n\n        const timeoutSettings = settings?.requestTimeout;\n        const maxRetries = settings?.maxRetries ?? DEFAULT_MAX_RETRIES;\n\n        const timeout = timeoutSettings?.[effort] ?? DEFAULT_REQUEST_TIMEOUTS[effort]; // Already in ms\n\n        return { timeout, maxRetries };\n    } catch {\n        // Fallback to defaults if settings can't be loaded\n        return {\n            timeout: DEFAULT_REQUEST_TIMEOUTS[effort],\n            maxRetries: DEFAULT_MAX_RETRIES\n        };\n    }\n}\n\n// Optimized base64 encoding with memory safety\nexport const toBase64 = (bytes: Uint8Array): string => {\n    // Node.js environment\n    if (typeof (globalThis as any).Buffer !== \"undefined\") {\n        return (globalThis as any).Buffer.from(bytes).toString(\"base64\");\n    }\n\n    // Browser environment - use chunked processing for large files\n    const CHUNK_SIZE = 1024 * 1024; // 1MB chunks to avoid memory issues\n    if (bytes.length > CHUNK_SIZE) {\n        let result = \"\";\n        for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n            const chunk = bytes.slice(i, i + CHUNK_SIZE);\n            let binary = \"\";\n            for (let j = 0; j < chunk.length; j++) {\n                binary += String.fromCharCode(chunk[j]);\n            }\n            result += (typeof btoa === \"function\" ? btoa(binary) : \"\");\n        }\n        return result;\n    }\n\n    // Small files - direct processing\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);\n    // @ts-ignore\n    return typeof btoa === \"function\" ? btoa(binary) : \"\";\n};\n\n//\nexport type RequestOptions = {\n    effort?: \"low\" | \"medium\" | \"high\";\n    verbosity?: \"low\" | \"medium\" | \"high\";\n    temperature?: number;\n    maxTokens?: number;\n    stream?: boolean;\n    responseFormat?: \"json\" | \"text\" | \"markdown\";\n}\n\nexport type AIResponse<T = unknown> = {\n    ok: boolean;\n    data?: T;\n    error?: string;\n    usage?: {\n        promptTokens: number;\n        completionTokens: number;\n        totalTokens: number;\n    };\n    responseId?: string | null;\n}\n\n//\nexport const getUsableData = async (data: DataInput) => {\n    const FileCtor = hasFile() ? (globalThis as any).File : undefined;\n    const BlobCtor = hasBlob() ? (globalThis as any).Blob : undefined;\n    const isFileOrBlob =\n        (BlobCtor && data?.dataSource instanceof BlobCtor) ||\n        (FileCtor && data?.dataSource instanceof FileCtor);\n\n    if (isFileOrBlob) {\n        const fileSize = data?.dataSource?.size || 0;\n        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB limit\n\n        // Check file size limit\n        if (fileSize > MAX_FILE_SIZE) {\n            console.warn(`[GPT-Responses] File too large: ${fileSize} bytes > ${MAX_FILE_SIZE} bytes`);\n            return {\n                \"type\": \"input_text\",\n                \"text\": `[File too large: ${(fileSize / 1024 / 1024).toFixed(1)}MB. Maximum allowed: ${(MAX_FILE_SIZE / 1024 / 1024).toFixed(1)}MB]`\n            };\n        }\n\n        if (typesForKind?.[data?.dataKind || \"input_text\"] === \"input_image\" || (data?.dataSource?.type?.startsWith?.(\"image/\"))) {\n            try {\n                const BASE64URL = `data:${data?.dataSource?.type};base64,`;\n                const arrayBuffer = await data?.dataSource?.arrayBuffer();\n                if (!arrayBuffer) {\n                    throw new Error(\"Failed to read file as ArrayBuffer\");\n                }\n                const bytes = new Uint8Array(arrayBuffer);\n                const URL = BASE64URL + toBase64(bytes);\n                return {\n                    \"type\": \"input_image\",\n                    \"detail\": \"auto\",\n                    \"image_url\": URL\n                };\n            } catch (error) {\n                console.error(\"[GPT-Responses] Failed to process image file:\", error);\n                return {\n                    \"type\": \"input_text\",\n                    \"text\": `[Failed to process image file: ${error}]`\n                };\n            }\n        }\n\n        // Handle other file types as text\n        try {\n            const text = await data?.dataSource?.text?.();\n            if (text) {\n                return {\n                    \"type\": \"input_text\",\n                    \"text\": text\n                };\n            }\n        } catch (error) {\n            console.error(\"[GPT-Responses] Failed to read text file:\", error);\n            return {\n                \"type\": \"input_text\",\n                \"text\": `[Failed to read text file: ${error}]`\n            };\n        }\n    } else if (typeof data?.dataSource == \"string\") {\n        // Auto-detect data kind if not specified\n        const effectiveKind = data?.dataKind || detectDataKindFromContent(data.dataSource);\n\n        // Only treat as image if explicitly detected as input_image kind\n        if (typesForKind?.[effectiveKind] == \"input_image\") {\n            // Validate that it's actually a proper data URL or regular URL\n            const content = data?.dataSource?.trim?.() || \"\";\n            if (content.startsWith(\"data:image/\") && content.includes(\";base64,\")) {\n                // Validate data URL format\n                try {\n                    const url = new URL(content);\n                    if (url.protocol === \"data:\" && url.pathname.startsWith(\"image/\")) {\n                        return {\n                            \"type\": \"input_image\",\n                            \"image_url\": content,\n                            \"detail\": \"auto\"\n                        };\n                    }\n                } catch {\n                    // Invalid data URL, treat as text\n                }\n            } else if (canParseURL(content)) {\n                // Valid regular URL\n                return {\n                    \"type\": \"input_image\",\n                    \"image_url\": content,\n                    \"detail\": \"auto\"\n                };\n            }\n        }\n\n        // anyways returns Promise<string>\n        return {\n            \"type\": \"input_text\",\n            \"text\": data?.dataSource\n        }\n    }\n\n    // is not Blob or File, so it's (may be) string (if not string, try to parse it as JSON)\n    let result = data?.dataSource;\n    try {\n        result = (typeof data?.dataSource != \"object\") ? data?.dataSource : encode(data?.dataSource);\n    } catch (e) {\n        console.warn(e);\n    }\n\n    //\n    return {\n        \"type\": typesForKind?.[data?.dataKind || \"input_text\"] || \"text\",\n        \"text\": result\n    }\n}\n\n//\nexport class GPTResponses {\n    private apiKey: string;\n    private apiSecret: string;\n    private apiUrl: string = \"https://api.proxyapi.ru/openai/v1\";\n    private model: string = \"gpt-5.2\";\n    private responseId?: string | null = null;\n\n    protected pending: any[] = [];\n    protected messages: any[] = [];\n    protected tools: Map<string, any> = new Map();\n    protected context: DataContext | null = null;\n    protected responseMap: Map<string, any> = new Map();\n\n    //\n    constructor(apiKey: string, apiUrl: string, apiSecret: string, model: string) {\n        this.apiKey = apiKey || \"\";\n        this.apiUrl = apiUrl || this.apiUrl;\n        this.apiSecret = apiSecret || \"\";\n        this.model = model || this.model;\n    }\n\n    //\n    setContext(context: DataContext | null) {\n        this.context = context;\n        return this;\n    }\n\n    //\n    async useMCP(serverLabel: string, origin: string, clientKey: string, secretKey: string) {\n        this.tools.set(origin?.trim?.(), {\n            \"type\": \"mcp\",\n            \"server_label\": serverLabel,\n            \"server_url\": origin,\n            \"headers\": {\n                \"authorization\": `Bearer ${clientKey}:${secretKey}`\n            },\n            \"require_approval\": \"never\"\n        })\n        return this.tools.get(origin?.trim?.());\n    }\n\n    //\n    async convertPlainToInput(\n        dataSource: (string | Blob | File | any),\n        dataKind: DataKind | null = null,\n        additionalAction: string | null = null\n    ): Promise<any> {\n        dataKind ??= getDataKindByMIMEType(dataSource?.type) || \"input_text\";\n\n        const dataInput: DataInput = { dataSource, dataKind, context: this.context };\n        const usableData = await getUsableData(dataInput);\n\n        return {\n            type: \"message\",\n            role: \"user\",\n            content: [\n                { type: \"input_text\", text: \"What to do: \" + actionWithDataType(dataInput) },\n                additionalAction ? { type: \"text\", text: \"Additional request data: \" + additionalAction } : null,\n                { type: \"input_text\", text: \"\\n === BEGIN:ATTACHED_DATA === \\n\" },\n                { ...usableData },\n                { type: \"input_text\", text: \"\\n === END:ATTACHED_DATA === \\n\" },\n            ]?.filter?.((item) => item !== null)\n        };\n    }\n\n    //\n    async attachToRequest(\n        dataSource: (string | Blob | File | any),\n        dataKind: DataKind | null = null,\n        firstAction: string | null = null\n    ) {\n        this.pending.push(await this.convertPlainToInput(\n            dataSource,\n            dataKind ??= getDataKindByMIMEType(dataSource?.type) || \"input_text\"\n        ));\n        if (firstAction) {\n            this.pending.push(await this.askToDoAction(firstAction));\n        }\n        return this.pending[this.pending.length - 1];\n    }\n\n    //\n    async attachExistingData(existingData: any, entityType?: string) {\n        this.context = {\n            ...this.context,\n            existingData,\n            entityType: entityType || this.context?.entityType\n        };\n\n        await this.giveForRequest(`existing_data: \\`${encode(existingData)}\\`\\n`);\n        return this;\n    }\n\n    //\n    async giveForRequest(whatIsIt: any) {\n        // If the caller passes non-string input (File/Blob/object), we must NOT put it into input_text.text.\n        // Convert it into a proper content item via getUsableData() (e.g. {type:\"input_image\", image_url:\"data:...\"}).\n        if (typeof whatIsIt !== \"string\") {\n            try {\n                const dataKind = getDataKindByMIMEType(whatIsIt?.type) || \"input_text\";\n                const usable = await getUsableData({ dataSource: whatIsIt, dataKind, context: this.context });\n                this?.pending?.push?.({\n                    type: \"message\",\n                    role: \"user\",\n                    content: [\n                        { type: \"input_text\", text: \"Additional data for request:\" },\n                        { type: \"input_text\", text: \"\\n === BEGIN:ATTACHED_DATA === \\n\" },\n                        { ...usable },\n                        { type: \"input_text\", text: \"\\n === END:ATTACHED_DATA === \\n\" },\n                    ]\n                });\n                return this?.pending?.[this?.pending?.length - 1];\n            } catch (e) {\n                // Fall back to string coercion (still must be string)\n                whatIsIt = String(whatIsIt);\n            }\n        }\n\n        this?.pending?.push?.({\n            type: \"message\",\n            role: \"user\",\n            content: [\n                { type: \"input_text\", text: \"Additional data for request:\" },\n                { type: \"input_text\", text: String(whatIsIt) }\n            ]\n        });\n        return this?.pending?.[this?.pending?.length - 1];\n    }\n\n    //\n    async askToDoAction(action: string) {\n        this?.pending?.push?.({\n            type: \"message\",\n            role: \"user\",\n            content: [{ type: \"input_text\", text: action }]\n        });\n        return this?.pending?.[this?.pending?.length - 1];\n    }\n\n    //\n    beginFromResponseId(responseId: string | null = null) {\n        this.responseId = (this.responseId = (responseId || this.responseId));\n        return this;\n    }\n\n    //\n    async sendRequest(\n        effort: \"low\" | \"medium\" | \"high\" = \"low\",\n        verbosity: \"low\" | \"medium\" | \"high\" = \"low\",\n        prevResponseId: string | null = null,\n        options: RequestOptions = {}\n    ): Promise<string | null> {\n        effort ??= \"low\";\n        verbosity ??= \"low\";\n\n        // De-duplicate pending items\n        const uniquePending = new Map();\n        for (const item of this.pending) {\n            if (!item) continue;\n            try {\n                const key = typeof item === 'object' ? JSOX.stringify(item) : String(item);\n                if (!uniquePending.has(key)) {\n                    uniquePending.set(key, item);\n                }\n            } catch (e) {\n                uniquePending.set(Math.random().toString(), item);\n            }\n        }\n        const filteredInput = Array.from(uniquePending.values());\n\n        // Build strict JSON instructions for json response format\n        // Following OpenAI Responses API best practices\n        const jsonInstructions = options?.responseFormat === \"json\"\n            ? STRICT_JSON_INSTRUCTIONS\n            : undefined;\n\n        const requestBody: any = {\n            model: this.model,\n            tools: Array.from(this?.tools?.values?.() || [])?.filter?.((tool: any) => !!tool),\n            input: filteredInput,\n            reasoning: { \"effort\": effort },\n            text: { verbosity: verbosity },\n            max_output_tokens: options?.maxTokens || 400000,\n            previous_response_id: (this.responseId = (prevResponseId || this?.responseId)),\n            instructions: jsonInstructions\n        };\n\n        // Add temperature if specified\n        /*if (options?.temperature !== undefined) {\n            requestBody.temperature = options.temperature;\n        }*/\n\n        // Execute request with retry logic and timeout\n        const { timeout: timeoutMs, maxRetries } = getTimeoutConfig(effort);\n        console.log(\"[GPT] Making request to:\", `${this?.apiUrl}/responses`);\n        console.log(\"[GPT] API key present:\", !!this?.apiKey);\n        console.log(\"[GPT] Request timeout:\", `${timeoutMs}ms (${timeoutMs/1000}s) (${effort} effort)`);\n        console.log(\"[GPT] Max retries:\", maxRetries);\n        console.log(\"[GPT] Request body size:\", JSON.stringify(requestBody).length, \"characters\");\n        console.log(\"[GPT] Request input count:\", filteredInput.length, \"items\");\n\n        let lastError: Error | null = null;\n\n        for (let attempt = 0; attempt <= maxRetries; attempt++) {\n            if (attempt > 0) {\n                console.log(`[GPT] Retry attempt ${attempt}/${maxRetries} after ${RETRY_DELAY}ms delay`);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n            }\n\n            try {\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => {\n                    console.warn(`[GPT] Request timeout after ${timeoutMs}ms (attempt ${attempt + 1}) - aborting request`);\n                    controller.abort('timeout');\n                }, timeoutMs);\n\n                console.log(`[GPT] Sending request (attempt ${attempt + 1})...`);\n                const response = await fetch(`${this?.apiUrl}/responses`, {\n                    method: \"POST\",\n                    priority: 'auto',\n                    // Remove keepalive for better timeout control\n                    signal: controller.signal,\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...(this?.apiKey ? { \"Authorization\": `Bearer ${this?.apiKey}` } : {})\n                    },\n                    body: JSON.stringify(requestBody),\n                });\n                console.log(`[GPT] Request sent successfully (attempt ${attempt + 1})`);\n\n                clearTimeout(timeoutId);\n\n                // Handle the response\n                console.log(\"[GPT] Response status:\", response.status, `(attempt ${attempt + 1})`);\n\n                if (response.status !== 200) {\n                    const error = await response?.json?.()?.catch?.((e) => {\n                        console.error(\"[GPT] Failed to parse error response:\", e);\n                        return null;\n                    });\n                    const errorMessage = error?.error?.message || error?.message || `HTTP ${response.status}`;\n                    lastError = new Error(`API error (${response.status}): ${errorMessage}`);\n                    console.error(\"[GPT] API error:\", errorMessage);\n\n                    // Don't retry on client errors (4xx)\n                    if (response.status >= 400 && response.status < 500) {\n                        throw lastError;\n                    }\n\n                    // Continue to retry on server errors (5xx) or network issues\n                    continue;\n                }\n\n                // Success - process the response\n                return await this.processSuccessfulResponse(response);\n\n            } catch (e) {\n                lastError = e instanceof Error ? e : new Error(String(e));\n                console.error(`[GPT] Request failed (attempt ${attempt + 1}):`, lastError.message);\n\n                // Don't retry on abort (timeout) or client errors\n                if (lastError.name === 'AbortError' || (lastError.message.includes('HTTP 4'))) {\n                    break;\n                }\n\n                // Continue to next retry attempt\n            }\n        }\n\n        // All retries failed\n        const errorMessage = lastError ? lastError.message : 'Unknown error after all retries';\n        console.error(\"[GPT] All retry attempts failed:\", errorMessage);\n        throw new Error(`Request failed after ${maxRetries + 1} attempts: ${errorMessage}`);\n    }\n\n    /**\n     * Process a successful response from the API\n     */\n    private async processSuccessfulResponse(response: Response): Promise<string | null> {\n\n        const resp = await response?.json?.()?.catch?.((e) => {\n            console.warn(\"[GPT] Failed to parse successful response:\", e);\n            return null;\n        });\n        if (!resp) return null;\n\n        console.log(\"[GPT] Raw API response structure:\", {\n            type: typeof resp,\n            isArray: Array.isArray(resp),\n            keys: Object.keys(resp).slice(0, 10),\n            keysLength: Object.keys(resp).length,\n            sample: JSON.stringify(resp).substring(0, 300)\n        });\n\n        //\n        this.responseMap.set((this.responseId = (resp?.id || resp?.response_id || this.responseId)), resp);\n        this?.messages?.push?.(...(this?.pending || []));\n        this?.pending?.splice?.(0, this?.pending?.length);\n        this.messages.push(...(resp?.output || []));\n\n        // Try best-effort extraction of textual content\n        const extractText = (r: any): string | null => {\n            try {\n                if (!r) return null;\n                if (typeof r === \"string\") {\n                    // Check if the string looks like JSON (starts and ends with quotes and contains escaped content)\n                    if (r.startsWith('\"') && r.endsWith('\"') && r.includes('\\\\n')) {\n                        try {\n                            // Try to parse as JSON string\n                            const parsed = JSON.parse(r);\n                            console.log(\"[GPT] Parsed JSON string response:\", typeof parsed, parsed?.substring?.(0, 100) || 'object');\n                            if (typeof parsed === \"string\") {\n                                return parsed;\n                            } else if (typeof parsed === \"object\") {\n                                // If it's an object, try to extract text from it\n                                return extractText(parsed);\n                            }\n                        } catch (e) {\n                            console.log(\"[GPT] Failed to parse JSON string, treating as plain text\");\n                        }\n                    }\n                    return r;\n                }\n\n                // Handle array responses (like when response has numeric keys)\n                if (Array.isArray(r)) {\n                    console.log(\"[GPT] Response is array with\", r.length, \"items\");\n                    console.log(\"[GPT] First few array items:\", r.slice(0, 3).map(item => ({\n                        type: typeof item,\n                        keys: typeof item === 'object' ? Object.keys(item || {}) : 'N/A',\n                        sample: typeof item === 'string' ? item.substring(0, 50) : JSON.stringify(item).substring(0, 100)\n                    })));\n                    const texts: string[] = [];\n                    for (const item of r) {\n                        if (typeof item === \"string\") texts.push(item);\n                        else if (item?.text) texts.push(item.text);\n                        else if (item?.content) texts.push(item.content);\n                        else if (item?.message?.content) texts.push(item.message.content);\n                    }\n                    if (texts.length) return texts.join(\"\\n\\n\");\n                }\n\n                // Handle object with numeric keys (array-like)\n                if (typeof r === \"object\" && Object.keys(r).every(key => !isNaN(Number(key)))) {\n                    console.log(\"[GPT] Response looks like array with\", Object.keys(r).length, \"numeric keys\");\n                    const texts: string[] = [];\n                    for (const key of Object.keys(r).sort((a, b) => Number(a) - Number(b))) {\n                        const item = r[key];\n                        if (typeof item === \"string\") texts.push(item);\n                        else if (item?.text) texts.push(item.text);\n                        else if (item?.content) texts.push(item.content);\n                        else if (item?.message?.content) texts.push(item.message.content);\n                    }\n                    if (texts.length) return texts.join(\"\\n\\n\");\n                }\n\n                if (r.output_text && Array.isArray(r.output_text) && r.output_text.length) {\n                    return r.output_text.join(\"\\n\\n\");\n                }\n                const outputs = r.output || r.choices || [];\n                const texts: string[] = [];\n                for (const msg of outputs) {\n                    const content = msg?.content || msg?.message?.content || [];\n                    if (!content) continue;\n                    if (typeof content === \"string\") {\n                        texts.push(content);\n                    } else if (Array.isArray(content)) {\n                        for (const part of content) {\n                            if (typeof part?.text === \"string\") texts.push(part.text);\n                            else if (part?.text?.value) texts.push(part.text.value);\n                        }\n                    }\n                }\n                if (texts.length) return texts.join(\"\\n\\n\");\n            } catch (e) {\n                console.warn(\"[GPT] Error extracting text:\", e);\n            }\n            return null;\n        };\n\n        const text = extractText(resp);\n        console.log(\"[GPT] Extracted text result:\", text ? `\"${text.substring(0, 100)}...\"` : \"null\");\n        if (text != null) {\n            // Return in the expected OpenAI format for compatibility\n            return JSON.stringify({\n                choices: [{\n                    message: {\n                        content: text\n                    }\n                }],\n                usage: resp?.usage || {},\n                id: this.responseId,\n                object: \"chat.completion\"\n            });\n        }\n\n        // Fallback: return last message content as JSON string\n        try {\n            const fallbackText = JSOX.parse(resp?.output ?? resp) as any;\n            if (fallbackText) {\n                return JSON.stringify({\n                    choices: [{\n                        message: {\n                            content: typeof fallbackText === 'string' ? fallbackText : JSON.stringify(fallbackText)\n                        }\n                    }],\n                    usage: resp?.usage || {},\n                    id: this.responseId,\n                    object: \"chat.completion\"\n                });\n            }\n        } catch { /* noop */ }\n        return JSON.stringify({\n            choices: [{\n                message: {\n                    content: \"No text content available\"\n                }\n            }],\n            usage: {},\n            id: this.responseId,\n            object: \"chat.completion\"\n        });\n    }\n\n    // === NEW METHODS FOR DATA MODIFICATION ===\n\n    //\n    async modifyExistingData(\n        existingData: any,\n        modificationPrompt: string,\n        instructions: ModificationInstruction[] = []\n    ): Promise<AIResponse<any>> {\n        try {\n            this.setContext({\n                operation: \"modify\",\n                existingData\n            });\n\n            await this.giveForRequest(DATA_MODIFICATION_PROMPT);\n            await this.giveForRequest(`existing_entity: \\`${encode(existingData)}\\`\\n`);\n\n            if (instructions.length) {\n                await this.giveForRequest(buildModificationPrompt(instructions));\n            }\n\n            await this.askToDoAction(modificationPrompt);\n\n            const raw = await this.sendRequest(\"high\", \"medium\", null, {\n                responseFormat: \"json\",\n                temperature: 0.2\n            });\n\n\n            // Use robust JSON extraction to handle markdown-wrapped responses\n            const parseResult = extractJSONFromAIResponse<any>(raw);\n            if (!parseResult.ok) {\n                console.warn(\"JSON extraction failed:\", parseResult.error, \"Raw:\", parseResult.raw);\n                return { ok: false, error: parseResult.error || \"Failed to parse AI response\" };\n            }\n\n            return {\n                ok: true,\n                data: parseResult.data?.modified_entity || parseResult.data,\n                responseId: this.responseId\n            };\n        } catch (e) {\n            console.error(\"Error in modifyExistingData:\", e);\n            return { ok: false, error: String(e) };\n        }\n    }\n\n    //\n    async selectAndFilterData(\n        dataSet: any[],\n        filters: DataFilter[],\n        searchTerms: string[] = []\n    ): Promise<AIResponse<any[]>> {\n        try {\n            this.setContext({\n                operation: \"extract\",\n                filters,\n                searchTerms\n            });\n\n            await this.giveForRequest(DATA_SELECTION_PROMPT);\n            await this.giveForRequest(`data_set: \\`${encode(dataSet)}\\`\\n`);\n\n            const filterDesc = filters.map(f =>\n                `Filter: ${f.field} ${f.operator} ${JSON.stringify(f.value)}`\n            ).join(\"\\n\");\n\n            await this.askToDoAction(`\nSelect items from the provided data set matching these criteria:\n${filterDesc}\n${searchTerms.length ? `\\nSearch terms: ${searchTerms.join(\", \")}` : \"\"}\n\nReturn matching items with relevance scores.\n            `);\n\n            const raw = await this.sendRequest(\"medium\", \"low\", null, {\n                responseFormat: \"json\",\n                temperature: 0.1\n            });\n\n\n            // Use robust JSON extraction to handle markdown-wrapped responses\n            const parseResult = extractJSONFromAIResponse<any>(raw);\n            if (!parseResult.ok) {\n                console.warn(\"JSON extraction failed:\", parseResult.error, \"Raw:\", parseResult.raw);\n                return { ok: false, error: parseResult.error || \"Failed to parse AI response\" };\n            }\n\n            return {\n                ok: true,\n                data: parseResult.data?.selected_items || parseResult.data,\n                responseId: this.responseId\n            };\n        } catch (e) {\n            console.error(\"Error in selectAndFilterData:\", e);\n            return { ok: false, error: String(e) };\n        }\n    }\n\n    //\n    async mergeEntities(\n        primary: any,\n        secondary: any | any[],\n        mergeStrategy: \"prefer_primary\" | \"prefer_secondary\" | \"prefer_newer\" | \"merge_all\" = \"prefer_primary\"\n    ): Promise<AIResponse<any>> {\n        try {\n            this.setContext({\n                operation: \"merge\",\n                existingData: primary\n            });\n\n            await this.giveForRequest(ENTITY_MERGE_PROMPT);\n            await this.giveForRequest(`primary_entity: \\`${encode(primary)}\\`\\n`);\n            await this.giveForRequest(`secondary_data: \\`${encode(secondary)}\\`\\n`);\n\n            await this.askToDoAction(`\nMerge the secondary data into the primary entity using \"${mergeStrategy}\" strategy:\n- prefer_primary: Keep primary values when conflicts occur\n- prefer_secondary: Use secondary values when conflicts occur\n- prefer_newer: Compare timestamps and use newer values\n- merge_all: Combine all unique values (arrays concatenated, objects deeply merged)\n\nReturn the merged entity with conflict resolution details.\n            `);\n\n            const raw = await this.sendRequest(\"high\", \"medium\", null, {\n                responseFormat: \"json\",\n                temperature: 0.2\n            });\n\n\n            // Use robust JSON extraction to handle markdown-wrapped responses\n            const parseResult = extractJSONFromAIResponse<any>(raw);\n            if (!parseResult.ok) {\n                console.warn(\"JSON extraction failed:\", parseResult.error, \"Raw:\", parseResult.raw);\n                return { ok: false, error: parseResult.error || \"Failed to parse AI response\" };\n            }\n\n            return {\n                ok: true,\n                data: parseResult.data?.merged_entity || parseResult.data,\n                responseId: this.responseId\n            };\n        } catch (e) {\n            console.error(\"Error in mergeEntities:\", e);\n            return { ok: false, error: String(e) };\n        }\n    }\n\n    //\n    async searchSimilar(\n        referenceEntity: any,\n        candidateSet: any[],\n        similarityThreshold: number = 0.7\n    ): Promise<AIResponse<{ item: any; similarity: number }[]>> {\n        try {\n            this.setContext({\n                operation: \"analyze\"\n            });\n\n            await this.giveForRequest(`reference_entity: \\`${encode(referenceEntity)}\\`\\n`);\n            await this.giveForRequest(`candidate_set: \\`${encode(candidateSet)}\\`\\n`);\n\n            // Note: We still show expected format in prompt but ask for raw JSON output\n            await this.askToDoAction(`\nFind items in the candidate set that are similar to the reference entity.\nConsider semantic similarity, not just exact matches.\nCompare:\n- Names/titles (fuzzy match)\n- Types/kinds\n- Properties overlap\n- Relationships\n\nReturn items with similarity score >= ${similarityThreshold}\n\nExpected output structure:\n{\n    \"similar_items\": [\n        { \"item\": {...}, \"similarity\": 0.85, \"match_reasons\": [...] }\n    ],\n    \"potential_duplicates\": [...],\n    \"related_but_different\": [...]\n}\n            `);\n\n            const raw = await this.sendRequest(\"medium\", \"medium\", null, {\n                responseFormat: \"json\",\n                temperature: 0.3\n            });\n\n\n            // Use robust JSON extraction to handle markdown-wrapped responses\n            const parseResult = extractJSONFromAIResponse<any>(raw);\n            if (!parseResult.ok) {\n                console.warn(\"JSON extraction failed:\", parseResult.error, \"Raw:\", parseResult.raw);\n                return { ok: false, error: parseResult.error || \"Failed to parse AI response\" };\n            }\n\n            return {\n                ok: true,\n                data: parseResult.data?.similar_items || [],\n                responseId: this.responseId\n            };\n        } catch (e) {\n            console.error(\"Error in searchSimilar:\", e);\n            return { ok: false, error: String(e) };\n        }\n    }\n\n    //\n    async batchProcess(\n        items: any[],\n        operation: string,\n        batchSize: number = 10\n    ): Promise<AIResponse<any[]>> {\n        const results: any[] = [];\n        const errors: string[] = [];\n\n        for (let i = 0; i < items.length; i += batchSize) {\n            const batch = items.slice(i, i + batchSize);\n\n            await this.giveForRequest(`batch_items: \\`${encode(batch)}\\`\\n`);\n            // Note: We show expected format but ask for raw JSON\n            await this.askToDoAction(`\nProcess this batch of ${batch.length} items:\n${operation}\n\nReturn processed items in same order.\nExpected output: { \"processed\": [...], \"failed\": [...] }\n            `);\n\n            const raw = await this.sendRequest(\"medium\", \"low\", null, {\n                responseFormat: \"json\"\n            });\n\n            if (raw) {\n                // Use robust JSON extraction to handle markdown-wrapped responses\n                const parseResult = extractJSONFromAIResponse<any>(raw);\n                if (parseResult.ok && parseResult.data) {\n                    results.push(...(parseResult.data?.processed || []));\n                    if (parseResult.data?.failed?.length) {\n                        errors.push(...parseResult.data.failed.map((f: any) => f?.error || \"Unknown error\"));\n                    }\n                } else {\n                    console.warn(\"Batch parsing failed:\", parseResult.error);\n                }\n            }\n        }\n\n        return {\n            ok: errors.length === 0,\n            data: results,\n            error: errors.length ? errors.join(\"; \") : undefined,\n            responseId: this.responseId\n        };\n    }\n\n    //\n    clearPending() {\n        this.pending.splice(0, this.pending.length);\n        return this;\n    }\n\n    //\n    getResponseId() { return this?.responseId; }\n    getMessages() { return this?.messages; }\n    getPending() { return this?.pending; }\n    getContext() { return this?.context; }\n\n    //\n    getResponse(responseId: string) { return this?.responseMap?.get?.(responseId); }\n}\n\n// === HELPER FUNCTIONS ===\n\n//\nexport const createGPTInstance = (\n    apiKey: string,\n    apiUrl?: string,\n    model?: string\n): GPTResponses => {\n    return new GPTResponses(\n        apiKey,\n        apiUrl || \"https://api.proxyapi.ru/openai/v1\",\n        \"\",\n        model || \"gpt-5.2\"\n    );\n}\n\n//\nexport const quickRecognize = async (\n    apiKey: string,\n    data: string | Blob | File,\n    apiUrl?: string,\n    options: RequestOptions & { timeoutOverride?: number } = {}\n): Promise<AIResponse<any>> => {\n    const gpt = createGPTInstance(apiKey, apiUrl);\n    await gpt.attachToRequest(data);\n\n    let raw;\n    try {\n        // Use timeout override if provided, otherwise use default medium effort timeout\n        const timeoutOptions = options.timeoutOverride\n            ? { ...options, maxTokens: options.maxTokens }\n            : options;\n\n        raw = await gpt.sendRequest(\"medium\", \"medium\", null, timeoutOptions);\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : String(e);\n        console.error(\"[quickRecognize] Request failed:\", errorMessage);\n        return { ok: false, error: errorMessage };\n    }\n\n    if (!raw) {\n        return { ok: false, error: \"No response from AI service\" };\n    }\n\n    // Use robust JSON extraction to handle markdown-wrapped responses\n    const parseResult = extractJSONFromAIResponse<any>(raw);\n    if (parseResult.ok) {\n        return { ok: true, data: parseResult.data };\n    }\n\n    // Fallback to raw text if JSON extraction fails\n    console.warn(\"[quickRecognize] JSON extraction failed, using raw text\");\n    return { ok: true, data: raw };\n}\n\n//\nexport const quickModify = async (\n    apiKey: string,\n    existingData: any,\n    modificationPrompt: string,\n    apiUrl?: string\n): Promise<AIResponse<any>> => {\n    const gpt = createGPTInstance(apiKey, apiUrl);\n    return gpt.modifyExistingData(existingData, modificationPrompt);\n}\n"],"names":["binary","MAX_FILE_SIZE","URL","errorMessage","texts"],"mappings":"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","x_google_ignoreList":[0]}